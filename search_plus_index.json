{"./":{"url":"./","title":"起始","keywords":"","body":"Document Library - 文档库 Here is the jsliang's learning and working experience document on programming. If you have doubts about this, please send an email to 1741020489@qq.com. 这里存放了jsliang的学习、工作中关于编程的经验文档。如果你对此有疑惑，请发邮件到 1741020489@qq.com。 一 前言 本文档库始建于 2018-08-20。 如想知道 jsliang 最新学习进度，请前往 撰文思路 进行查看。 如想知道 jsliang 各种新奇玩意，请前往 网站清单 进行查看。 如想参与 jsliang 组织的小竞赛，请前往 个人竞赛 进行查看。 建文档库的初始目的：记录一下 jsliang 的在折腾学习某个黑科技的时候的操作笔记。 因为，如果你学习而不写文章、不做笔记，某天你突发奇想，需要用到某个之前你用过的黑科技……那样的话，还需要 百度 / google 一遍，太累了！太浪费人生了！ 所以，集一生洪荒之力，写一个编程文档库，存放，我编程生涯的点点滴滴。 不折腾的前端，跟咸鱼有什么区别！ 二 文件目录 文件名 存放内容 CSS-library CSS 文档仓库 HTML-library HTML 文档仓库 JavaScript-library JavaScript 文档仓库 other-library 其他文档仓库(整站制作/微信小程序) public-repertory 文档仓库使用到的图片、CSS文件等…… 三 个人网站 目录 介绍 jsliang.top jsliang 的网站列表 cv.jsliang.top 通过 ECharts + Vue 打造个人线上简历 playregex.jsliang.top 通过游戏来了解正则表达式 lucky.jsliang.top 悠闲刮刮乐，仅供娱乐 deadline.jsliang.top jsliang 的工作时间轴 webpack.jsliang.top Webpack 学习成果，Webpack 多页面配置 game.jsliang.top 一个小游戏，只兼容 PC，适配移动端失败 company.jsliang.top Node 打造企业网站，支持注册、登录及留言 work.jsliang.top jsliang 工作成果，给领导或者工作小伙伴查看 四 反馈 QQ 群 如果对该文档库的某篇文章存有疑惑，如果有些问题想看下 jsliang 折腾过没有，请加 QQ 群：798961601。jsliang 在群里将第一时间根据小伙伴的疑问进行解答~ 五 推荐学习方法 建议小伙伴们有机会可以给自己配个显示器，也就 5/600 元，用起来也舒服。 jsliang 的开发配置为手提（16G / 6核 / 12线程 / 7200RMB） + 显示器 （21.5寸 / 1080P / 650RMB)。对前端开发的来说，这个价还是用得起的，而且自己的配置，自己用得会比较舒服。 最后，祝小伙伴们在编程生涯中找到自己的节奏，工资步步高升。 办公场景 学习场景 六 云服务器推广 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎加 QQ：1741020489 骚扰欢迎点击 云服务器推广 查看了解更多！ 七 打赏 撰文不易，如果文章对小伙伴有帮助，希望小伙伴们给勤劳敲代码、辛苦撰文的 jsliang 进行微信/支付宝打赏，你们的每一次打赏都是最好的鼓励，谢谢~ 八 文档协议 document library of jsliang by 梁峻荣 is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.Based on a work at https://github.com/LiangJunrong/document-library.Permissions beyond the scope of this license may be available at https://creativecommons.org/licenses/by-nc-sa/2.5/cn/. jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 15:44:36 "},"SUMMARY.html":{"url":"SUMMARY.html","title":"目录","keywords":"","body":"文档库目录 起始 目录 ★ CSS 资料室 ☆ CSS 基础 ✔ CSS 重置 ☆ CSS 布局 ✔ Flex 布局 ★ HTML 资料室 ★ JavaScript 资料室 ☆ JavaScript ✔ 方法 - indexOf() ✔ 方法 - map() ✔ 方法 - pop() ✔ 方法 - sort() ✔ 对象 - Map ✔ 对象 - Math ✔ 对象 - Number ✔ 对象 - String ✔ 删除数组项目的技巧 ✘ ES6学习 - 1 - Promise ✘ JavaScript 之 构造函数与原型对象 ☆ jQuery ✔ jQuery 基础 ✔ jQuery 工作常用解决方案 ☆ Vue ✔ Vue 基础 ✔ Vue 官方文档二三事 ✔ Vue 开发准备 ✘ Axios ✘ VueCli2 ✘ VueCli3 ✘ Vue Router ✘ Vuex ✘ Vue SSR 服务端渲染 ✔ Vue 上传文件 ✔ Vue 部署优化 ✘ Vue 源码剖析 ✔ Vue Demo - 功成千骨 ✘ Vue Demo Two - 新闻 SPA ✘ Vue Demo Three - 千人千魔 ☆ React ✘ React 基础 ✘ React 开发准备 ✘ React 知识点清单 ✔ React List - Create React App ✔ React List - React Redux ✔ React List - React Router ✔ React Demo One - TodoList ✔ React Demo Two - TodoList 升级 ✔ React Demo Three - 简书 ✔ React Demo Four - 掘金 ✘ React Demo Five - 员岗周边 ☆ Angular ✘ Angular Demo One - 打造企业级协作平台 ✘ Angular Demo Two - Angular 股票管理平台 ☆ ECharts ✔ ECharts 打造在线个人简历 ✔ ECharts 打造在线个人简历 【升级版】 ✔ ECharts + Vue 折腾记 ☆ 设计模式 ✘ 设计模式手册 - 1 - 部署开发环境 ✘ 设计模式手册 - 2 - 面向对象 ✘ 设计模式手册 - 3 - 工厂模式 ✘ 设计模式手册 - 4 - 单例模式 ✘ 设计模式手册 - 5 - 适配器模式 ✘ 设计模式手册 - 6 - 装饰器模式 ✘ 设计模式手册 - 7 - 代理模式 ✘ 设计模式手册 - 8 - 外观模式 ✘ 设计模式手册 - 9 - 观察者模式 ✘ 设计模式手册 - 10 - 迭代器模式 ✘ 设计模式手册 - 11 - 状态模式 ✘ 设计模式手册 - 12 - 其他模式 ✘ 设计模式手册 - 13 - 综合应用 ★ 其他资料室 ☆ Git ☆ LeetCode LeetCode - 简单模式 ✔ 001 - 两数之和（two-sum） ✔ 007 - 整数反转（reverse-integer） ★ 共用资料 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:41:58 "},"CSS-library/":{"url":"CSS-library/","title":"★ CSS 资料室","keywords":"","body":"CSS 资料室 Create by jsliang on 2018-10-28 10:49:09Recently revised in 2019-5-20 08:23:35 Here is an article about CSS. 这里存放了关于 CSS 的文章。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 "},"CSS-library/CSSBase/":{"url":"CSS-library/CSSBase/","title":"☆ CSS 基础","keywords":"","body":"CSS 基础 Create by jsliang on 2019-5-20 08:34:15Recently revised in 2019-5-20 08:34:18 记录 CSS 基础相关的资料 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 "},"CSS-library/CSSBase/CSSReset.html":{"url":"CSS-library/CSSBase/CSSReset.html","title":"✔ CSS 重置","keywords":"","body":"CSS Reset Create by jsliang on 2018-12-23 20:12:08Recently revised in 2019-04-25 17:46:46 各式各样浏览器总有一些让人感觉难以接受的样式， 不管是 jQuery 还是 Vue，使用前最好重置一下样式： reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /* * 图片自适应 - image responsize * 1. 清空浏览器对图片的设置 * 2. 图片 的情况下，图片会撑高 div，这么设置可以清除该影响 */ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .32rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .32rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .32rem } /* Internet Explorer */ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-25 17:46:47 "},"CSS-library/Layout/":{"url":"CSS-library/Layout/","title":"☆ CSS 布局","keywords":"","body":"CSS 布局 Create by jsliang on 2019-5-20 08:35:56Recently revised in 2019-5-20 08:35:59 记录 CSS 布局相关的资料 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 "},"CSS-library/Layout/Flex.html":{"url":"CSS-library/Layout/Flex.html","title":"✔ Flex 布局","keywords":"","body":"Flex 布局 create by jsliang on 2019-3-27 13:36:02Recently revised in 2019-3-27 13:42:10 万丈高楼平地起，熟悉 Flex 需要先了解下面这 7 个 CSS 属性： /* 设置 Flex 模式 */ display: flex; /* 决定元素是横排还是竖着排，要不要倒序 */ flex-direction: column; /* 决定元素换行格式，一行排不下的时候如何排 */ flex-wrap: wrap; /* flex-flow = flex-direction + flex-wrap */ flex-flow: column wrap; /* 同一排下对齐方式，空格如何隔开各个元素 */ justify-content: space-between; /* 同一排下元素如何对齐，顶部对齐、中部对齐还是其他 */ align-items: center; /* 多行对齐方式 */ align-content: space-between; 下面我们详细分析这些元素的情况： flex-direction：决定主轴的方向 row - （默认）水平方向，起点在左端 row-reverse - 水平方向，起点在右端 column - 垂直方向，起点在上沿 column-reverse - 垂直方向，起点在下沿 display: flex; flex-direction: row | row-reverse | column | column-reverse; flex-wrap：一条轴线（一行）排不下时如何解决 nowrap - （默认）不换行 wrap - 换行，第一行在上方 wrap-reverse - 换行，第一行在下方 display: flex; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow：flex-flow = flex-direction + flex-wrap。即 flex-flow 是这两个属性的合集 row nowrap - （默认）水平方向，起点在左端，不换行 display: flex; flex-flow: || ;  详解参考 1 和 2 justify-content：定义项目在主轴上的对齐方式 flex-start - 左边对齐 flex-end - 右边对齐 center - 居中对齐 space-between - 两端对齐，空格在中间 space-around - 空格环绕 display: flex; justify-content: flex-start | flex-end | center | space-between | space-around; align-items：定义项目在交叉轴上如何对齐 flex-start - 顶部对齐，即文字图片等顶部同一条线上 flex-end - 底部对其，即文字图片等底部在同一条线上 center - 中间对其，即文字图片不管多高，都拿它们的中间放在同一条线上 stretch - 将文字图片充满整个容器的高度，强制统一 baseline - 将每项的第一行文字做统一在一条线上对齐 display: flex; align-items: flex-start | flex-end | center | stretch | baseline; align-content：定义多根轴线的对齐方式。如果只有一根轴线（只有一行），该属性不起作用 flex-start - 这几行顶部对齐 flex-end - 这几行底部对齐 center - 这几行居中对齐 stretch - 这几行进行扩展或者缩放，从而填满容器高 space-between - 这几行中间使用空格进行填充 space-around - 这几行两边及中间进行填充 display: flex; align-content: flex-start | flex-end | center | space-between | space-around | stretch; jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"HTML-library/":{"url":"HTML-library/","title":"★ HTML 资料室","keywords":"","body":"HTML 资料室 Create by jsliang on 2018-10-28 10:50:22Recently revised in 2019-5-20 08:24:19 Here is an article about HTMl 这里存放了关于HTML的文章 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 "},"JavaScript-library/":{"url":"JavaScript-library/","title":"★ JavaScript 资料室","keywords":"","body":"JavaScript 资料室 Create by jsliang on 2018-10-28 10:51:18Recently revised in 2019-5-20 08:24:52 Here is an article about JavaScript 这里存放了关于 JavaScript 的文章 目录 Angular ES6 ECharts JavaScript React Vue 设计模式 jQuery jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 "},"JavaScript-library/JavaScript/":{"url":"JavaScript-library/JavaScript/","title":"☆ JavaScript","keywords":"","body":"JavaScript 知识点 Create by jsliang on 2018-12-11 09:21:24Recently revised in 2019-05-20 18:20:34 万丈高楼平地起 地基还得自己起 记录 JavaScript 各个知识点 MDN 是个非常实用的网站，有不懂的知识点可尽管搜索： MDN 搜索页 下面知识点不分先后，如果有目的查找，请使用 Ctrl/Command + F： 类型 名称 简介 地址 方法 indexOf() 判断数组中是否存在判断条件中的值。如果存在，则返回第一次出现的索引；如果不存在，则返回 -1。 indexOf() 详细介绍 方法 map() 遍历数组，item 返回遍历项，index 返回当前索引。 map() 详细介绍 方法 pop() 从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 pop() 详细介绍 方法 sort() 排序，数字 1-9，字母 a-z。 sort() 详细介绍 类型 名称 简介 地址 对象 Map 保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。 Map 详细介绍 对象 Math 内置对象，它具有数学常数和函数的属性和方法。不是一个函数对象。 Math 详细介绍 对象 Number 可以将其他类型的值转为数字。 Number 详细介绍 对象 String 将其他格式转成字符串。 String 详细介绍 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 18:57:22 "},"JavaScript-library/JavaScript/Function/indexOf.html":{"url":"JavaScript-library/JavaScript/Function/indexOf.html","title":"✔ 方法 - indexOf()","keywords":"","body":"方法 - indexOf() Create by jsliang on 2019-05-17 11:30:04Recently revised in 2019-05-17 14:37:49 原文：MDN - indexOf() 功能：indexOf() 方法返回调用 String 对象中第一次出现的指定值的索引。 语法：indexOf(searchValue, fromIndex) searchValue：查找的值 formIndex：开始查找的位置 返回值：如果找到了，则返回第一次出现的索引；如果没找到，则返回 -1。 代码： 'I am jsliang'.indexOf('a', 4); // 9 [1, 3, 1, 4].indexOf(1, 1); // 2 '怪盗 jsliang'.indexOf('我'); // -1 扩展：如果需要查找到最后一次出现指定值的索引，可以使用 lastIndexOf()。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 18:55:14 "},"JavaScript-library/JavaScript/Function/map.html":{"url":"JavaScript-library/JavaScript/Function/map.html","title":"✔ 方法 - map()","keywords":"","body":"方法 - map() Create by jsliang on 2019-05-17 11:30:04Recently revised in 2019-05-17 14:50:46 原文：MDN - map() 功能：map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法：map((item, index) => {}) item：遍历的项 index：该次遍历项的索引 返回值：一个新数组，每个元素都是回调函数的结果。 代码： [1, 2, 3, 4].map(item => item * 2) // [2, 4, 6, 8] [{ name: 'jsliang', age: 24, }, { name: '梁峻荣', age: 124 }].map((item, index) => { return `${index} - ${item.name}`; }) // ['0 - jsliang', '1 - 梁峻荣'] jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 18:55:34 "},"JavaScript-library/JavaScript/Function/pop.html":{"url":"JavaScript-library/JavaScript/Function/pop.html","title":"✔ 方法 - pop()","keywords":"","body":"方法 - pop() Create by jsliang on 2019-05-19 11:40:27Recently revised in 2019-05-19 11:40:30 原文：MDN - pop() 功能：pop() 方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 语法： arr.pop()：返回从数组中删除的元素 返回值：一个新数组，每个元素都是回调函数的结果。 代码： let arr = [1, 2, 3, 4]; for(let i = 0, time = 1; i jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 18:55:54 "},"JavaScript-library/JavaScript/Function/sort.html":{"url":"JavaScript-library/JavaScript/Function/sort.html","title":"✔ 方法 - sort()","keywords":"","body":"方法 - sort() Create by jsliang on 2019-05-17 11:31:56Recently revised in 2019-05-17 14:57:45 原文：MDN - sort() 功能：sort() 对数组的元素进行排序，并返回数组。 语法：sort(function) function：按某种顺序进行排列的函数。 返回值：排序后的数组。 代码： [4, 2, 5, 1, 3].sort(), // [1, 2, 3, 4, 5] [4, 2, 5, 1, 3].sort((a, b) => a jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 18:56:16 "},"JavaScript-library/JavaScript/Object/Map.html":{"url":"JavaScript-library/JavaScript/Object/Map.html","title":"✔ 对象 - Map","keywords":"","body":"对象 - Map Create by jsliang on 2019-05-17 11:45:35Recently revised in 2019-05-17 15:05:47 原文：MDN - Map 功能：Map 对象保存键值对。 方法： new Map()：新建一个 Map 对象 Map.prototype.has(key)：返回布尔值。表示 Map 实例是否包含键对应的值。 Map.prototype.set(key, value)：返回该 Map 对象。设置 Map 对象中键的值。 Map.prototype.get(key)：返回键对应的值，如果不存在，则返回 undefined。 Map.prototype.delete(key)：如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false。 代码： var twoSum = function(nums, target) { let map = new Map(); for (let i = 0; i jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 11:22:20 "},"JavaScript-library/JavaScript/Object/Math.html":{"url":"JavaScript-library/JavaScript/Object/Math.html","title":"✔ 对象 - Math","keywords":"","body":"对象 - Math Create by jsliang on 2019-05-19 11:32:44Recently revised in 2019-05-19 11:32:47 原文：MDN - Math 功能：Math 是一个内置对象，它具有数学常数和函数的属性和方法。不是一个函数对象。 方法： Math.abs(x)：返回 x 的绝对值。 Math.ceil(x)：返回 x 向上取整后的值。x = 99.1; result = 100 Math.floor(x)：返回小于 x 的最大整数。x = 99.1; result = 99 Math.pow(x,y)：返回 x 的 y 次幂。 Math.round(x)：返回四舍五入后的整数。 代码： Math.abs(-999); // 999 Math.ceil(99.1); // 100 Math.floor(99.1); // 99 Math.pow(2, 3); // 8 Math.round(99.5); // 100 Math.round(99.4); // 99 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 11:39:55 "},"JavaScript-library/JavaScript/Object/Number.html":{"url":"JavaScript-library/JavaScript/Object/Number.html","title":"✔ 对象 - Number","keywords":"","body":"对象 - Number Create by jsliang on 2019-05-19 11:17:28Recently revised in 2019-05-19 11:17:31 原文：MDN - Number 功能：Number 可以将其他类型的值转为数字。 方法： new Map()：新建一个 Map 对象 Number(x)：将其他类型的值转为数字 Number.MAX_SAFE_INTEGER：JavaScript 中最大的安全整数 (2 的 53 次方 - 1)。 Number.MIN_SAFE_INTEGER：JavaScript 中最小的安全整数 (-(2 的 53 次方 - 1)). 代码： Number(\"123\") // 123 Number(\"\") // 0 Number(\"0x11\") // 17 Number(\"0b11\") // 3 Number(\"0o11\") // 9 Number(\"foo\") // NaN Number(\"100a\") // NaN jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 11:21:51 "},"JavaScript-library/JavaScript/Object/String.html":{"url":"JavaScript-library/JavaScript/Object/String.html","title":"✔ 对象 - String","keywords":"","body":"对象 - String Create by jsliang on 2019-05-19 11:17:49Recently revised in 2019-05-19 11:22:42 原文：MDN - String 功能：String 将其他值生成或转换成字符串。 方法： String(thing)：将 thing 转成字符串。 代码： String(123); // '123' String(true); // 'true' jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 11:26:32 "},"JavaScript-library/JavaScript/Other/DeleteArrrayItem.html":{"url":"JavaScript-library/JavaScript/Other/DeleteArrrayItem.html","title":"✔ 删除数组项目的技巧","keywords":"","body":"删除数组项目的技巧 Create by jsliang on 2019-4-5 09:56:19Recently revised in 2019-4-6 10:34:11 /** * 这里使用了三种写法 * 1. map + splice * 2. splice + findIndex * 3. filter */ // 1. map + splice 写法 deleteInfo(recycleItem) { this.todoInfos.map((item, index) => { if(item.id == recycleItem.id) { this.todoInfos.splice(index, 1); } }) }, // 2. splice + findIndex 写法 deleteInfo(recycleItem) { this.todoInfos.splice( this.todoInfos.findIndex( v => v.id === recycleItem.id), 1); }, // 3. filter 写法 deleteInfo(recycleItem) { this.todoInfos = this.todoInfos.filter( (x) => { return x.id != recycleItem.id; }) } Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 11:19:23 "},"JavaScript-library/JavaScript/Other/Promise.html":{"url":"JavaScript-library/JavaScript/Other/Promise.html","title":"✘ ES6学习 - 1 - Promise","keywords":"","body":"ES6学习 - 1 - Promise create by jsliang on 2018-8-23 14:26:38Recently revised in 2018-12-23 20:35:05 PS：由于工作突然来活，Promise学习暂且放下，jsliang会利用下班时间慢慢补充。 学习导言  在学习Promise前，我们先理解两组词：单线程和多线程、同步和异步。 单线程和多线程：在你选购电脑的时候，也许会时不时听导购员跟你推荐：“这台机子是6核12线程的” “这台机子是4核8线程的”……啪啦啪啦介绍一番，然后你就纳闷了，什么是线程？线程是干什么的？……哎~停！专业的解释小伙伴们可以去看专业的回答：线程、单线程和多线程、单线程和多线程的区别。在这里，我们通过一个通俗易懂的小场景，带大家去理解单线程和多线程： 图（一堆钱） 图（单线程抢钱） 图（多线程抢钱） 解释：通过这个小场景，我们明白了单线程和多线程是什么样子的。下面我们继续了解同步和异步。 同步和异步：文章1、文章2、文章3 在理解了 单线程和多线程、同步和异步的基础上，我们来看看单线程的JavaScript是如何通过Promise来实现异步操作的。 借鉴与领悟  今天我们看看邵哥关于Promise的文章，理解下Promise的世界。先行观赏 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 11:19:25 "},"JavaScript-library/JavaScript/Other/prototype&constructor.html":{"url":"JavaScript-library/JavaScript/Other/prototype&constructor.html","title":"✘ JavaScript 之 构造函数与原型对象","keywords":"","body":"JavaScript 之 构造函数与原型对象 Create by jsliang on 2018-12-11 09:27:44Recently revised in 2018-12-25 20:43:57 “每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例都包含一个指向原型对象的内部指针。”—— 《JavaScript 高级程序设计》 一 目录  不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文  3.1 箭头函数  3.2 不能使用箭头函数的场景  3.3 构造函数和原型对象 四 总结 二 前言 返回目录  在编写学习 Node 基础 中，写到 Node 仿 Express 的时候，我写了这么一段代码： let Application = () => { // ... } Application.prototype.get = (path, handle) => { // ... }  然后代码死活跑不起来，于是我就去问大佬，大佬默默回了句： “构造函数不能用箭头函数呀”  我一愣： 为什么不能用构造函数？ 什么时候我不能使用构造函数？ 箭头函数的解释是什么咯？ 什么是构造函数？ ……  所以，在下面，咱一一分析这些问题。 三 正文 返回目录  参考文献： 箭头函数 | 廖雪峰的官网 什么时候你不能使用箭头函数？ | 简书 - 王仕军 js深入理解构造函数和原型对象 | 博客园 - 快饿死的鱼 一句话总结JS构造函数、原型和实例的关系 | CSDN - 夜色芜染 箭头函数 | MDN 3.1 箭头函数 返回目录  ES6 标准新增了一种新的函数：Arrow Function(箭头函数)。 为什么叫箭头函数？ x => x * x;  因为它的定义用的就是一个箭头。上面代码相当于： function(x) { return x * x; }  那么，它的作用是什么呢：箭头函数相当于匿名函数，并且简化了函数定义。而箭头函数内部的 this 是词法作用域，由上下文确定： var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = function () { return new Date().getFullYear() - this.birth; // this 指向 window 或 undefined }; return fn(); } };  在上文的代码中： return new Date().getFullYear() - this.birth;  这里的 this 指向 window 或 undefined，从而使 JavaScript 函数对 this 的绑定没有得到预期的结果。 那么，我们可以尝试使用箭头函数： var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = () => new Date().getFullYear() - this.birth; // this 指向 obj 对象 return fn(); } }; obj.getAge(); // 25  这就是箭头函数及其大致作用。 3.2 不能使用箭头函数的场景 返回目录  什么时候不能使用箭头函数呢？ 定义对象方法 定义原型方法 定义构造函数 定义事件回调函数  首先，在定义对象方法中，举例： const calculator = { array: [1, 2, 3], sum: () => { console.log(this === window); // => true return this.array.reduce((result, item) => result + item); } }; console.log(this === window); // => true // Throws \"TypeError: Cannot read property 'reduce' of undefined\" calculator.sum();  如上，它会报错，因为 this 的指向不对，需要修改为： const calculator = { array: [1, 2, 3], sum() { console.log(this === calculator); // => true return this.array.reduce((result, item) => result + item); } }; calculator.sum(); // => 6  然后，在定义原型方法上，也需要注意不能滥用箭头函数： function Cat(name) { this.name = name; } Cat.prototype.sayCatName = () => { console.log(this === window); // => true return this.name; }; const cat = new Cat('Mew'); cat.sayCatName(); // => undefined  这里需要修改为： function Cat(name) { this.name = name; } Cat.prototype.sayCatName = function () { console.log(this === cat); // => true return this.name; }; const cat = new Cat('Mew'); cat.sayCatName(); // => 'Mew'  接着，在定义事件回调函数时，也需要注意 this 的指向： const button = document.getElementById('myButton'); button.addEventListener('click', () => { console.log(this === window); // => true this.innerHTML = 'Clicked button'; });  修正为： const button = document.getElementById('myButton'); button.addEventListener('click', function() { console.log(this === button); // => true this.innerHTML = 'Clicked button'; });  最后，在定义构造函数上： const Message = (text) => { this.text = text; }; // Throws \"TypeError: Message is not a constructor\" const helloMessage = new Message('Hello World!');  修正为： const Message = function(text) { this.text = text; }; const helloMessage = new Message('Hello World!'); console.log(helloMessage.text); // => 'Hello World!'  综合 3.1 与 3.2 的内容，我们可以清晰明白，虽然使用箭头函数，能够精简代码，并在一定程度上有所帮助。 但是，我们不能因为追求简洁的代码，而提升我们的代码维护难度和造成多种 bug。 量力而行才是最好的。 3.3 构造函数和原型对象 返回目录   四 总结 返回目录   jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 11:19:26 "},"JavaScript-library/jQuery/":{"url":"JavaScript-library/jQuery/","title":"☆ jQuery","keywords":"","body":"jQuery Create by jsliang on 2018-11-4 10:38:08Recently revised in 2018-12-23 20:39:34 记录 jQuery 学习及 jQuery 工作日常 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/jQuery/jQueryBase.html":{"url":"JavaScript-library/jQuery/jQueryBase.html","title":"✔ jQuery 基础","keywords":"","body":"jQuery 基础 Create by jsliang on 2018-05-07 15:56:17Recently revised in 2019-2-11 11:18:19  jQuery 操作 DOM 的那一套，还是非常值得关注的。我那时候一直想看 妙味 的 jQuery 剖析，我会员都买了，但是那会又去折腾小程序了，所以就没空了。  其实我觉得，jQuery 不是说丢就能丢的，只是前端新人，都觉得 Vue、React 工作好找，就学点 JavaScript 皮毛，去折腾那个去了。但是，讲真原生 JavaScript 还是要操作 DOM 的，DOM 操作哪家强，前端技术找 jQuery。  而且，一些开发中，直接用 jQuery 暴力拆迁，还是挺快的。我觉得我以后不用 jQuery 的原因，可能是项目涉及的数据量太大，操作 DOM 太多的时候，我才会更换成 Vue 这些。  最后的最后，一句话吧：没有最屌的技术，只有最适合项目的技术。 一 目录  不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 尝试 四 兼容 五 jQuery 语法 六 jQuery 选择器  6.1 元素选择器  6.2 #ID 选择器  6.3 .class 选择器  6.4 其他用法 七 DOM 事件  7.1 mouseover 与 mouseenter  7.2 键盘事件顺序 八 jQuery 效果  8.1 显示/隐藏  8.2 淡入/淡出  8.3 滑动  8.4 动画  8.5 停止动画  8.6 链 九 捕获 十 设置 十一 添加元素 十二 删除元素 十三 CSS 类 十四 CSS() 方法 十五 尺寸 十六 祖先选择器 十七 后代选择器 十八 同胞选择器 十九 过滤选择器 二十 load 二十一 get() 和 post() 二十二 Ajax 二十三 JSONP 二十四 无冲突 - noConflict 二十五 jQuery 实例 二十六 选择器扩展  26.1 基本选择器  26.2 层次选择器  26.3 过滤选择器（重点）   26.3.1 内容过滤选择器   26.3.2 可见性过滤选择器  26.4 属性过滤选择器  26.5 状态过滤选择器  26.6 表单选择器 二十七 插件扩展  27.1 jQuery Validate  27.2 jQuery Accordion  27.3 jQuery Autocomplete  27.4 jQuery Growl  27.5 jQuery Password Validation  27.6 jQuery Prettydate  27.7 jQuery Treeview 二 前言 返回目录  本文最初用 word 记录于 2018-05-07。 那时候还是前端职场新人，想在想起还是非常感谢带我的前端小姐姐的指导。 这篇文章是在 jQuery 教程 | 菜鸟教程 学习的过程中的记录笔记。 如需系统学习 jQuery，建议参考网上现成的系统的 jQuery 网站教程/视频教程。 本文仅供 jQueryer 复习自己所学知识。 三 尝试 返回目录  jQuery是一个轻量级的 \"写的少，做的多\" 的 JavaScript 库。  jQuery 的引用： 百度 CDN： jQuery 官网 CDN： BootCDN：  尝试： index.html 尝试引用jQuery - 2018年5月7日16:20:50 点我？消失给你看哦~ 继续点试试？ 再点试试？ $(document).ready(function(){ $(\"p\").click(function(){ $(this).hide(); }); }); 四 兼容 返回目录  jQuery 版本 2 以上不支持 IE6，7，8 浏览器。 如果需要支持 IE6/7/8，那么请选择 1.9。 你还可以通过条件注释在使用 IE6/7/8 时只包含进1.9。 五 jQuery 语法 返回目录  基础语法： $(selector).action()。在jQuery中，$=jQuery  ready： 写法1：$(document).ready(function(){ // 开始写 jQuery 代码... }); 写法2：$(function(){ // 开始写 jQuery 代码... }); 六 jQuery 选择器 返回目录  jQuery 选择器可以帮助我们更好地选择 DOM 元素。 6.1 元素选择器 返回目录  在页面中选取所有 元素: js 代码片段 $(\"p\") 实例： $(document).ready(function(){ $(\"button\").click(function(){ $(\"p\").hide(); }); }); 6.2 #ID 选择器 返回目录  通过 id 选取元素语法如下：$(\"#test\") js 代码片段 $(document).ready(function(){ $(\"button\").click(function(){ $(\"#test\").hide(); }); }); 6.3 .class 选择器 返回目录  jQuery 类选择器可以通过指定的 class 查找元素：$(\".test\") js 代码片段 $(document).ready(function(){ $(\"button\").click(function(){ $(\".test\").hide(); }); }); 6.4 其他用法 返回目录 语法 描述 $(\"*\") 选取所有元素 $(this) 选取当前 HTML 元素 $(\"p.intro\") 选取 class 为 intro 的 元素 $(\"p:first\") 选取第一个 元素 $(\"ul li:first\") 选取第一个 元素的第一个 元素 $(\"ul li:first-child\") 选取每个 元素的第一个 元素 $(\"[href]\") 选取带有 href 属性的元素 $(\"a[target='_blank']\") 选取所有 target 属性值等于 \"_blank\" 的 元素 $(\"a[target!='_blank']\") 选取所有 target 属性值不等于 \"_blank\" 的 元素 $(\":button\") 选取所有 type=\"button\" 的 元素 和 元素 $(\"tr:even\") 选取偶数位置的 元素 $(\"tr:odd\") 选取奇数位置的 元素 七 DOM 事件 返回目录 鼠标事件 键盘事件 表单事件 文档/窗口事件 click - 点击 keypress - 键被按下 submit - 表单提交 load - 全部加载（1.8已废弃） dbclick - 双击 keydown - 键按下的过程 change - 文本改变 resize - 浏览器窗口大小调试 mouseenter - 鼠标进入 keyup - 键被松开 focus - 获得焦点 scroll - 滚动 mouseleave - 鼠标离开   blur - 失去焦点 unload - 离开页面（1.8已废弃） 7.1 mouseover 与 mouseenter 返回目录  mouseover 事件在鼠标移动到选取的元素及其子元素上时触发。 mouseenter 事件只在鼠标移动到选取的元素上时触发。 mouseleave 与 mouseout同样。 7.2 键盘事件顺序 返回目录 keydown - 键按下的过程  ↓↓↓↓↓ keypress - 键被按下  ↓↓↓↓↓ keyup - 键被松开 八 jQuery 效果 返回目录  jQuery 可以使用其事件，做一些好玩的事情 8.1 显示/隐藏 返回目录  语法： 隐藏：$(selector).hide(speed,callback); 显示：$(selector).show(speed,callback); 切换：$(selector).toggle(speed,callback); speed：速度（毫秒） callback：完成后显示的函数 index.html 显示与隐藏 如果你点击“隐藏” 按钮，我将会消失。 隐藏 显示 $(function () { $(\"#hide\").click(function () { $(\"p\").hide(5000); }); $(\"#show\").click(function () { $(\"p\").show(1000); }); }); 8.2 淡入/淡出 返回目录  语法： 淡入：$(selector).fadeIn(speed,callback); 淡出：$(selector).fadeOut(speed,callback); 切换：$(selector).fadeToggle(speed,callback); 渐变：$(selector).fadeTo(speed,opacity,callback); speed：速度 opacity：透明度 callback：回调函数 index.html 淡入与淡出 .container { width: 320px; margin: 0 auto; } #red { width: 100px; height: 100px; background: red; } #green { width: 100px; height: 100px; background: green; } #blue { width: 100px; height: 100px; background: blue; } #fadeIn { display: none; } 淡入 淡出 渐变 $(function(){ $(\"#fadeToggle\").click(function(){ $(\"#blue\").fadeToggle(1000,function(){ $(\"#green\").fadeToggle(500,function(){ $(\"#red\").fadeToggle(200) }); }); $(\"#fadeIn\").toggle(); $(\"#fadeOut\").toggle(); }); $(\"#fadeTo\").click(function(){ $(\"#red\").fadeTo(500,0.3); $(\"#green\").fadeTo(1000,0.5); $(\"#blue\").fadeTo(\"slow\",0.1); }) }); 8.3 滑动 返回目录  语法： $(selector).slideDown(speed,callback); $(selector).slideUp(speed,callback); $(selector).slideToggle(speed,callback); speed：时间 callback：回调函数 index.html 显示与隐藏 #toggleHide { display: none; } 显示 隐藏 如果你点击“隐藏” 按钮，我将会消失。 $(function () { $(\"#toggle\").click(function () { $(\"#toggleHide\").toggle() $(\"#toggleShow\").toggle(); $(\"p\").toggle(1000); }); }); 8.4 动画 返回目录  语法： $(selector).animate({params},speed,callback); params：css 属性（键值对形式，-号替换为驼峰 → border-radius=borderRadius:'15px'） speed：时间 callback：回调函数  操作： 能操作单个属性 能操作多个属性 值能使用相对值（+=、-=） 属性值能为\"show\"、\"hide\" 或 \"toggle\"等 编写多个animate能使用队列功能 index.html 动画 .container { width: 320px; margin: 0 auto; text-align: center; } #circle { width: 100px; height: 100px; border-radius: 50px; background: rgb(243, 207, 5); display: inline-block; position: relative; } #stop { display: none; } start! stop! $(function () { var start; $(\"#stop\").click(function(){ clearInterval(start); $(\"#start\").show(); $(\"#stop\").hide(); }); $(\"#start\").click(function(){ start = setInterval(\"runBall()\", 1000); $(\"#start\").hide(); $(\"#stop\").show(); }); }); function runBall() { $(\"#circle\").animate({ left: '-=110px', top: '+=150px', backgroundColor: 'red' }); $(\"#circle\").animate({ left: '110px', backgroundColor: 'rgb(5, 243, 172)' }); $(\"#circle\").animate({ left: '0', top: '0', backgroundColor: 'rgb(243, 207, 5)' }); }; 8.5 停止动画 返回目录  语法： $(selector).stop(stopAll,goToEnd); stopAll：默认 false。true：停止包括后续 animate 的所有动作 goToEnd：默认 false。true：直接跳到该动作末尾，同时停止后面动作 index.html 停止动画 .container { width: 320px; margin: 0 auto; } #text { background: #b9f309; position: relative; } #text p { text-indent: 2em; } 开始 停止 停止所有 停止动画，但完成动作 点击 \"开始\" 按钮开始动画。 点击 \"停止\" 按钮停止当前激活的动画，但之后我们能再动画队列中再次激活。 点击 \"停止所有\" 按钮停止当前动画，并清除动画队列，所以元素的所有动画都会停止。 点击 \"停止动画，但完成动作\" 快速完成动作，并停止它。 $(function () { $(\"#start\").click(function () { $(\"#text\").animate({ top: '200px' }, 1000); $(\"#text\").animate({ top: '0' }, 1000); }); $(\"#stopDefault\").click(function(){ $(\"#text\").stop(); }) $(\"#stopAll\").click(function(){ $(\"#text\").stop(true); }) $(\"#stopToEnd\").click(function(){ $(\"#text\").stop(true,true); }) }); 8.6 链 返回目录  jQuery可以通过链的形式，链接多个动作。  修改8.4动画的代码： js 代码片段 function runBall() { $(\"#circle\").animate({ left: '-=110px', top: '+=150px', backgroundColor: 'red' }).animate({ left: '110px', backgroundColor: 'rgb(5, 243, 172)' }).animate({ left: '0', top: '0', backgroundColor: 'rgb(243, 207, 5)' }); }; 九 捕获 返回目录 text()：捕获文本 html()：捕获HTML val()：捕获表单文本值 attr()：捕获属性值 index.html 捕获 .container { width: 320px; margin: 0 auto; } 显示文本 显示HTML 显示表单值 显示属性 这是段落中的粗体 文本。 梁峻荣的网站 $(function(){ $(\"#showText\").click(function(){ alert(\"显示文本：\"+$(\"#text\").text()); }); $(\"#showHtml\").click(function(){ alert(\"显示HTML：\"+$(\"#text\").html()); }); $(\"#showVal\").click(function(){ alert(\"显示表单值：\"+$(\"#webSkill\").val()); }); $(\"#showAttr\").click(function(){ alert(\"显示属性：\"+$(\"#myBlog\").attr(\"target\")); }); }); 十 设置 返回目录 text()：捕获文本 html()：捕获HTML val()：捕获表单文本值 attr()：捕获属性值   在设置方面，这4个方法还提供回调函数。 index.html 设置 .container { width: 320px; margin: 0 auto; } 修改文本 这是段落中的 粗体 文本。 修改HTML 这是段落中的 粗体 文本。 修改表单值 修改属性1 梁峻荣的网站 修改属性2 便捷校园 $(function(){ $(\"#changeText\").click(function(){ $(\"#text\").text(\"Hello World!\"); }); $(\"#changeHtml\").click(function(){ $(\"#htmlText\").html(\"Hello World！\"); }); $(\"#changeVal\").click(function(){ $(\"#webSkill\").val(\"Hello World!\"); }); $(\"#changeAttr1\").click(function(){ $(\"#myBlog1\").text(\"便捷校园\").attr(\"href\", \"http://www.liangjunrong.com:3000\"); }); $(\"#changeAttr2\").click(function(){ $(\"#myBlog2\").text(\"梁峻荣的网站\").attr({ \"href\":\"http://www.liangjunrong.com\", \"target\":\"\" }); }); }); 十一 添加元素 返回目录 append() - 在被选的元素的结尾插入内容 prepend() - 在被选的元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容 index.html 添加元素 #container { background: red; } append追加文本 after追加文本 这是一个段落。 Hello World! function appendText() { var txt1 = \"文本。\"; // 使用 HTML 标签创建文本 var txt2 = $(\"\").text(\"文本。\"); // 使用 jQuery 创建文本 var txt3 = document.createElement(\"p\"); txt3.innerHTML = \"文本。\"; // 使用 DOM 创建文本 text with DOM $(\"#container\").append(txt1, txt2, txt3); // 追加新元素 } function afterText() { var txt1 = \"文本。\"; // 使用 HTML 标签创建文本 var txt2 = $(\"\").text(\"文本。\"); // 使用 jQuery 创建文本 var txt3 = document.createElement(\"p\"); txt3.innerHTML = \"文本。\"; // 使用 DOM 创建文本 text with DOM $(\"#container\").after(txt1, txt2, txt3); // 追加新元素 } 十二 删除元素 返回目录 remove() - 删除被选元素（及其子元素）（可附加参数） empty() - 从被选元素中删除子元素 index.html 删除元素 .container { width: 320px; margin: 0 auto; } #text { width: 200px; height: 200px; background: rgb(255, 217, 0); } remove元素 empty元素 remove部分元素 Hello World! Hello World! Liang~ Hello GuangZhou! $(function(){ $(\"#remove\").click(function(){ $(\"#text\").remove(); }); $(\"#empty\").click(function(){ $(\"#text\").empty(); }); $(\"#removeFew\").click(function(){ $(\"p\").remove(\".pText\"); }); }); 十三 CSS 类 返回目录 addClass() - 向被选元素添加一个类或多个类 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - 设置或返回样式属性 index.html CSS类 .container { width: 320px; margin: 0 auto; } .changeClass { background: rgb(0, 255, 179); } 添加样式 Hello World! 我叫梁峻荣！ $(function () { $(\"#addClass\").click(function () { $(\"#changeClass\").toggleClass(\"changeClass\"); }); }); 十四 CSS() 方法 返回目录  语法： 返回CSS： css(\"propertyname\"); 修改CSS： css(\"propertyname\",\"value\"); index.html CSS类 .container { width: 320px; margin: 0 auto; } p { background: red; } 获取CSS 修改CSS 这是一个段落。 $(function () { $(\"#getCss\").click(function () { alert($(\"p\").css(\"background\")); }); $(\"#changeCss\").click(function () { $(\"p\").css({ \"background\": \"red\", \"fontSize\": \"30px\" }); }); }); 十五 尺寸 返回目录 width() - 元素宽度 height() - 元素高度 innerWidth() - padding+元素 宽度 innerHeight() - padding+元素 高度 outerWidth() - border+padding+元素 宽度 outerHeight() - border+padding+元素 高度 index.html 尺寸 .container { width: 320px; margin: 0 auto; text-align: center; } .box { width: 220px; height: 220px; padding: 10px; border: 5px solid #ccc; background: rgb(6, 193, 240); display: inline-block; } 显示width 显示height 显示innerWidth 显示innerHeight 显示outerWidth 显示outerHeight $(function(){ $(\"#showWidth\").click(function(){ var width = \"div的width是：\" + $(\".box\").width() + \"\"; $(\"#width\").html(width); }); $(\"#showHeight\").click(function(){ var height = \"div的height是：\" + $(\".box\").height() + \"\"; $(\"#height\").html(height); }); $(\"#showInnerWidth\").click(function(){ var innerWidth = \"div的innerWidth是：\" + $(\".box\").innerWidth() + \"\"; $(\"#innerWidth\").html(innerWidth); }); $(\"#showInnerHeight\").click(function(){ var innerHeight = \"div的innerHeight是：\" + $(\".box\").innerHeight() + \"\"; $(\"#innerHeight\").html(innerHeight); }); $(\"#showOuterWidth\").click(function(){ var outerWidth = \"div的outerWidth是：\" + $(\".box\").outerWidth() + \"\"; $(\"#outerWidth\").html(outerWidth); }); $(\"#showOuterHeight\").click(function(){ var outerHeight = \"div的outerHeight是：\" + $(\".box\").outerHeight() + \"\"; $(\"#outerHeight\").html(outerHeight); }); }); 十六 祖先选择器 返回目录 parent() - 上一级父元素 parents() - 上至html标签 parentsUntil() - 介于目前元素与选择元素之间的所有标签。 index.html 祖先 .container { width: 320px; margin: 0 auto; text-align: center; } .ancestorsClass { color: rgb(0, 0, 0); border: 2px solid rgb(0, 247, 255); } body （曾曾祖父元素） div （曾祖父元素） parent parents parents刷选 parentsUntil 清空 ul （祖父元素） li （父元素） span $(function(){ $(\"#parent\").click(function(){ $(\"span\").parent().addClass(\"ancestorsClass\"); }); $(\"#parents\").click(function(){ $(\"span\").parents().addClass(\"ancestorsClass\"); }); $(\"#parentsSelect\").click(function(){ $(\"span\").parents(\"ul\").addClass(\"ancestorsClass\"); }); $(\"#parentUntil\").click(function(){ $(\"span\").parentsUntil(\"div\").addClass(\"ancestorsClass\"); }); $(\"#clear\").click(function(){ $(\"span\").parents().removeClass(\"ancestorsClass\"); }); }); 十七 后代选择器 返回目录 children() - 所选元素的所有直接子元素 find() - 找到符合条件的子元素 index.html 后代 .container { width: 320px; margin: 0 auto; text-align: center; } .boxClass { font-size: 2em; color: rebeccapurple; } children find Hello World! !dlroW olleH $(function(){ $(\"#children\").click(function(){ $(\"#box\").children(\"p.p1\").addClass(\"boxClass\"); }); $(\"#find\").click(function(){ $(\"#box\").find(\"*\").addClass(\"boxClass\"); }); }); 十八 同胞选择器 返回目录 siblings() - 被选元素的所有同胞元素 next() - 被选元素的下一个元素 nextAll() - 被选元素的下面所有元素 nextUntil() - 被选元素到后面指定元素中间的所有元素 prev() - 被选元素的前一个元素 prevAll() - 被选元素的前面所有元素 prevUntil() - 被选元素到前面指定元素中间的所有元素 index.html 同胞 .container { width: 320px; margin: 0 auto; text-align: center; } .textClass { border: 2px solid rgb(0, 255, 221); border-radius: 20px; } sibling next nextAll nextUntil prev prevAll prevUntil clear Hello! Hello! Hello! Hello! Hello! Hello! $(function () { $(\"#sibling\").click(function () { $(\"h3\").siblings(\"h4\").addClass(\"textClass\"); }); $(\"#next\").click(function () { $(\"h1\").next().addClass(\"textClass\"); }); $(\"#nextAll\").click(function () { $(\"h1\").nextAll().addClass(\"textClass\"); }); $(\"#nextUntil\").click(function () { $(\"h3\").nextUntil(\"h6\").addClass(\"textClass\"); }); $(\"#prev\").click(function () { $(\"h6\").prev().addClass(\"textClass\"); }); $(\"#prevAll\").click(function () { $(\"h6\").prevAll().addClass(\"textClass\"); }); $(\"#prevUntil\").click(function () { $(\"h6\").prevUntil(\"h3\").addClass(\"textClass\"); }); $(\"#clear\").click(function () { $(\"#box\").children().removeClass(\"textClass\"); }); }); 十九 过滤选择器 返回目录 first() - 第一个匹配条件的元素 last() - 最后一个匹配条件的元素 eq() - 符合索引号的元素 filter() - 匹配filter里条件的元素 not() - 去掉not里符合条件的元素后的其他元素 index.html 过滤 .container { width: 320px; margin: 0 auto; text-align: center; } .textClass { border: 2px solid rgb(0, 255, 221); border-radius: 20px; } first last eq filter not clear Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! $(function(){ $(\"#first\").click(function(){ $(\"#box h3\").first().addClass(\"textClass\"); }); $(\"#last\").click(function(){ $(\"#box h3\").last().addClass(\"textClass\"); }); $(\"#eq\").click(function(){ $(\"#box\").children().eq(2).addClass(\"textClass\"); }); $(\"#filter\").click(function(){ $(\"#box\").children().filter(\"h3\").addClass(\"textClass\"); }); $(\"#not\").click(function(){ $(\"#box\").children().not(\"h3\").addClass(\"textClass\"); }); $(\"#clear\").click(function(){ $(\"#box\").children().removeClass(\"textClass\"); }) }); 二十 load 返回目录  语法：$(selector).load(URL,data,callback); URL：请求加载的URL data：查询字符串键值对集合 callback：load() 方法完成后所执行的函数名称 responseTxt - 包含调用成功时的结果内容 statusTxt - 包含调用的状态 xhr - 包含XMLHttpRequest对象 二十一 get() 和 post() 返回目录  get - 从指定的资源请求数据 post - 向指定的资源提交要处理的数据  语法： $.get(URL,callback); URL：请求的 URL callback：请求成功后所执行的函数名 二十二 Ajax 返回目录  语法：$.ajax({name:value, name:value, ... })  方法 1： js 代码片段1 $.ajax({ url: host + '/addressInfo', type: 'get', dataType: 'json', data: { addressName: $serA } }).done(function (res) { console.log(res); }).fail(function () { console.log(\"error\"); }).always(function () { console.log(\"complete\"); });  方法 2： js 代码片段2 $.ajax({ url: host + '/olduser/up', type: 'get', dataType: 'json', data: { userName: $(\"#search-name\").val(), adsl: $(\"#search-id\").val() }, success:function(res){ if(res.code == 0) { \"#search-name\").val()) + \"&adsl=\" + escape($(\"#search-id\").val()); } else { alert(res.msg); } } }) 二十三 JSONP 返回目录  跨域读取数据，请用 JSONP。 注意：JSONP 与 Ajax 没任何关系！JSONP 是利用 script 标签来 get 到被包裹的 json 数据。 index.html JSONP $.getJSON(\"http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=?\", function (data) { var html = ''; for (var i = 0; i ' + data[i] + ''; } html += ''; $('#divCustomers').html(html); }); 二十四 无冲突 - noConflict 返回目录  当 jQuery 和其他的 JavaScript 框架同时将$作为简写的使用，可以考虑使用noConflict()方法解决冲突。 二十五 jQuery 实例 返回目录  总结前面的 jQuery 实例：https://www.runoob.com/jquery/jquery-examples.html 二十六 选择器扩展 返回目录  选择器的扩展大全 26.1 基本选择器 返回目录 $(\"#id\") // ID选择器 $(\"div\") // 元素选择器 $(\".classname\") // 类选择器 $(\".classname,.classname1,#id1\") // 组合选择器 26.2 层次选择器 返回目录 $(\"#id>.classname \") // 子元素选择器 $(\"#id .classname \") // 后代元素选择器 $(\"#id + .classname \") // 紧邻下一个元素选择器 $(\"#id ~ .classname \") // 兄弟元素选择器 26.3 过滤选择器（重点） 返回目录 $(\"li:first\") // 第一个 li $(\"li:last\") // 最后一个 li $(\"li:even\") // 挑选下标为偶数的 li $(\"li:odd\") // 挑选下标为奇数的 li $(\"li:eq(4)\") // 下标等于 4 的 li $(\"li:gt(2)\") // 下标大于 2 的 li $(\"li:lt(2)\") // 下标小于 2 的 li $(\"li:not(#runoob)\") // 挑选除 id=\"runoob\" 以外的所有 li 26.3.1 内容过滤选择器 返回目录 $(\"div:contains('Runob')\") // 包含 Runob 文本的元素 $(\"td:empty\") // 不包含子元素或者文本的空元素 $(\"div:has(selector)\") // 含有选择器所匹配的元素 $(\"td:parent\") // 含有子元素或者文本的元素 26.3.2 可见性过滤选择器 返回目录 $(\"li:hidden\") // 匹配所有不可见元素，或 type 为 hidden 的元素 $(\"li:visible\") // 匹配所有可见元素 26.4 属性过滤选择器 返回目录 $(\"div[id]\") // 所有含有 id 属性的 div 元素 $(\"div[id='123']\") // id属性值为123的div 元素 $(\"div[id!='123']\") // id属性值不等于123的div 元素 $(\"div[id^='qq']\") // id属性值以qq开头的div 元素 $(\"div[id$='zz']\") // id属性值以zz结尾的div 元素 $(\"div[id*='bb']\") // id属性值包含bb的div 元素 $(\"input[id][name$='man']\") //多属性选过滤，同时满足两个属性的条件的元素 26.5 状态过滤选择器 返回目录 $(\"input:enabled\") // 匹配可用的 input $(\"input:disabled\") // 匹配不可用的 input $(\"input:checked\") // 匹配选中的 input $(\"option:selected\") // 匹配选中的 option 26.6 表单选择器 返回目录 $(\":input\") //匹配所有 input, textarea, select 和 button 元素 $(\":text\") //所有的单行文本框，$(\":text\") 等价于$(\"[type=text]\")，推荐使用$(\"input:text\")效率更高，下同 $(\":password\") //所有密码框 $(\":radio\") //所有单选按钮 $(\":checkbox\") //所有复选框 $(\":submit\") //所有提交按钮 $(\":reset\") //所有重置按钮 $(\":button\") //所有button按钮 $(\":file\") //所有文件域 二十七 插件扩展 返回目录  配合 jQuery 的插件，可以更好的进行工作。 27.1 jQuery Validate 返回目录  说明：jQuery Validate是在jQuery基础上扩展的为表单提供验证功能的插件。 网址：https://www.runoob.com/jquery/jquery-plugin-validate.html 27.2 jQuery Accordion 返回目录  说明：jQuery Accordion插件用于创建折叠菜单 网址：https://www.runoob.com/jquery/jquery-plugin-accordion.html 27.3 jQuery Autocomplete 返回目录  说明：jQuery Autocomplete插件根据用户输入值进行搜索和过滤 网址：https://www.runoob.com/jquery/jquery-plugin-autocomplete.html 27.4 jQuery Growl 返回目录  说明：jQuery Growl用户做消息提醒 网址：https://www.runoob.com/jquery/jquery-plugin-message.html 27.5 jQuery Password Validation 返回目录  说明：jQuery Password Validation 在jQuery Validation 的基础上扩展，专门对密码进行验证 网址：https://www.runoob.com/jquery/jquery-plugin-password-validation.html 27.6 jQuery Prettydate 返回目录  说明：jQuery Prettydate为表单提供验证功能 网址：https://www.runoob.com/jquery/jquery-plugin-prettydate.html 27.7 jQuery Treeview 返回目录  说明：jQuery Treeview提供无序灵活的可折叠树形菜单 网址：https://www.runoob.com/jquery/jquery-plugin-treeview.html jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/jQuery/jQueryFrequentlyUsed.html":{"url":"JavaScript-library/jQuery/jQueryFrequentlyUsed.html","title":"✔ jQuery 工作常用解决方案","keywords":"","body":"jQuery 工作常用解决方案 Create by jsliang on 2018-11-4 10:37:33Recently revised in 2019-2-11 11:18:40  Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址  记录工作中，使用 jQuery、HTML、CSS 等技术的技巧，包括但不限于：rem 适配、css reset、活动边框、弹窗等。  比较琐碎，各取所需。 一 JavaScript 1.1 jQuery 引入  CDN： 1.2 双引号与单引号的使用规范  在平时的时候，能使用双引号就用双引号。 在拼接字符串的时候，使用单引号裹住。 1.3 移动端rem适配  直接在 index.html 中引用该 js 文件即可。 mobile-terminal-adaptation.js /* * 2018年7月25日10:38:23 * 移动端rem适配，px:rem = 100:1 * 该适配兼容UC竖屏转横屏出现的BUG * 自定义设计稿的宽度：designWidth * 最大宽度:maxWidth * 这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750) */ ! function (e, t) { function n() { var n = l.getBoundingClientRect().width; t = t || 540, n > t && (n = t); var i = 100 * n / e; r.innerHTML = \"html{font-size:\" + i + \"px;}\" } var i, d = document, o = window, l = d.documentElement, r = document.createElement(\"style\"); if (l.firstElementChild) l.firstElementChild.appendChild(r); else { var a = d.createElement(\"div\"); a.appendChild(r), d.write(a.innerHTML), a = null } n(), o.addEventListener(\"resize\", function () { clearTimeout(i), i = setTimeout(n, 300) }, !1), o.addEventListener(\"pageshow\", function (e) { e.persisted && (clearTimeout(i), i = setTimeout(n, 300)) }, !1), \"complete\" === d.readyState ? d.body.style.fontSize = \"16px\" : d.addEventListener( \"DOMContentLoaded\", function (e) { d.body.style.fontSize = \"16px\" }, !1) }(1000, 1000); 1.4 jQuery ajax  方法1： $.ajax({ url: host + '/addressInfo', type: 'get', dataType: 'json', data: { addressName: $serA } }).done(function (res) { console.log(res); }).fail(function () { console.log(\"error\"); }).always(function () { console.log(\"complete\"); });  方法2： $.ajax({ url: host + '/olduser/up', type: 'get', dataType: 'json', data: { userName: $(\"#search-name\").val(), adsl: $(\"#search-id\").val() }, success:function(res){ if(res.code == 0) { $(\"#search-name\").val() + \"&adsl=\" + escape($(\"#search-id\").val()); } else { alert(res.msg); } } }) 1.5 URL加码及解码  加码： window.location = \"adslList.htm?name=\" + escape(name) + \"&idNo=\" + escape(idNo);  解码： function getUrlParam(name) { var reg = new RegExp(\"(^|&)\"+ name +\"=([^&]*)(&|$)\"); var r = window.location.search.substr(1).match(reg); if(r!=null)return unescape(r[2]); return null; } console.log(\"url name=\" + getUrlParam(\"name\") + \",url idNo=\" + getUrlParam(\"idNo\")); 1.6 常用正则表达式 使用方式：if(!/^((\\d{8})|(1[35784]\\d{9}))$/.test($(\"#user-phone\").val())){ alert('请填写11位手机号码或8位固话号码'); return false; } 密码强度 必须包含数字+小写字母+大写字母的密码，位数在8-10位之间： ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 只能是字母、数字和下划线： ^\\w+$ 校验中文： ^[\\u4e00-\\u9fa5]{0,}$ Email验证： [\\w!#$%&'*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])? 身份证验证 ^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$ 手机号验证：以1开头，第二位数是3/4/5/7/8的11位手机号码 ^1[3,4,5,7,8]\\d{9}$ 二 HTML 2.1 搜索跳转到百度 皮皮虾我们溜 三 CSS 3.1 设置input的placeholder reset.css /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #727272; } /* Webkit browsers */ input::-moz-placeholder { color: #727272; } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #727272; } /* Internet Explorer */ 3.2 使图片根据不同设备自适应 reset.css /** 图片自适应 - image responsize **/ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; } 3.3 垂直居中  首先，父元素设置relative； 然后，需要定位的元素设置absolute； 最后，垂直居中的top为50%，margin-top为该元素高度的负一半的高度值。 .search-result-area { position: relative; padding: 0 36px; } .previous-page, .next-page { position: absolute; top:50%; margin-top: -36px; } .previous-page { left: 0; } .next-page { right: 0; } 3.4 左右两栏布局 div1不变，div2浮动，div2的margin-left为div1的宽度。 div1+div2浮动，父级overflow=hidden。 父级relative定位，子级absolute定位。 3.5 css reset /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /* * 图片自适应 - image responsize * 1. 清空浏览器对图片的设置 * 2. 图片 的情况下，图片会撑高 div，这么设置可以清除该影响 */ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .32rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .32rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .32rem } /* Internet Explorer */ 3.6 li前面点换成图片 ul{ list-style-image: url(img/5.jpg); } 3.7 制作div的边框 .content:before { content: \" \"; display: block; width: 100%; height: 3.46rem; background: url(\"../images/mobile-frame-top.jpg\") no-repeat center; background-size: 100%; position: absolute; left: 0; top: 0; z-index: 9; } .content { position: relative; background: url(\"../images/mobile-frame-content.jpg\") repeat-y center; background-size: 100% auto; width: 10rem; padding: 3.46rem 1.37rem 2.26rem; font-size: .3rem; } .content:after { content: \" \"; display: block; width: 100%; height: 2.26rem; background: url(\"../images/mobile-frame-bottom.png\") no-repeat center; background-size: 100%; position: absolute; left: 0; bottom: 0; z-index: 9; } 3.8 手机端背景图不能正确放大 .banner { background: url(\"../images/banner.jpg\") no-repeat; background-size: 100% auto; } 3.9 position情况下居中  left值计算：width - button宽度一半 3.10 jsliang的弹窗  如果希望弹窗不固定大小，在手机端或者 PC 端都能使用，推荐使用百分比配置。 *.html 该板块暂未开放~ 好的，我知道了 *.css /** 弹窗 - alert **/ .jsliang-prompt { display: none; } .jsliang-mask { z-index: 998; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; filter: alpha(opacity=30); -ms-filter: \"alpha(opacity=30)\"; opacity: .3; } .jsliang-alert { z-index: 999; position: fixed; top: 30%; left: 40%; width: 320px; height: 220px; box-shadow: 2px 2px 4px #A0A0A0, -2px -2px 4px #A0A0A0; background-color: #fff; padding: 25px; border-radius: 15px; text-align: center; } .jsliang-alert img { width: 120px; height: 83.8px; } .jsliang-alert p { margin-top: 10px; } .jsliang-get-it { color: #fff; background: #5bc0de; display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; font-weight: 400; line-height: 1.42857143em; white-space: nowrap; cursor: pointer; border-color: #46b8da; border: 1px solid transparent; border-radius: 4px; text-align: center; vertical-align: middle; text-decoration: none; } .jsliang-get-it:hover { background: #31b0d5; } /* end */ 3.11 常用SVG  直接引用到页面即可。 3.12 滚动条 http://www.xuanfengge.com/demo/201311/scroll/css3-scroll.html 3.13 修改select样式 *.html 请选择商铺区域 香洲 拱北 前山 横琴 斗门 金湾 *.css .activity-area-select { width: 4.3rem; height: .6rem; line-height: .6rem; margin-left: .5rem; border: 1px solid #e0e0e0; border-radius: .28rem; font-size: .24rem; float: left; } /* 修改浏览器默认select */ .activity-area-select select { /* 清除边框 - Chrome和Firefox里面的边框不一样，需要复写 */ border: none; /* 清除聚焦颜色 */ outline: none; /* 清除默认样式 */ appearance: none; -moz-appearance: none; -webkit-appearance: none; /*在选择框的最右侧中间显示小箭头图片*/ background: url(\"../images/icon-select.png\") no-repeat center right scroll transparent; /*为下拉小箭头留出一点位置，避免被文字覆盖*/ padding-left: .3rem; padding-right: 2rem; } /* 清除边框 - 清除ie的默认选择框样式清除，隐藏下拉箭头*/ .activity-area-select select::-ms-expand { display: none; outline: none; } 3.14 修改table样式 *.html 商铺名称 商铺地址 珠海粤西贸易有限公司 珠海市香洲区群华路44号（五洲康城） 珠海市香洲阑山唯佳生鲜馆 香洲区南福路199号商铺 *.css .search-result-table { border:solid #e1e1e1; border-width:1px 0px 0px 1px; } table thead, tbody tr { display: table; width: 100%; table-layout: fixed; } .search-result-table tr:nth-child(2n+2) { background: #fff7ef; } .search-result-table th { background: #ffa751; color: #fff; font-size: .24rem; height: .63rem; line-height: .63rem; border:solid #e1e1e1; border-width: 0px 1px 1px 0px; } .search-result-table tbody { display: block; height: 6.05rem; overflow-x: hidden; overflow-y: scroll; } .search-result-table td { font-size: .22rem; height: .9rem; padding-left: .22rem; border:solid #e1e1e1; border-width: 0px 1px 1px 0px; } 四 Other 4.1 VSCode 选中设置  文件 -> 设置 -> User Settings -> editor.wordSeparators 下划线选中： `~!@#$%^&*()-=+[{]}\\\\|;:'\\\",.<>/?  横杠选中： ./\\\\()\\\"':,.;<>~!@#$%^&*|+=[]{}`~? 4.2 浏览器前缀参照  -moz- 对应 Firefox, -webkit- 对应 Safari and Chrome -o- 对应 Opera -ms- 对应 Internet Explorer 4.3 git的使用  本地仓库上传到GitHub： git init git add . git commit -m \"first commit\" git remote add origin https://github.com/address git push -u origin master  更新本地仓库到GitHub git add . git commit -m \"更新\" git push -u origin master  拉取GitHub项目到本地 git clone address 4.4 VS Code 设置模板页 安装插件 HTML Snippets 文件-首选项-用户代码片段-HTML 修改文件内容为： { // Place your snippets for html here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the // same ids are connected. // Example: // \"Print to console\": { // \"prefix\": \"log\", // \"body\": [ // \"console.log('$1');\", // \"$2\" // ], // \"description\": \"Log output to console\" // } \"!!\": { \"prefix\": \"!!\", \"body\": [ \"\", \"\", \"\", \"\\t\", \"\\t\", \"\\t\", \"\\tHelloWorld\", \"\", \"\", \"\\t$1\", \"\\t\", \"\\t\", \"\", \"\" ], \"description\": \"!! - Defines a template for a html5 document\" } } 在HTML页面输入!!然后回车，即可看到新效果 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Vue/":{"url":"JavaScript-library/Vue/","title":"☆ Vue","keywords":"","body":"Vue Create by jsliang on 2018-10-29 11:48:55Recently revised in 2019-05-20 19:39:49  记录下关于 Vue 框架的系统学习旅途：Vue 基础 -> Vue 实战 -> Vue 源码剖析。  如果小伙伴也在学习 Vue，或者想复习下 Vue。那么，跟我一起走吧，发车啦~ 一 学习目录 目录 Vue 基础 Vue Router Vue-Cli Axios 二 写在前面 问：Vue 是啥？ 答：Vue 是前端三大流行框架之一，学前端不知道 Vue 就跟炒股不认识巴菲特一样。老铁，了解来一发？【 Go! 】 问：学 Vue 有啥用？ 答：小伙伴们应该不会跟钱过不去吧？现在企业的前端招聘要求中大都有 Vue 技能需求，所以学了拿更高工资啊。不信？点击去看看：【 Go! 】 问：有没有参考文档？ 答：关于学习 Vue 方面，最佳推荐还是官方文档，因为不管是其他文字还是视频教程，都是基于 Vue 的官方文档或者 GitHub 进行学习编写的。 Vue.js 官方文档 问：有没有参考视频？ 答： 开课吧 - Vue.js 及项目实战(2018/06)  在这里偶然发现一套来自 开课吧 的教学视频，然后发现它是今年 6 月份录制的，内容上还算是比较新，并且文件命名非常有意思，在这里咱的 Vue 基础知识先跟着它走一遍看看~ 【11-08】补充：Axios 中涉及到 Koa 提供的后端接口，还需要恶补一番 Node 基础或者 Koa 直接上手。 慕课网 - 《Vue.js 源码全方位深入解析》  还未开封，但是研究源码可能参考该套视频。 插件：Vue DevTools 三 学习旅途  在 Vue 套餐的学习旅途中： 【10-25】想用 Vue + Koa + MongoDB 搭建一套商城，于是学习 jspang 的教程。 【10-28】跟着学习了几天，发现一些基础知识真的忘得差不多了，不知道 Vue 基础知识，不知道 Node 基础知识，不知道 Koa 怎么玩，好纠结，好难受。 【10-29】敲下 Vue 的 README 文章，开始 Vue 学习。 【11-08】发现自己所有知识点都塞进一篇文章了，感觉不好，所以拆分成 VueBase、VueRouter、VueCli、Axios 这四篇文章。同时，发现自己 Axios 没法跟着教程下去了，想搞点 Node 基础，弄个 Koa 服务来帮助自己。 四 感言  【11-04】今天第一次发表该文章，收到了许许多多的评价，这里我抽取印象教深刻的两句话，说说我的想法： “我现在 觉得看别人的技术书籍都没有官方的好.因为别人吃过一遍，可能还没有消化好就出来欺世盗名...然后我们看他写的...学到的就更少了” “为什么不直接翻官方文档，然后再以别人的技术文章为辅”。  再三咀嚼这两句话，我觉得还是有道理的，就好比我在文章中，会说明我参考了哪里的视频，哪里的文章，最后推荐小伙伴们去积极查阅官方文档。 关于 欺世盗名 说法，个人觉得我不曾牛逼做到这种效果 ^_^。 我写文章的目的，仅仅是为了加深我的印象，并且将我的学习、工作经验分享出来，让其他人学习后，可以减少重复躺坑时间。 五 感谢 QQ群：364140450 的网友 青蛙表哥。非常佩服这位老哥，发表文章当天就我的代码敲了一遍，然后告诉我一些代码是可以优化的，并且对【深度监听】章节进行了自己的理解并推翻了我的代码。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:39:50 "},"JavaScript-library/Vue/VueBase.html":{"url":"JavaScript-library/Vue/VueBase.html","title":"✔ Vue 基础","keywords":"","body":"Vue 基础 Create by jsliang on 2018-11-8 13:34:30Recently revised in 2019-05-20 19:35:47 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址 推荐通过 目录 以及使用 返回目录 按钮，获得更好的阅读体验。 一 目录 不折腾的前端，和咸鱼有什么区别~ 目录 一 目录 二 正文  2.1 初识 Vue  2.2 挂载数据 - data  2.3 进一步优化 el  2.4 插值表达式 - {{ }}  2.5 指令 - v-*  2.6 事件 - methods  2.7 组件 - components   2.7.1 初识组件   2.7.2 父子组件通讯   2.7.3 共用组件  2.8 过滤器 - filter   2.8.1 局部过滤   2.8.2 全局过滤  2.9 监听数据   2.9.1 侦听属性 - watch   2.9.2 计算属性 - computed   2.9.3 watch、computed 与 methods 对比  2.10 传递 DOM - slot   2.10.1 slot 单个传递   2.10.2 具名 slot  2.11 Vue 组件生命周期   2.11.1 beforeCreate & created   2.11.2 beforeMount & mounted   2.11.3 beforeUpdate & updated   2.11.4 beforeDestory & destory   2.11.5 activated & deactivated  2.12 获取 DOM 元素   2.12.1 单个 DOM 元素获取   2.12.2 组件 DOM 元素获取   2.12.3 Vue.nextTick() 三 实战 四 总结 二 正文 返回目录 饮水思源：Vue 官方文档 Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 学习版本：v2.5.21编写时间：2019-1-10 如版本更迭太大或者时间小伙伴们看到这篇文章太久没更新，小伙伴们请查看 Vue 官方文档学习最新的 Vue。 2.1 初识 Vue 返回目录 那么，Vue 是怎么折腾的呢？ 话不多说，我们直接来看代码实现： index.html Vue 学习 new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: '#app', // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` Hello World ` }) 现在，我们解析下代码运行： 首先，创建一个空白的 html 模板文件，通过 CDN 引用 Vue： Vue 一般分两个版本：开发版本：开发中有友好的错误提示。生产版本：上线部署使用的版本，代码包比较小 index.html 代码片段 然后，我们编写一个挂载点，即我们的 Vue，最终会在哪个 DOM 里面进行操作： 最后，我们通过 New 一个 Vue 实例对象，对我们 id 为 app 的 DOM 节点进行操作： new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容。 // 最外层必须有一层包裹，例如 template: ` Hello World ` }) 这样，我们最终就显示了 Vue 的简单引用，是不是觉得非常简单： 2.2 挂载数据 - data 返回目录 如果 Vue 仅仅是只有 template 这个模板装载，那么它跟 jQuery 就显得没多大差别了，下面我们使用下 Vue 的 data 进行数据渲染： index.html Vue 学习 new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: '#app', // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` {{ text }} `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 text: 'Hello World!' } } }) 在这里，我们可以看到，我们在 template 中加了一个 标签，通过 {{ text }} 形式，引入了一个叫 text 的 data 数据： {{ text }} 接着我们在 中定义了 text 的内容，从而实现数据渲染： data() { return { // template 中要使用的数据 text: 'Hello World!' } } 这样，我们就知道了，我们不仅可以通过模板 template 来渲染 标签，我们也可以将 js 中定义的数据或者变量，通过操作 data 从而改变 html 里面的内容。 2.3 进一步优化 el 返回目录 在 2.1 章节 及 2.2 章节中，我们使用 el 的方式是： el: '#app', 该 el 挂载形式，在 Vue 内部运行机制中，它会根据你传入的值，进行查找： 如果传入的是 #app，那它就判断查找 id 为 app 的节点； 如果传入的是 .app，那它就查找 class 为 app 的节点； 如果传入的是节点名 div，那它就查找节点名…… 大家应该清楚，这样判断查找是需要时间的，多执行一个判断都是罪恶。 所以我们可以： el: document.getElementById('app'), 这般操作，使得 Vue 直接将挂载点挂载到 id 上去，从而获得更好的加载速度。这算是对 el 的一个小优化。 2.4 插值表达式 - {{ }} 返回目录 如果小伙伴有点印象，应该还记得，我们在章节 2.2 中通过 {{}} 这个插值表达式的使用，在 data 中对其里面的数据进行操作。 下面，我们进一步讲解这个插值表达式 {{}} 还可以进行哪种骚操作： 对象：{{ {name: 'jack'} }} 字符串 {{ 'Hello World!' }} 布尔值： {{ isTrue == -1 }} 三元表达式： {{ isTrue ? '正确' : '错误' }} 光字面理解是不够的，我们通过代码进行操作演示： index.html Vue 学习 new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` {{ text }} {{ {name: 'jack'} }} {{ 'Hello World!' }} {{ isTrue == -1 }} {{ isTrue ? '真' : '假' }} `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 text: 'Hello World!', isTrue: true } } }) 它在浏览器的展示为： 关键代码讲解： 标签中 --> {{ text }} {{ {name: 'jack'} }} {{ 'Hello World!' }} {{ isTrue == -1 }} {{ isTrue ? '真' : '假' }} 通过三元表达式的运用，我们可以做到一些判断：数组最后一个元素、是否动态显示隐藏等。 2.5 指令 - v-* 返回目录 在 Vue 中，如果单单使用 {{}} 这种插值表达式，是满足不了我们对数据的操作欲望的。所以，Vue 以 v-if、v-bind 等形式，提供了一些对于页面 + 数据的更为方便的操作：指令 v-text v-html v-if v-else-if v-else v-show v-bind v-click v-model v-for 这里采用一个页面展示所有指令，如果小伙伴想逐个详细了解指令，推荐去官网查看学习：Vue 指令 那么，上面的指令都是怎么使用的呢？这里通过一个 index.html 及一张图向大家演示其基本用法： index.html Vue 学习 /* 颜色样式：红、绿、蓝 */ .color-red { color: red; } .color-blue { color: blue; } .color-green { color: green; } new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` v-text 演示 v-html 演示 v-if -> v-else-if -> v-else 演示 Hello v-If Hello v-else-if Hello v-else v-show 演示 v-bind:××× -> :××× 演示 v-click -> @click 演示 v-on:click - 点击直接改变 vBind 的值 v-on:click - 点击通过事件改变 vBind 的值 v-model 演示 {{ vModel }} v-for 演示 {{index+1}}. {{item.name}} - {{item.age}} `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 // v-text 及 v-html 使用数据 vTextOrHtml: '我是红的', // v-if 使用数据 vIf: 2, // v-show 使用数据 isTrue: false, // v-bind 使用数据 vBind: \"Hello v-bind\", // v-bind 通过动态绑定 class 修改样式 colorRed: 'color-red', // v-bind 的 :属性 的使用形式 other1: 'other1', // 同上 other2: 'other2', // v-model 使用数据 vModel: 'Hello v-model', // v-for 使用数据 vFor: [{ name: '张三', // 姓名 age: 22, // 年龄 classStyle: \"color-red\" // 样式 }, { name: '李四', age: 23, classStyle: \"color-blue\" }, { name: '王五', age: 24, classStyle: \"color-green\" } ] } } }) 我们看下页面： 在这里，我们对代码进行下讲解： Hello v-If Hello v-else-if Hello v-else > --> v-on:click - 点击直接改变 vBind 的值 v-on:click - 点击通过事件改变 vBind 的值 {{ vModel }} {{index+1}}. {{item.name}} - {{item.age}} v-bind 和 v-model 的区别： v-bind：将 Vue 中的数据同步到页面，即该值大部分用于前端向浏览器传固定数据。v-bind 可以给任何属性赋值，是从 Vue 到页面的单向数据流，即 Vue -> html。 v-model：双向数据绑定，前端向浏览器传数据，用户操作浏览器的更改前端可以察觉到。v-model 只能给具有 value 属性的元素进行双向数据绑定（必须使用的是有 value 属性的元素），即 Vue -> html -> Vue 关于 Vue 的指令，这里咱先对它进行了个全面的简单了解，知道它是如何使用的。想详细学习的小伙伴，记得前往官方文档：Vue 文档 2.6 事件 - methods 返回目录 在上一章 2.5 中，我们通过在 button 中使用 v-on:click 时，给它绑定了事件方法。 但是，在 2.5 中，我们大体讲述了事件方法的使用，但是我们只是一知半解。 在这里，我们抽取出来做下讲解： index.html Vue 学习 new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` 添加行内样式 `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { addStyle(e) { e.toElement.style.background = \"red\" } } }) 此时页面的点击效果如下所示： 此刻我们分析下页面： 首先，在上面的 中，我们通过 @click 绑定了事件 addStyle： 添加行内样式 接着，方法的编写，需要写到与 data 同级的 methods 中： methods: { // 方法 addStyle: function(e) { e.toElement.style.background = \"red\" } } 然后，我们通过传递参数 e，可以获取到点击的时候的元素，通过查找，我们发现它的样式所在的目录结构如下： - button - toElement - style - background 最后，我们在用户点击按钮的时候，直接修改了它的背景。 2.7 组件 - components 返回目录 敲黑板！敲黑板！敲黑板！ 组件是 Vue 学习的重点，组件化的 SPA 或者 SSR 页面的制作，使得我们开发起来更加随心应手。 2.7.1 初始组件 返回目录 在上面的章节中，我们一直使用 template: `` 的形式，编写 html 标签。但是，随着项目的不断扩大，如果全部代码都写在一个 template 中，那么我们修改起来就复杂了。所以，我们应该想办法对它进行划分，例如将一个页面划分为 header、content、footer 三部分。这样，我们需要修改 nav 的时候，只需要在 header 中修改就可以了。 页面结构 - app - header - content - footer 这样的思想，在 Vue 中体现为组件（组合起来的部件）。那么，在 Vue 中，需要如何做，才能比较好的做到组件的划分呢？ 首先，我们捋捋逻辑： 在前面的章节中，在 Vue 的定义上，我们将首个 template 挂载到了 id 为 app 的节点上。然后将 template 划分为三个块：header、content、footer。 在这里，我们将 #app 的 template 叫做父组件，header 等叫子组件，就好比父亲下面有三个儿子一样。 然后，我们尝试从 new Vue 中抽离单个组件出来： index.html Vue 学习 // 声明入口组件 var App = { template: `我是入口组件` } new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: '', // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 app: App } }) 这时候页面如下所示： 接着，我们分析下进行的三部曲： 在 component 中定义并抽离 App 在 new Vue 外定义 App 在 template 中使用 App 这样，我们就做到了单个组件的抽离，及 new Vue 是 App 的父组件，App 是 new Vue 的子组件。 最后，既然上面做到了单个组件的抽离，现在我们实现多个组件的抽离： index.html Vue学习 // 声明头部组件 var MyHeader = { template: `我是头部` }; // 声明内容组件 var MyContent = { template: `我是躯体` }; // 声明底部组件 var myFooter = { template: `我是底部` } new Vue({ el: document.getElementById('app'), components: { // 声明要用的组件们 // key 是组件名，value 是组件对象 'my-header': MyHeader, 'my-content': MyContent, 'my-footer': myFooter }, template: ` ` }) 这样，我们就做到了组件的抽离。 注意：template 有且只有一个根节点，如果没有根节点，Vue 会给你报错。 template: ` ` 上面那种写法是错误的，谨记。 做到这里，我们又可以愉快玩耍了，而且 myHeader、myContent、myFooter 中是可以跟 new Vue 一样写 data、methods 的哦~ 例如： var MyHeader = { data() { return { // ... 定义数据 } }, template: `我是头部`, methods: { // 定义方法 } }; 2.7.2 父子组件通讯 返回目录 既然前面章节已经划分了父子组件，那么在这里，我们讲件更有趣的事：父子组件通讯。 在组件间，我们 new Vue 相当于父亲（父组件），他有自己的 data。然后，子组件也会有自己的 data。 假如某天，父亲找到自己的儿子，想告诉他：“其实你不是我亲生的，你的姓名是***”。 那么，在 Vue 中，我们要怎么做，才能让它的儿子（子组件），知道它的姓究竟是什么呢？我们来看代码： index.html Vue 学习 // 子组件 var Son = { template: ` 我的名字：{{name}} `, props: ['name'] } new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 name: '皮皮虾' } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 son: Son } }) 编写完代码后，我们可以在浏览器看到，浏览器显示出了：我的名字：皮皮虾，这几个大字。 哦了，原来父亲的儿子姓 皮。同时，我们也就知道了，在父组件中的数据，通过 v-bind:*** 的形式，将父组件中的 data，发送给子组件。而子组件呢，通过 props 的定义，获取到了父亲的数据。 这样我们就做到了父组件传递数据给子组件。 2.7.3 共用组件 返回目录 在上面中，我们提到： - App - my-header - my-content - my-footer 在 App 这个组件上，我们挂载了三个子组件：myHeader、myContent、myFooter。 但是，如果某天，出现了一个女孩（共有组件），这个女孩的名字叫：beautifulGirl。然后不仅三个儿子（子组件）想追求她，就连父亲（父组件）也想追求她（够疯狂）。 那么，在 Vue 中，是通过什么方式，使父亲和儿子都有机会接触到这个女孩呢？（父子组件如何能够都可以使用共用组件） index.html Vue 学习 // 声明头部组件 var MyHeader = { template: ` 我是头部，我想了解 ` }; // 声明内容组件 var MyContent = { template: ` 我是内容区，我想了解 ` }; // 声明底部组件 var myFooter = { template: ` 我是底部，我想了解 ` } // 声明共用组件 Vue.component('beautiful-girl', { template: `—— 美丽女孩 ——` }) new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 'my-header': MyHeader, 'my-content': MyContent, 'my-footer': myFooter, } }) 在这里，我们通过 Vue.component('组件名',{ }) 的形式，注册了个全局组件 beautiful-girl，这样，父子组件都可以直接调用该组件，从而在浏览器显示为： 现在，父亲和儿子都可以和漂亮女孩沟通了。究竟是父亲给他们的儿子找了个后妈，还是他们儿子找到自己所爱呢？敬请期待…… 2.8 过滤器 - filter 返回目录 在工作中，我们经常需要对一些后端传回来的数据进行过滤。例如：我司 Java 小哥传回来的金钱，就是分进制的，即：1元 = 100分。所以传回个 2000，其实是 20 元。那么，在 Vue 中，我们该如何对数据进行过滤呢？ 2.8.1 局部过滤 返回目录 话不多说，先上代码： index.html Vue 学习 // 声明头部组件 var MyHeader = { template: ` 我是头部，我想了解 ` }; // 声明内容组件 var MyContent = { template: ` 我是内容区，我想了解 ` }; // 声明底部组件 var myFooter = { template: ` 我是底部，我想了解 ` } // 声明共用组件 Vue.component('beautiful-girl', { template: `—— 美丽女孩 ——` }) new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` 我是钱多多，我有 {{money}} 多一点： ￥{{money | addDot}}，跟我混有出息~ `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 money: 1000000 } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 }, // 8. filters - 组件内的过滤器 filters: { addDot(money) { return (money / 1000000 + \".000000\"); } } }) 在上面，我们通过 filters 中的 addDot 方法，对数据进行了过滤，将 money 的数据，从 10000000 变成了 1.000000。 2.8.2 全局过滤 返回目录 然后，在尝试了局部 filters 的好处之后，我们还可以试试它的全局过滤器写法： index.html Vue 学习 // 全局过滤器 Vue.filter('addDot', function(money) { return (money / 1000000 + \".000000\"); }) new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` 我是钱多多，我有 {{money}} 多一点： ￥{{money | addDot}}，跟我混有出息~ `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 money: 1000000 } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 }, // 8. filters - 组件内的过滤器 filters: { } }) 最后在页面中显示为： 2.9 监听数据 返回目录 在 Vue 中，我们通过 v-model 做了双向数据绑定，即在页面的 中输入的值，在我们的 Vue 中可以获得数据；在 Vue 中定义的数据，也会即时渲染到页面中。 但是，在代码中，我们怎样才能获取到它即时输入的数据呢？ 2.9.1 侦听属性 - watch 返回目录 话不多说，先上代码： index.html Vue 学习 new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` {{money}} `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 money: '' } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 }, // 8. filters - 组件内的过滤器 filters: { }, // 9. watch - 侦听属性 watch: { // key: data 属性的属性名 money(newVal, oldVal) { console.log(newVal, oldVal); } } }) 这样，当我们输入 11 个 1 的过程中，浏览器的 Console 对应输出为： 2.9.2 计算属性 - computed 返回目录 在上面，我们讲了通过 watch 来监听 data 中 number、string 等字段的改变。但是，在 Vue 中，为了方便我们的监听操作，Vue 还定义了个方法：computed，我们可以通过 computed，监控我们在 data 中定义的全部数据。 index.html Vue学习 new Vue({ el: document.getElementById('app'), template: ` + * = {{result}} `, data: { number1: 0, number2: 0, number3: 0, result: '', }, computed: { // 如果原值不变，缓存不调函数的优化机制 result: function() { // 监视对象，写在了函数内部， // 凡是函数内部有 this. 相关属性，改变都会触发当前函数 let addSum = parseInt(this.number1) + parseInt(this.number2); let allSum = addSum * this.number3; return allSum; } } }) 其结果如下面 GIF 图所示： 2.9.3 watch、computed 与 methods 对比 返回目录 在上面，我们涉及了两个知识点：watch 与 computed。 那么，又到 “玄学” 的时刻了，都是跟监听数据打交道，我们平时使用 Vue 的时候，什么时候使用 watch，什么时候使用 computed？然后，如果我们在加上 methods，那么什么时候我们又用 methods 呢？ 首先，我们对比下 computed 与 methods： computed 是根据 data 中的数据变化，而进行的操作。即 this.任意数据 改变了，那么，computed 就会进行改变；而如果 this.任务数据 不变，那么 computed 就会执行它的缓存策略，不会更新 methods 一般是根据点击之类的事件来触发的，例如用户通过 @click=\"方法\" 来进行数据的改变。 然后，我们对比下 computed 与 watch： 如果上面章节的 computed 方法换成 watch： index.html 代码片段 // 9. watch - 侦听属性 watch: { // key: data 属性的属性名 result(newVal, oldVal) { console.log(newVal, oldVal); this.result = this.number1 + this.number2 * this.number3; } }, 你会发现，result 数据不变化了，因为这是 computed 才特有的玩意，如果你需要将上面章节的 computed 方法换成 watch，那么你需要： index.html 代码片段 // 9. watch - 侦听属性 watch: { // key: data 属性的属性名 number1(val) { this.result = parseInt(this.number1) + parseInt(this.number2) * parseInt(this.number3); }, number2(val) { this.result = parseInt(this.number1) + parseInt(this.number2) * parseInt(this.number3); }, number3(val) { this.result = parseInt(this.number1) + parseInt(this.number2) * parseInt(this.number3); } }, 如此，小伙伴应该了解到，watch 如果需要完成 computed 的功能，那么，它需要监听每一个需要改变的属性。 最后，在这里，我们大致描述下 watch 与 computed 的区分： computed 强调计算，例如 c = a + b，b 是外界传来不断变化的，因为你只要显示 c，所以使用 computed。而 watch 属性强调自身值的变化前后的动作，如果需要完成 c = a + b，那么你需要 watch 数据 a 与 b 的变化，在这两者变化的时候，在方法中执行 c = a + b。 watch 在处理异步操作或者开销较大的操作上有优势。 执行异步操作不能串行返回结果，使用 watch； 开销较大的操作，避免堵塞主线程，使用 watch； 简单且串行返回的，使用 computed。 computed 对绑定的值有依赖，如果每次操作的值不变化，则不进行计算，具有缓存特性。watch 会侦听前后变化的状态，无论操作的值是否变化，都会执行定义的函数体，所以会有 data(newVal, oldVal)。 如果小伙伴们较真上了，那么请查看官方文档：计算属性和侦听器 2.10 传递 DOM - slot 返回目录 在日常工作中，我们对一些常用的功能，例如：侧边栏、顶部导航栏等，会进行常用的封装，等我们想用的时候，就可以直接引用。那么，在 Vue 中，想实现这类功能，我们还需要了解什么？ 2.10.1 slot 单个传递 返回目录 话不多说，先上代码： index.html Vue 学习 var myLi = { template: ` ` }; Vue.component('my-li', myLi); var App = { template: ` 我是第一行 button 按钮 我是第二行 h3 标签 我是第三行 a 导航 我是第四行 span 标签 ` }; new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 app: App }, // 8. filters - 组件内的过滤器 filters: { }, // 9. watch - 侦听属性 watch: { // key: data 属性的属性名 }, // 10. computed - 计算属性 computed: { // 如果原值不变，computed 会执行缓存，即不调用方法 } }) 其结果如下图所示： 那么，上面代码中，我们干了什么？ 首先，如上代码及其结果图，我们的 new Vue 中挂载了一个组件 App。 new Vue({ el: document.getElementById('app'), components: { app: App }, template: ` ` }) 然后，该 App 的目的，是想动态引用一个 li 组件 var App = { template: ` 1 2 3 4 ` }; 接着，我们在全局定义 myLi 组件的同时，通过 插槽，使它能够动态地加载 dom 节点。 var myLi = { template: ` ` }; Vue.component('my-li', myLi); 最后，我们在 App 中，传递给它不同的 dom 节点，从而动态生成 App。 var App = { template: ` 我是第一行 button 按钮 我是第二行 h3 标签 我是第三行 a 导航 我是第四行 span 标签 ` }; 这样，我们就思路清晰地知道，如何通过 来动态地加载 dom 节点，对我们 Vue 开发又有了更好的帮助。 2.10.2 具名 slot 返回目录 在上面中，我们谈论到了单个插槽 slot 的用法。但是，如果组件想根据父组件是否传递某个变量来存放插槽的数量，要怎么做呢？ index.html Vue 学习 var mySlot = { template: ` ` }; Vue.component('my-slot', mySlot); var App = { template: ` Helo World! 按钮 链接 ` }; new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 app: App }, // 8. filters - 组件内的过滤器 filters: { }, // 9. watch - 侦听属性 watch: { // key: data 属性的属性名 }, // 10. computed - 计算属性 computed: { // 如果原值不变，computed 会执行缓存，即不调用方法 } }) 效果图如下： 下面我们分析下，我们在代码中做了啥： 首先，我们通过下面代码可以知道，第一个 li 的 slot 是未命名的默认 slot，所以它在页面中展示为 p 的数据。 var mySlot = { template: ` ` }; var App = { template: ` Helo World! 按钮 链接 ` }; 然后，再观察下 App 中的代码 按钮 和 链接，发现它们使用了 slot=\"***\"，这说明了它指定了要求组件中 的代码接收。所以第二行第三行显示为按钮和链接。 最后，由于最后一个 li 中 ，这个 name=\"three\" 在 App 组件中没有用到，所以它表现为空。 2.11 Vue 组件生命周期 返回目录 在 Vue 中，什么时候进行虚拟 dom 渲染成 dom，或者什么时候销毁代码，都是有对应的钩子的： beforeCreate created beforeMount mounted beforeUpdate updated activated deactivated beforeDestory destory 关于生命周期，Vue 官方文档是有相关图示及文档的：官方文档 - Vue 生命周期 下面我们通过代码演示，讲解这 5 组生命周期的用法。 2.11.1 beforeCreate & created 返回目录 话不多说，先上代码： index.html Vue 学习 var lifeCycle = { template: ` 我是生命周期组件 `, data: function() { return { text: 'Hello World!' } }, beforeCreate: function() { // 组件创建之前 console.log(this.text); // [Console] undefined }, created: function() { // 组件创建之后 console.log(this.text); // [Console] Hello World! } /* * 使用 lifeCycle 组件，就会触发以上的事件函数（钩子函数） * created 中可以操作数据，并且可以实现 Vue -> 页面 的影响 * 应用：发起 ajax 请求 */ } var App = { components: { 'life-cycle': lifeCycle }, template: ` ` } new Vue({ el: document.getElementById('app'), components: { app: App }, template: ` ` }) 在代码中可以看到，我们在 App 中引用了 lifeCycle 这个组件。 我们通过钩子函数 beforeCreate（组件创建之前） 与 created（组件创建之后），结合 console 发现，这两个钩子函数对于 data 来说，一个在 data 挂载前（beforeCreate），所以打印出来的是：undefined，而另外一个发生在 data 挂载后，所以打印出来的是：Hello World!。 2.11.2 beforeMount & mounted 返回目录 话不多说，先上代码： index.html Vue 学习 var lifeCycle = { template: ` 我是生命周期组件 `, data: function() { return { text: 'Hello World!' } }, beforeMount: function() { // Vue 起作用之前 console.log(document.body.innerHTML); }, mounted: function() { // Vue 起作用，装载数据到 DOM 之后 console.log(document.body.innerHTML); } } var App = { components: { 'life-cycle': lifeCycle }, template: ` ` } new Vue({ el: document.getElementById('app'), components: { app: App }, template: ` ` }) 那么，虽说它们的作用，一个是 Vue 起作用之前，一个是 Vue 起作用，装载数据到 DOM 之后。 我们应该怎样才能观察到它的作用？ 看到上图的红框，也许你会恍然大悟：“喔，beforeMount 就是我装载之前的钩子函数，而 mounted 是我装载之后的钩子函数，它是 Vue 作用以后的 DOM” 2.11.3 beforeUpdate & updated 返回目录 话不多说，先上代码： index.html Vue 学习 var lifeCycle = { template: ` 我是生命周期组件 {{text}} 点击改变 text `, data: function() { return { text: 'Hello World!' } }, // 基于数据改变，影响页面 beforeUpdate: function() { // 改变前 console.log(document.getElementById('update').innerHTML); }, updated: function() { // 改变后 console.log(document.getElementById('update').innerHTML); } /* * 在日常工作中，我们可以在事件前后拿到它的 DOM，从而做一些我们想要的操作 */ } var App = { components: { 'life-cycle': lifeCycle }, template: ` ` } new Vue({ el: document.getElementById('app'), components: { app: App }, template: ` ` }) 在解析代码前，我们先查看它的输出： 可以看出，beforeUpdate 可以获取原 DOM，而 updated 可以获取新 DOM。 它们在上面代码中变现为：获取 按钮触发的事件前后 DOM 的变化，通过这个变化，我们可以在当中做一些操作，从而更好的满足我们的业务需求。 小结：（ beforeMount & mounted ） VS （ beforeUpdate & updated ） 那么问题来了，beforeMount 这组和 beforeUpdate 都能监控到 DOM 的变化，它们有什么区别呢？ 答案是，一般我们如果需要在页面加载的时候，监控 DOM 的变化，那就使用 beforeMount 和 mounted；但是，如果我们想监控用户的操作（点击事件等），那么，我们就需要使用 beforeUpdate 和 updated，因为它们不像 beforeMount 和 mounted 只会在页面挂载初期执行一次，它们可以根据用户的操作被执行多次。 2.11.4 beforeDestory & destory 返回目录 话不多说，先上代码： index.html Vue 学习 var lifeCycle = { template: ` 我是生命周期组件 `, // 对应父组件 v-if == false 的时候，就产生下面钩子函数，销毁当前组件 beforeDestroy: function() { // 销毁之前 console.log('实例销毁之前调用。在这一步，实例仍然完全可用。'); }, destroyed: function() { // 销毁之后 console.log('Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。'); } } var App = { components: { 'life-cycle': lifeCycle }, data: function() { return { isExist: true } }, template: ` 点击改变 子组件 状态 ` } new Vue({ el: document.getElementById('app'), components: { app: App }, template: ` ` }) 在这里，我们在点击 的时候，控制台显示为： 可以看出，当我们点击 的时候，我们的 isExist 状态（第一次时）被改变为 false，从而触发了 lifeCycle 的销毁钩子函数，在控制台打印了上面两行话。 相应的，如果是当 isExist 状态变为 true 的时候，会触发我们的 beforeCreate 和 created 这两个钩子函数，有兴趣的小伙伴可以尝试一下，这里不做过多演示。 2.11.5 activated & deactivated 返回目录 经过长期的工作，我们知道，如果频繁的操作 DOM，进行影响到钩子函数 beforeCreate 和 created 及 beforeDestory 和 destory 的操作，是对我们的性能会产生影响的。我们要如何防止某部分代码的频繁操作 DOM，并且监听到它的操作呢？ index.html Vue 学习 var lifeCycle = { template: ` 我是生命周期组件 `, activated: function() { console.log(\"组件被激活了\"); }, deactivated: function() { console.log(\"组件被停用了\"); } } var App = { components: { 'life-cycle': lifeCycle }, data: function() { return { isExist: true } }, template: ` 点击改变 子组件 状态 ` } new Vue({ el: document.getElementById('app'), components: { app: App }, template: ` ` }) 在代码中，我们通过 这个 Vue 的内置组件，对我们子组件进行了包裹。 然后，当我们进入页面和点击按钮时，做到了 activated 和 deactivated 这两个钩子函数的触发： 可以看出，当我们进来页面的时候，它就告诉我们，该组件被激活了。当我们第一次点击 按钮的时候，isExist 的状态变成了 false，即该组件被停用了。最后，我们再次点击了 ，这时候控制台再次打印 组件被激活了。 小结：这时候，希望小伙伴回到生命周期章节的开头，看官方关于生命周期的解析图，它将有助于我们更加理解声明周期。如果还是不够清晰，可以点击图片旁边的按钮，进入官方文档，查看官方关于生命周期的解析。【返回加深学习】 2.12 获取 DOM 元素 返回目录 在日常开发中，可能有小伙伴会想到操作 DOM 元素。如果用原生的 document.getElementById 吧，可能太 low 了，所以，有没有类似于 jQuery 的 $(\"#id\") 之类的呢？ 2.12.1 单个 DOM 元素获取 返回目录 话不多说，先上代码： index.html Vue 学习 var App = { template: ` 按钮 `, beforeCreate: function() { // 这里不能操作数据，只是初始化了事件等…… console.log(this.$refs.btn); // [Console] undefined }, created: function() { // 可以操作数据了 console.log(this.$refs.btn); // [Console] undefined }, beforeMount: function() { // new Vue 发生装载，替换 之前 console.log(this.$refs.btn); // [Console] undefined }, mounted: function() { // 装载数据之后 console.log(this.$refs.btn.innerHTML); // [Console] 按钮 } } new Vue({ el: document.getElementById('app'), components: { app: App }, template: `` }) 我们先查看下页面： 首先，我们在组件的 DOM 部分（），写上 ref = \"btn\"。 然后，我们发现只有在 mounted 数据装载之后这个钩子函数中，通过组件对象 this.$refs.btn 可以获取到元素 这样，我们就知道在一些场景，如何可以方便地通过 Vue 获取到 DOM 元素了。 2.12.2 组件 DOM 元素获取 返回目录 在上面，我们获取到了单个 DOM 节点的部分，假如我们需要获取到整个子组件，那么要怎么做呢？ index.html Vue 学习 var tempComponent = { template: ` 我是临时组件 ` } Vue.component('temp', tempComponent); var App = { template: ` `, mounted: function() { // 装载数据之后 console.log(this.$refs.temp.$el); } } new Vue({ el: document.getElementById('app'), components: { app: App }, template: `` }) 我们先不急着分析，先看控制台打印出了什么； 在这里可以看到它打印出了一堆关于该组件的东西，其中 $children - 当前组件的子组件 $el - 当前组件的元素节点 $parent - 当前组件的父组件 $root - 获取 new Vue 实例 然后发现元素 $el是 DOM 节点的内容，我们尝试打印出来看一下： console.log(this.$refs.temp.$el); Console 我是临时组件 通过 Console 可以看出，$el 就可以打印出其中的 元素了。 2.12.3 Vue.nextTick() 返回目录 当然，我们有时候操作 DOM，是想在 data 数据变更的时候进行操作，如果是使用上面方法，有些时候是搞不定的。 那么，我们应该怎么做呢？ index.html Vue 学习 var App = { template: ` `, data: function() { return { isShow: true } }, mounted: function() { // 希望在 Vue 真正渲染 DOM 到页面之后进行下面操作 this.$nextTick(function() { this.$refs.input.focus(); }) } } new Vue({ el: document.getElementById('app'), components: { app: App }, template: `` }) 如上，通过 Vue 的全局 API Vue.nextTick()，我们在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 这个操作我们可想象下 Promise 的执行流程，会获得更好的体验。 三 实战 返回目录 那么，学到这里，我们应该进行一个简单的操练，来回顾我们所学知识了： Vue Todolist - 功成千骨教学文章 Vue Todolist - 功成千骨代码地址 Vue Todolist - 功成千骨页面演示 四 总结 返回目录 如上，我们入门了基础的 Vue，可能小伙伴们会觉得还是很晕。 但是，没关系，我们接下来在讲解 VueRouter、VueCli 的时候还是会使用 Vue 基础语法的，正如那句话：万丈高楼平地起，地基还得自己起。 多实操，多做笔记，总能熟练上去的，加油~ 后记 如果小伙伴需要存放 jsliang.top 这样的纯静态页面或者 company.jsliang.top 这样的具有 Node 后端支持的页面，推荐购买云服务器来存放。 如果小伙伴们不知道该怎么选择云服务器，可以查看 详细介绍 或者加 jsliang QQ：1741020489 咨询。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:35:49 "},"JavaScript-library/Vue/VueOfficialDocuments.html":{"url":"JavaScript-library/Vue/VueOfficialDocuments.html","title":"✔ Vue 官方文档二三事","keywords":"","body":"Vue 官方文档二三事 Create by jsliang on 2019-1-14 10:40:32Recently revised in 2019-1-22 08:31:29 记录在阅读 Vue、VueRouter、VueCli 等官方文档时的一些笔记，仅供参考，不做意见发表。 一 目录 目录 一 目录 二 Vue  2.1 安装  2.2 指令  2.3 生命周期钩子  2.4 数据监听  2.5 样式  2.6 数组操作  2.7 事件修饰符  2.8 按键修饰符  2.9 父子组件及其通讯  2.10 过渡动画  2.11 混入  2.12 自定义指令  2.13 过滤器 三 Vue Router 四 Vue Cli 五 Vuex 六 风格规范  6.1 命名规范  6.2 全局规范  6.3 HTMl 规范  6.4 JS 规范  6.5 CSS 规范 二 Vue 返回目录 本章节内容参考自： Vue 教程 Vue API 2.1 安装 返回目录 如果是 0 基础，推荐通过 CDN 引用 Vue：BootCDN。 如果有 Node + Webpack 基础，推荐使用命令行工具：Vue Cli npm i @vue/cli -g 2.2 指令 返回目录 v-text —— 将数据解析为纯文本。另外还可以使用 {{ }}，它也会将数据解析为纯文本，与 v-text 的区别就是花括号在网络加载慢的时候会显示 {{ * }}。 v-html —— 输出真正的 HTML，在 v-html 中可以使用 HTML 标签，但是请注意防范 XSS 攻击。 v-if —— 通过值 true 或者 false 来 添加/删除标签，一般会结合三元表达式使用。与 v-show 的区别是，v-if 的标签，如果为 false 是直接删掉该节点，而 v-show 是通过 display:none 来控制标签。同时，v-if 与 v-else-if、v-else 可以配套使用。 v-show —— 通过值 true 或者 false 来切换 display 显示/隐藏标签，一般会结合三元表达式。 v-for —— 常见形式：v-for=\"(item, index) in items。item 是单个元素，index 是数组下标。其他形式：v-for=\"item of items。 v-bind —— 可以通过 v-bind 或者其简写 :bind 绑定到 HTML 的属性字段上，例如 标签动态绑定 url 的时候 :url 或者自定义属性 :disabled 或者动态绑定 class、style 中使用 :class、style 等…… v-on —— 可以通过 v-on 或者其简写 @ 来绑定到 HTML 事件上，例如点击事件 @click 或者鼠标回车事件 v-on:keyup.enter。v-on 与 methods 是一对搭档。 v-model —— 双向数据绑定。通常与 、 及 进行绑定。 v-once —— 只渲染元素和组件一次。之后重新渲染，该元素及其子元素会被视为静态内容忽略。 详细介绍：API - Vue.js 小 tips v-if 和 v-show：一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 v-if 和 v-for：永远不要把 v-if 和 v-for 同时用在同一个元素上，例如：v-for=\"user in users\" v-if=\"user.isActive\" 就是不推荐的。建议可以通过 HTML5 的标签 来分开这两者，其作用类似于微信小程序的 。如果你打死都要这么做，那么 v-for 具有比 v-if 更高的优先级。 v-model：善用三个修饰符：v-model.lazy 将 input 更新换为 change 更新；v-model.number 直接绑定数字，结合 更好使用；v-model.trim 自动过滤首尾空白字符。 2.3 生命周期钩子 返回目录 2.4 数据监听 返回目录 watch 与 computed： 对比一： computed 强调计算。例如 c = a + b，因为你只要显示 c，所以不需要理会 a 与 b 的值是否动态传入，只需要使用 computed 监察 c 即可。 watch 属性强调自身值的变化前后的动作。如果需要完成 c = a + b，那么你需要 watch 数据 a 与 b 的变化，在这两者变化的时候，在方法中执行 c = a + b。 对比二： watch 在处理异步操作或者开销较大的操作上有优势。执行异步操作不能串行返回结果、执行开销较大的操作避免堵塞主线程的时候，使用 watch。 简单且串行返回的，使用 computed。 对比三： computed 对绑定的值有依赖，如果每次操作的值不变化，则不进行计算，具有缓存特性。 watch 会侦听前后变化的状态，无论操作的值是否变化，都会执行定义的函数体，所以会有 data(newVal, oldVal)。 2.5 样式 返回目录 类型 说明 :class 动态绑定 Class，可以通过多分类：:class=\"{ a: true, 'b', c: false }，或者结合计算属性 :class=\"computedClass\"，或者通过三元表达式：:class=\"{ a ? a == 1 : a == 2 }\" :style 动态绑定行内样式，如果是 font-size 之类的，最好通过驼峰式 fontSize 来编写。如果采用 :style=\"{styleOne, styleTwo}\" 的形式，当遇到 transform 时，Vue 会自动添加相应的前缀。 2.6 数组操作 返回目录 改变原数组的方法 push() - 向数组尾部添加元素 pop() - 删除并导出数组最后一个元素 shift() - 删除并导出数组第一个元素 unshift() - 向数组开头添加元素 splice() - 向数组中添加/删除元素并返回新的数组 sort() - 排序 reverse() - 反转数组 不改变原数组的方法 filter() - 过滤数组 concat() - 拼接两至多个数组 slice() - 获取数组指定位置数据 不改变原数组的方法比改变原数组的方法高效，至于怎么姿势才爽，那就看个人感受了。 2.7 事件修饰符 返回目录 .stop - 阻止事件冒泡。例如：@click.stop=\"say\" 阻止 say 方法传递到上一级 DOM。 .prevent - 阻止默认事件。例如：@click.prevent=\"say\"，阻止点击事件，然后执行 say。 .capture - 给元素添加监听器，在一个 HTML 模块中，如果有 4 层嵌套，前 2 层使用了 .capture 修饰符，第 3/4 层未使用，点击第 4 层触发点击事件，则顺序为：1 -> 2 -> 4 -> 3，因为 .capture 会先触发。 .self - 只触发该 DOM 本身的事件。相比于 .stop 阻止事件冒泡，.self 忽略事件冒泡和捕获的影响。 .once - 事件将只会触发一次。例如：@click.once='doOnce'，doOnce 只会执行一次。 .passive - 不要阻止事件的默认行为。例如：v-on:scroll.passive=\"onScroll\"，在进行滚动的时候同时执行 onScroll，而不是等 onScroll 执行完再滚动。 2.8 按键修饰符 返回目录 v-on:keyup.13 = @click.enter .enter - 回车 .tab - Tab 键 .delete - Back Space 或者 Delete .esc - Esc 键 .space - 空格键 .up - 上箭头 .down - 下箭头 .left - 左箭头 .right - 右箭头 .ctrl - Ctrl 键 .alt - Alt 键 .shift - Shift 键 2.9 父子组件及其通讯 返回目录 基础组件的写法 全局组件与局部组件 父组件传递数据给子组件 子组件传递数据给父组件 父子组件的 v-model 实现 - 默认插槽与其具名插槽 :is 的灵活应用 缓存状态，避免重新渲染 静态赋值 props：title=\"My name is jsliang\"；动态赋值 props：:title=\"article.title + ' by ' + article.name；props 可以传入 String、Number、Boolean、Array、Object、Date、Function、Symbol 并且对其进行以上类型验证。 2.10 过渡动画 返回目录 单组件过渡 过渡 6 状态：v-enter、v-enter-active、v-enter-to、v-leave、v-leave-active、v-leave-to 过渡系统 + 第三方 CSS 动画库（Animate.css） 过渡时间：:duration 过渡钩子：@:before-enter、@:enter、@:after-enter、@:enter-cancelled、@:before-leave、@:leave、@:after-leave、@:leave-cancelled key 在 的作用 过渡模式：in-out 与 out-in 数字过渡 颜色过渡 2.11 混入 返回目录 在 Vue 中，有一群万金油般存在，高尚的临时工：mixins。 城管临时工：干着城管的活，日常冲在第一线，有问题直接背锅。 mixins，在官方的称呼是：混入。 然而，在个人理解上，更宁愿称呼它为：模具。 什么意思呢？就是当你发现 new Vue() 中的 data、methods，在多个页面重复使用的时候，你可以将它们抽取出来，然后跟 模具 一样，给需要使用的每个页面，先盖个章，留个某某到此一游的印迹，再在此基础上进行开发。 举个例子：你有一个字段 pageNo: 1，在文章列表页、商品页都定义了，你抽取出来，存放到 mixins.js 中，然后在这两个页面通过 mixins: mymixin 盖个章，让这两个页面初始数据都存有 pageNo: 1。 以后，你就是我的小弟了~ 项目目录 - src - mixins - utils src/mixins/mixins.js export default { data() { return { message: 'hello', foo: 'abc' } } } HomeHeader.vue import mymixin from '../src/mixins/mixins' new Vue({ mixins: mymixin, data: function () { return { message: 'goodbye', bar: 'def' } }, created: function () { console.log(this.$data) // => { message: \"goodbye\", foo: \"abc\", bar: \"def\" } } }) 选项混入 全局混入 extends 类似于 mixins extends 支持单个对象，mixins 支持数组 Vue.extend > Vue.component > extends > mixins，即开发的时候同时使用 extends 和 mixins，注意覆盖顺序 测试代码.html Vue 学习 var extend = { data() { return { number: 1 } } } var mixin = { data() { return { number: 2 } } } new Vue({ el: '#app', data() { return { number: 3 } }, extends: extend, mixins: [mixin], created() { // 在这里不推荐同时使用 extends 与 mixins，因为会混淆 // 如果代码是这样子的，则这里输出的是 3 // 如果 new Vue 中没定义 number，则输出的是 2（mixins 中的值） // 如果 mixins 中没定义 number，则输出的是 1（extend 中的值） console.log(this.number); // Console：3 } }) 2.12 自定义指令 返回目录 局部指令：directives 全局指令：Vue.directive 自定义指令钩子函数：bind、inserted、update、componentUpdated、unbind 作用： focus 自动聚焦 2.13 过滤器 返回目录 使用方法：{{ message | messageFilter }}，然后定义 filters: { messageFilter(value) { // ...代码 } } 局部过滤器 全局过滤器 串联过滤器 三 Vue Router 返回目录 Vue Router 的基础使用。 动态路由匹配，动态设置匹配路径，动态匹配任意路径。 路由可以嵌套匹配，每个页面都可以有自己的 。 编程式导航：不仅可以通过 来定义导航链接，也可以通过 router.push(\"...\") 的形式来实现。同时，我们还可以采用 router.replace(\"...\") 来实现路由替换，通过 router.go(n) 来实现前进或者后退多少步路由。 命名路由的两种形式：在 中通过 :to=\"{name, params}\" 或者在 router.push() 中通过 {name, params} 来定义。 一个页面可以同时存在多个 ，只需要通过给它们命名 name 就可以实现。 路由可以通过 redirect 进行重定向，或者通过 alias 取别名，从而自由地将 UI 结构映射到任意的 URL。 路由还可以进行传参，通过取代与 $route 的耦合或者通过 props 解耦。其中有三种模式：布尔模式、对象模式以及函数模式。 Vue Router 的默认模式是 hash 模式，我们可以通过 mode，将其设置为 history 模式。 通过 router.beforeEach((to, from, next) => { ... }) 来注册全局路由守卫，它会在访问某个路由前进行拦截。其中 to 为即将进入的目标，from 为当前路由即将离开的位置，next 类似于 Promise 的 resolve。在 2.5+ 版本添加了 router.beforeResolve，作用类似于 router.beforeEach 路由全局后置钩子：router.afterEach((to, from) => {})。 可以针对某个路由进行守卫，即在 new VueRouter({}) 中通过 beforeEnter: (to, from, next) => {} 进行守卫。 可以直接在路由组件中定义：beforeRouteEnter、beforeRouteUpdate 以及 beforeRouteLeave。 完整的导航解析流程： 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 Vue Router 通过定义 meta，可以制定路由鉴权，缓存，标题信息等。 通过给 添加 包裹，并给 设置不同的 name，则添加过渡效果。同时，可以根据当前路由与目标路由的关系，动态设置过渡效果。 Vue Router 的引用，可以让我们动态设置数据是在导航完成之后获取还是在导航完成之前获取。 路由可以设置滚动行为，在切换到新路由时，可以滚动到顶部或者保持原先的滚动位置。 当路由过多，组件过大的时候，我们应该把不同的路由对应的组件分割成不同的代码块，从而使这些路由被访问的时候才加载对应组件，从而提高加载效率。使用 const Foo = () => import('./Foo.vue') 即可。同时，这些组件都可以通过 /* webpackChunkName: \"***\" */ 的形式，进行命名 chunk。 四 Vue Cli 返回目录 安装：npm install -g @vue/cli 创建项目：vue create my-project 或者 vue ui 兼容 VueCli 2.0 版本：npm i @vue/cli-init，然后就可以使用 vue init webpack 了。 五 Vuex 返回目录 为什么使用 Vuex ？ 数据的综合交错，很容易使代码难以维护。 数据传参非常繁琐，尤其是兄弟组件。 什么情况下使用 Vuex ？ 开发大型应用 数据庞大且繁杂 六 风格规范 返回目录 下面精简来自 Vue 风格指南 的条例，如需详细了解请访问 Vue 风格指南。 并不期望你能规规矩矩遵守，只是想让你有一套自己的编写风格，而不是一个项目一套风格，从而害人害己。 6.1 命名规范 返回目录 组件名应该始终是多个单词的，根组件 App 除外。这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。例如：todo-item、TodoItem。 只要有能够拼接文件的构建系统，就把每个组件单独分成文件。例如： components/ |- TodoList.vue |- TodoItem.vue 单文件组件的文件名应该要么始终是单词大写开头 PascalCase，要么始终是横线连接 kebab-case。例如： components/ |- MyComponent.vue 或者 components/ |- my-component.vue 基础文件名，即应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V。例如： components/ |- BaseButton.vue |- BaseTable.vue |- BaseIcon.vue 或者 components/ |- VButton.vue |- VTable.vue |- VIcon.vue 如果某个组件，像菜单栏、左侧菜单一样，全局中只拥有一个，那就以 The 前缀命名。例如： components/ |- TheHeading.vue |- TheSidebar.vue 和父组件紧密耦合的子组件应该以父组件名作为前缀命名。例如： components/ |- TodoList.vue |- TodoListItem.vue |- TodoListItemButton.vue 组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾；并且组件名应该倾向于完整单词而不是缩写。例如： components/ |- SearchButtonClear.vue |- SearchButtonRun.vue |- SearchInputQuery.vue |- SearchInputExcludeGlob.vue |- SettingsCheckboxTerms.vue |- SettingsCheckboxLaunchOnStartup.vue 而不是 components/ |- ClearSearchButton.vue |- ExcFromSearchInput.vue |- LaunchOnStartupCheckbox.vue |- RunSearchButton.vue |- SearchInput.vue |- TermsCheckbox.vue 6.2 全局规范 返回目录 尽量别在组件模板中使用 JS 来 bb 套太多话语，毕竟 HTML 就尽量让它做 HTML 该有的事；更好的分类能使代码更加简洁易懂；并且将组件模板中多特性的元素分多行来写，看起来会更舒服点。例如： |- HTML {{ normalizedFullName }} |- JS // 复杂表达式已经移入一个计算属性 computed: { normalizedFullName: function () { return this.fullName.split(' ').map(function (word) { return word[0].toUpperCase() + word.slice(1) }).join(' ') } } 而不是 |- HTML {{ fullName.split(' ').map(function (word) { return word[0].toUpperCase() + word.slice(1) }).join(' ') }} 尽可能在 HTML、CSS 中使用双引号（\"），在 JS 中使用单引号（'）。例如： 而不是 6.3 HTMl 规范 返回目录 在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的，且使用 PascalCase 形式命名。然后在 DOM 模板中不应该闭合，且使用 kebab-case 形式命名。例如： 尽可能统一指令书写形式，例如统一用简写形式 @ 及 : 或者统一用全拼形式 v-bind 及 v-on。 6.4 JS 规范 返回目录 组件的 data 必须是一个函数。当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。例如： data() { return { name: 'jsliang' } } Prop 的定义应该尽量详细，至少指定其类型。并且在声明的时候采用 camelCase，在使用的时候采用 kekab-case。例如： props: { status: { type: String, required: true, validator: function (value) { return [ 'syncing', 'synced', 'version-conflict', 'error' ].indexOf(value) !== -1 } }, greetingText: String } 总是用 key 配合 v-for。key 的作用：a.key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。b. 在 v-for 中使用 key，方便 Vue 跟踪每个节点，从而重用和重新排序现有元素。例如： ... {{ text }} 永远不要把 v-if 和 v-for 同时用在同一个元素上。例如： {{ user.name }} 6.5 CSS 规范 返回目录 为组件样式设置作用域。给每个组件的 CSS 使用 scoped，避免组件之间的样式互相影响。 .button { border: none; border-radius: 2px; } jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:37:01 "},"JavaScript-library/Vue/VuePrepare.html":{"url":"JavaScript-library/Vue/VuePrepare.html","title":"✔ Vue 开发准备","keywords":"","body":"Vue 开发准备 Create by jsliang on 2018-12-24 11:54:30Recently revised in 2019-3-13 11:11:31 在使用 VueCli 开发之前，有些步骤是重复的，如果一个一个重新写过比较麻烦，故在此记录一些常用步骤。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 大体步骤 三 详细步骤  3.1 安装 VueCli  3.2 项目目录结构  3.3 配置使用 less  3.4 重置 CSS 样式  3.5 引用左上角图标  3.6 按需引用 ElementUI  3.7 Axios 封装使用  3.8 动态引用组件  3.9 图片的引用及打包  3.10 rem 适配 二 大体步骤 返回目录 启动 VueCli 开发模式 引用重置 CSS 样式表 引用右上角 icon 图标 按需引用 ElementUI 引用并封装 Axios 三 详细步骤 返回目录 3.1 安装 VueCli 返回目录 安装 vue-cli：npm i vue-cli -g 初始化 Vue 项目：vue init webpack 开启开发模式：npm run dev 打开浏览器，查看网页： http://localhost:8080 3.2 项目目录结构 返回目录 - build —————————————————————— 构建脚本目录 - build.js —— 运行本地构建服务器，可以访问构建后的页面 - check-versions.js —— 检查版本 - utils.js —— 构建相关工具方法 - vue-loader.conf.js —— 判断是否为生产环境 - webpack.base.conf.js —— webpack 开发环境配置 - webpack.prod.conf.js —— webpack 生产环境配置 - config ————————————————————— 配置 - dev.env.js —— 开发配置 - index.js —— 配置总文件 - prod.env.js —— 打包配置 - node_modules ——————————————— Node 依赖包，请忽略 - src ———————————————————————— 主要工作区 - api —— 接口统一管理文件夹 - api.js —— 接口文件 - assets —— 需要压缩文件 - img —— 图片 - components —— 共用组件 - pages —— 页面 - router —— 路由文件夹 - index.js —— 路由文件 - style —— 样式文件 - reset.less —— 重置样式 - common.less —— 公共样式 - utils —— 工具文件夹 - md5.js —— md5 加密 App.vue ————————————————————— 根组件 main.js ————————————————————— 根组件配置 - static ————————————————————— 静态资源文件，不会被打包 - css —— CSS 文件夹 - reset.css —— 重置样式 - img —— 图片文件夹 - .babelrc ——————————————————— babel 配置，转换 ES6/7 为 ES5 - .editorconfig —————————————— 编辑器风格配置 - .gitignore ————————————————— 忽略 git 上传文件 - .postcssrc.js —————————————— 转换 CSS 的插件 - index.html ————————————————— 首页 - package.json ——————————————— 定义这个项目所需要的各种模块 - README.md —————————————————— 开搞必读文档 3.3 配置使用 less 返回目录 安装 less 和 less-loader：cnpm i less less-loader -D 添加 webpack 打包规则： build/webpack.base.conf.js { test: /\\.less$/, loader: \"style-loader!css-loader!less-loader\" } 在 style 中使用 less： .left { border: 1px solid #ccc; .left-one { font-size: 10px; } } 引用下边的 reset.less 和 common.less App.vue @import './style/reset'; @import './style/common'; 3.4 重置 CSS 样式 返回目录 引入重置样式表 static/css/reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /** 图片自适应 - image responsize **/ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .26rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .26rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .26rem } /* Internet Explorer */ 引用重置样式表 src/main.js // 引入样式重置 import '../static/css/reset.css' 3.5 引用左上角图标 返回目录 在下面目录存放 ico 图片：在线制作 ico 图标 static/img/icon.ico 引用左上角图标 index.html 3.6 按需引用 ElementUI 返回目录 安装 ElementUI：npm i element-ui -S 如果需要完整使用 ElementUI： src/main.js import Vue from 'vue' import App from './App' import router from './router' // 引用 ElementUI import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; Vue.use(ElementUI); // 引用 ElementUI 结束 Vue.config.productionTip = false new Vue({ el: '#app', router, components: { App }, template: '' }) App.vue 左一 左二 右二 右一 如果需要按需引用 ElementUI： 安装 babel 插件：cnpm i babel-plugin-component -D 修改 .babelrc： .babelrc { \"presets\": [ [\"env\", { \"modules\": false, \"targets\": { \"browsers\": [\"> 1%\", \"last 2 versions\", \"not ie 按需引入 Row 与 Col： main.js // 引入及使用 ElementUI import {Row, Col} from 'element-ui'; Vue.use(Row).use(Col); App.vue 左一 左二 右二 右一 响应式布局下基于断点的隐藏类： main.js // 引入基于断点的隐藏类 import 'element-ui/lib/theme-chalk/display.css'; 然后你就可以使用下面的 CSS 类： hidden-xs-only - 当视口在 xs 尺寸时隐藏 hidden-sm-only - 当视口在 sm 尺寸时隐藏 hidden-sm-and-down - 当视口在 sm 及以下尺寸时隐藏 hidden-sm-and-up - 当视口在 sm 及以上尺寸时隐藏 hidden-md-only - 当视口在 md 尺寸时隐藏 hidden-md-and-down - 当视口在 md 及以下尺寸时隐藏 hidden-md-and-up - 当视口在 md 及以上尺寸时隐藏 hidden-lg-only - 当视口在 lg 尺寸时隐藏 hidden-lg-and-down - 当视口在 lg 及以下尺寸时隐藏 hidden-lg-and-up - 当视口在 lg 及以上尺寸时隐藏 hidden-xl-only - 当视口在 xl 尺寸时隐藏 注： 参数 说明 xs sm >=768px md >=992px lg >=1200px xl >=1920px 更多：ElementUI 组件 3.7 Axios 封装使用 返回目录 安装 Axios：cnpm i axios -D 封装 api 到 src/api/api.js 中 api.js /** * 封装逻辑 * 1. 引入 axios。 * 2. 设置请求配置 request。如：请求超时，响应头等 * 3. 设置请求中的遮罩（未实现） * 4. 设置请求成功后的数据过滤（未实现） * 5. 设置并暴露接口，传 data、method、url 到请求配置 request 上。 */ // 设置 axios import axios from 'axios'; // 请求配置 const request = axios.create({ // 本地开发 dev 的时候，不需要开启这个 // baseURL: 'http://172.26.167.5:8080', timeout: 5000, headers: { timestamp: \"20181026094424\", deviceid: \"10102\", signature: \"F9CB03DD3ED50EDA5DB214C42D4DC0D6\", } }) /** * 获取用户名 * userId */ export const getUserName = data => request({ method: 'get', url: '/api/getUserName', params: data }) 在 Pages 中调用： UserInfo.vue // 引用接口 import { getUserName } from \"@/api/api\" export default { methods: { _getUserName() { // 获取用户名 getUserName({ userId: this.userId, }).then( (res) => { console.log(\"\\n【API - 获取用户名】：\"); }) } } } 设置 webpack 跨域 index.js： config/index.js dev: { proxyTable: { '/stat': { // restful 接口规律 target: 'http://172.**.**.**:8080/', // 接口的域名 changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 } }, }, 更多参考：Axios 中文说明 3.8 动态引用组件 返回目录 修改路由文件： 项目/src/router/index.js import Vue from 'vue' import Router from 'vue-router' const Login = () => import('@/pages/Home/Login') const Index = () => import('@/pages/Home/Index') const ListOnePageOne = () => import('@/pages/ListOne/PageOne') Vue.use(Router) export default new Router({ routes: [ { path: '/', name: 'Login', component: Login }, { path: '/Index', component: Index, children: [ { path:'/', component: ListOnePageOne, meta: [\"第一组第一页\"], } ] } ] }) 3.9 图片的引用及打包 返回目录 在 VueCli 中，图片可以存放在两个位置： 静态目录，不会被打包：项目/static/img 动态目录，将会被打包：项目/src/assets/img 详细来说： static 的目录中的图片，不会被 Webpack 相关机制理会，你引入的时候，是怎样的，它就是怎样的。 assets 中的图片，它会被 Webpack 处理，在配置了图片相关打包 loader 的情况下，它会在 项目/build/webpack.base.conf.js 中依据相关的 loader 限制，在一定大小下转换为 Base64。 项目/build/webpack.base.conf.js { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') } }, 从代码中可以看出可以看出，它对于小于 10K(10000/1024) 的图片，会打包成 base64，从而减少了我们在浏览器加载时的性能损耗。 那么，在 VueCli 中应该如何引用图片呢？ export default { data() { return { icon1: require('../../assets/img/emoticon_cool.png'), // 引用 assets 下的图片 icon2: '/static/img/emoticon_cute.png' // 引用 static 下的图片 } } } 说完 static 和 assets 的区别，以及对图片的引用，如果小伙伴们想验证下，那么可以看看 Webpack 在打包的时候对图片的处理： 项目/config/index/js 'use strict' const path = require('path') module.exports = { dev: { assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: {}, //... 省略剩下的代码 }, build: { index: path.resolve(__dirname, '../dist/index.html'), assetsRoot: path.resolve(__dirname, '../dist'), assetsSubDirectory: 'static', assetsPublicPath: '/', // ...省略剩下的代码 } } 从代码中可以看出，对于 static 的资源，VueCli 在开发模式 dev 以及打包模式 build 中都进行了配置，它不会被 webpack 进行打包，属于 “静态资源”。 但是，问题来了： VueCli 打包的时候，生成的是图片的绝对路径，部署的时候无法解析到图片，需要配置成相对路径，需要怎么改呢？ 位置 1： 项目/build/webpack.prod.conf.js output: { publicPath: './', path: config.build.assetsRoot, filename: utils.assetsPath('js/[name].[chunkhash].js'), chunkFilename: utils.assetsPath('js/[id].[chunkhash].js') }, 在 output 这块，新增代码 publicPath: './'。 位置 2： 项目/build/utils.js if (options.extract) { return ExtractTextPlugin.extract({ use: loaders, publicPath: '../../', fallback: 'vue-style-loader' }) } else { return ['vue-style-loader'].concat(loaders) } 在 vue-style-loader 这里，新增 publicPath: '../../ 这行代码。 这样，打包出来的图片路径，就是相对路径了。 3.10 rem 适配 返回目录 如果项目属于手机端，那么需要进行 rem 适配，即将固定宽度的 px 转换为 rem，为了方便计算，下面有一份 100px = 1rem 的 JS 适配代码，只需要将代码放到 项目/src/utils/rem.js 中，并在 项目/src/main.js 中引用即可。 项目/src/main.js // 引用 rem 适配 import './utils/rem' 项目/src/utils/rem.js /* * 移动端 rem 适配，px:rem = 100:1 * 该适配兼容 UC 竖屏转横屏出现的 BUG * 自定义设计稿的宽度：designWidth * 最大宽度：maxWidth * 这段 js 的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为 750，最大宽度为 750，则为(750,750) */ ! function (e, t) { function n() { var n = l.getBoundingClientRect().width; t = t || 540, n > t && (n = t); var i = 100 * n / e; r.innerHTML = \"html{font-size:\" + i + \"px;}\" } var i, d = document, o = window, l = d.documentElement, r = document.createElement(\"style\"); if (l.firstElementChild) l.firstElementChild.appendChild(r); else { var a = d.createElement(\"div\"); a.appendChild(r), d.write(a.innerHTML), a = null } n(), o.addEventListener(\"resize\", function () { clearTimeout(i), i = setTimeout(n, 300) }, !1), o.addEventListener(\"pageshow\", function (e) { e.persisted && (clearTimeout(i), i = setTimeout(n, 300)) }, !1), \"complete\" === d.readyState ? d.body.style.fontSize = \"16px\" : d.addEventListener( \"DOMContentLoaded\", function (e) { d.body.style.fontSize = \"16px\" }, !1) }(750, 750); jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Vue/Axios.html":{"url":"JavaScript-library/Vue/Axios.html","title":"✘ Axios","keywords":"","body":"Axios Create by jsliang on 2018-11-8 13:41:10Recently revised in 2018-12-25 21:47:43  饮水思源：Axios 中文文档  Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 一 目录 目录 一 目录 二 正文  2.1 get  2.1 post 二 正文 返回目录  axios 实战经验 2.1 get 返回目录  方法：axios.get(url, options)  话不多说，先上代码： Vue学习 new Vue({ el: document.getElementById('app'), template: ` 发送请求 数据为： {{ getData }} `, data() { return { getData: '' } }, methods: { sendAjax() { // 直接使用 axios // get 为请求方式 axios.get('https://www.easy-mock.com/mock/5be3885e033152564881d354/getInfo') // then 为 promise 获取数据 .then((res) => { this.getData = res.data; }) // catch 为 promise 捕获异常 .catch(); } } })  如上，我们使用 axios 非常简单，只需要引用它的 cdn，然后通过： axios.get() .then() .catch()  就可以直接调用 axios 获取数据。 2.2 post 返回目录  post 请求讲解 三 杂记 3.1 跨域代理  http-proxy-middleware | 代理了解推荐文章 设置 index.js： dev: { proxyTable: { '/stat': { target: 'http://172.**.**.**:8080/', // 接口的域名 changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 } }, }, 设置 main.js 全局拦截器： // 设置 axios import axios from 'axios'; // 添加请求拦截器 axios.interceptors.request.use( (config) => { config.headers.common['timestamp'] = \"******\"; config.headers.common['deviceid'] = \"******\"; config.headers.common['signature'] = \"******\"; // 在发送请求之前做些什么 return config; }, (error) => { // 在请求错误时做些什么 return Promise.reject(error); }) 调用 PartOne.vue： axios({ url: \"stat/getApersonnelDistribution\", method: \"get\", params: { rank: 4 }, }).then( (res) => { console.log(res); }) 3.2 单个页面多 API 调用 全代码为： create() { this._getApi(); }, methods: { _getApi() { axios(xxx).then( res=> { console.log(res); this._drawxxx(res); }) }, _drawxxx(res) { } } 理解：  首先，在 create() 中调用方法体。 然后，在 methods() 中编写方法体，方法体调用 axios。 最后，在方法体中通过 axios 获取到数据之后，将数据传入到方法中进行处理。 缘故：这样分布处理，有利于代码逻辑优化，当某步出现错误的时候，方便调试。同时使用 _ 开头命名方法，防止与其他 api 冲突。 3.3 Axios 封装 封装 api 到 src/api/api.js 中 api.js /** * 封装逻辑 * 1. 引入 axios。 * 2. 设置请求配置 request。如：请求超时，响应头等 * 3. 设置请求中的遮罩（未实现） * 4. 设置请求成功后的数据过滤（未实现） * 5. 设置并暴露接口，传 data、method、url 到请求配置 request 上。 */ // 设置 axios import axios from 'axios'; // 请求配置 const request = axios.create({ // 本地开发 dev 的时候，不需要开启这个 // baseURL: 'http://172.****.****.5:8080', timeout: 5000, headers: { timestamp: \"20181026094424\", deviceid: \"10102\", signature: \"F9CB03DD3ED50EDA5DB214C42D4DC0D6\", } }) /** * 获取用户名 * userId */ export const getUserName = data => request({ method: 'get', url: '/api/getUserName', params: data }) 在 Pages 中调用： UserInfo.vue // 引用接口 import { getUserName } from \"@/api/api\" export default { methods: { _getUserName() { // 获取用户名 getUserName({ userId: this.userId, }).then( (res) => { console.log(\"\\n【API - 获取用户名】：\"); }) } } } jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Vue/VueCli2.html":{"url":"JavaScript-library/Vue/VueCli2.html","title":"✘ VueCli2","keywords":"","body":"VueCli Create by jsliang on 2018-11-8 21:12:34Recently revised in 2018-12-26 08:17:06  VueCli 的学习  关于 Vue 系列学习。 学习 VueBase.md 学习 VueRouter.md 学习 Axios.md 学习 VueCli.md 学习 VueDeploymentOptimization.md 学习 VuePrepare.md jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Vue/VueCli3.html":{"url":"JavaScript-library/Vue/VueCli3.html","title":"✘ VueCli3","keywords":"","body":"VueCli3 Create by jsliang on 2018-12-29 22:14:56Recently revised in 2018-12-29 22:15:00  VueCli3 的学习 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Vue/VueRouter.html":{"url":"JavaScript-library/Vue/VueRouter.html","title":"✘ Vue Router","keywords":"","body":"Vue Router Create by jsliang on 2018-11-8 13:39:39Recently revised in 2019-1-23 08:26:17  饮水思源：Vue Router 官方文档  Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有： 嵌套的路由/视图表 模块化的、基于组件的路由配置 路由参数、查询、通配符 基于 Vue.js 过渡系统的视图过渡效果 细粒度的导航控制 带有自动激活的 CSS class 的链接 HTML5 历史模式或 hash 模式，在 IE9 中自动降级 自定义的滚动条行为 一 目录 目录 一 目录 二 正文  2.1 初识 Vue Router  2.2 路由初定义  2.3 router-view 与 router-link  2.4 路由 name 的使用  2.5 路由传参  2.6 嵌套路由  2.7 路由守卫 2.1 初识 Vue Router 返回目录  在介绍路由的时候，我们先理清下传统开发方式的路由和 SPA 页面的路由： 传统开发方式中，url 改变后，立刻发起请求，响应整个页面，渲染整个页面。 SPA 锚点值改变后，不会发起立即发起请求。发起 ajax 请求，SPA 应用会局部改变页面数据。 2.2 路由初定义 返回目录  话不多说，先上代码： index.html Vue学习 // 2. 使用插件 Vue.use(VueRouter); // 3. 定义路由对象 var Login = { template: ` 登录页面 ` } // 4. 创建路由挂载对象 var router = new VueRouter({ // 5. 配置路由对象 routes: [ { path: '/login', component: Login } ] }); // 6. 指定路由改变局部的位置 var App = { template: ` ` } // 7. 将路由对象关联到 Vue 实例中 new Vue({ el: document.getElementById('app'), // 注意这里比平时多了个 router，标明我们要开启路由模式 router: router, components: { app: App }, template: `` })  在上面代码中，我们先编写第 1 步，引用 vue-router 这个插件。 然后，我们通过第 2 步 Vue.use(VueRouter) 来使用这个插件。 接着，我们通过第 3 步来定义路由对象，即我们的子组件页面。 再来，我们通过第 4 步创建路由挂载对象后，在第 5 步配置路由对象。 紧接着，我们通过第 6 步的 来挂载我们的路由子组件。 最后，我们通过第 7 步的操作，在 new Vue 中使用 router，从而做到 SPA 页面路由的使用。  那么，他们是怎么显示的呢？ 我们在展示的页面后面敲上 /login，页面就会加载 Login 子组件。例如 jsliang 的就是 http://127.0.0.1:8080/#/login。 此刻页面显示为： 2.3 router-view 与 router-link 返回目录  话不多说，先看代码： index.html Vue学习 // 2. 使用插件 Vue.use(VueRouter); // 3. 定义路由对象 var Login = { template: ` 登录页面 ` } var Register = { template: ` 注册页面 ` } // 4. 创建路由挂载对象 var router = new VueRouter({ // 5. 配置路由对象 routes: [ { path: '/login', component: Login }, { path: '/register', component: Register } ] }); // 6. 指定路由改变局部的位置 var App = { template: ` 登录 注册 ` } // 7. 将路由对象关联到 Vue 实例中 new Vue({ el: document.getElementById('app'), // 注意这里比平时多了个 router，标明我们要开启路由模式 router: router, components: { app: App }, template: `` })  在上一章节理解了路由的使用之后，现在我们要做的很简单，就是在第 3 步中定义 Register 组件，并在第 5 步中挂载该组件，最后通过第 6 步的 ，从而达到 中展示对应路由组件的目的。  下面我们查看下该代码是否能正确运行： 2.4 路由 name 的使用 返回目录  在章节 3.13.1 和章节 3.13.2 中，我们都是通过 来切换路由的。 假如某天需求改了，产品经理或者项目经理说页面上不能用 localhost:8080/#/login，那样子太 low（真的 low 吗？不见得，但是它们要求就是这样，能咋办啊~ o(╥﹏╥)o），而是用 localhost:8080/#/mylogin，所以我们需要修改页面两次（ 和 path）…… 又到了哪天，它丢你个文档说，我们路由定好了，照着文档写。然后你一看，我天，页面上显示的路径都和你做的不一样……所以有没有更好的方法解决这个问题呢？ 有的，那就是给 routes 起 name 值： index.html Vue学习 // 2. 使用插件 Vue.use(VueRouter); // 3. 定义路由对象 var Login = { template: ` 登录页面 ` } var Register = { template: ` 注册页面 ` } // 4. 创建路由挂载对象 var router = new VueRouter({ // 5. 配置路由对象 routes: [ { name: 'login', path: '/myLogin', component: Login }, { name: 'register', path: '/myRegister', component: Register } ] }); // 6. 指定路由改变局部的位置 var App = { template: ` 登录 注册 ` } // 7. 将路由对象关联到 Vue 实例中 new Vue({ el: document.getElementById('app'), // 注意这里比平时多了个 router，标明我们要开启路由模式 router: router, components: { app: App }, template: `` })  首先，在代码方面，我们通过沿用章节 3.13.2 中的代码来演示 name 的使用。 然后，在第 5 步中，我们分别给两个路由对象起了名字。 最后，我们在第 6 步中，通过 :to 来动态绑定了路由值为 name: '***，从而达到了我们的目的。  这样，当我们上头想修改网址路径的时候，我们只需要到第 5 步的代码中修改即可。 2.5 路由传参 返回目录  在平时开发中，我们经常给我们的 url 传参，那么在 Vue 开发中，Vue 是如何在路径中带参数，并且在对应路由中获取到参数的呢？ 先上代码，先睹为快： index.html Vue学习 // 2. 使用插件 Vue.use(VueRouter); // 3. 定义路由对象 var Login = { template: ` 登录页面 `, // 输出路径 created: function() { console.log(this.$route); console.log(this.$route.query); } } var Register = { template: ` 注册页面 `, // 输出路径 created: function() { console.log(this.$route); console.log(this.$route.params); } } // 4. 创建路由挂载对象 var router = new VueRouter({ // 5. 配置路由对象 routes: [ { name: 'login', path: '/myLogin', component: Login }, { name: 'register', path: '/myRegister/:name', component: Register } ] }); // 6. 指定路由改变局部的位置 var App = { template: ` 登录 注册 ` } // 7. 将路由对象关联到 Vue 实例中 new Vue({ el: document.getElementById('app'), // 注意这里比平时多了个 router，标明我们要开启路由模式 router: router, components: { app: App }, template: `` })  下面我们先查看其结果：  在这里，我们有两种传参方式： query 传参：  首先，在第 6 步的 :to 中，我们通过 登录，设置传参的值为 id=1。 接着，在第 3 步的 Login 组件中定义 created，打印出它的对象及其参数： {name: \"login\", meta: {…}, path: \"/myLogin\", hash: \"\", query: {…}, …} {id: 1}  最后，在页面中路径显示为显示为：http://127.0.0.1:8080/#/myLogin?id=1 params 传参：  首先，在第 6 步的 :to 中，我们通过 注册，设置传参的值为 name=jsliang。 接着，在第 5 步中，给它的 path 预留个 name 的插槽：path: '/myRegister/:name' 然后，在第 3 步的 Login 组件中定义 created，打印出它的对象及其参数： {name: \"register\", meta: {…}, path: \"/myRegister/jsliang\", hash: \"\", query: {…}, …} {name: \"jsliang\"}  最后，在页面中路径显示为：http://127.0.0.1:8080/#/myRegister/jsliang  当然，小伙伴可能会考虑到传多个参数： query 传多个参数代码片段：http://127.0.0.1:8080/#/myLogin?id=1&name=jsliang 登录 params 传多个参数代码片段：http://127.0.0.1:8080/#/myRegister/2/梁峻荣 path: '/myRegister/:id/:name' 注册 2.6 嵌套路由 返回目录  在章节 3.10 传递 DOM - slot 中，我们提到了 slot 及具名 slot 的区分。然后，在 Vue 日常开发中，如果我们的路由只能一个 放整版页面，这是满足不了我们需求的。 所以，你考虑到的，大佬们也考虑到了：嵌套路由！通过不同锚点值，填入不同的组件。 index.html Vue学习 // 2. 使用插件 Vue.use(VueRouter); // 3. 定义路由对象 var Login = { // 8. 插槽。路由对象下中还有 template: ` 登录页面 我是屌丝 我是土豪 ` } // 9. 二级路由子组件 var poorManLogin = { template: ` 屌丝登录页面 ` } var richManLogin = { template: ` 土豪登录页面 ` } var Register = { template: ` 注册页面 ` } // 4. 创建路由挂载对象 var router = new VueRouter({ // 5. 配置路由对象 routes: [ { name: 'login', path: '/myLogin', component: Login, // 10. 定义路由下的子路由 children: [ { name: 'poorManLogin', path: 'loginWayOne', component: poorManLogin }, { name: 'richManLogin', path: 'loginWayTwo', component: richManLogin } ] }, { name: 'register', path: '/myRegister', component: Register } ] }); // 6. 指定路由改变局部的位置 var App = { template: ` 登录 注册 ` } // 7. 将路由对象关联到 Vue 实例中 new Vue({ el: document.getElementById('app'), // 注意这里比平时多了个 router，标明我们要开启路由模式 router: router, components: { app: App }, template: `` })  先看看代码的实现效果：  首先，我们使用章节 3.13.3 路由 name 的使用 的代码，在其基础上开发，没有搞懂该章节代码的小伙伴可以先看该章节代码讲解。 然后，我们在第 8 步中，给路由对象再嵌套子路由： // 8. 插槽。路由对象下中还有 template: ` 登录页面 我是屌丝 我是土豪 `  接着，我们在第 9 步中定义这两个路由子组件。 最后，我们在第 10 步中，通过 children 数组，将这两个子组件配置到路由对象上，我们就可以在 的组件中，再定义一层 ，并使用它，从而做到嵌套路由的开发。  看到这里，小伙伴们是不是也想到了，可以用嵌套路由来满足用单页应用来开发多页应用的目的~ 3.7 路由守卫 返回目录  话不多说，先上代码： index.html Vue学习 // 2. 使用插件 Vue.use(VueRouter); // 3. 定义路由对象 var Login = { // 简单的登录页面 template: ` 登录页面 用户名： 登录 `, data() { return { userName: '' } }, methods: { // 点击登录按钮，将输入框的内容记录为 userName，并存到 localStorage login: function(e) { localStorage.setItem(\"userName\", this.userName); console.log(\"存储了用户名：\" + this.userName); } } } var User = { template: ` 用户页面 ` } // 4. 创建路由挂载对象 var router = new VueRouter(); // 5. 动态配置路由对象，设置路由规则 router.addRoutes([ { path: '/', redirect: { name: 'login' } }, { name: 'login', path: '/login', component: Login }, { name: 'user', path: '/user', component: User, // 权限控制，给用户界面定义全局路由守卫 meta: { isChecked: true } } ]) // 6. 定义路由守卫 router.beforeEach(function(to, from, next) { // 如果是前往登录页或者首页，则直接前往 if(to.name === \"login\" || to.path === '/') { // 执行下一步，不定义就会卡住 next(); } else { // 如果是前往用户页，则需要进行判断 localStorage 是否有值 if(!localStorage.getItem(\"userName\")) { alert('请登录~'); next({ name: 'login' }) } else { // 执行下一步，不定义就会卡住 next(); } } }) // 7. 指定路由改变局部的位置 var App = { template: ` 登录 我的 ` } // 8. 将路由对象关联到 Vue 实例中 new Vue({ el: document.getElementById('app'), // 注意这里比平时多了个 router，标明我们要开启路由模式 router: router, components: { app: App }, template: `` })  看下代码成果：  首先，我们做下知识点讲解： 路由元数据 meta meta 是对于路由规则是否需要验证权限的配置。 在路由对象中和 name 属性同级的代码上添加 { meta: { isChecked: true }} 即可做标记。 路由钩子 路由钩子发生在权限控制的函数执行时期。在每次路由匹配后，渲染组件到 router-view 之前触发。 router.beforeEach(function(to, from, next){ }) next() 有三种状态：1.next() 为放行，即路由可以正常跳转；2.next(false) 为取消用户导航的行为，即不放行；3.next({name:'***'}) 为重定向到某个页面。  然后，在 index.html 中，我们在第 3 步中，做了个简单登录页面，将用户输入的信息 userName，存储到了 localStorage。 接着，在第 5 步中，我们对 user 路由，做了 meta 判断，进行权限控制。 最后，我们在第 6 步中，定义了路由守卫，先判断是哪个页面登录，如果是登录页或者首页，则直接前往；如果是用户页，则进行 localStorage 判断，如果用户输入了并保存了 userName，则跳往用户页，否则不给跳转。  如此，我们做到了路由守卫。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Vue/Vuex.html":{"url":"JavaScript-library/Vue/Vuex.html","title":"✘ Vuex","keywords":"","body":"Vuex Create by jsliang on 2018-12-29 18:58:58Recently revised in 2018-12-29 18:59:02  Vuex 的学习 安装 Vuex：cnpm i vuex -S src/main.js // 1. 引入 Vuex import Vuex from 'vuex'; // 2. 安装插件 Vue.use(Vuex); // 3. 创建 store let store = new Vuex.Store({ // 4. 配置 store 中的数据/存/取 state: { number: 30 }, // 取数据 getters: { getNum(state) { return state.num; } }, // 操作数据 mutations: { addNum(state, payload) { // 调用者传递增加的数量 state.num += payload.num; } }, // 行为，在行为中，可以存在异步操作，但是最终还是通知 mutations actions: { addNumByServerRate(store, payload) { setTimeout(function() { let rate = 1; state.commit('addNum', {num: payload.num * rate}); }, 1000) } } }) new Vue({ el: '#app', // 5. 将 store 对象关联到 Vue 实例 store, compontents: { App }, template: '' }) App.vue export default { methods: { change() { // 也可以改值，但不是官方推荐，会被寄刀片的 // this.$store.state.xxx // 一般写代码都不直接提交，除非明知是同步操作，没有后台请求 this.$store.commit('addNum', {num:5}); // 完美的套路 this.$store.dispatch('addNumByServerRate', { num: 10 }); } }, computed: { appShowNum() { return this.$store.getters.getNum; } } } 提取出来，提高解耦性 新建 src/modules/numModule.js modules/numModule.js // 上面内容 main.js import numModule from '@/modules/numModule'; jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Vue/VueSSR.html":{"url":"JavaScript-library/Vue/VueSSR.html","title":"✘ Vue SSR 服务端渲染","keywords":"","body":"Vue SSR 服务端渲染 Create by jsliang on 2018-12-29 20:04:33Recently revised in 2018-12-29 20:04:37 Vue.js 服务器端渲染指南 用 Vue 构建多页面应用 vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 为什么会有 SPA localhost:8080/#/xxx 不会因为用户的字段输入而刷新 可以通过 location.hash 控制路由 history 模式 去除了 # 的方式，每次都向服务器请求 index.html，再由客户端分析当前 url，做不同的变化 实现原理 在页面中通过 location.pathname 获取当前请求 url 让服务器不论什么请求都返回以上这个 index.html SPA 是什么 Vue-Router 中是否可以不使用 # 来开发 -> history 模式，默认是 hash 模式 在 history 模式中，可以使用 scroll 导航后滚动（history 模式实现其实基于服务器每次返回 index.html，而客户端根据 location.pathname 来做渲染） SEO 是什么 - 搜索引擎优化 SPA 下 SEO 必然比较差 使用预渲染，固定的页面，作为服务器响应的结果回来 - history 模式 Vue SPA 实现 SEO 优化 vue项目做seo（prerender-spa-plugin预渲染） 下载 npm i prerender-spa-plugin -D 配置 webpack.prod.js 文件 webpack.prod.js const PrerenderSpaPlugin = require('prerender-spa-plugin'); plugins: [ new PrerenderSpaPlugin({ staticDir: path.join(__dirname, '..', 'dist'), // Required - Routes to render. routes: [ '/', '/user' ] // 根据这两个路由规则找到组件渲染 HTML 文件 }) ] 配置路由变更对象，传递构造属性 mode: history 构建项目代码：npm run build 进入 dist 目录，启动生成的代码 node index.js 效果 骨架屏 Skeleton Screen - 骨架屏。骨架屏就是在页面数据尚未加载前先给用户展示出页面的大致结构，直到请求数据返回后再渲染页面，补充进需要显示的数据内容。常用于文章列表、动态列表页。 相当于 loading 图标而言，用户可以预览未来要看的结构，同时避免白屏的尴尬，还能操作。因此用户体验较好。 Vue 页面骨架屏注入实践 LAVAS - 基于 Vue.js 的 PWA 解决方案 结合 Service Worker 做了用户体验优化，实现了离线浏览。 npm i lavas -g lavas init 选择包含 app_shell，也包含了骨架屏的功能 骨架屏的实现原理，就是在 Vue 真正渲染之前，先加载了默认的一套代码 预加载样式 先加载预加载样式的 js 文件 然后加载 Vue 文件，渲染页面 所以，在我们请求加载数据，完成渲染之前，我们可以先使用骨架屏，然后等数据渲染完成之后，我们将骨架屏关掉。 自己配置骨架屏：Vue 页面骨架屏注入步骤详解 什么是 PWA PWA （渐进式 Web Application） 慢慢收服你。 离线浏览 Web 应用，生成桌面应用，顶部通知（页面都可以不存在），预缓存（在页面没启动之前，请求资源保存到浏览器。从而在访问的时候，大幅提升速度），骨架屏，App shell（利用缓存机制保存 css + html + js 等等），分享，全屏图标。 这些东西，是产品经理设计的，因为这项 PWA 技术，经 Chrome 推出，但是一直没有火起来（手机端 55 以上支持这些所有技术）、IOS Safari 考虑支持。（支持率比较差） 英文 caniuse，中文 lavas 官网 history 源码 index.html HelloWorld 显示区域 去看 user 页面 去看 goods 页面 function goHistory(url) { let text = ''; // 判断用户点击的是哪个按钮 switch(url) { case '/user': test = '用户页面'; alert('/user'); break; case '/goods': text = '商品页面'; alert('/goods'); break; } history.pushState( {}, '', url); // 改变页面效果 document.getElementById(\"app\").innerText = text; } // 当页面加载的时候 window.onload = function() { let text2 = ''; // 获取当前 path 路径 var path = location.pathname; switch(path) { case '/user': test = '用户页面'; alert('/user'); break; case '/goods': text = '商品页面'; alert('/goods'); break; } // 改变页面效果 document.getElementById(\"app\").innerText = text2; } index.js const http = require('http'); const fs = require('fs'); http.createServer( (req, res) => { fs.readFile('./index.html', (err, data) => { res.end(data); }) }).listen(8888); 启动 node index.js，这样，我们就可以监听到我们的页面了。 多页应用 核心思想：就是两个 Vue 项目，一次 Webpack 打包，关联用 url 联系 Webpack 操作 多个入口： {main1: './usermain.js', main2:'./goodsmain.js'} 多个 html 插件 注意事项： // 文件名称 filename: filename + '.html', // 页面模板需要加对应的 js 脚本，如果不加这行，则每个页面都会引入所有的 js 脚本 chunks: ['mainfest', 'vendor', filename], inject: true 使用 CachesAPI 获取指定缓存的内容 caches.open('key').then(function(cachedRequests) { ... }) jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Vue/VueUploadFile.html":{"url":"JavaScript-library/Vue/VueUploadFile.html","title":"✔ Vue 上传文件","keywords":"","body":"Vue 上传文件 Create by jsliang on 2019-3-21 16:57:58Recently revised in 2019-3-21 16:58:02 步骤 1. 设置 Node 跨域代理 修改 项目/config/index.js 下的 dev 设置： 原 build/index.js 配置： dev: { // Paths assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: {}, } 修改后 build/index.js 配置： dev: { // Paths assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: { '/services': { // 碰到 /services 类型的接口，使用 node 代理 target: 'http://172.**.**.49:8080', // 需要将开发模式的 localhost:8080 代理到哪个接口 changeOrigin: true, // 如果接口跨域，需要设置这个参数为 true } }, }, 这时，我们在 npm run dev 下，就可以将 localhost:8080 调用 http://172.**.**.49:8080 的接口由 Node 代理转发，从而实现接口的跨域请求。 步骤 2. 实现原生上传图片 步骤 1 为前置条件 如何实现 上传图片： Album.vue // 如果使用方法 1 // import { uploadFile } from '../../api/api' // 如果使用方法 2 import axios from 'axios' export default { methods: { // 普通上传图片 uploads(e) { // 方法 1 - 可行 // const file = e.target.files[0]; // console.log(file); // const fd = new FormData(); // fd.append('userBlicence', file); // uploadFile(fd).then( res => { // console.log(res); // }).catch( error => { // console.log(error); // }) // 方法 2 - 可行 const file = e.target.files[0]; console.log(file); const fd = new FormData(); fd.append('userBlicence', file); axios({ method: 'post', timeout: 5000, headers: { 'Content-Type':'multipart/form-data', timestamp: \"2019032009000\", deviceid: \"10001\", signature: \"2743cfbda4601a359400929393b7657a\", }, url: '/services/Auser-uploadImg.action', data: fd, }).then( res => { console.log(res); }).catch( error => { console.log(error); }) }, } } 如果我们不用封装接口，那么我们直接使用方法 2 即可。 但是，一般情况下，我们会抽取接口到 api.js，进行接口的统一管理： api.js // 设置 axios import axios from 'axios'; // 请求配置 const request = axios.create({ // 开发模式下不需要开启，打包模式下去掉该注释 // baseURL: 'http://172.**.**.49:8080', timeout: 5000, headers: { timestamp: \"2019032009000\", deviceid: \"10001\", signature: \"2743cfbda4601a359400929393b7657a\", } }) /** * 上传图片 * userBlicence - 图片 */ export const uploadFile = data => request({ method: 'post', headers: { 'Content-Type':'multipart/form-data', }, url: '/services/Auser-uploadImg.action', data: data, }) 这样，当我们使用方法 1 的时候，我们直接调用接口即可。 步骤 3. 实现 ElementUI 上传图片 步骤 1 为前置条件 相对于原生上传图片来说，ElementUI 上传图片更为便捷： 点击上传 export default { data() { return { headers: { timestamp: \"2019032009000\", deviceid: \"10001\", signature: \"2743cfbda4601a359400929393b7657a\", } } }, methods: { // ElementUI 上传图片成功 uploadSuccess(res, file) { console.log(res); console.log(file); }, } } 如此，就可以实现图片上传的功能。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Vue/VueDeploymentOptimization.html":{"url":"JavaScript-library/Vue/VueDeploymentOptimization.html","title":"✔ Vue 部署优化","keywords":"","body":"Vue 部署优化 Create by jsliang on 2018-12-7 14:53:566Recently revised in 2019-3-6 10:57:46  在进行 Vue 项目部署时，发现它访问速度贼慢，于是做了下优化，下面是优化建议： 一 进行路由懒加载  路由懒加载 - VueRouter 官网  大致意思就是，将 import PartOne from '@/components/PartOne'  换成 const PartOne = () => import('@/components/PartOne');  这样，就可以访问快点了。 index.js import Vue from 'vue' import Router from 'vue-router' Vue.use(Router) // 路由懒加载 const PartOne = () => import('@/components/PartOne'); export default new Router({ routes: [ { path: '/', components: { PartOne: PartOne, } }, { path: '/PartOne', name: 'PartOne', component: PartOne }, ] }) 二 开启 Gzip Nginx 配置 Gzip PS：Nginx 需要在 conf/nginx.conf 文件中的 http 中设置。 #user nobody; # 跟CPU有关，不用修改 worker_processes 1; events { # nginx最大负载量 worker_connections 1024; } http { # mime type映射 include mime.types; default_type application/octet-stream; # 启动高效传输文件的模式 sendfile on; # 长连接timeout keepalive_timeout 65; # 开启 gzip gzip on; gzip_types text/plain application/x-javascript application/javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; # http结构下可以有多个server。请求进来后，确定哪一个server由server_name决定 server { # 监听端口 listen 80 default_server; # 识别的域名 server_name localhost default_server; # 一个关键配置，与URL参数乱码问题有关 #charset utf-8; root html; location / { index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } include ../vhost/*.conf; } Vue 开启 Gzip  首先，安装 compression-webpack-plugin： npm i compression-webpack-plugin -D  然后，修改配置代码： config/index.js // ... 代码省略 productionGzip: true, productionGzipExtensions: ['js', 'css'],  最后，打包的文件中会有 .gz 后缀的文件，表示开启成功了。 三 屏蔽 sourceMap  修改配置代码： config/index.js // ... 代码省略 productionSourceMap: false,  这个 productionSourceMap 有什么作用呢？其实就是项目打包后，我们的代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确知道是哪里的代码出错了，而开启了 productionSourceMap，就会自动生成一些 map 文件，准确地告诉我们哪一行那一列出错。 关闭了 productionSourceMap 后，一方面可以减少上线代码包的大小，另一方面提高系统的安全性。 四 开启 uglifyjs-webpack-plugin 的 cache build/webpack.prod.conf.js new UglifyJsPlugin({ cache: true, uglifyOptions: { compress: { warnings: false } }, sourceMap: config.build.productionSourceMap, parallel: true }), 开启后打包第二次的时间是第一次的一半。 五 优化图片  平时我们切图、下载图的 png、jpg 图片，都异常的大，所以我们需要对图片进行压缩： TinyPNG | 图片压缩  上面的网站就能很不错地压缩图片，从而减少图片的体积。 六 参考文献： vuejs项目性能优化总结 | 简书 - Evtion jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Vue/VueSourceCode.html":{"url":"JavaScript-library/Vue/VueSourceCode.html","title":"✘ Vue 源码剖析","keywords":"","body":"Vue 源码剖析 Create by jsliang on 2018-12-29 23:21:20Recently revised in 2018-12-31 19:29:31 什么是 Flow Flow 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查，所以了解 Flow 有助于我们阅读源码。 为什么使用 Flow JavaScript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用是很容易就写出非常隐蔽的隐患代码，在编译期甚至看上去都不会报错，但在运行阶段就可能出现各种奇怪的 bug。 项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。Vue.js 在做 2.0 重构的时候，在 ES2015 的基础上，除了 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。之所以选择 Flow，主要是因为 Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力。 Flow 工作方式 类型推断：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型。 类型注释：事先注释好我们期待的类型，Flow 会基于这些注释来判断。 Flow 在 Vue.js 源码中的应用 有时候我们想引用第三方库，或者自定义一些类型，但 Flow 并不认识，因此检查的时候会报错。为了解决这类问题，Flow 提出了一个 libdef 的概念，可以用来识别这些第三方库或者是自定义类型，而 Vue.js 也利用了这一特性。 在 Vue.js 的主目录下有 .flowconfig 文件， 它是 Flow 的配置文件，感兴趣的同学可以看官方文档。这其中的 [libs] 部分用来描述包含指定库定义的目录，默认是名为 flow-typed 的目录。 这里 [libs] 配置的是 flow，表示指定的库定义都在 flow 文件夹内。我们打开这个目录，会发现文件如下： flow ├── compiler.js # 编译相关 ├── component.js # 组件数据结构 ├── global-api.js # Global API 结构 ├── modules.js # 第三方库定义 ├── options.js # 选项相关 ├── ssr.js # 服务端渲染相关 ├── vnode.js # 虚拟 node 相关 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Vue/VueDemoOne.html":{"url":"JavaScript-library/Vue/VueDemoOne.html","title":"✔ Vue Demo - 功成千骨","keywords":"","body":"Vue Demo - 功成千骨 Create by jsliang on 2019-1-2 08:46:46Recently revised in 2019-1-12 20:00:02 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习折腾的动力！GitHub 地址 抛开 Vue-Cli，使用最简单原始的方式开发一个 TodoList 并不断完善，完成正在进行、完成列表、回收站这三个功能模块，并实现下面这些功能： 新增任务 改变状态 修改任务 删除任务 成品展示： 代码地址：功成千骨 - 代码地址 项目地址：功成千骨 - 线上地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 项目解析 四 骨架 - HTML 五 功能 - JS  5.1 页面数据化  5.2 数据简化  5.3 添加数据  5.4 改变状态  5.5 修改内容  5.6 数据回收  5.7 彻底删除 六 皮肤 - CSS  6.1 重置样式  6.2 偷天换日 七 总结 二 前言 返回目录 经过系列的折腾，并且参照不同大佬的“新人作”，将五花八门的 TodoList 各种写法综合起来，从 0 到 1 不依赖 Vue-Cli 打造一个属于自己的 TodoList，后期将加以 Node 的框架 Koa 连接 MySQL 提供接口，从而实现面向大众的 TodoList！ 欲练此功，必先自宫，额(⊙o⊙)…不对，必先学习 Vue 系列之 Vue 基础。 三 项目解析 返回目录 在我们平时的工作中，我们应该在拿到 PSD 设计稿或者原型设计的时候，我们应该对我们的功能进行划分，对 HTML、CSS、JS 进行划分，以便于后期的维护制作，下面我们先看一下我们的 UI： 额(⊙o⊙)… 好吧-_-|| 惨不忍睹，我们还是按照这形式，将 HTML 搭建出来，并用 JS 实现功能先吧，后期再填充 CSS 了。 下面是目录结构： 四 骨架 - HTML 返回目录 现在，我们先完成 index.html 架构。 然后 index.css 和 index.js 这两个文件，可以是空的，因为我们先架好骨架，再进行 JS 的事件以及 CSS 的渲染。 index.html 功成千骨 .content-list { display: flex; } 功成千骨 进击 千军万马取敌首 （待完成） 敌军 1 × 敌军 2 >× 敌军 3 × 敌羞吾去脱他衣 （已完成） 亡军 1 × 亡军 2 × 亡军 3 × 溃不成军鸟兽散 （回收站） 返回 逃军 1 × 返回 逃军 2 × 返回 逃军 3 × 不折腾的前端 和咸鱼有什么区别 @2019 jsliang 文档库 此时页面内容如下所示： 五 功能 - JS 返回目录 搭建好网页的骨架，我们先让它跑起来吧。 你可以上面的 HTML 步骤想象成造了一个骷髅人，然后现在你要施法，要让骷髅人跑起来了。 奔跑吧，骷髅人~ 5.1 页面数据化 返回目录 现在，我们进行页面的数据化，我们需要考虑有哪几块是需要变成数据的：输入的内容、todo 项、完成项、未完成项。 那么，我们先进行简单抽取： index.html 代码片段 进击 千军万马取敌首 （待完成） x 敌羞吾去脱他衣 （已完成） x 溃不成军鸟兽散 （回收站） 返回 x 在这里，我们将页面数据化了，现在看下我们的 index.js 内容： index.js var app = new Vue({ el: \"#app\", data: { id: 1, todo: \"\", todoInfos: [ { id: 7, isChecked: false, todoTitle: \"敌军 1\", }, { id: 8, isChecked: false, todoTitle: \"敌军 2\", }, { id: 9, isChecked: false, todoTitle: \"敌军 3\", }, ], finishInfos: [ { id: 1, isChecked: true, todoTitle: \"亡军 1\", }, { id: 2, isChecked: true, todoTitle: \"亡军 2\", }, { id: 3, isChecked: true, todoTitle: \"亡军 3\", }, ], recycleInfos: [ { id: 4, isChecked: false, todoTitle: \"逃军 1\", }, { id: 5, isChecked: false, todoTitle: \"逃军 2\", }, { id: 6, isChecked: false, todoTitle: \"逃军 3\", }, ] } }) 这样，我们就通过 v-for 完成了数据的渲染，同时页面和之前的一样： 5.2 数据简化 返回目录 在这里，我们稍微暂停下，观察 todoInfos、finishInfos、recycleInfos 这三个数组，发现它们都是差不多的结构。那么，我们干脆将它合并？ index.js var app = new Vue({ el: \"#app\", data: { id: 1, todo: \"\", todoInfos: [ { id: 7, // id 唯一且自增 isChecked: false, // 未完成和放弃为 false，完成为 true isEdit: false, // 是否在编辑 todoTitle: \"敌军 1\", state: 0, // 0 - 未完成，1 - 完成，2 - 放弃完成 }, { id: 8, // id 唯一且自增 isChecked: false, // 未完成和放弃为 false，完成为 true isEdit: false, // 是否在编辑 todoTitle: \"敌军 2\", // todo 标题 state: 1, // 0 - 未完成，1 - 完成，2 - 放弃完成 }, { id: 9, // id 唯一且自增 isChecked: false, // 未完成和放弃为 false，完成为 true isEdit: false, // 是否在编辑 todoTitle: \"敌军 3\", // todo 标题 state: 2, // 0 - 未完成，1 - 完成，2 - 放弃完成 }, ] } }) 这样一来，我们就可以修改 HTML，让它通过 state 来区分这三块的数据： index.html 代码片段 进击 千军万马取敌首 （待完成） x 敌羞吾去脱他衣 （已完成） x 溃不成军鸟兽散 （回收站） 返回 x 此时，我们的页面还是如修改之前一般，但是已经实现了数据化。 下面我们开始写增删改数据的功能方法。 5.3 添加数据 返回目录 首先，我们往 HTML 中添加点击事件，当然，如果每次都要点击按钮，就太麻烦了，干脆我们再加个键盘回车事件： index.html 代码片段 进击 然后，我们往 JS 中添加点击方法： index.js var app = new Vue({ el: \"#app\", data: { id: 1, todo: \"\", todoInfos: [ // 已不需要，注释掉 // { // id: 7, // id 唯一且自增 // isChecked: false, // 未完成和放弃为 false，完成为 true // isEdit: false, // 是否在编辑 // todoTitle: \"敌军 1\", // state: 0, // 0 - 未完成，1 - 完成，2 - 放弃完成 // }, ] }, methods: { addTodoItem() { // 每次点击，往数组中添加一组数据 this.todoInfos.push({ id: this.id, // id 唯一且自增 isChecked: false, // 未完成和放弃为 false，完成为 true isEdit: false, // 是否在编辑 todoTitle: this.todo, // todo 标题 state: 0, // 0 - 未完成，1 - 完成，2 - 放弃完成 }) // id 自增 this.id++; // 清空输入框 this.todo = \"\"; }, } }) 最后，我们查看下新增功能是否实现： 5.4 改变状态 返回目录 下面我们进行 isChecked 与 state 的改变，从而让数据在这三种状态中变化： 栏目 状态 未完成 isChecked: false、state: 0 已完成 isChecked: true、state: 1 回收站 state: 2 在本章节，我们实现 未完成 -> 已完成 的转变，这里只需要修改下 HTML 代码即可： index.html 代码片段 千军万马取敌首 （待完成） x 敌羞吾去脱他衣 （已完成） x 我们可以查看下结果： OK，成功完成 待完成 -> 已完成 的转变。 5.5 修改内容 返回目录 现在，我们实现点击 todoTitle，变成修改模式，修改完后点击其他地方，或者按下回车按钮，从而实现数据的修改： index.html 代码片段 千军万马取敌首 （待完成） x 敌羞吾去脱他衣 （已完成） x 溃不成军鸟兽散 （回收站） 返回 x 在这里，我们仅需要在点击 span 标签的时候，改变下 isEdit 的状态，即进入编辑模式，同时，在 input 标签失去焦点或者在输入完成后点击回车按钮，就可以实现数据的修改。 最后，我们查看下实现情况： 5.6 数据回收 返回目录 同理，如果我们要将数据扔进回收站中去，那就需要将 state 改为 2 即可。 如果数据是从回收站返回待完成，我们只需要将 state 改为 0 即可。 index.html 代码片段 千军万马取敌首 （待完成） x 敌羞吾去脱他衣 （已完成） x 实现结果： 5.7 彻底删除 返回目录 首先，我们给 HTML 添加点击事件，将参数传递给方法体中 index.html 代码片段 溃不成军鸟兽散 （回收站） 返回 x 然后，我们通过编写 deleteInfo 来删除 todoInfos 中的数据： index.js 代码片段 methods: { addTodoItem() { // 每次点击，往数组中添加一组数据 this.todoInfos.push({ id: this.id, // id 唯一且自增 isChecked: false, // 未完成和放弃为 false，完成为 true isEdit: false, // 是否在编辑 todoTitle: this.todo, // todo 标题 state: 0, // 0 - 未完成，1 - 完成，2 - 放弃完成 }) // id 自增 this.id++; // 清空输入框 this.todo = \"\"; }, /** * 这里使用了三种写法 * 1. map + splice * 2. splice + findIndex * 3. filter */ // // 1. map + splice 写法 // deleteInfo(recycleItem) { // this.todoInfos.map((item, index) => { // if(item.id == recycleItem.id) { // this.todoInfos.splice(index, 1); // } // }) // }, // // 2. splice + findIndex 写法 // deleteInfo(recycleItem) { // this.todoInfos.splice( this.todoInfos.findIndex( v => v.id === recycleItem.id), 1); // }, // 3. filter 写法 deleteInfo(recycleItem) { this.todoInfos = this.todoInfos.filter( (x) => { return x.id != recycleItem.id; }) } } 兴致突来，想起 茴字的四种写法，于是，这里也奉上删除数据的三种写法，这里就不估算性能损耗了，哪种喜欢就用哪种吧。 此时完成功能如下所示： 到此，我们完成了所有的功能实现~ 六 皮肤 - CSS 返回目录 那么，我们回来我们的大难题，就是给这个页面增加皮肤，让这个页面漂亮点。 6.1 重置样式 返回目录 enm......因为不同浏览器对于一些 DOM 元素的渲染不同，所以我们先重置下浏览器样式吧： reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /** 图片自适应 - image responsize **/ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: 16px } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: 16px } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: 16px } /* Internet Explorer */ 6.2 偷天换日 返回目录 然后，我们就面临一个问题，要怎么美化呢？ 脑阔疼，我们还是去网上盗个皮肤下来吧： 很好，然后我们对着修改下 CSS： index.css /* 共用 */ html, body { height: 100%; } body { background: url(\"../img/background.jpg\") no-repeat center; background-size: 100% 100%; } /* 多项选项框 */ input[type=\"checkbox\"] { width: 25px; height: 25px; background-color: #fff; -webkit-appearance: none; border: 1px solid deepskyblue; border-radius: 2px; outline: none; } input[type=\"checkbox\"]:hover { cursor: pointer; } input[type=\"checkbox\"]:checked { background: url(\"../img/icon-checked.png\") no-repeat center; background-size: 100%; } /* 共用标题样式 */ .todo-title { margin-top: 10px; word-break: normal; width: 75%; display: block; white-space: pre-wrap; word-wrap: break-word ; overflow: hidden ; } /* 图标样式 */ .icon-recycle { width: 25px; height: 25px; background: url(\"../img/icon-recycle.png\") no-repeat center; background-size: 100%; } .icon-delete { width: 25px; height: 25px; background: url(\"../img/icon-delete.png\") no-repeat center; background-size: 100%; } .content-list-recycle-back { display: block; width: 20px; height: 20px; background: url(\"../img/icon-back.png\") no-repeat center; background-size: 100%; } /* 页面主体 */ .main-container { width: 1200px; height: 100%; margin: 0 auto; position: relative; } /* 头部标题 */ .header { width: 100%; height: 150px; background: url(\"../img/title.png\") no-repeat center; } /* 内容区 */ .content { text-align: center; } /* 内容区 - 输入区 */ .content-input-todo { height: 40px; } .content-input-todo input { height: 40px; padding-left: 20px; padding-right: 20px; border: none; border-radius: 20px; } .content-input-todo button { width: 100px; padding: 5px; border-radius: 20px; background: #36AF9E; color: #fff; outline: none; } /* 内容区 - 列表区 */ .content-list { display: flex; margin-top: 30px; } .content-list div { width: 380px; margin-right: 20px; border: 1px solid #ccc; padding: 30px; border: 15px solid transparent; border-image: url(\"../img/border.png\") 60 60 stretch; } .content-list div ul { text-align: left; } .content-list div ul li { width: 100%; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #ccc; } .content-list div ul li:hover { cursor: pointer; } .content-list div ul li input[type=\"checkbox\"] { margin-right: 10px; } .content-list div ul li input[type=\"text\"] { outline: none; border: none; background: rgba(255, 255, 255, 0); color: #000; border-bottom: 1px solid #ccc; } /* 底部区 */ .footer { position: absolute; bottom: 0; width: 100%; text-align: center; } .footer a { color: deepskyblue; } .footer a:hover { color: deepskyblue; } 大功告成，看下我们的成品： 七 总结 返回目录 到此，我们就写完了这个简单的小 Demo 咯~ 下面将代码地址和项目地址贴出来，需要 参考 的小伙伴自行下载或者观看。 代码地址：功成千骨 - 代码地址 项目地址：功成千骨 - 线上地址 当然，还没完！ 我们还可以折腾更多： 使用 ElementUI 或者 Bootstrap 进行多端适配 使用 localStorage 来进行本地版开发 使用 Node 来进行数据多端使用 使用 可视化配置，将 DOM 元素的 CSS 抽取成数据，让用户可以配置自己的 Todolist 使用 HTML5 的 manifest 来开发 离线存储 …… 那么，后面有机会折腾，咱再相会 Todolist ，打造升级版本的啦~ 后记 如果小伙伴需要存放 jsliang.top 这样的纯静态页面或者 company.jsliang.top 这样的具有 Node 后端支持的页面，推荐购买云服务器来存放。 如果小伙伴们不知道该怎么选择云服务器，可以查看 详细介绍 或者加 jsliang QQ：1741020489 咨询。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Vue/VueDemoTwo.html":{"url":"JavaScript-library/Vue/VueDemoTwo.html","title":"✘ Vue Demo Two - 新闻 SPA","keywords":"","body":"Vue Demo Two - 新闻 SPA Create by jsliang on 2019-1-23 12:56:37Recently revised in 2019-2-11 11:31:58 Mint-UI 9 宫格布局： 在 src/components/home 中使用 Home.vue 1 2 3 4 5 6 .grid ul { margin: 0; padding: 0; } .grid li { list-style: none; float: left; width: 33.3%; backgorund-color: yellowgreen; text-align: center; height: 30px; } 组件封装 在 components 文件夹下新建 common 在 common 下新建 MyUl.vue MyUl.vue export default { name: 'my-ul', data() { return { } } } ul { margin: 0; padding: 0; } MyLi.vue export default { name: 'my-li', data() { return { } } } li { list-style: none; float: left; width: 33.3%; backgorund-color: yellowgreen; text-align: center; height: 30px; } main.js 中引用自己的组件 main.js // 引入自己的 ul 和 li 组件 import MyUl from '@/components/Common/MyUl' import MyLi from '@/components/Common/MyLi' // 注册全局组件 Vue.component(MyUl.name, MyUl); Vue.component(MyLi.name, MyLi); 在页面中使用 Home.vue {{grid.title}} data() { return { grids: [ { className: \"cms-news\", title: \"新闻资讯\", url: \"baidu.com\" }, { className: \"cms-photo\", title: \"图文分享\", url: \"jsliang.top\" }, ] } } 重定向路由： router/index.js routes: [ { path: '/', redirect: { name: 'home' }, } ] 通过 导向页面： Home.vue 首页 data() { return { grids: [ {className: \"cms-news\", title: \"新闻\", router:{name: 'new.list'}} ] } } router/index.js import NewsList from \"@/components/News/NewsList\" routers: [ { name: \"news.list\", path: \"/news/list\", component: NewsList } ] News/NewsList.vue ……省略 关于 :key=\"**\"，如果数据有对应的 id，则用它的 id。 时间过滤器：Moments.js 安装 Monents.js：npm install moment --save main.js // 定义 moment 全局日期过滤器 import Moment from 'moment'; // {{ 'xxx' | converTime('YYYY-MM-DD') }} // {{ 'xxx' | converTime('YYYY年MM月DD日') }} Vue.filter(\"converTime\", function(data, formatStr) { return Moment(data).format(formatStr); }); NewsList.vue {{ news.add_time | converTime('YYYY-MM-DD') }} 可以获取绝对时间或者相对时间 Vue.filter(\"relativeTime\", function(previousTime) { return Moment(previousTime).fromNow(); }) 封装头部 components/common/NavBar.vue 返回 {{title}} export default { name: 'nav-bar', props: ['title'], methods: { goBack() { this.$router.go(-1); } } } src/main.js // 引入自己的 ul 和 li 组件 import NabBar from '@/components/Common/NabBar' // 注册全局组件 Vue.component(NabBar.name, NabBar); NewsList.vue 点击切换不同页面，MintUI 组件下边导航 App.vue @click = \"changeHash\" methods: { changeHash() { // 在 Vue 完成渲染任务以后的行为 this.$nextTick(function() { console.log(this.selected); this.$router.push({ name: this.selected }) }) } } 点击跳转到文章详情 NewsList.vue index.js import NewsDetail from '@/components/News/NewsDetail'; export default new Router({ routes: [ // 新闻详情 { name: 'news.detail', path: '/news/detail', component: NewsDetail } ] }) NewsDetail …… 图文分享 Home.vue { className: \"cms-photo\", title: \"图文分享\", router: { name: \"photo.list\", params: { categoryId: 0 } } } router/index.js { name: \"photo.list\", path: \"/photo/list/:category\", component: PhotoList } lazy load 使用 MintUi 自带的 v-lazy 指令 安装 v-lazy 包 路由守卫  路由守卫 PhotoList.vue export default { beforeRouteUpdate(to, from, next) { // ... console.log(to); next(); } } 接口返回信息 { Status: 1, //数据状态 Code: 200, //反码状态 Message: 'Successful', //描述信息 ClientTime: 1473765898, //客户端请求时间 ServerTime: 1473765935, //服务端响应时间 token: '38ce6474a370c3fe84ddf92403bec204cfcbe07b', //唯一token也可做加密key data:{ //json数据，格式层级关系根据对应需求虽易定 key1: value1, key2: value2, key3: { [ name: '小明', sex: 1, ],[ name: '小华', sex: 1, ],[ name: '小刚', sex: 1, ]} } } 关于分类跳转 在 created() 中调用函数，查看 id，跳转到不同分类 在用户修改 url 时，beforeRouteUpdate() 中调用函数，查看 id，跳转到不同分类 在点击按钮上触发事件。 新闻详情 通过 v-html 来渲染富文本 NewsDetail.vue 由于 v-html 是 this.nextTick() 中执行的，所以要注意下渲染机制。 图片预览 图片预览插件 - vue-preview main.js // 图片预览插件 import VuePreview from 'vue-preview' // default install Vue.use(VuePreview); // 上面代码会内部运行下面代码 Vue.component('vue-preview', componentObj); 封装评论组件 新建 src/components/Common/Comment.vue Comment.vue // 内容 export default { name: \"comment\" } main.js import Comment from '@/components/Common/Comment'; Vue.component(Comment.name, Comment); PhotoDetail.vue let id = this.$route.query.id; 关于使用组件 artId - 详情 id pageIndex - 页数 Comment.vue export default { name: \"comment\", props: ['cid'], // 评论需要的 id created() { // 使用该组件的时候，是否有页码，如果有，就到那个页面，如果没有，就是第一页。 let id = this.$route.query.page || '1'; } } 关于评论方式 路人 用户 加载中功能 src/main.js // 配置请求拦截器，显示 loading 图标 Axios.interceptors.request.use(function(config) { MintUI.Indicator.open({ text: \"加载中...\", spinnerType: \"fading-circle\" }) return config; }); // 配置响应拦截器，关闭 loading 图标 Axios.intercepotrs.response.use(function(response) { MintUI.Indicator.close(); return response; }) MintUI 下拉刷新与上拉加载 参考地址 // loadmore 的禁止函数调用的属性来控制 this.isAllLoaded = true; // 通知元素重新定位 this.$refs.loadmore.onBottomLoaded(); 过渡效果 Vue 过渡动画 父子组件通讯 新建 src/EventBus.js EventBus.js import Vue from 'vue'; // bus 公交车，基于事件的同一个载体对象 let EventBus = new Vue(); // $on(事件名, function() {}) -> $emit('事件名', 数据) export default EventBus; src/App.vue import EventBus from './EventBus.js'; export default { created() { EventBus.$on('addShopcart', (data) => { console.log(data); console.log(this); }) } } src/components/Goods/GoodsDetail.vue insertBall() { // 通知 App 组件增加小球数量 EventBus.$emit('addShopcart', this.pickNum); } 路由守卫判断来回的路由 路由守卫 beforeRouteEnter (to, from, next) { next(vm => { // 通过 `vm` 访问组件实例 }) } 商品的增删改查 src/GoodsTools.js let obj = {}; // 获取所有商品数据 obj.getGoodsList = function() { return JSON.parse(window.localStorage.getItem('goodsList') || '{}'); } // 保存商品 obj.saveGoods = function(goodsList) { // 本地存储 window.localStorage.setItem('goodsList', JSON.stringify(goodsList)); } // 新增一个商品 obj.add = function(goods) { // 判断当前 goodsList 中是否包含该商品，有则追加，无则赋值 let goodsList = this.getGoodsList(); if(goodsList[goods.id]) { // 有该 key 做追加 goodsList[goods.id] += goods.num; } else { goodsList[goods.id] = goods.num; } // 保存数据 this.saveGoods(goodsList); } // 获取购物车数量总数 obj.getTotalCount = function() { let goodsList = this.getGoodsList(); let values = Object.value(goodsList); let sum = 0; values.forEach(val => sum += val); return sum; } export default obj; App.vue import GoodsTools from './GoodsTools.js'; export default { created() { // 初始化小球的数量 this.num = GoodsTools.getTotalCount(); } } GoodsDetail.vue import GoodsTools from '@/GoodsTools'; afterEnter() { // 添加到本地存储 GoodsTools.add({ id: this.goodsInfo.id, num: this.pickNum }) } 离开页面 beforeRouteLeave(to, from, next) { // 导航离开该组件的对应路由时调用 // 可以访问组件实例 this if(confirm('亲，真的要离开吗？')) { } else { // 取消导航行为 next(false); } } 中获取其他组件的高度 App.vue Content.vue export default { props: ['apprefs'], mounted() { console.log(this.apprefs.appHeader.$el.offsetHeight); console.log(this.apprefs.appFooter.$el.offsetHeight); } } 滚动行为 VueRouter 滚动行为 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Vue/VueDemoThree.html":{"url":"JavaScript-library/Vue/VueDemoThree.html","title":"✘ Vue Demo Three - 千人千魔","keywords":"","body":"Vue Demo Three - 千人千魔 Create by jsliang on 2019-1-23 12:56:37Recently revised in 2019-2-11 11:31:58 该 Demo，可分为四大部分： 部分一：吐槽系统 功能 用户可吐槽工作、生活、学习 用户可查看吐槽详情 用户可点赞吐槽 用户可评论吐槽 用户可回复吐槽评论 用户可举报吐槽 用户举报数超 50，管理员将审核，吐槽将可能因违规被删除 数据库设计 字段 类型 说明 id int 主键，自动递增 time datetime 时间 部分二：商城系统 用户可以上传商品 用户可以查看商品详情 用户可以添加商品到购物车并购买 用户可以评论商品 用户可以点赞商品 用户的商品评论违法被举报删除 商品分为人气商品和新商品 用户可以搜索商品 商品违法被举报删除 用户可以实施商品攻略战，以超过商品原价 10 倍的积分买断商品拥有权 商品不能是正规商品 部分三：积分系统 用户签到能领取积分 用户评论被点赞能获得积分 用户上传商品能获得积分 用户上传的商品获得点赞可以领取积分 用户文章、商品被举报删除可以获得成就 用户商品被买断可以获得积分 积分可用户商品购买以及商品拥有权购买 积分可用于系统成就达成 部分四：用户信息 用户信息来源于微信/QQ 用户可有个人座右铭 用户拥有文章发表权以及商品发表权 部分五：土豪系统 积分累计到一定程度开启土豪系统 土豪可以看到普通用户看不到的页面 土豪可以 8 折垄断商品 土豪可以花费积分购买排名 土豪可以打赏其他用户 土豪被举报将扣除全部积分 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/React/":{"url":"JavaScript-library/React/","title":"☆ React","keywords":"","body":"React create by jsliang on 2018-9-5 08:59:31Recently revised in 2019-04-23 14:32:31 一 React 介绍 React 是 Facebook 于 2013 年推出的函数式编程，是目前前端框架中使用人数最多的前端框架，其拥有健全的文档与完善的社区。 React 16.0 及以上版本，又被成为 React Fiber。 二 React 与 Vue 比较 Vue 提供了非常丰富的 API，但是因为过于丰富，灵活度相对于 React 没有那么灵活。 开发复杂度比较高的项目时，可以选择 React。而面向用户端复杂度没那么高的项目，可以使用 Vue。 具体选用何种框架，还是取决于个人/团队对于该框架的驾驭程度 三 目录 文章 知识点 《React Demo One - TodoList》) React 《React Demo Two - TodoList 升级》 React、Redux、Redux-Thunk、Redux-Saga、React-Redux 《React Demo Three - 简书》 React、Redux、React-Redux、Redux-Thunk 四 学习顺序 ReactBase ReactDemoOne-TodoList ReactRedux ReactDemoTwo-TodoListUpgrade ReactDemoThree-JianShu jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-23 14:32:48 "},"JavaScript-library/React/ReactBase.html":{"url":"JavaScript-library/React/ReactBase.html","title":"✘ React 基础","keywords":"","body":"React 基础 create by jsliang on 2019-3-26 09:25:41Recently revised in 2019-04-23 16:14:43 记录 React 基础知识，并尝试构建个人知识体系。 React 版本：16.4 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 JSX  3.1 什么是 JSX  3.2 JSX（一）  3.3 JSX（二）  3.3 JSX（三） 四 元素渲染 五 组件 & Props 六 state & 生命周期  6.1 Mounting  6.2 Updation  6.3 Unmounting  6.4 汇总 二 前言 返回目录 万丈高楼平地起，地基还得自己起。 从 0 开始，丰富自己的 React 技术栈。 最好的学习还是自己看官方文档，别人的笔记终究是别人学习的总结。 三 JSX 返回目录 3.1 什么是 JSX 返回目录 const element = Hello, world!; 在 React 中，我们管这样的内容，叫 JSX。 3.2 JSX（一） 返回目录 JSX 类似于 HTML 标签，但是它确切来说是 React 内部生成的，它也可以包含表达式，例如： function formatName(user) { return user.firstName + ' ' + user.lastName; } const user = { firstName: 'Harper', lastName: 'Perez' }; const element = ( Hello, {formatName(user)}! ); ReactDOM.render( element, document.getElementById('root') ); 3.3 JSX（二） 返回目录 不仅如此，还可以将 JSX 作为返回值： function getGreeting(user) { if (user) { return Hello, {formatName(user)}!; } return Hello, Stranger.; } 3.4 JSX（三） 返回目录 Babel 转译器会把 JSX 转换成一个名为 React.createElement() 的方法调用。 const element = ( Hello, world! ); // 等价于上面代码 const element = React.createElement( 'h1', {className: 'greeting'}, 'Hello, world!' ); 四 元素渲染 返回目录 元素是构成 React 应用的最小单位。 元素用来描述你在屏幕上看到的内容： const element = Hello, world; 与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。 我们可以拿 create-react-app 中的简化代码来看看： index.html Todolist 你需要允许在 APP 中运行 JavaScript index.js import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; ReactDOM.render(, document.getElementById('root')); App.js import React, { Component } from 'react'; class App extends Component { render() { return ( Hello React! ); } } export default App; 在这三个文件中我们可以很简单地看出猫腻： 我们在 index.html 中有个根节点： 我们通过 index.js 往 index.html 挂载元素：ReactDOM.render(, document.getElementById('root')); 我们在 App.js 中表示元素的具体内容为：Hello React! 如此，小伙伴们对元素应该有个清晰了解了。 五 组件 & Props 返回目录 元素是 React 中的最小单位，当元素堆积过多的时候就形成页面，而我们可以将页面划分成不同的部门，从而实现复用，于是就有了组件。 组件可以将 UI 切分成一些独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。 组件从概念上看就像是函数，它可以接收任意的输入值（称之为 props），并返回一个需要在页面上展示的 React 元素。 下面我们来看个例子： function Welcome(props) { return Hello, {props.name}; } const element = ; ReactDOM.render( element, document.getElementById('root') ); 在这个例子中，我们做了 4 件事： 我们对 元素调用了 ReactDOM.render() 方法。 React 将 {name: 'Sara'} 作为 props 传入并调用 Welcome 组件。 Welcome 组件将 Hello, Sara 元素作为结果返回。 React DOM 将 DOM 更新为 Hello, Sara。 六 state & 生命周期 返回目录 本文生命周期为 React 16.4，目前 React 16.8 版本已有新生命周期 上图为 React 16.4 版本的生命钩子。 何为生命周期：生命周期函数指在某一个时刻会自动调用执行的函数。 6.1 Mounting 返回目录 componentWillMount()：在组件即将被挂载到页面的时刻自动执行。 render()：渲染 JSX。 componentDidMount()：在组件被挂载到页面之后，自动被执行。 6.2 Updation 返回目录 shouldComponentUpdate()：在组件被更新之前，它会自动被执行。如果该生命周期存在于子组件，然后该子组件不需要根据父组件更新而更新，我们只需要 return false 即可①。 componentWillUpdate()：在组件被更新之前，它会自动被执行，但是它在 shouldComponentUpdate() 之后被执行。如果 shouldComponentUpdate() 返回 true，这个函数会被执行；如果返回 false，该函数不会被执行。 render()：渲染 JSX。 componentDidUpdate()：组件更新完成之后，它会被执行。 ①： shouldComponentUpdate(nextProps, nextState) { if(nextProps.content !== this.props.content) { return true; } else { return false; } } componentWillReceiveProps()：当一个组件从父组件中接收了参数。只要父组件的 render() 函数被重新执行了，子组件的这个生命周期函数就会被执行。 6.3 Unmounting 返回目录 componentWillUnmount()：当这个组件即将被从页面中剔除的时候，会被执行。 6.4 汇总 返回目录 n 调试工具 React Development Tools 介绍 React Development Tools 下载地址 n 子组件接受数据校验及默认设置 // 引用类型校验 import PropTypes from 'prop-types' class TodoItem extends React { // ...省略 } // 使用类型校验 TodoItem.protoTypes = { test: PropTypes.string.isRequired, content: PropTypes.arrayOf(PropTypes.number, PropTypes.string), deleteItem: PropTypes.func, index: PropTypes.number } // 使用字段默认值 TodoItem.defaultProps = { test: 'Hello World!' } export default TodoItem; n poops、state 以及 render 函数的关系 当组件的 state 或者 props 发生改变的时候，render 函数就会重新执行。 当父组件的 render 函数被运行时，它的子组件的 render 都将被重新运行一次。 n React 的 DOM 操作 首先，尝试模仿下 React 的数据更新： state 数据 JSX 模板 数据 + 模板结合，生成真实的 DOM，来显示 state 发生改变 数据 + 模板结合，生成真实的 DOM，替换原始的 DOM 然后，我们分析下缺陷： 第一次生成了一个完整的 DOM 片段 第二次生成了一个完整的 DOM 片段 第二次的 DOM 替换第一次的 DOM，非常耗性能 接着，我们尝试优化下思路： state 数据 JSX 模板 数据 + 模板结合，生成真实的 DOM，来显示 state 发生改变 数据 + 模板结合，生成真实的 DOM，并不直接替换原始的 DOM 新的 DOM（Document Fragment）与原始的 DOM 作对比，找差异 找出 input 框发生了什么变化 只用新的 DOM 中的 input 元素，替换掉老的 DOM 中的 input 元素 再来，我们再次分析下缺陷： 性能的提升并不明显 然后，我们进一步优化提升： state 数据 JSX 模板 数据 + 模板生成虚拟 DOM（虚拟 DOM 就是一个 JS 对象，用来描述真实 DOM）（损耗了性能） ['div', {id: 'abc'}, [ 'span', {}, 'Hello World!' ]] 用虚拟 DOM 的解构生成真实的 DOM，来显示 Hello World! state 发生变化 数据 + 模板生成新的虚拟 DOM（极大提升了性能） ['div', {id: 'abc'}, [ 'span', {}, 'Hello jsliang!' ]] 比较原始虚拟 DOM 和新的虚拟 DOM 的区别，找到区别是 span 中内容（极大提升了性能） 直接操作 DOM，改变 span 中的内容 最后，我们分析下现在优点： 性能提升了 它使得跨端应用得以实现。React Native（网页上生成 DOM 标签，手机上生成原生应用代码） 在 JSX 中，JSX -> createElemnt -> 虚拟 DOM（JS 对象） -> 真实的 DOM：return item可以被下面语句替换：return React.createElement('div', {}, React.createElement('span', {}, 'item')) n 虚拟 DOM 中的 diff 算法 比较原生虚拟 DOM 和新的虚拟 DOM 的区别，使用 Diff（different）算法 如上图，在 React 中，对于 setState，它采用异步操作，统一对 state 中的数据进行更改。 首先，比对第一层的 DOM 节点，如果它相同，则往下继续对比；如果它不同，则停止对比，更新第一层及以下的 DOM 节点。 然后，比对第二次的 DOM 节点…… 最后，形成一种比对算法。 关于 React 中的 key 值： 如果我们没有在 for 遍历中，给节点赋值上相应的 key 值，那么，React 的查找就像上图左侧一样，毫无目的，很难进行比较。 当我们使用了相应的 key 值时，我们就可以快速找到不同的地方，进行对比，从而方便进行渲染。 现在可以解释，为啥不要使用 index 作为 for 循环的 key 值。 第一次我们添加了：a - 0、b - 1、 c - 2 当我们删除了 a 之后：b - 0、c - 1 这时候，我们对应的 key 值就变了，我们就需要重新渲染整个 DOM 节点了。 ref： ref 帮助我们在 React 中直接获取 DOM 元素 TodoList.js {this.input = input}} onChange={this.handleInputChange.bind(this)} /> handleInputChange() { const value = this.input.value; } // 之前 // handleInputChange(e) { // const value = e.target.value; // } 工作中不推荐 ref 形式，因为它操作 DOM 了。 n setState 异步 在 this.setState() 中，我们知道它是异步执行的。 那么，当我们需要在它进行数据更新之后操作，我们要怎么做呢？使用 Promise？不需要！因为 React 提供了 setState 后的操作： this.setState( (prevState) => { inputValue: '', }), () => { console.log('设置完状态后执行'); }); n 调用接口 - axios 安装：npm i axios -S 引用：import axios from 'axios' 使用：axios.get('地址').then( (res) => {}).catch( (error) => {})) mock：使用 Charles 模拟接口。 n React 中的动画 使用 CSS3 编写动画 使用插件 react-transition-grup 地址：react-transition-group 安装：npm i react-transition-group --save jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:19:42 "},"JavaScript-library/React/ReactPrepare.html":{"url":"JavaScript-library/React/ReactPrepare.html","title":"✘ React 开发准备","keywords":"","body":"React 开发准备 Create by jsliang on 2019-04-25 16:20:59Recently revised in 2019-04-26 11:57:21 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 二 前言 返回目录 在使用 Create React App 搭建脚手架的时候，有些步骤是重复的，有时候甚至还会忘记这些配置的使用方法，故在此记录一些常用步骤（插件安装等），方便自己回顾。 三 初始化目录 返回目录 下载 Node.js 安装 Create React App： npm i create-react-app -g 开启新项目： create-react-app todolist cd todolist npm start 打包项目：npm build 项目目录： - todolist + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - mainfest.json —— 提供 meta 信息给项目，并与 serviceWorker.js 相呼应，进行离线 APP 定义 - src ——————————————————— 项目主要目录 - App.css —— 主组件样式 - App.js —— 主组件入口 - App.test.js —— 自动化测试文件 - index.css —— 全局 css 文件 - index.js —— 所有代码的入口 - logo.svg —— 页面的动态图 - serviceWorker.js —— PWA。帮助开发手机 APP 应用，具有缓存作用 - .gitignore ———————————— 配置文件。git 上传的时候忽略哪些文件 - package-lock.json ————— 锁定安装包的版本号，保证其他人在 npm i 的时候使用一致的 node 包 - package.json —————————— node 包文件，介绍项目以及说明一些依赖包等 - README.md ————————————— 项目介绍文件 当然，一般我们都需要进行项目定制化，有些功能不需要的（例如 Service Worker），有些文件不需要的（例如 logo.svg），有些文件需要修改的（例如 index.html），就需要进行简化下： - demo + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 + mock —— 本地 Mock 文件夹 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - src ——————————————————— 重要的目录 + api —— 封装 API 接口文件 - assets —— 静态资源文件夹 + img —— 图片资源文件夹 + components —— 共用组件 + pages —— 路由页面 + store —— 全局配置 store - style —— 全局配置样式 - index.css —— 全局样式 - reset.css —— 重置浏览器样式 - common.css —— 项目复用样式 - icon.css —— 图标样式 - App.js —— 主组件入口 - index.js —— 所有代码的入口 - .gitignore ———————————— 配置文件。Git 上传的时候忽略哪些文件 - package.json —————————— Node 包文件。介绍项目以及说明一些依赖包等 - README.md ————————————— 项目介绍文件 Reset CSS reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 16px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 16px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /* * 图片自适应 - image responsize * 1. 清空浏览器对图片的设置 * 2. 图片 的情况下，图片会撑高 div，这么设置可以清除该影响 */ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .32rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .32rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .32rem } /* Internet Explorer */ Npm Install 安装 Redux：npm i redux -S 安装 React-Redux：npm i react-redux -S 安装 Redux-Saga：npm i redux-saga -S 安装 React-Router：npm i react-router-dom -S 安装 Ant Design：npm i antd -S 安装 Axios：npm i axios -S 总：cnpm i redux react-redux redux-saga react-router-dom antd axios -S React Router DOM 案例 import React, { Fragment } from 'react'; import { BrowserRouter, Route } from 'react-router-dom'; import Header from './components/Header'; import TimeLine from './pages/TimeLine'; function App() { return ( ); } export default App; jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:21:35 "},"JavaScript-library/React/ReactList.html":{"url":"JavaScript-library/React/ReactList.html","title":"✘ React 知识点清单","keywords":"","body":"React 知识点清单 create by jsliang on 2019-04-23 14:10:18Recently revised in 2019-04-26 11:49:38 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 清单 四 Create React App 五 DvaJS 六 Service Workers 七 Debugger for Chrome 八 Source Maps 分析包大小 九 Sass 安装及使用 十 React Loadable - 代码打包分割 十一 React Router - 路由 十二 Axios - 调用后端接口 十三 Fetch - 调用后端接口 十四 Mock - 利用 Create React App 特性 二 前言 返回目录 求你别更新了，我学不过来了！ 别笑，这是事实。 现在前端界的玩意真的太多了，有些东西你听都没听过，然后很多招聘信息中居然 明目张胆 的贴着应聘者须具备 XX 技能，看得你目瞪口呆。 所以，这篇文章仅仅罗列知识点及其简单使用，更深一步的时候还是看我其他的实战文章或者自行百度搜索。 由于是罗列，有时候你会发现它毫无逻辑，甚至可读性极差。毕竟 —— 仅仅是罗列。 三 清单 返回目录 【Create React App】：构建一个 React 的脚手架工具 通过本文快速了解 Create React App 中文文档 【DvaJS】：类似 Create React App 的，方便 React 快速搭建项目的脚手架工具 通过本文快速了解 DvaJS 官网 【Service Worker】：具有离线缓存作用，能让浏览器在网速差或者网络不通的情况下，还能访问网站的静态资源。 通过本文快速了解 Service Workers API - MDN 制作渐进式 Web 应用程序(PWA) 【Debugger for Chrome】：Visio Studio Code 软件的开发插件，可以用来调试 Vue、React 等脚手架代码，非常方便。 通过本文快速了解 使用 VSCode 调试 React 应用 【source-map-explorer】：用来分析 Bundle 包的大小，从而进一步优化项目。 通过本文快速了解 React App 中如何分析Bundle Size？ 【node-sass】：通过 Sass 这个 CSS 预编译处理器，更好地编写 CSS。 通过本文快速了解 添加 Sass 样式表 【React Loadable】：配合 React Router，在 Create React App 中进行组件分割，减少每个 JS 文件的大小。 通过本文快速了解 Code-Splitting - GitHub react-loadable Code Splitting in Create React App 【React Router】：由于 Create React App 并没有规定路由解决方案，在此推荐 React Router。 通过本文快速了解 React Router 【Axios】：Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 Node.js 中。可以用来调用后端接口。 通过本文快速了解 Axios 中文说明 【Fetch】：Fetch API 类似于 Axios，它提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的部分，例如请求和响应。 通过本文快速了解 使用 Fetch - MDN React 快速上手 - 09 数据请求 fetch - SegmentFault 【Mock】：有时候后端接口还没好，我们不能干愣着，可以借助 Create React App 中的 Node 服务，直接调用本地模拟数据。 通过本文快速了解 四 Create React App 返回目录 通过运行一个命令来建立现代 Web 应用程序，来帮助你快速开发 React 项目。 步骤： 下载 Node.js 安装 Create React App： npm i create-react-app -g 开启新项目： create-react-app todolist cd todolist npm start 打包项目：npm build 项目目录： - todolist + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - mainfest.json —— 提供 meta 信息给项目，并与 serviceWorker.js 相呼应，进行离线 APP 定义 - src ——————————————————— 项目主要目录 - App.css —— 主组件样式 - App.js —— 主组件入口 - App.test.js —— 自动化测试文件 - index.css —— 全局 css 文件 - index.js —— 所有代码的入口 - logo.svg —— 页面的动态图 - serviceWorker.js —— PWA。帮助开发手机 APP 应用，具有缓存作用 - .gitignore ——————————— 配置文件。git 上传的时候忽略哪些文件 - package-lock.json ———— 锁定安装包的版本号，保证其他人在 npm i 的时候使用一致的 node 包 - package.json ————————— node 包文件，介绍项目以及说明一些依赖包等 - README.md ———————————— 项目介绍文件 参考链接：Create React App 中文文档 五 DvaJS 返回目录 什么是 DvaJS？ dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。 说白了，它是类似于 create-react-app 的，帮你配置脚手架的工具，可以让你快速搭建项目。 参考链接：DvaJS 官网 六 Service Workers 返回目录 在使用 Create React App 创建新项目时，会默认装上未开启的 Service Workers。 什么是 Service Workers？ Service Workers 本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步 API。 为什么加入 Service Workers？ 在 Create React App 中，由于离线优先的 Progressive Web Apps（渐进式 Web 应用程序）比传统网页更快，更可靠，并提供了很好的移动体验，所以它将 Service Workers 添加了进来。 如何开启 Service Workers？ 修改 src/index.js 目录中的 serviceWorker.unregister(); 为 serviceWorker.register() 即可开启离线缓存功能。 进一步定制需要自行百度/Chrome。 参考链接： Service Workers API - MDN 制作渐进式 Web 应用程序(PWA) - Create Web App 中文文档 七 Debugger for Chrome 返回目录 可以通过 Visio Studio Code 的插件 Debugger for Chrome 调试 Create React App： 安装 -> Debugger for Chrome 调试 -> 添加配置： launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Chrome\", \"type\": \"chrome\", \"request\": \"launch\", \"url\": \"http://localhost:3000\", \"webRoot\": \"${workspaceRoot}/src\", \"sourceMapPathOverrides\": { \"webpack:///src/*\": \"${webRoot}/*\" } } ] } 保存 -> 开始调试 通过上述步骤即可开始调试 如有问题可以参考下面资料 参考资料：使用 VSCode 调试 React 应用 - 知乎 八 Source Maps 分析包大小 返回目录 使用 source maps 分析 JavaScript 包。 这有助于你了解代码膨胀的来源，从而配合其他插件来减少每个包的大小，优化项目。 安装：npm i source-map-explorer -S 修改 package.json： package.json \"scripts\": { \"analyze\": \"source-map-explorer build/static/js/main.*\", \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test\", } 打包：npm run build 分析：npm run analyze 参考资料：React App 中如何分析Bundle Size？ - 简书 九 Sass 安装及使用 返回目录 Sass 是一种 CSS 的预编译处理器，简单来说就是方便你有组织有预谋地编写 CSS，更多 Sass 技巧可以去参考文献查找。 安装 node-sass：npm i node-sass -S 引入：@import 'styles/_colors.scss'; // 假设 styles 目录 在 src/ 目录下 参考文献： Sass 中文文档 添加 Sass 样式表 - Create React App 中文文档 十 React Loadable - 代码打包分割 返回目录 在 Create React App 中，我们可以使用 React Loadable 来进行代码的分割。 使用方式： import Loadable from 'react-loadable'; const LoadableOtherComponent = Loadable({ loader: () => import('./OtherComponent'), loading: () => Loading..., }); const MyComponent = () => ( ); 参考文献： Code-Splitting - GitHub react-loadable - GitHub Code Splitting in Create React App - Server Less Stack Overflow 十一 React Router - 路由 返回目录 由于 Create React App 并没有规定路由解决方案，然后市面上比较收欢迎的路由解决方案是 React Router，所以可以尝试使用： 安装：npm i react-router-dom -S 使用： React Router 官方文档 React Router DOM 中文文档（一） - 简书 React Router DOM 中文文档（二） - 简书 十二 Axios - 调用后端接口 返回目录 Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 Node.js 中。 功能： 从浏览器中创建 XMLHttpRequests 从 Node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 安装：npm install axios -S 使用：axios.get('/user').then((res) => {}).catch((err) => {}) Axios 中文说明 当然 React 调用接口不可能一家独霸，你还可以了解：AJAX API三驾马车: Axios vs . jQuery和Fetch - 掘金 十三 Fetch - 调用后端接口 返回目录 Fetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的部分，例如请求和响应。它还提供了一个全局 fetch() 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。 由于 Fetch 是浏览器内置，所以可以直接调用： fetch('http://example.com/movies.json') .then(function(response) { return response.json(); }) .then(function(myJson) { console.log(myJson); }); 由于 Fetch 具有极大兼容性，所以可以在 Create React App 中使用插件：cross-fetch，它能解决掉一大部分的兼容：npm i cross-fetch -S。 参考文献： 使用 Fetch - MDN React 快速上手 - 09 数据请求 fetch - SegmentFault 十四 Mock - 利用 Create React App 特性 返回目录 在我们的 Create React App 中，其实是可以使用它自带的 Node 进行接口模拟的，下面我们来看目标目录： - todolist + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 - api —— 新增的 Mock 文件夹 - user.json —— Mock 的 JSON 数据 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - src ——————————————————— 项目主要目录 - App.js —— 主组件入口 - index.css —— 全局 css 文件 - index.js —— 所有代码的入口 - .gitignore ——————————— 配置文件。git 上传的时候忽略哪些文件 - package.json ————————— node 包文件，介绍项目以及说明一些依赖包等 然后，我们在 src 目录中某个文件的 ComponentDidMount 等位置，调用 Fetch 或者 Axios，即可获取到数据： user.json { \"status\": \"0\", \"data\": [ { \"name\": \"jsliang\", \"age\": 24 }, { \"name\": \"梁峻荣\", \"age\": 24 } ] } Test.js import React, { Component } from 'react'; class Test extends Component { render() { return( Hello React ) } componentDidMount() { fetch( '/api/test.json' ) .then(res => res.json()) .then(data => { console.log(data) }) .catch(e => { console.log('错误:', e) }) } } export default Test; 最后，我们就可以在浏览器的控制台查看到 Mock 接口数据： data: [{name: \"jsliang\", age: 24}, {name: \"梁峻荣\", age: 24}] status: \"0\" Else 阅读推荐 返回目录 知乎专栏 - 魔都三帅和江浙沪包邮技术大联盟 关于 export 和 import - Stack Overflow 从redux-thunk到redux-saga实践 - SegmentFault jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-26 11:59:34 "},"JavaScript-library/React/ReactList-CreateReactApp.html":{"url":"JavaScript-library/React/ReactList-CreateReactApp.html","title":"✔ React List - Create React App","keywords":"","body":"React List - Create React App create by jsliang on 2019-04-24 11:36:57Recently revised in 2019-04-25 10:44:54 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 安装及初始目录 四 默认支持特性 五 配合 VS Code 调试 六 分析包大小 七 模块引入 CSS 八 Sass 安装及使用 九 添加图片、背景、SVG 十 public 文件夹  10.1 引用静态资源  10.2 Mock 数据 十一 代码打包分割 十二 引用 TypeScript 十三 React Router - 路由 十四 自定义环境变量 十五 测试 十六 开发环境代理 十七 使用 Ajax 请求获取数据 十八 Title 和 Meta 十九 总结 二 前言 返回目录 Create React App 是一个官方支持的创建 React 单页应用程序的方法。它提供了一个零配置的现代构建设置。 本文 绝大多数、99% 内容来自 Create React App 的文档，1% 来自个人的整理。 如果对此话有所误解，请跳至文：十九 总结 可加 QQ 群：798961601，跟随 jsliang 一起折腾 参考文献： Create React App - 英文文档 Create React App - 中文文档 Create React App - GitHub 三 安装及初始目录 返回目录 下载 Node.js 安装 Create React App： npm i create-react-app -g 开启新项目： create-react-app todolist cd todolist npm start 打包项目：npm build 项目目录： - todolist + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - mainfest.json —— 提供 meta 信息给项目，并与 serviceWorker.js 相呼应，进行离线 APP 定义 - src ——————————————————— 项目主要目录 - App.css —— 主组件样式 - App.js —— 主组件入口 - App.test.js —— 自动化测试文件 - index.css —— 全局 css 文件 - index.js —— 所有代码的入口 - logo.svg —— 页面的动态图 - serviceWorker.js —— PWA。帮助开发手机 APP 应用，具有缓存作用 - .gitignore ——————————— 配置文件。git 上传的时候忽略哪些文件 - package-lock.json ———— 锁定安装包的版本号，保证其他人在 npm i 的时候使用一致的 node 包 - package.json ————————— node 包文件，介绍项目以及说明一些依赖包等 - README.md ———————————— 项目介绍文件 参考文献：入门 - Create React App 中文文档 四 默认支持特性 返回目录 支持所有现代浏览器（IE 9、10、11 除外，如果需要，请自行配置） 支持指数运算符 (ES2016) 支持 async / await (ES2017) 支持 Object Rest(剩余) / Spread(展开) 属性 (ES2018) 支持动态 import() (stage 3 proposal) 支持 Class 字段和静态属性 (part of stage 3 proposal) 支持 JSX, Flow 和 TypeScript 支持 PostCSS，无需手动添加 CSS 前缀，Create React App 会自动补全 参考文献：支持的浏览器和特性 - Create React App 中文文档 五 配合 VS Code 调试 返回目录 可以通过 Visio Studio Code 的插件 Debugger for Chrome 调试 Create React App： 安装 -> Debugger for Chrome 调试 -> 添加配置： launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Chrome\", \"type\": \"chrome\", \"request\": \"launch\", \"url\": \"http://localhost:3000\", \"webRoot\": \"${workspaceRoot}/src\", \"sourceMapPathOverrides\": { \"webpack:///src/*\": \"${webRoot}/*\" } } ] } 保存 -> 开始调试 通过上述步骤即可开始调试 如有问题可以参考下面资料 参考资料：使用 VSCode 调试 React 应用 - 知乎 六 分析包大小 返回目录 使用 source maps 分析 JavaScript 包。 这有助于你了解代码膨胀的来源，从而配合其他插件来减少每个包的大小，优化项目。 安装：npm i source-map-explorer -S 修改 package.json： package.json \"scripts\": { \"analyze\": \"source-map-explorer build/static/js/main.*\", \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test\", } 分析：npm run build 分析：npm run analyze 参考资料：React App 中如何分析Bundle Size？ - 简书 七 模块引入 CSS 返回目录 在 Create React App 中，如果你的 react-scripts 版本是 2.0 或者更高，你可以通过模块形式引入样式： Button.js import React, { Component } from 'react'; import styles from './Button.module.css'; // 将 css modules 文件导入为 styles import './another-stylesheet.css'; // 导入常规 CSS 文件 class Button extends Component { render() { // 作为 js 对象引用 return Error Button; } } 这样子不会导致样式的冲突，就好比你 import JS 进来一样。 参考资料：添加 CSS Modules 样式表 - Create React App 中文文档 八 Sass 安装及使用 返回目录 安装 node-sass：npm i node-sass -S 引入：@import 'styles/_colors.scss'; // 假设 styles 目录 在 src/ 目录下 参考文献：添加 Sass 样式表 - Create React App 中文文档 九 添加图片、背景、SVG 返回目录 添加图片：通过 import 引入即可。 import React from 'react'; import logo from './logo.png'; // 告诉 Webpack 这个 JS 文件使用了这个图片 console.log(logo); // /logo.84287d09.png function Header() { // 导入结果是图片的 URL return ; } export default Header; 引用背景：通过 url 引用即可。 .logo { background-image: url(./logo.png); } 引用 SVG： import React from 'react'; import logo from './logo.svg'; import './App.css'; function App() { return ( ); } export default App; 或者： import { ReactComponent as Logo } from './logo.svg'; const App = () => ( {/* ReactComponent 导入名称是特殊的 */} {/* Logo 是一个实际的 React 组件 */} ); 参考文献：添加图片，字体和文件 - Create React App 中文文档 十 public 文件夹 返回目录 在 Create React App 创建的项目中，有个 public 文件夹，该文件夹下通常有： favicon.ico - 网页小标签 index.html - 项目首页 mainfest.json - 提供 meta 信息给项目，并与 serviceWorker.js 相呼应，进行离线 APP 定义 当然，它不仅可以拥有这些文件，还可以新增内容。 10.1 引用静态资源 返回目录 index.html 可以引用静态资源。 在 index.html 中引用的静态资源不会被 Webpack 打包，而是被复制到打包目录中，使用方法： 只需要加上 %PUBLIC_URL%/ 表示引用 public 下的资源即可。 在 JavaScript 中： render() { return ; } 这样也会引用 public 中的资源，从而让图片 不会被 Webpack 打包。当然，需要牺牲的代价有： public 文件夹中的所有文件都不会进行后处理或压缩。 在编译时不会调用丢失的文件，并且会导致用户出现 404 错误。 结果文件名不包含内容哈希值，因此你需要添加查询参数或在每次更改时重命名它们（以便清除浏览器缓存）。 10.2 Mock 数据 返回目录 此外，由于它内含 Node.js，所以还可以利用这点进行数据模拟（Mock），做法是： 在 public 文件夹中新建 api 目录，然后创建文件 headerList.json，引用 axios 后，通过： axios.get('/api/headerList.json').then() 即可调用该文件进行 Mock。 api 下可以存放多个 json 文件 参考文献：使用 public 文件夹 - Create React App 中文文档 十一 代码打包分割 返回目录 在 Create React App 中，我们可以使用 React Loadable 来进行代码的分割。 使用方式： import Loadable from 'react-loadable'; const LoadableOtherComponent = Loadable({ loader: () => import('./OtherComponent'), loading: () => Loading..., }); const MyComponent = () => ( ); 参考文献： Code-Splitting - GitHub react-loadable - GitHub Code Splitting in Create React App 十二 引用 TypeScript 返回目录 使用 TypeScript 启动新的 Create React App项目：npx create-react-app my-app --typescript 往 Create React App 现有项目中添加 TypeScript：npm i typescript @types/node @types/react @types/react-dom @types/jest -S。（记得修改所有 JS 文件为 TS 文件，例如 src/index.js -> src/index.tsx） 参考文献：添加 TypeScript - Create React App 中文文档 十三 React Router - 路由 返回目录 由于 Create React App 并没有规定路由解决方案，然后市面上比较收欢迎的路由解决方案是 React Router，所以可以尝试使用： 安装：npm i react-router-dom -S 使用：React Router 十四 自定义环境变量 返回目录 定义环境变量：process.env.REACT_APP_SECRET_CODE 获取特殊内置环境变量：process.env.NODE_ENV。值为：test、development、production。对应三种环境。 render() { return ( You are running this application in {process.env.NODE_ENV} mode. ); } 在开发环境，该页面渲染为： You are running this application in development mode. 十五 测试 返回目录 Create React App 使用 Jest 作为其测试运行器。 但是很不幸的是，工作中并没有用上，估计以后的工作也可能不会用上，所以咱们只需要知道有这回事，等有机会再进行尝试。 参考文献： 运行测试 - Create React App 中文文档 调试测试 - Create React App 中文文档 十六 开发环境代理 返回目录 在开发项目的过程中，最担心的莫过于浏览器告诉你跨域了：后端端口在 4000，或者主机在另一个 IP 地址…… 所以，我们需要在开发环境中配置代理。 嗯，你问为什么生产（部署）环境我们不做代理？因为那属于后端的活了，或许你是个 全栈 工程师，你可以自行解决下。 往 package.json 中添加字段： package.json \"proxy\": \"http://localhost:4000\", 这样当你调用接口：fetch('/api/todos') 时，它会请求代理到 http://localhost:4000/api/todos。 当然，有可能 proxy 不够灵活，小伙伴们可以尝试通过直接访问 Express，并连接项目的代理中间件，详情看参考文献。 参考文献： 在开发环境中代理 API 请求 - Create React App 中文文档 手动配置代理 - Create React App 中文文档 十七 使用 Ajax 请求获取数据 返回目录 在 Create React App 中，可以通过下面两种方法获取 Ajax 数据： fetch() API axios 库 当然，没有限制死必须使用这两种。 这两种调用 Ajax 请求获取数据的方式便捷在它返回 Promise 供链式调用数据。 参考文献：使用AJAX请求获取数据- Create React App 中文文档 十八 Title 和 Meta 返回目录 动态更新 Title：document.title API 根据 React 组件更改 Title：React Helmet 等第三方库 动态更新 Meta： 然后读取 index.html 并将 __OG_TITLE__ 和 __OG_DESCRIPTION__ 替换掉即可。 参考文献：Title(网页标题) 和 Meta 标签 - Create React App 中文文档 十九 总结 返回目录 关于照抄 Create React App： 有必要吗？有必要，也没有必要。 有必要是因为 好记性不如烂笔头，自己敲一遍可以加深点点记忆，而且中文文档的翻译比较哆嗦，所以总结起来看着方便。 没必要是因为大部分都在 Create React App 的中文文档/英文文档中都有提示，所以一些小伙伴可能在下面 ** 了。 whatever, just record. 关于前端学习： 昨天微信群一位小伙伴询问有没有购买慕课网的 TS 重构 Axios 视频 昨天票圈一位小伙伴推荐 Koa 源码剖析视频 只能说，各自有各自的安排。 但是，千万千万不要随大流，能用到工作的知识才是 有用知识。 如果这些知识对你目前的工作，或者甚至以后的工作毫无帮助，请忽视它，无论它在前端圈子有多热闹。 关于 jsliang： 将 React 及其周边技术的官方文档过一遍 进行自己构思的项目实战 跟随公司项目进行大量操练 进一步剖析 React 源码 学习算法和数据结构 再说…… jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-26 12:01:56 "},"JavaScript-library/React/ReactList-ReactRedux.html":{"url":"JavaScript-library/React/ReactList-ReactRedux.html","title":"✔ React List - React Redux","keywords":"","body":"React List - React Redux Create by jsliang on 2019-3-26 08:51:55Recently revised in 2019-04-24 10:00:40 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 二 前言 返回目录 在 React 中，如果兄弟组件需要通讯，例如左侧中的深色圆圈发送到底部圆圈，需要兜很多弯子。 而 Redux 的出现，是为了弥补这种麻烦的通讯方式，建立起一个中央机制，方便各组件之间的通讯。 Redux = Reducer + Flux 如上图，即为 Redux 工作机制。 蓝色：借书人 黄色：借书动作 橙色：图书管理员 紫色：系统 它的流程可以理解为：借书人走到前台（借书动作）跟图书管理员申请借书，图书管理员帮它查找书籍资料，然后拿到电脑返回信息，告诉他去哪借就行了。 换回正常话，即：当组件（React Components）需要调用数据的时候，它就向创造器（Action Creators）发起请求，创造器通知管理者（Store），管理者就去查找相关资料（Reducers），拿到返回的信息后，再告诉组件。 Redux 知识点补充 store 是唯一的 只有 store 能够改变自己的内容 Redux 核心 API createStore：创建 store store.dispatch：派发 action store.getState：获取 store 所有数据内容 store.subscribe：监控 store 改变，store 改变了该方法就会被执行 UI 组件和容器组件 UI 组件 —— 傻瓜组件，做页面的渲染 容器组件 —— 聪明组件，做页面的逻辑 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-26 12:05:18 "},"JavaScript-library/React/ReactList-ReactRouter.html":{"url":"JavaScript-library/React/ReactList-ReactRouter.html","title":"✔ React List - React Router","keywords":"","body":"React List - React Router Create by jsliang on 2019-04-26 13:13:18Recently revised in 2019-04-29 15:25:01 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 初试 四 简介 五 BrowserRouter  5.1 BrowserRouter 语法  5.2 BrowserRouter - basename  5.3 BrowserRouter - getUserConfirmation  5.4 BrowserRouter - forceRefresh  5.5 BrowserRouter - keyLength 六 HashRouter  6.1 HashRouter - basename  6.2 HashRouter - getUserConfirmation  6.3 HashRouter - hashType 七 Link  7.1 Link - to  7.2 Link - replace  7.3 Link - other 八 NavLink  8.1 NavLink - activeClassName  8.2 NavLink - activeStyle  8.3 NavLink - exact  8.4 NavLink - isActive 九 MemoryRouter  9.1 MemoryRouter - initialEntries  9.2 MemoryRouter - initialIndex  9.3 MemoryRouter - getUserConfirmation  9.4 MemoryRouter - keyLength 十 Redirect  10.1 Redirect - from  10.2 Redirect - to  10.3 Redirect - push  10.4 Redirect - exact 十一 Route  11.1 Route - component  11.2 Route - render  11.3 Route - children  11.4 Route - path  11.5 Route - exact  11.6 Route - location  11.7 Route - sensitive 十二 Switch 十三 篇外一：history 十四 篇外二：Code Splitting 十五 篇外三：Scroll To Top  15.1 跳转页面后滚动到顶部  15.2 页面滚动到顶部 十六 篇外四：Redux 十七 总结 二 前言 返回目录 前端路由，是指改变 URL 路径的形式，从而切换到不同的页面，例如： localhost:3000/home localhost:3000/user 通过切换不同的 URL，显示不同的页面，从而有了 路由 的概念。 这篇文章我们讲解在 React 中如何通过 React Router 这个插件，灵活使用路由。 jsliang 瞎吹的，最好自己百度 前端路由 是啥。 参考资料： React Router 官方文档 React Router 中文文档 React Router 中文文档（旧） React Router DOM 中文文档（一） - 简书 React Router DOM 中文文档（二） - 简书 篇外话题： 网上有很多 React Router 文章了，例如： React Router 中文文档（一） React Router DOM 中文文档（一） 为何 jsliang 要多次一举？ 你记录你的，我记录我的，互相不妨碍。 看这些跟看官网没啥两样，所以我需要亲自动手过一遍官网。 记录我看官网的内容，顺带记录我应用上去的实例，方便我下次回顾。 三 初试 返回目录 当前版本：\"react-router-dom\": \"^5.0.0\" 首先，在 Create React App 中，我们引用 React Router： npm i react-router-dom -S 然后，在 src 目录下新建 pages 用来存放页面，并修改 App.js： 案例：App.js import React, { Fragment } from 'react'; import { BrowserRouter, Route, Switch, Redirect } from 'react-router-dom'; import ScrollToTop from './components/ScrollToTop'; import Header from './components/Header'; import TimeLine from './pages/TimeLine'; import NotFound from './pages/404'; function App() { return ( ); } export default App; 最后，通过在 App.js 中如此定义，即可定义对应的组件，并渲染对应页面和进行跳转。 四 简介 返回目录 下面我们拿一些常用的进行介绍： import { BrowserRouter, HashRouter, Redirect, Route, NavLink, Link, MemoryRouter, Switch, withRouter } from \"react-router-dom\"; ：\b路由组件包裹层。 和 的包裹层。 ：路由组件包裹层。相对于 来说，更适合静态文件的服务器。 ：路由重定向。渲染 将使导航到一个新的地址。 ：路由。定义一个路由页面，用来匹配对应的组件（Component）和路由路径。 ：活跃链接。当 URL 中的路径等于该路由定义的路径时，该标签可以呈现它定义的 activeClassName。 ：链接。用来跳转到 对应的路由（Component） 中。 ：暂未使用。 能在内存中保存 URL 的历史记录。很适合在测试环境和非浏览器环境中使用，例如 React Native。 ：路由分组。渲染与该地址匹配的第一个子节点 或者 。可以利用 做分组。 ：路由组合。通过 高阶组件访问 history 对象的属性和最近的 的 match。或者利用它来结合 Redux。 五 BrowserRouter 返回目录 会为你创建一个专门的 history 对象，用来记录你的路由，从而能够返回上一页或者跳转到指定的路由页面。 区别于 ，有响应请求的服务器时使用 ，使用的是静态文件的服务器，则用 。 简单案例： 5.1 BrowserRouter 语法 返回目录 import { BrowserRouter } from 'react-router-dom' 5.2 BrowserRouter - basename 返回目录 规则：basename: string 为里面的子目录提供基础路径名，例如： {/* 渲染为 */} 5.3 BrowserRouter - getUserConfirmation 返回目录 规则：getUserConfirmation: function 用于确认导航的功能。 // 默认使用 window.confirm。 const getConfirmation = (message, callback) => { const allowTransition = window.confirm(message) callback(allowTransition) } 5.4 BrowserRouter - forceRefresh 返回目录 规则：forceRefresh: bool 如果为 true，则路由器将在页面导航中使用整页刷新 const supportsHistory = 'pushState' in window.history 5.5 BrowserRouter - keyLength 返回目录 规则：keyLength: number 设置它里面路由的 location.key 的长度。默认为 6。 key 的作用：点击同一个链接时，每次该路由下的 location.key都会改变，可以通过 key 的变化来刷新页面。 六 HashRouter 返回目录 使用 URL 的 hash 部分（即 window.location.hash ）的 使 UI 与 URL 保持同步。 重要提示：Hash 历史记录不支持 location.key 或 location.state。 import { HashRouter } from 'react-router-dom' 6.1 HashRouter - basename 返回目录 规则：basename: string 所有位置的基本 URL，格式正确的基本名应该有一个前导斜线，但结尾不能有斜线。 {/* 渲染为 */} 6.2 HashRouter - getUserConfirmation 返回目录 规则：getUserConfirmation: func 用于确认导航的功能。默认使用 window.confirm。 // this is the default behavior const getConfirmation = (message, callback) => { const allowTransition = window.confirm(message) callback(allowTransition) } 6.3 HashRouter - hashType 返回目录 规则：hashType: string 用于 window.location.hash 的编码类型。可用的值是： slash - 创建 #/ 和的 #/sunshine/lollipops noslash - 创建 # 和的 #sunshine/lollipops hashbang - 创建 ajax crawlable，如 #!/ 和 #!/sunshine/lollipops 默认为 slash。 七 Link 返回目录 在应用程序周围提供声明式的,可访问的导航。 7.1 Link - to 返回目录 规则 1：to: string 链接位置的字符串表示，通过连接位置的路径名，搜索和 hash 属性创建。 字符串形式跳转 规则 2：to: object 一个可以具有以下任何属性的对象： pathname: 表示要链接到的路径的字符串。 search: 表示查询参数的字符串形式。 hash: 放入网址的 hash，例如 #a-hash。 state: 状态持续到 location。 对象形式跳转 7.2 Link - replace 返回目录 规则：replace: bool 如果为 true，则单击链接将替换历史堆栈中的当前入口，而不是添加新入口。 替换当前 hash 路径 7.3 Link - other 返回目录 还可以传递想要放在 上的属性，例如标题，ID、className 等。 测试 1 返回目录 八 NavLink 返回目录 一个特殊版本的 Link，当它与当前 URL 匹配时，为其渲染元素添加样式属性。 高亮显示首页：首页 8.1 NavLink - activeClassName 返回目录 规则：activeClassName: string 要给出的元素的类处于活动状态时。默认的给定类是 active。它将与 className 属性一起使用。 FAQs 8.2 NavLink - activeStyle 返回目录 规则：activeStyle: object 当元素处于 active 时应用于元素的样式。 FAQs 8.3 NavLink - exact 返回目录 规则：exact: bool 如果为 true，则仅在位置完全匹配时才应用 active 的类/样式。 Profile 8.4 NavLink - isActive 返回目录 规则：isActive: function 一个为了确定链接是否处于活动状态而添加额外逻辑的函数，如果你想做的不仅仅是验证链接的路径名与当前 URL 的 pathname 是否匹配，那么应该使用它 // 如果链接不仅仅匹配 events/123，而是所有奇数链接都匹配 const oddEvent = (match, location) => { if (!match) { return false } const eventID = parseInt(match.params.eventID) return !isNaN(eventID) && eventID % 2 === 1 } Event 123 九 MemoryRouter 返回目录 能在内存中保存 URL 的历史记录(并不会对地址栏进行读写)。很适合在测试环境和非浏览器环境中使用，例如 React Native。 9.1 MemoryRouter - initialEntries 返回目录 规则：initialEntries: array history 栈中的一个 location 数组。这些可能是具有 { pathname, search, hash, state } 或简单的 URL 字符串的完整地址对象。 9.2 MemoryRouter - initialIndex 返回目录 规则：initialIndex: number 在 initialEntries 数组中的初始化地址索引。 9.3 MemoryRouter - getUserConfirmation 返回目录 规则：getUserConfirmation: function 用于确认导航的函数。在使用 时，直接使用 ，你必须使用这个选项。 9.4 MemoryRouter - keyLength 返回目录 规则：keyLength: number location.key的长度。默认为 6。 十 Redirect 返回目录 渲染 将使导航到一个新的地址。这个新的地址会覆盖 history 栈中的当前地址，类似服务器端（HTTP 3xx）的重定向。 我们可以设置某个路由重定向到另一个路由，例如下面即对 / 完全匹配重定向到 /timeline 页面。 10.1 Redirect - from 返回目录 规则：from: string 重定向 from 的路径名。可以是任何 path-to-regexp 能够识别的有效的 URL 路径。 所有匹配的 URL 参数都提供给 to 中的模式。 必须包含在 to 中使用的所有参数。 to 未使用的其他参数将被忽略。 10.2 Redirect - to 返回目录 规则：to: string 重定向到的 URL，可以是任何 path-to-regexp 能够理解有效 URL 路径。 在 to 中使用的 URL 参数必须由 from 覆盖。 规则：to: object 重定向到的 location，pathname 可以是任何 path-to-regexp 能够理解的有效的 URL 路径。 10.3 Redirect - push 返回目录 规则：push: bool 当 true 时，重定向会将新地址推入 history 中，而不是替换当前地址。 10.4 Redirect - exact 返回目录 规则：exact: bool 完全匹配 from。 十一 Route 返回目录 只要应用程序位置与 Route 的路径匹配，组件就会被渲染。 11.1 Route - component 返回目录 只有当位置匹配时才会渲染的 React 组件。 const User = ({ match }) => { return Hello {match.params.username}! } 11.2 Route - render 返回目录 规则：render: function 这允许方便的内联渲染和包裹，而不是上面那种不想要的重新安装的解释 可以传递一个在位置匹配时调用的函数，而不是使用属性为您创建新的 React element component，该 render 属性接收所有相同的 route props 的 component 渲染属性。 // 行内编写 Home}/> // 包裹分开写 const FadingRoute = ({ component: Component, ...rest }) => ( ( )}/> ) 11.3 Route - children 返回目录 规则：children: function 有时你需要渲染路径是否匹配位置。在这些情况下，您可以使用函数 children 属性，它的工作原理与渲染完全一样，不同之处在于它是否存在匹配。 children 渲染道具接收所有相同的 route props 作为 component 和 render 方法，如果 Route 与 URL 不匹配，match 则为 null ，这允许你动态调整你的 UI 界面，基于路线是否匹配，如果路线匹配我们则添加一个 active 类。 const ListItemLink = ({ to, ...rest }) => ( ( )}/> ) 11.4 Route - path 返回目录 规则：path: string 任何 path-to-regexp 可以解析的有效的 URL 路径 11.5 Route - exact 返回目录 规则：exact: bool 如果为 true，则只有在路径完全匹配 location.pathname 时才匹配。 path location.pathname exact matches? /one /one/two true no /one /one/two false yes jsliang 个人经验： 加了 exact 属性后，会完全匹配路径；如果没有加，则二级路径也会匹配当前路径（例如 /timeline/book）。 我们可以动态设置 extra 的值，从而判断是否需要加载某个组件。 const Home = () => Home; const App = () => { const someVariable = true; return ( {/* these are good */} } /> {/* do not do this */} } /> ); }; 11.6 Route - location 返回目录 规则：location: object 一个 元素尝试其匹配 path 到当前的历史位置（通常是当前浏览器 URL）。但是，也可以通过location 一个不同 pathname 的匹配。 11.7 Route - sensitive 返回目录 规则：sensitive: bool 如果路径区分大小写，则为 true，则匹配。 path location.pathname sensitive matches? /one /one true yes /One /one true no /One /one false yes 十二 Switch 返回目录 渲染与该地址匹配的第一个子节点 或者 。 可以利用 做分组，即当有匹配时，匹配对应 path 对应的组件；如果没有匹配，则匹配 NotFound 页面。 十三 篇外一：history 返回目录 history 是一个包，在你安装 React Router 的时候，会作为它依赖包安装到项目中，所以你可以直接使用 history 中的属性和方法： length - (number 类型) history 堆栈的条目数 action - (string 类型) 当前的操作(push, replace, pop) location - (object 类型) 当前的位置。location 会具有以下属性： pathname - (string 类型) URL 路径 search - (string 类型) URL 中的查询字符串 hash - (string 类型) URL 的哈希片段 state - (object 类型) 提供给例如使用 push(path, state) 操作将 location 放入堆栈时的特定 location 状态。只在浏览器和内存历史中可用 push(path, [state]) - (function 类型) 在 history 堆栈添加一个新条目 replace(path, [state]) - (function 类型) 替换在 history 堆栈中的当前条目 go(n) - (function 类型) 将 history 堆栈中的指针调整 n goBack() - (function 类型) 等同于 go(-1) goForward() - (function 类型) 等同于 go(1) block(prompt) - (function 类型) 阻止跳转 十四 篇外二：Code Splitting 返回目录 随着应用的增长，代码包会随着生长。 到最后你会发现，你打包后的 js 文件大地太多离谱。 所以，我们需要通过代码分割，依据不同的路由，加载不同的 js 文件。 安装 React Loadable：npm i react-loadable -S 结合 React Router 和 React Loadable 进行 Code Spliting： import { BrowserRouter as Router, Route, Switch } from 'react-router-dom'; import Loadable from 'react-loadable'; const Loading = () => Loading...; const Home = Loadable({ loader: () => import('./routes/Home'), loading: Loading, }); const About = Loadable({ loader: () => import('./routes/About'), loading: Loading, }); const App = () => ( ); 打包项目： npm run build 十五 篇外三：Scroll To Top 返回目录 15.1 跳转页面后滚动到顶部 返回目录 首先，在全局 components 文件中定义 ScrollToTop 文件夹，其中 index.js 内容为： src/components/ScrollToTop/index.js import { Component } from 'react'; import { withRouter } from 'react-router-dom'; class ScrollToTop extends Component { componentDidUpdate(prevProps) { if (this.props.location !== prevProps.location) { window.scrollTo(0, 0) } } render() { return this.props.children } } export default withRouter(ScrollToTop); 然后，在 App.js 或者其他页面中使用 ScrollToTop 功能： src/App.js import React, { Fragment } from 'react'; import { BrowserRouter, Route, Switch, Redirect } from 'react-router-dom'; import ScrollToTop from './components/ScrollToTop'; import Header from './components/Header'; import TimeLine from './pages/TimeLine'; import NotFound from './pages/404'; function App() { return ( ); } export default App; 最后，我们切换路由的时候，页面就会滚动到顶部。 15.2 页面滚动到顶部 返回目录 暂未实现 十六 篇外四：Redux 返回目录 在项目中，我们更希望 React Router 和 React Redux 合并起来，这时候可以： // before export default connect(mapStateToProps)(Something) // after import { withRouter } from 'react-router-dom' export default withRouter(connect(mapStateToProps)(Something)) 参考文献：Redux Integration 十七 总结 返回目录 如果你纯粹过文档（官方文档，jsliang 的文档），你会觉得毫无趣味、了无生趣、乏味、沉闷…… 所以，jsliang 的学法是：开启了一个项目，边翻阅文档，边应用到项目中，并进行 Mark 标记，以便下次使用。 如此，该文档虽然完结了，但是仍未完结！完结的是我过完了官方文档，未完结的是 React Router 在我项目中可能有其他应用，需要我一一添加进来。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:07:50 "},"JavaScript-library/React/ReactDemoOne-TodoList.html":{"url":"JavaScript-library/React/ReactDemoOne-TodoList.html","title":"✔ React Demo One - TodoList","keywords":"","body":"React Demo One - TodoList Create by jsliang on 2019-3-18 08:37:10Recently revised in 2019-05-20 17:50:01 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文  3.1 新建 React 项目  3.2 项目目录解析  3.3 精简项目结构  3.4 初探组件  3.5 JSX  3.6 事件及双向数据绑定  3.7 优化-抽取 CSS  3.8 优化-抽取 JS 四 总结 五 参考文献 二 前言 返回目录 关于 React，jsliang 从 2018-9-5 就开始折腾了，中途因为工作调动，没能继续折腾下去。最近因为新公司工作需求，从头开始继续折腾 React，希望我的文章能对没学过 React 或者初入 React 的小伙伴有所帮助。 本文参考来自慕课网： 《React 16.4 开发简书项目从零基础入门到实战》 其中掺杂个人对编程的理解，如有错误，望多多指正。 前置知识： ES5/ES6 Webpack npm 文章结构： 基础内容 -> 环境搭建 -> 基础语法 -> 原理进阶 -> 动画 Redux -> Redux 进阶 实战项目 -> 环境搭建 -> Header -> 首页 -> 详情页 登录校验 -> 上线 涉及知识点： create-react-app 组件化思维 JSX 开发调试工具 虚拟 DOM 生命周期 React-transition-group Redux Antd UI、容器组件 无状态组件 redux-thunk redux-saga styled-components immutable.js redux-immutable axios 其中，本文为第一个 Demo 案例：通过编写一个简单的 TodoList 小 Demo，熟悉 React 的开发流程。 三 正文 返回目录 Now，开始搞事情。 3.1 新建 React 项目 返回目录 下载 Node.js 安装 React 脚手架： npm i create-react-app -g 开启新项目： create-react-app todolist cd todolist npm start 打开 localhost:3000 查看页面 3.2 项目目录解析 返回目录 - todolist + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - mainfest.json —— 提供 meta 信息给项目，并与 serviceWorker.js 相呼应，进行离线 APP 定义 - src ——————————————————— 项目主要目录 - App.css —— 主组件样式 - App.js —— 主组件入口 - App.test.js —— 自动化测试文件 - index.css —— 全局 css 文件 - index.js —— 所有代码的入口 - logo.svg —— 页面的动态图 - serviceWorker.js —— PWA。帮助开发手机 APP 应用，具有缓存作用 - .gitignore ———————————— 配置文件。git 上传的时候忽略哪些文件 - package-lock.json ————— 锁定安装包的版本号，保证其他人在 npm i 的时候使用一致的 node 包 - package.json —————————— node 包文件，介绍项目以及说明一些依赖包等 - README.md ————————————— 项目介绍文件 3.3 精简项目结构 返回目录 为了方便开发，下面对 creat-react-app 的初始目录进行精简： - todolist + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - src ——————————————————— 重要的目录 - App.js —— 主组件入口 - index.js —— 所有代码的入口 - .gitignore ———————————— 配置文件。git 上传的时候忽略哪些文件 - package.json —————————— node 包文件，介绍项目以及说明一些依赖包等 - README.md ————————————— 项目介绍文件 favicon.ico、.gitignore、README.md 是我们无需理会的，但是其他文件，我们需要精简下它们的代码： index.html Todolist 你需要允许在 APP 中运行 JavaScript App.js import React, { Component } from 'react'; class App extends Component { render() { return ( Hello React! ); } } export default App; index.js import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; ReactDOM.render(, document.getElementById('root')); package.json { \"name\": \"todolist\", \"version\": \"0.1.0\", \"private\": true, \"dependencies\": { \"react\": \"^16.8.4\", \"react-dom\": \"^16.8.4\", \"react-scripts\": \"2.1.8\" }, \"scripts\": { \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test\", \"eject\": \"react-scripts eject\" }, \"eslintConfig\": { \"extends\": \"react-app\" }, \"browserslist\": [ \">0.2%\", \"not dead\", \"not ie 3.4 初探组件 返回目录 类似于上图，在进行页面开发的时候，我们很容易地使用庖丁解牛的技巧，将页面进行划分，然后一部分一部分地将页面搭建出来。 给个比较官方的说法，就叫页面组件化：将页面切成几个部分，从而有利于页面的拼装以及代码的维护。 在 create-react-app 的默认配置中，App.js 就是一个组件，一起来看： App.js // 1. 引用 React 及其组件 import React, { Component } from 'react'; // 2. 定义一个叫 App 的组件继承于 Component class App extends Component { render() { return ( Hello React! ); } } // 3. 根据 React 实例，在 App 内部编写完毕后，导出这个 App 组件 export default App; 在上面，我们引用、定义并导出了这个 App 的组件，然后我们就要使用它： index.js // 1. 引入 React、ReactDOM import React from 'react'; import ReactDOM from 'react-dom'; // 2. 将 App.js 导入进来 import App from './App'; // 3. 通过 ReactDOM 将 App.js 以虚拟 DOM 的形式渲染/挂载到 root 根节点，该节点在 index.html 中 ReactDOM.render(, document.getElementById('root')); index.js 告诉我们，它会通过 ReactDom，将 App.js 这个组件挂载到 root 这个节点上，那么，这个 root 在哪里呢？我们查看下 index.html： index.html Todolist 你需要允许在 APP 中运行 JavaScript OK，很容易地我们就捋清楚思路了：我们在 index.html 中定义了个 root 根节点，然后我们通过 index.js，将 App.js 以组件形式渲染到了 index.html 中，从而实现了节点的挂载。 思维发散：我们知道 index.js 和 App.js 的最终结合是挂载到 id=\"root\" 节点上的，如果我们再开一个 index2.js 和 App2.js，挂载到 id=\"root2\" 节点上，行不行呢？亦或者我们开一个 id=\"root3\" 的节点，我们在其中操作 jQuery，是不是也可行？ 3.5 JSX 返回目录 在 create-react-app 的文件中，不管是 index.js 中的： ReactDOM.render(, document.getElementById('root')); 还是 App.js 中的： class App extends React.Component { render() { return ( Hello React! ); } } 等这些有关 DOM 的渲染，都需要用到 JSX，因此需要引入 React： import React from 'react'; JSX 的定义： 那么，什么是 JSX 呢？ React 的核心机制之一就是可以在内存中创建虚拟的 DOM 元素。React 利用虚拟 DOM 来减少对实际 DOM 的操作从而提升性能。 JSX 就是 JavaScript 和 XML 结合的一种格式。 React 发明了 JSX，利用 HTML 语法来创建虚拟 DOM。当遇到 ，JSX 就当 HTML 解析，遇到 { 就当 JavaScript 解析。 JSX 的使用： 在 JSX 语法中，如果我们需要使用自己创建的组件，我们直接使用它的定义名即可，例如： index.js // 1. 引入 React、ReactDOM import React from 'react'; import ReactDOM from 'react-dom'; // 2. 将 App.js 导入进来 import App from './App'; // 3. 通过 ReactDOM 将 App.js 以虚拟 DOM 的形式渲染/挂载到 root 根节点，该节点在 index.html 中 ReactDOM.render(, document.getElementById('root')); 其中第三点即是自定义组件渲染到根节点。 提示：在 React 中，如果需要使用自定义组件，那么该组件不能小写开头 app，而是使用 App 这样的大写开头形式。 3.6 事件及双向数据绑定 返回目录 这是我们精简后的目录结构： 我们修改下目录结构，开始编写 TodoList： 首先，我们修改 App.js 为 TodoList.js： App.js TodoList.js import React, { Component } from 'react'; class TodoList extends Component { render() { return ( Hello React! ); } } export default TodoList; 然后，我们修改 index.js 中挂载到 index.html 的组件为 TodoList： index.js import React from 'react'; import ReactDOM from 'react-dom'; import TodoList from './TodoList'; // 3. 通过 ReactDOM 将 App.js 以虚拟 DOM 的形式渲染/挂载到 root 根节点，该节点在 index.html 中 ReactDOM.render(, document.getElementById('root')); 修改完毕，小伙伴们可以重启下 3000 端口，查看下我们的 React 是否能正常启动。 在此步骤中，我们仅仅修改 App.js 为 TodoList.js，使 index.js 挂载到 root 的是 TodoList.js，除此之外没进行其他操作。 最后，如果没有问题，那么我们进一步编写 TodoList，获取到 input 输入框的值，并渲染到列表中： TodoList.js // Fragment 是一种占位符形式，类似于 Vue 的 Template import React, { Component, Fragment } from 'react'; class TodoList extends Component { constructor(props) { super(props); this.state = { inputValue: '', list: [] } } render() { return ( {/* 单项数据绑定 */} 提交 吃饭 X 睡觉 X 打豆豆 X ) } handleInputChange(e) { console.log(e.target.value); this.setState({ inputValue: e.target.value }) } } export default TodoList; 我们先查看演示： OK，这样我们在每输入一个字符的时候，我们就能立刻获取到对应的数据，这时候实现了单向数据流：输入框 -> JS 内存。 其中有 3 点需要讲解下： Fragment 是 React 提供的一种占位符，它像 、 等标签一样，但是它在实际渲染的时候是不会出现的。因为 React 的 JSX 首层必须要有标签，然后如果使用 等会占用一个层级，所以，类似于 Vue 的 Template，React 使用了 Fragment 这种空标签。 constructor 表示父类的构造方法，在 ES6 中，构造方法 constructor 相当于其构造函数，用来新建父类的 this 对象，而 super(props) 则是用来修正 this 指向的。简而言之，我们可以在这里定义数据，并在整个 js 文件中使用。 onChange 这种写法，是 React 指定的写法，例如 onClick 等，在原生 JS 中，使用的是 onclick，而在 React 中，为了区别，需要进行半驼峰编写事件名字。同时，绑定的 handleInputChange，可以直接在 render 下面进行编写。 参考文献：《react 中 constructor() 和 super() 到底是个啥？》 这样，我们就对 React 的数据及事件有了初步理解，下面我们加下按钮点击新增列表事件以及点击 X 删除列表事件。 TodoList.js // Fragment 是一种占位符形式，类似于 Vue 的 Template import React, { Component, Fragment } from 'react'; class TodoList extends Component { // 构造函数 constructor(props) { super(props); // 定义数据 this.state = { inputValue: '', list: [] } } // 渲染页面 render() { let closeStyle = { fontSize: '1.2em', color: 'deepskyblue', marginLeft: '10px' } return ( {/* 单项数据绑定 */} {/* 在 React 中，绑定时间的，一般为半驼峰形式 */} 提交 { this.state.list.map( (item, index) => { return {index}. {item} X }) } ) } // 方法体 - 输入内容 handleInputChange(e) { this.setState({ inputValue: e.target.value }) } // 方法体 - 点击提交 handleBtnClick() { this.setState({ list: [...this.state.list, this.state.inputValue], inputValue: '' }) } // 方法体 - 删除项目 handleItemDelete(index) { const list = [...this.state.list]; list.splice(index, 1); this.setState({ list: list }) } } export default TodoList; 在这一部分，我们需要了解 3 个知识点： 在 render 中 closeStyle 这个变量，我们用来定义 CSS 属性，然后我们通过 style={closeStyle}，直接写了个行内样式（下面我们会抽离出来） 关于 JSX 遍历输出的形式： { this.state.list.map( (item, index) => { return {index}. {item} X }) } 我们通过 {} 里面循环输出 DOM 节点。如果你学过 jQuery，那么可以将它当为拼接字符串；如果你学过 Vue，那么可以将它当成 v-for 变了种写法。 在这里我们不用理会为什么这么写，我们先接受这种写法先。 关于改变 constructor 中的数据，我们使用： this.setState({ list: list }) 这种形式。其实，这也是有记忆技巧的，要知道我们在定义数据的时候，使用了： // 定义数据 this.state = { inputValue: '', list: [] } 即： this.state，那么我们需要修改数据，那就是 this.setState 了。 至此，我们的简易 TodoList 就实现了，下面我们进一步优化，将 CSS 和 JS 进一步抽取。 3.7 优化-抽取 CSS 返回目录 在上面中，我们提到 closeStyle 是一种行内的写法，作为一枚 完美编程者，我们肯定不能容忍，下面我们开始抽离： TodoList.js import React, { Component, Fragment } from 'react'; import './style.css' // ... 省略中间代码 { this.state.list.map( (item, index) => { return {index}. {item} X }) } 在这里，我们需要知道：我们可以通过 import 的形式，直接将 CSS 文件直接导入，然后，我们命名 class 的时候，因为 React 怕 JS 的 class 与 HTML 的 class 冲突，所以我们需要使用 className。 最后我们再编写下 CSS 文件： .icon-close { font-size: 1.2em; color: deepskyblue; margin-left: 10px; } 如此，我们就实现了 CSS 的抽取。 3.8 优化-抽取 JS 返回目录 在第 4 章关于组件的介绍中，我们讲到：一些复杂的 JS 是可以抽取出来，并以组件的形式，嵌入到需要放置的位置的。 那么，我们在 JSX 越写越多的情况下，是不是可以将列表渲染那部分抽取出来，从而精简下 JSX 呢？ 答案是可以的，下面我们看下实现： TodoList.js // Fragment 是一种占位符形式，类似于 Vue 的 Template import React, { Component, Fragment } from 'react'; // 引入组件 import TodoItem from './TodoItem'; // 引用样式 import './style.css'; class TodoList extends Component { // 构造函数 constructor(props) { super(props); // 定义数据 this.state = { inputValue: '', list: [] } this.handleInputChange = this.handleInputChange.bind(this); this.handleBtnClick = this.handleBtnClick.bind(this); this.handleItemDelete = this.handleItemDelete.bind(this); } // 渲染页面 render() { return ( 输入内容： {/* 单项数据绑定 */} {/* 在 React 中，绑定时间的，一般为半驼峰形式 */} 提交 {/* 精简 JSX，将部分抽取出来 */} { this.getTodoItem() } ) } // 获取单独项 getTodoItem() { return this.state.list.map( (item, index) => { return ( ) }) } // 方法体 - 输入内容 handleInputChange(e) { const value = e.target.value; this.setState( () => ({ inputValue: value })) } // 方法体 - 点击提交 handleBtnClick() { const list = this.state.list, inputValue = this.state.inputValue; this.setState( () => ({ list: [...list, inputValue], inputValue: '' })) } // 方法体 - 删除项目 handleItemDelete(index) { // immutable - state 不允许做任何改变 const list = [...this.state.list]; list.splice(index, 1); this.setState( () => ({ list: list })) } } export default TodoList; 我们关注下 TodoList.js 的改变： 我们在 constructor 中，将方法进行了提前定义： this.handleInputChange = this.handleInputChange.bind(this); 这样，我们在下面就不用写 .bind(this) 形式了。 我们修改了下 this.setState() 的形式： 原写法： this.setState({ list: list }) 现写法： this.setState( () => ({ list: list })) 因为 React 16 版本进行了更新，使用这种写法比之前的好，至于好在哪，咱先不关心，以后就用这种写法了。 我们引用了组件： import TodoItem from './TodoItem'; 并且将组件放到方法体：this.getTodoItem() 中，而 this.getTodoItem() 的定义是： // 获取单独项 getTodoItem() { return this.state.list.map( (item, index) => { return ( ) }) } 在这里我们可以看到，我们通过自定义值的形式，将数据 key、item、index 传递给了子组件 TodoItem。同时，通过 handleItemDelete，将自己的方法传递给了子组件，这样子组件就可以调用父组件的方法了： TodoItem.js import React, { Component } from 'react' class TodoItem extends Component { constructor(props) { super(props); // 这种写法可以节省性能 this.handleClick = this.handleClick.bind(this); } render() { const { item } = this.props; return ( {item} X ) } handleClick() { const { handleItemDelete, index } = this.props; handleItemDelete(index); } } export default TodoItem; 这样，我们就完成了组件的抽取，并学会了 父组件传递值给子组件 子组件调用父组件的方法 由此，我们在接下来就可以编写更丰富健全的项目了。 本文代码地址：React 系列源码地址 四 总结 返回目录 在我们学习任意一门语言中，大多就是上手 “Hello World！” 编程~ 然后做小案例的时候，我们都喜欢来个 TodoList，因为它能讲清楚一些有关基础的知识点。 现在，我们回顾下，我们开发 React 的 TodoList 有啥收获： create-react-app 的安装及开发。 组件化的思想及在 create-react-app 中关于组件化的应用。 React 关于数据 data 以及方法 methods 的定义及使用，以及如何进行数据双向绑定。 将大的组件拆分成小组件，并实现父子组件通讯（父组件传递参数给子组件，子组件调用父组件的方法） 至此，jsliang 就精通 jQuery、Vue、React 编写 TodoList 了，哈哈！ 五 参考文献 返回目录 《React.Component 与 React.PureComponent（React之性能优化）》 《visual studio code + react 开发环境搭建》 《react 中 constructor() 和 super() 到底是个啥？》 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:50:01 "},"JavaScript-library/React/ReactDemoTwo-TodoListUpgrade.html":{"url":"JavaScript-library/React/ReactDemoTwo-TodoListUpgrade.html","title":"✔ React Demo Two - TodoList 升级","keywords":"","body":"React Demo Two - TodoList 升级 create by jsliang on 2019-3-26 09:26:53Recently revised in 2019-4-7 03:04:02 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 初始化项目 四 使用 Ant Design 五 使用 Redux 六 Redux 探索  6.1 Redux 插件  6.2 Redux 知识点讲解 七 Redux 探索  7.1 Input 输入数据  7.2 Button 提交数据  7.3 删除 TodoItem 列表项 八 优化：抽取 ActionType 九 优化：抽取整个 action 十 优化：UI 组件和容器组件 十一 优化：无状态组件 十二 结尾：调用 Axios，Redux-Base 完成 十三 进阶：Redux 中间件 十四 进阶：Redux-Thunk 中间件进行 ajax 请求管理 十五 进阶：Redux-Saga 中间件进行 Ajax 请求管理 十六 进阶：React-Redux 十七 总结 二 前言 返回目录 声明：该系列文章主要参考慕课网的 React 实战视频，并结合个人理解进行编写： 《React 16.4 开发简书项目从零基础入门到实战》 本次 Demo 基于 ReactDemoOne 进行了 Redux 的升级，同时会讲解到中间件 Redux-Thunk 以及 Redux-Saga，最终会使用 React-Redux 进行项目重构。 所以，没有看第一篇的小伙伴可以查看： React Demo One - TodoList 如果小伙伴想对照这源码一起看文章，可以前往下面地址下载： React 系列源码地址 注意，本文代码在 TodoListUpgrade 目录，并且它四个文件夹，分别对应： Redux-Base —— 记录 Redux 基础内容 Redux-Thunk —— 在 Redux-Base 基础上进行 redux-thunk 的中间件配置 Redux-Saga —— 在 Redux-Base 基础上进行 redux-saga 的中间件配置 React-Redux —— 对 TodoList 进行 react-redux 重新改造 Redux-Base 项目最终目录如下，小伙伴可以先创建空文件放着，后续将使用到： 三 初始化项目 返回目录 获取 React 系列 中 Simpify 目录中的代码，将其 Copy 到 Redux-Base 中，并将 App 修改为 TodoList，进行 TodoList 小改造。 下面我们开始修改： src/index.js 代码详情 ```js import React from 'react'; import ReactDOM from 'react-dom'; import TodoList from './TodoList'; ReactDOM.render(, document.getElementById('root')); ``` src/App.js TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; class TodoList extends Component { render() { return ( Hello TodoList! ); } } export default TodoList; ``` src/index.css 代码详情 ```css /* 尚未进行编写 */ ``` 此时我们在终端运行 npm run start，显示结果为： 四 使用 Ant Design 返回目录 Ant Design 官网：https://ant.design/index-cn 下面开始在 TodoList 项目中使用 Ant Design： 安装：npm i antd -S 使用： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; // 引入 React 及其 Component import './index.css'; // 引入 index.css import { Input, Button, List } from 'antd'; // 1. 引入 antd 的列表 import 'antd/dist/antd.css'; // 2. 引入 antd 的样式 // 3. 定义数据 const data = [ '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ]; class TodoList extends Component { render() { return ( TodoList {/* 4. 使用 Input、Button 组件 */} 提交 {/* 5. 使用 List 组件 */} ({index + 1} - {item})} /> ); } } export default TodoList; ``` src/index.css 代码详情 ```css .todo { width: 1000px; margin: 20px auto 0; padding: 30px; border: 1px solid #ccc; border-radius: 10px; } .todo-title { text-align: center; } .todo-action .todo-input { width: 200px; } .todo-action .todo-submit { margin-left: 10px; } .todo-list { margin-top: 30px; } ``` 在这里，我们引用 Ant Design 的步骤大致为： 引入 antd 的 Input、Button、List 组件 引入 antd 的样式 定义数据 使用 Input、Button 组件 使用 List 组件 此时页面显示为： 五 使用 Redux 返回目录 我觉得有必要在讲解 Redux 之前，我们先使用 Redux 体验一下： 安装 Redux：npm i redux -S 下面我们按照 Redux 的使用方法先试试： 在 src 目录下创建 store 目录用来存储 Redux 数据，该目录下有 reducer.js 以及 index.js 两个文件 首先，我们编写 reducer.js 文件，该文件的作用是定义并处理数据： src/store/reducer.js 代码详情 ```js // 1. 我们定义一个数据 defaultState const defaultState = { inputValue: '', todoList: [ '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ] } // 2. 我们将数据 defaultState 最终以 state 形式导出去 export default (state = defaultState, action) => { return state; } ``` 然后，我们编写 index.js 文件，该文件的作用是通过 createStore 方法创建数据仓库并导出去给 TodoList.js 使用。 src/store/index.js 代码详情 ```js import { createStore } from 'redux'; // 3. 我们引用 redux 这个库中的 createStore import reducer from './reducer'; // 4. 我们引用 reducer.js 中导出的数据 // 5. 我们通过 redux 提供的方法 reducer 来构建一个数据存储仓库 const store = createStore(reducer); // 6. 我们将 store 导出去 export default store; ``` 最后，我们在 TodoList.js 中引用 store/index.js 并到列表中进行使用，以及打印出来 store 传递给我们的数据： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; // 引入 React 及其 Component import './index.css'; // 引入 index.css import { Input, Button, List } from 'antd'; // 引入 antd 的组件 import 'antd/dist/antd.css'; // 引入 antd 的样式 import store from './store'; // 7. 引入 store，你可以理解为 store 提供数据。./store 是 ./store/index.js 的缩写 class TodoList extends Component { // 8. 在 constructor 中通过 store.getState() 方法来获取数据，并赋值为 state constructor(props) { super(props); // 9. 我们尝试在 Console 中打印 store.getState() console.log(store.getState()); this.state = store.getState(); } render() { return ( TodoList {/* 使用 Input、Button 组件 */} 提交 {/* 使用 List 组件 */} {/* 10. 将原先的 data 换成 state 中的 todoList */} ({index + 1} - {item})} /> ); } } export default TodoList; ``` 这时候，我们查看 Chrome 控制台和页面，发现它的确起作用了： 这样我们就完成了 Redux 中数据的【查询】，那么我们如何【修改】 Redux 中的数据，以及 Redux 是什么呢？我们一一道来。 六 Redux 探索 返回目录 Redux 官网：链接 Redux 中文小册：链接 如果小伙伴觉得自己看小册或者官网理解比较通透，请自行查阅，下面观点仅供参考。 6.1 Redux 插件 返回目录 安装：科学上网找到对应的 Chrome 插件，或者百度下载一个，或者通过 npm install --save-dev redux-devtools 安装它的开发者工具。 使用： 关闭浏览器，并重新打开，再打开控制台（F12），进入 Redux 栏，提示你尚未安装代码 前往 index.js 安装代码。 查看 state 中发现存有数据，此时 Redux 插件安装完毕。 src/store/index.js 代码详情 ```js import { createStore } from 'redux'; import reducer from './reducer'; // 如果安装了 Redux 工具，则在这里可以直接使用该工具 const store = createStore( reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__() ); export default store; ``` 6.2 Redux 知识点讲解 返回目录 由于 React 关于自身的定义：“用于构建用户界面的 JavaScript 库”。 所以，当我们在 React 中，如果兄弟组件需要通讯，例如上图中左侧的深色圆圈发送数据到顶部（第一排）的圆圈，我们就需要兜很多弯子，导致数据通讯非常麻烦。 而 Redux 的出现，是为了弥补这种麻烦的通讯方式：建立起一个中央机制，方便各组件之间的通讯。从而就有了上图中右侧的调度方式。 那么，Redux 是怎么个运行/工作机制呢？我们通过下面图片进行分析： 在上面图中，我们假设： 蓝色（React Component）：借书人 黄色（Action Creators）：借书动作 橙色（Store）：图书管理员 紫色（Reducers）：系统 它的流程可以理解为：首先借书人走到前台（借书动作）跟图书管理员申请借书，图书管理员帮它在系统中查找书籍资料，然后拿到电脑返回信息，最后告诉他去哪借/怎么使用。 换回正常话，即：当组件（React Components）需要调用数据的时候，它就向创造器（Action Creators）发起请求，创造器通知管理者（Store），管理者就去查找相关资料（Reducers），拿到返回的信息后，再告诉组件。 而在这过程中，我们会使用到 Redux 的一些常用/核心 API： createStore：创建 store store.dispatch：派发 action store.getState：获取 store 所有数据内容 store.subscribe：监控 store 改变，store 改变了该方法就会被执行 下面我们通过 Input 输入数据、Button 提交数据以及删除 TodoItem 列表项进一步讲解上面知识点。 七 Redux 数据修改 返回目录 现在开始通过 Input 输入数据、Button 提交数据以及删除 TodoItem 列表项讲解 Redux 数据修改。 7.1 Input 输入数据 返回目录 src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; // 引入 React 及其 Component import './index.css'; // 引入 index.css import { Input, Button, List } from 'antd'; // 引入 antd 的组件 import 'antd/dist/antd.css'; // 引入 antd 的样式 import store from './store'; // 引入 store，你可以理解为 store 提供数据。./store 是 ./store/index.js 的缩写 class TodoList extends Component { // 在 constructor 中通过 store.getState() 方法来获取数据，并赋值为 state constructor(props) { super(props); // 我们尝试在 Console 中打印 store.getState() // console.log(store.getState()); this.state = store.getState(); // 2. 定义 handleInputChange this.handleInputChange = this.handleInputChange.bind(this); // 7. 绑定方法 handleStoreChange 来处理 Redux 返回回来的数据 this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); } render() { return ( TodoList {/* 使用 Input、Button 组件 */} {/* 1. Input 绑定 handleInputChange 事件 */} 提交 {/* 使用 List 组件 */} {/* 将原先的 data 换成 state 中的 todoList */} ({index + 1} - {item})} /> ); } // 3. 编写 handleInputChange handleInputChange(e) { // 4. 通过 action，将数据传递给 store const action = { type: 'change_input_value', value: e.target.value } store.dispatch(action); } // 8. 在 handleStoreChange 中处理数据 handleStoreChange() { this.setState(store.getState()); } } export default TodoList; ``` src/store/reducer.js 代码详情 ```js // 定义一个数据 defaultState const defaultState = { inputValue: '', todoList: [ // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ] } // 将数据 defaultState 最终以 state 形式导出去 export default (state = defaultState, action) => { // 5. 打印 state 和 action console.log(state); console.log(action); // 6. 在 reducer.js 中获取数据，并 return 回去处理结果 if(action.type === 'change_input_value') { const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState } return state; } ``` 此时，我们打开控制台，一边在 Input 输入框输入内容，一边查看 Console 输出，会发现： 现在我们来分析下（或者小伙伴看着代码的备注理解下），我们修改代码的时候做了什么： 在 Input 组件中，我们为其 onChange 时绑定 handleInputChange 事件。 定义 handleInputChange 方法。 编写 handleInputChange 方法。 我们在 handleInputChange 中编写 action，通过 dispatch 将 action 从 TodoList.js 传递给 Redux 中的 reducer.js。 在 reducer.js 中打印 state 和 action。 Redux 在 reducer.js 中接收到 state 和 action，然后我们将新的 newState 返回回去（先返回到 src/store/index.js，再返回到 src/TodoList.js），期望 TodoList.js 能接受到反馈。 在 TodoList 的 constructor 中通过 store.subscribe 绑定处理 Redux 传回来的数据的处理方法 handleStoreChange。 在 handleStoreChange 中，我们直接 setState Redux 返回的 state，即 store.getState()。 这时候，我们再查看章节 6.2 的 Redux 知识点讲解，就会发现知识点通畅了。 前往：6.2 Redux 知识点讲解 参考：计数器 代码详情 ```js import { createStore } from 'redux'; /** * 这是一个 reducer，形式为 (state, action) => state 的纯函数。 * 描述了 action 如何把 state 转变成下一个 state。 * * state 的形式取决于你，可以是基本类型、数组、对象、 * 甚至是 Immutable.js 生成的数据结构。惟一的要点是 * 当 state 变化时需要返回全新的对象，而不是修改传入的参数。 * * 下面例子使用 `switch` 语句和字符串来做判断，但你可以写帮助类(helper) * 根据不同的约定（如方法映射）来判断，只要适用你的项目即可。 */ function counter(state = 0, action) { switch (action.type) { case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; } } // 创建 Redux store 来存放应用的状态。 // API 是 { subscribe, dispatch, getState }。 let store = createStore(counter); // 可以手动订阅更新，也可以事件绑定到视图层。 store.subscribe(() => console.log(store.getState()) ); // 改变内部 state 惟一方法是 dispatch 一个 action。 // action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行 store.dispatch({ type: 'INCREMENT' }); // 1 store.dispatch({ type: 'INCREMENT' }); // 2 store.dispatch({ type: 'DECREMENT' }); // 1 ``` 7.2 Button 提交数据 返回目录 下面，我们为 Input 提供回车事件，以及使用 Button 的提交事件，小伙伴们可以参照 Input 的输入事件，先自行编写，写完再查看这个章节收获会更大。 src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; // 引入 React 及其 Component import './index.css'; // 引入 index.css import { Input, Button, List } from 'antd'; // 引入 antd 的组件 import 'antd/dist/antd.css'; // 引入 antd 的样式 import store from './store'; // 引入 store，你可以理解为 store 提供数据。./store 是 ./store/index.js 的缩写 class TodoList extends Component { // 在 constructor 中通过 store.getState() 方法来获取数据，并赋值为 state constructor(props) { super(props); // 我们尝试在 Console 中打印 store.getState() // console.log(store.getState()); this.state = store.getState(); // 处理 handleInputChange 方法 this.handleInputChange = this.handleInputChange.bind(this); // 绑定方法 handleStoreChange 来处理 Redux 返回回来的数据 this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); // 2. 处理 handleAddItem 方法 this.handleAddItem = this.handleAddItem.bind(this); // 7. 处理 handleInputKeyUp 方法 this.handleInputKeyUp = this.handleInputKeyUp.bind(this); } render() { return ( TodoList {/* 使用 Input、Button 组件 */} {/* Input 绑定 handleInputChange 事件 */} {/* 6. Input 绑定回车事件：handleInputKeyUp */} {/* 1. 为 Button 定义点击执行 handleAddItem 方法 */} 提交 {/* 使用 List 组件 */} {/* 将原先的 data 换成 state 中的 todoList */} ({index + 1} - {item})} /> ); } // 编写 handleInputChange 方法 handleInputChange(e) { // 通过 dispatch(action)，将数据传递给 store const action = { type: 'change_input_value', value: e.target.value } store.dispatch(action); } // 在 handleStoreChange 中处理数据 handleStoreChange() { this.setState(store.getState()); } // 3. 编写 handleAddItem 方法 handleAddItem() { // 4. 通过 dispatch(action)，将数据传递给 store const action = { type: 'add_todo_item' } store.dispatch(action); } // 8. 为 Input 的 keyUp 方法 handleInputKeyUp 绑定 handleAddItem handleInputKeyUp(e) { if(e.keyCode === 13) { this.handleAddItem(); } } } export default TodoList; ``` src/store/reducer.js 代码详情 ```js // 定义一个数据 defaultState const defaultState = { inputValue: '', todoList: [ // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ] } // 将数据 defaultState 最终以 state 形式导出去 export default (state = defaultState, action) => { // 打印 state 和 action // console.log(state); // console.log(action); // 在 reducer.js 中获取数据，并 return 回去处理结果 if(action.type === 'change_input_value') { const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; } // 5. 在 reducer.js 中获取数据，并 return 回去处理结果 if(action.type === 'add_todo_item') { const newState = JSON.parse(JSON.stringify(state)); newState.todoList.push(newState.inputValue); newState.inputValue = ''; return newState; } return state; } ``` 这时候，我们的 Button 提交事件都处理完毕了，此时页面的功能实现： OK，我们再来梳理一遍流程： 为 Button 定义点击执行 handleAddItem 方法 处理 handleAddItem 方法 编写 handleAddItem 方法 通过 dispatch(action)，将数据传递给 store 在 reducer.js 中获取数据，并 return 回去处理结果 Input 绑定回车事件：handleInputKeyUp 处理 handleInputKeyUp 方法 为 Input 的 keyUp 方法 handleInputKeyUp 绑定 handleAddItem 值得注意的是，我们在 Input 的时候，就做过 handleStoreChange 的处理，所以我们就没有再写 store.subscribe() 来监控数据的改变，所以小伙伴们要注意整体流程。 7.3 删除 TodoItem 列表项 返回目录 那么接下来，我们再给列表项点击添加删除事件。 src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; // 引入 React 及其 Component import './index.css'; // 引入 index.css import { Input, Button, List } from 'antd'; // 引入 antd 的组件 import 'antd/dist/antd.css'; // 引入 antd 的样式 import store from './store'; // 引入 store，你可以理解为 store 提供数据。./store 是 ./store/index.js 的缩写 class TodoList extends Component { // 在 constructor 中通过 store.getState() 方法来获取数据，并赋值为 state constructor(props) { super(props); // 我们尝试在 Console 中打印 store.getState() // console.log(store.getState()); this.state = store.getState(); // 处理 handleInputChange 方法 this.handleInputChange = this.handleInputChange.bind(this); // 绑定方法 handleStoreChange 来处理 Redux 返回回来的数据 this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); // 处理 handleAddItem 方法 this.handleAddItem = this.handleAddItem.bind(this); // 处理 handleInputKeyUp 方法 this.handleInputKeyUp = this.handleInputKeyUp.bind(this); } render() { return ( TodoList {/* 使用 Input、Button 组件 */} {/* Input 绑定 handleInputChange 事件 */} {/* Input 绑定回车事件：handleInputKeyUp */} {/* 为 Button 定义点击执行 handleAddItem 方法 */} 提交 {/* 使用 List 组件 */} {/* 将原先的 data 换成 state 中的 todoList */} {/* 1. 列表点击事件绑定 handleDeleteItem 方法 */} ( {index + 1} - {item} )} /> ); } // 编写 handleInputChange 方法 handleInputChange(e) { // 通过 dispatch(action)，将数据传递给 store const action = { type: 'change_input_value', value: e.target.value } store.dispatch(action); } // 在 handleStoreChange 中处理数据 handleStoreChange() { this.setState(store.getState()); } // 编写 handleAddItem 方法 handleAddItem() { // 通过 dispatch(action)，将数据传递给 store const action = { type: 'add_todo_item' } store.dispatch(action); } // 为 Input 的 keyUp 方法 handleInputKeyUp 绑定 handleAddItem handleInputKeyUp(e) { if(e.keyCode === 13) { this.handleAddItem(); } } // 2. 编写 handleDeleteItem 方法 handleDeleteItem(index) { console.log(index); // 3. 通过 dispatch(action)，将数据传递给 store const action = { type: 'delete_todo_item', index } store.dispatch(action); } } export default TodoList; ``` src/store/reducer.js 代码详情 ```js // 定义一个数据 defaultState const defaultState = { inputValue: '', todoList: [ // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ] } // 将数据 defaultState 最终以 state 形式导出去 export default (state = defaultState, action) => { // 打印 state 和 action // console.log(state); // console.log(action); // 在 reducer.js 中获取数据，并 return 回去处理结果 if(action.type === 'change_input_value') { const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; } // 在 reducer.js 中获取数据，并 return 回去处理结果 if(action.type === 'add_todo_item') { const newState = JSON.parse(JSON.stringify(state)); newState.todoList.push(newState.inputValue); newState.inputValue = ''; return newState; } // 4. 在 reducer.js 中获取数据，并 return 回去处理结果 if(action.type === 'delete_todo_item') { const newState = JSON.parse(JSON.stringify(state)); newState.todoList.splice(action.index, 1); return newState; } return state; } ``` 现在我们先进行功能演示： 再来查看下我们的编程思路： 列表点击事件绑定 handleDeleteItem 方法。此时，由于需要绑定 this，并且传递值 index，即两个值，所以我们直接在代码中：this.handleDeleteItem.bind(this, index) 编写 handleDeleteItem 方法 通过 dispatch(action)，将数据传递给 store 在 reducer.js 中获取数据，并 return 回去处理结果 这样，我们就完成了列表项的删除。 至此，我们就熟悉了 Reudx 的数据获取以及修改方法。 八 优化：抽取 action 中的 type 返回目录 在上面章节中，我们已经完成了 TodoList 的建设，可以说我们已经搞定了。 但是，你懂的，本篇文章名为：【React Demo Two - TodoList 升级】 就是说，我们不仅要升级到 Redux，还要进一步地升级，为大型项目的开发做铺垫。 所以，本章节开始进行优化处理。 在上面代码中，我们有没有发现我们 action 的 type 是写到 TodoList.js 中的，多了后不好处理？ change_input_value add_todo_item delete_todo_item 所以我们需要进行下 type 的处理，我们在 store 目录下新增一个 actionTypes.js： src/store/actionTypes.js 代码详情 ```js // 1. 定义 actionTypes export const CHANGE_INPUT_VALUE = 'change_input_value'; export const ADD_TODO_ITEM = 'add_todo_item'; export const DELETE_TODO_ITEM = 'delete_todo_item'; ``` 然后在 TodoList.js 和 reducer.js 中使用： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; // 引入 React 及其 Component import './index.css'; // 引入 index.css import { Input, Button, List } from 'antd'; // 引入 antd 的组件 import 'antd/dist/antd.css'; // 引入 antd 的样式 import store from './store'; // 引入 store，你可以理解为 store 提供数据。./store 是 ./store/index.js 的缩写 import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM } from './actionTypes'; // 2. 引用 actionTypes class TodoList extends Component { // 在 constructor 中通过 store.getState() 方法来获取数据，并赋值为 state constructor(props) { super(props); // 我们尝试在 Console 中打印 store.getState() // console.log(store.getState()); this.state = store.getState(); // 处理 handleInputChange 方法 this.handleInputChange = this.handleInputChange.bind(this); // 绑定方法 handleStoreChange 来处理 Redux 返回回来的数据 this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); // 处理 handleAddItem 方法 this.handleAddItem = this.handleAddItem.bind(this); // 处理 handleInputKeyUp 方法 this.handleInputKeyUp = this.handleInputKeyUp.bind(this); } render() { return ( TodoList {/* 使用 Input、Button 组件 */} {/* Input 绑定 handleInputChange 事件 */} {/* Input 绑定回车事件：handleInputKeyUp */} {/* 为 Button 定义点击执行 handleAddItem 方法 */} 提交 {/* 使用 List 组件 */} {/* 将原先的 data 换成 state 中的 todoList */} {/* 列表点击事件绑定 handleDeleteItem 方法 */} ( {index + 1} - {item} )} /> ); } // 编写 handleInputChange 方法 handleInputChange(e) { // 通过 dispatch(action)，将数据传递给 store // 3. 使用 actionTypes const action = { type: CHANGE_INPUT_VALUE, value: e.target.value } store.dispatch(action); } // 在 handleStoreChange 中处理数据 handleStoreChange() { this.setState(store.getState()); } // 编写 handleAddItem 方法 handleAddItem() { // 通过 dispatch(action)，将数据传递给 store // 3. 使用 actionTypes const action = { type: ADD_TODO_ITEM } store.dispatch(action); } // 为 Input 的 keyUp 方法 handleInputKeyUp 绑定 handleAddItem handleInputKeyUp(e) { if(e.keyCode === 13) { this.handleAddItem(); } } // 编写 handleDeleteItem 方法 handleDeleteItem(index) { console.log(index); // 通过 dispatch(action)，将数据传递给 store // 3. 使用 actionTypes const action = { type: DELETE_TODO_ITEM, index } store.dispatch(action); } } export default TodoList; ``` src/store/reducer.js 代码详情 ```js import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM } from './actionTypes'; // 2. 引用 actionTypes // 定义一个数据 defaultState const defaultState = { inputValue: '', todoList: [ // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ] } // 将数据 defaultState 最终以 state 形式导出去 export default (state = defaultState, action) => { // 打印 state 和 action // console.log(state); // console.log(action); // 在 reducer.js 中获取数据，并 return 回去处理结果 // 3. 使用 actionTypes if(action.type === CHANGE_INPUT_VALUE) { const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; } // 在 reducer.js 中获取数据，并 return 回去处理结果 // 3. 使用 actionTypes if(action.type === ADD_TODO_ITEM) { const newState = JSON.parse(JSON.stringify(state)); newState.todoList.push(newState.inputValue); newState.inputValue = ''; return newState; } // 在 reducer.js 中获取数据，并 return 回去处理结果 // 3. 使用 actionTypes if(action.type === DELETE_TODO_ITEM) { const newState = JSON.parse(JSON.stringify(state)); newState.todoList.splice(action.index, 1); return newState; } return state; } ``` 另外，抽取 actionTypes.js 的意义在于，固定 action.type 值，从而不会因为在两处不同地方使用，导致报错。 九 优化：抽取整个 action 返回目录 随着代码量的增多，我们发现注释逐渐增长，所以在这里，我们先去掉所有注释，请小伙伴们自行熟悉上面章节的代码流程。 清除完毕后，我们可以发现：虽然 actionType 抽取出来了，但是当页面足够复杂的时候，我们的 action 管理起来还是非常复杂，所以我们尝试将整个 action 抽取出来。 我们在 store 目录中新建一个 actionCreators.js： src/store/actionCreators.js 代码详情 ```js // 1. 引入 actionTypes import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM } from './actionTypes' // 2. 导出相应 action export const getInputChangeAction = (value) => ({ type: CHANGE_INPUT_VALUE, value }) export const getAddItemAction = () => ({ type: ADD_TODO_ITEM }) export const getItemDeleteAction = (index) => ({ type: DELETE_TODO_ITEM, index }) ``` 机智的小伙伴，看到这里，应该就明白我们的意图了，所以，我们再修改下 TodoList.js 即可： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import { Input, Button, List } from 'antd'; import 'antd/dist/antd.css'; import store from './store'; import { getChangeInputValue, getAddTodoItem, getDeleteTodoItem } from './store/actionCreators'; // 3. 引入 actionCreators class TodoList extends Component { constructor(props) { super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); this.handleAddItem = this.handleAddItem.bind(this); this.handleInputKeyUp = this.handleInputKeyUp.bind(this); } render() { return ( TodoList 提交 ( {index + 1} - {item} )} /> ); } handleInputChange(e) { // 4. 使用 actionCreators 中的 getChangeInputValue const action = getChangeInputValue(e.target.value); store.dispatch(action); } handleStoreChange() { this.setState(store.getState()); } handleAddItem() { // 4. 使用 actionCreators 中的 getAddTodoItem const action = getAddTodoItem(); store.dispatch(action); } handleInputKeyUp(e) { if(e.keyCode === 13) { this.handleAddItem(); } } handleDeleteItem(index) { // 4. 使用 actionCreators 中的 getAddTodoItem const action = getDeleteTodoItem(index); store.dispatch(action); } } export default TodoList; ``` 这样，我们就把整个 action 抽取出来了，在大型项目中，对我们的工作会非常方便。 十 优化：UI 组件和容器组件 返回目录 现在，先抛出两个定义： UI 组件 —— 傻瓜组件，做页面的渲染 容器组件 —— 聪明组件，做页面的逻辑 我们先不多解释，进行代码拆分，再来讲解为什么会有这两个定义。 在这里，我们进行组件的拆分： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import 'antd/dist/antd.css'; import store from './store'; import { getChangeInputValue, getAddTodoItem, getDeleteTodoItem } from './store/actionCreators'; // 1. 将 Input 等 antd 的组件引入迁移到 TodoListUI，并引入 TodoListUI import TodoListUI from './TodoListUI'; class TodoList extends Component { constructor(props) { super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleAddItem = this.handleAddItem.bind(this); this.handleInputKeyUp = this.handleInputKeyUp.bind(this); this.handleDeleteItem = this.handleDeleteItem.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); } render() { return ( // 2. 编写 TodoListUI，传递参数到 TodoListUI 中 ); } handleInputChange(e) { // 解决 Antd 中的 bug e.persist(); const action = getChangeInputValue(e.target.value); store.dispatch(action); } handleStoreChange() { this.setState(store.getState()); } handleAddItem() { const action = getAddTodoItem(); store.dispatch(action); } handleInputKeyUp(e) { // 解决 Antd 中的 bug e.persist(); if(e.keyCode === 13) { this.handleAddItem(); } } handleDeleteItem(index) { // 解决 Antd 中的 bug index.persist(); const action = getDeleteTodoItem(index); store.dispatch(action); } } export default TodoList; ``` 在这里，我们将 render 中的内容抽取到子组件，该子组件在 src 目录下，叫 TodoListUI，我们将 TodoList.js 当成容器组件中，只需要将数据传递给 TodoListUI 就行了，然后我们编写 UI 组件内容： src/TodoListUI.js 代码详情 ```js // 3. 引入 Input 等组件 import React, { Component } from 'react'; import { Input, Button, List } from 'antd'; class TodoListUI extends Component { render() { return ( // 4. 接收 TodoList.js 中传递的数据 TodoList 提交 {/* 5. 在处理 handleDeleteItem 的时候需要注意，index 的值需要再进行处理 */} ( {this.props.handleDeleteItem(index)}}> {index + 1} - {item} )} /> ); } } export default TodoListUI; ``` 这样，我们就完成了 UI 组件和容器组件的拆分。 我们所做的内容有： 将 Input 等 antd 的组件引入迁移到 TodoListUI，并引入 TodoListUI 编写 TodoListUI，传递参数到 TodoListUI 中 引入 Input 等组件 接收 TodoList.js 中传递的数据 在处理 handleDeleteItem 的时候需要注意，index 的值需要再进行处理 这样，我们就完成了页面的抽取，当我们页面过多的时候，我们就将内容独立到 UI 组件中。而容器组件，则可以包含无数个 UI 组件。所以： 容器组件是聪明组件，它对整体进行了一个把控；而 UI 组件是傻瓜组件，只需要执行容器组件传递过来的事件并渲染页面即可。 十一 优化：无状态组件 返回目录 当一个组件中，只有 render() 函数，而不做其他事情的时候，我们就把它叫做无状态组件。 在 TodoList 这个项目中，我们的 TodoListUI 就只做了 render() 工作，所以可以将 TodoListUI 作为一个无状态组件： src/TodoListUI 代码详情 ```js // 1. 我们不需要 react 中的 Component 了 import React from 'react'; import { Input, Button, List } from 'antd'; // class TodoListUI extends Component { // 2. 进行无状态组件定义，然后父组件传递过来的数据，通过 props 获取 const TodoListUI = (props) => { // 3. 我们不需要进行 render 了，直接 return 就可以了 return ( // 4. 接收 TodoList.js 中传递的数据 TodoList {/* 5. 我们修改 this.props 为 props */} 提交 ( {props.handleDeleteItem(index)}}> {index + 1} - {item} )} /> ); } export default TodoListUI; ``` 在这里，大致做了 5 项工作： 我们不需要 react 中的 Component 了，所以我们去掉了 Component 进行无状态组件定义，然后父组件传递过来的数据，通过 props 获取 我们不需要进行 render 了，直接 return 就可以了 接收 TodoList.js 中传递的数据 我们修改 this.props 为 props 十二 结尾：调用 Axios，Redux-Base 完成 返回目录 终于来到最终环节，我们需要获取后端提供的接口，来进一步开发。 引入 Axios：cnpm i axios -S 在 componentDidMount 中获取接口数据，并走流程，最终渲染到页面上： TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import 'antd/dist/antd.css'; import store from './store'; // 7. 从 actionCreators 中引入 initListAction import { getChangeInputValue, getAddTodoItem, getDeleteTodoItem, initListAction } from './store/actionCreators'; import TodoListUI from './TodoListUI'; import axios from 'axios'; // 1. 引入 axios class TodoList extends Component { constructor(props) { super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleAddItem = this.handleAddItem.bind(this); this.handleInputKeyUp = this.handleInputKeyUp.bind(this); this.handleDeleteItem = this.handleDeleteItem.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); } render() { return ( ); } // 2. 在 componentDidMount() 中进行 axios 接口调用 componentDidMount() { axios.get('https://www.easy-mock.com/mock/5ca803587e5a246db3d100cb/todolist').then( (res) => { console.log(res.data.todolist); // 3. 将接口数据 dispatch 到 action 中，所以需要先前往 actionCreators.js 中创建 action // 8. 创建 action 并 dispatch 到 reducer.js 中 const action = initListAction(res.data.todolist); store.dispatch(action); }) } handleInputChange(e) { // 解决 Antd 中的 bug e.persist(); const action = getChangeInputValue(e.target.value); store.dispatch(action); } handleStoreChange() { this.setState(store.getState()); } handleAddItem() { const action = getAddTodoItem(); store.dispatch(action); } handleInputKeyUp(e) { // 解决 Antd 中的 bug e.persist(); if(e.keyCode === 13) { this.handleAddItem(); } } handleDeleteItem(index) { // 解决 Antd 中的 bug index.persist(); const action = getDeleteTodoItem(index); store.dispatch(action); } } export default TodoList; ``` actionCreators.js 代码详情 ```js // 5. 从 actionTypes 引入 INIT_LIST_ACTION import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM, INIT_LIST_ACTION } from './actionTypes'; export const getChangeInputValue = (value) => ({ type: CHANGE_INPUT_VALUE, value }) export const getAddTodoItem = () => ({ type: ADD_TODO_ITEM }) export const getDeleteTodoItem = (index) => ({ type: DELETE_TODO_ITEM, index }) // 4. 编写导出的 initListAction，所以需要先在 actionTypes 中引入 INIT_LIST_ACTION export const initListAction = (data) => ({ type: INIT_LIST_ACTION, data }) ``` actionTypes.js 代码详情 ```js export const CHANGE_INPUT_VALUE = 'change_input_value'; export const ADD_TODO_ITEM = 'add_todo_item'; export const DELETE_TODO_ITEM = 'delete_todo_item'; // 6. 导出 INIT_LIST_ACTION export const INIT_LIST_ACTION = 'init_list_action'; ``` reducer.js 代码详情 ```js // 9. 从 actionTypes 引用 INIT_LIST_ACTION import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM, INIT_LIST_ACTION } from './actionTypes'; const defaultState = { inputValue: '', todoList: [] } export default (state = defaultState, action) => { if(action.type === CHANGE_INPUT_VALUE) { const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; } if(action.type === ADD_TODO_ITEM) { const newState = JSON.parse(JSON.stringify(state)); newState.todoList.push(newState.inputValue); newState.inputValue = ''; return newState; } if(action.type === DELETE_TODO_ITEM) { const newState = JSON.parse(JSON.stringify(state)); newState.todoList.splice(action.index, 1); return newState; } // 10. 接受 TodoList 传递过来的数据，并进行处理与返回 if(action.type === INIT_LIST_ACTION) { const newState = JSON.parse(JSON.stringify(state)); newState.todoList = action.data; return newState; } return state; } ``` 这样，我们就完成了 axios 的调用，并渲染到页面上，整理出来，思路为： TodoList.js —— 引入 axios TodoList.js —— 在 componentDidMount() 中进行 axios 接口调用 TodoList.js —— 将接口数据 dispatch 到 action 中，所以需要先前往 actionCreators.js 中创建 action actionCreators.js —— 编写导出的 initListAction，所以需要先在 actionTypes 中引入 INIT_LIST_ACTION actionCreators.js —— 从 actionTypes 引入 INIT_LIST_ACTION actionTypes.js —— 导出 INIT_LIST_ACTION 到 actionCreators TodoList.js —— 从 actionCreators 中引入 initListAction TodoList.js —— 创建 action 并 dispatch 到 reducer.js 中 reducer.js —— 从 actionTypes 引用 INIT_LIST_ACTION reducer.js —— 接受 TodoList 传递过来的数据，并进行处理与返回 如此，我们就完成了接口的调用，此时页面显示如下： 到此，我们就完成了 Redux-Base。 但是，这只是简单的 Redux 的使用，我们可以感受到，仅仅使用 Redux 对于项目来说还是复杂的，所以我们需要 Redux 的中间件 Redux-Thunk 以及 Redux-Saga。并在最后尝试使用下 React-Redux。 十三 进阶：Redux 中间件 返回目录 什么是中间件？ 中间件即是安排在谁与谁之间的插件。 什么是 Redux 中间件？ 看图： 在上面图中我们可以看出，我们通过 Dispatch 将 Action 派发到 Store 的时候，我们在 Dispatch 中引用了中间件做处理。它对 Dispatch 做了封装升级，从而使得我们不仅可以在 Dispatch 使用对象，而且可以使用方法函数。 这样，当我们传递给 Dispatch 一个对象的时候，跟我们正常使用 redux 没区别。但是，当我们传递给 Dispatch 一个函数的时候，如果我们使用了 Redux-Thunk 或者 Redux-Saga 的时候，它们就会对此进行处理，从而让我们也可以调用函数。 因此，简单来说，Redux 的中间件，就是对 Dispatch 的封装升级。 十四 进阶：Redux-Thunk 中间件进行 ajax 请求管理 返回目录 在第十二章节中，我们在 TodoList 中进行了 Ajax 请求，这是可以的。 但是，随着 Ajax 请求越来越多，如果我们都在页面中编写，那么就会让页面显得臃肿。 这时候，就需要 Redux-Thunk 了。Redux-Thunk 可以把异步请求及复杂业务逻辑抽取到其他地方处理。 我们拷贝一份 Redux-Base 代码到 Redux-Thunk 目录中，并执行： 注意：不需要拷贝 node_modules 文件夹 安装依赖：npm i 运行项目：npm run start 然后，我们开始引用 Redux-Thunk： Redux Thunk：Github 地址 安装：npm i redux-thunk -S 教程小例子： test.js 代码详情 ```js import { createStore, applyMiddleware } from 'redux'; import thunk from 'redux-thunk'; import rootReducer from './reducers/index'; const store = createStore( rootReducer, applyMiddleware(thunk) ) ``` 很好看上去非常 easy 有木有，那么我们在项目中尝试一下。 src/store/index.js 代码详情 ```js // 2. 从 redux 中引入 applyMiddleware，applyMiddleware 的作用是应用 redux 中间件 // 3. 引入 compose 函数，因为我们用到了两个中间件：redux-thunk 以及 redux-devtools-extension，需要 compose 辅助 import { createStore, applyMiddleware, compose } from 'redux'; import reducer from './reducer'; // 1. 从 redux-thunk 中引入 thunk import thunk from 'redux-thunk'; // 3. 使用 redux-devtools-extension 中间件 const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose; // 4. 使用 applyMiddleware 对此进行扩展 const enhancer = composeEnhancers( applyMiddleware(thunk), ); // 5. 在 createStore 进行 enhancer 调用 const store = createStore( reducer, enhancer ); export default store; ``` 在这里，我们做了几件事： 从 redux-thunk 中引入 thunk 从 redux 中引入 applyMiddleware，applyMiddleware 的作用是应用多个 redux 中间件 引入 compose 函数，因为我们用到了两个中间件：redux-thunk 以及 redux-devtools-extension，需要 compose 辅助 使用 redux-devtools-extension 中间件 使用 applyMiddleware 对此进行扩展，即 redux-thunk 中间件加上 redux-devtools-extension 中间件 在 createStore 进行 enhancer 调用 这样，我们就同时在一个项目中使用了 redux-thunk 中间件加上 redux-devtools-extension 中间件，从而做到了 redux-thunk 的引用。 接下来，我们就要使用 redux-thunk 了 src/store/actionCreators.js 代码详情 ```js import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM, INIT_LIST_ACTION } from './actionTypes'; // 1. 把 axios 从 TodoList.js 中剪切到 actionCreators.js 中 import axios from 'axios'; export const getChangeInputValue = (value) => ({ type: CHANGE_INPUT_VALUE, value }) export const getAddTodoItem = () => ({ type: ADD_TODO_ITEM }) export const getDeleteTodoItem = (index) => ({ type: DELETE_TODO_ITEM, index }) export const initListAction = (data) => ({ type: INIT_LIST_ACTION, data }) // 2. 把 TodoList 文件中 componentDidMount() 的 axios.get() 挪到 actionCreators.js 中 // 3. 在没使用 redux-thunk 之前，我们仅可以在 actionCreators.js 中使用对象，现在我们也可以使用函数了。 export const getTodoList = () => { // 7. 当我们使用 getTodoList 的时候，我们也能传递 store 的 dispatch，从而在下面代码中使用 return (dispatch) => { axios.get('https://www.easy-mock.com/mock/5ca803587e5a246db3d100cb/todolist').then( (res) => { // 8. 直接使用 actionCreators.js 中的 initListAction方法，并 dispatch 该 action const action = initListAction(res.data.todolist); dispatch(action); }) } } ``` src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import 'antd/dist/antd.css'; import store from './store'; // 4. 在 TodoList.js 中引用 actionCreators.js 中的 getTodoList import { getChangeInputValue, getAddTodoItem, getDeleteTodoItem, getTodoList } from './store/actionCreators'; import TodoListUI from './TodoListUI'; class TodoList extends Component { constructor(props) { super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleAddItem = this.handleAddItem.bind(this); this.handleInputKeyUp = this.handleInputKeyUp.bind(this); this.handleDeleteItem = this.handleDeleteItem.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); } render() { return ( ); } componentDidMount() { // 5. 在 componentDidMount 中调用 getTodoList。如果我们没使用 redux-thunk，我们只能使用对象，但是现在我们可以使用函数了。 const action = getTodoList(); // 6. 当我们 dispatch 了 action 的时候，我们就调用了步骤 1 的 getTodoList()，从而获取了数据 store.dispatch(action); } handleInputChange(e) { const action = getChangeInputValue(e.target.value); store.dispatch(action); } handleStoreChange() { this.setState(store.getState()); } handleAddItem() { const action = getAddTodoItem(); store.dispatch(action); } handleInputKeyUp(e) { if(e.keyCode === 13) { this.handleAddItem(); } } handleDeleteItem(index) { const action = getDeleteTodoItem(index); store.dispatch(action); } } export default TodoList; ``` 看到这里，我们或许已经懵逼，所以先瞅瞅思路： 把 axios 从 TodoList.js 中剪切到 actionCreators.js 中 把 TodoList 文件中 componentDidMount() 的 axios.get() 挪到 actionCreators.js 中 在没使用 redux-thunk 之前，我们仅可以在 actionCreators.js 中使用对象，现在我们也可以使用函数了。 在 TodoList.js 中引用 actionCreators.js 中的 getTodoList()，并去除没再引用的 initListAction 在 componentDidMount() 中调用 getTodoList()。如果我们没使用 redux-thunk，我们只能使用对象，但是现在我们可以使用函数了。 当我们 dispatch 了 action 的时候，我们就调用了步骤 1 的 getTodoList()，从而获取了数据 当我们使用 getTodoList() 的时候，我们也能传递 store 的 dispatch，从而在下面代码中使用 直接使用 actionCreators.js 中的 initListAction 方法，并 dispatch 该 action 如此，我们就通过 redux-thunk，将 axios 的接口调用抽取到了 actionCreators.js 中了。 为什么我们原本在 TodoList.js 中用的好好的，到了这里要走那么多步骤把它抽取出来？ 其实我们需要知道的是，当页面足够复杂，项目足够大，代码越来越多的时候，如果我们的接口调用都在容器组件中，我们就不方便对接口进行管理，最后如果我们需要改动某个接口，我们就要在页面中慢慢查找。 通过 redux-thunk 的调用，我们就把接口代码从容器组件中抽取出来，从而做到：接口代码逻辑是接口代码逻辑，业务代码逻辑是业务代码逻辑。 而且，通过 redux-thunk 的抽取，可以方便我们的自动化测试。当然，自动化测试长啥样子，我们还不清楚，但是我们可以安慰自己的是：这样子始终是有道理的。 总结：至此，我们就完成了 Redux-Thunk 的引用及其使用，小伙伴们可以多进行尝试，进一步熟悉 Redux-Thunk。 十五 进阶：Redux-Saga 中间件进行 Ajax 请求管理 返回目录 有了 Redux-Thunk 的经验，我们也可以了解下 Redux-Saga 了。 首先我们还是从 Redux-Base 中拷贝一份文件到 Redux-Saga 目录中。 注意：不需要拷贝 node_modules 文件夹 安装依赖：npm i 运行项目：npm run start 然后，我们开始引用 Redux-Saga： Redux Saga：Github 地址 安装：npm i redux-saga -S 教程小例子： test.js 代码详情 ```js import { createStore, applyMiddleware } from 'redux' import createSagaMiddleware from 'redux-saga' import reducer from './reducers' import mySaga from './sagas' // create the saga middleware const sagaMiddleware = createSagaMiddleware() // mount it on the Store const store = createStore( reducer, applyMiddleware(sagaMiddleware) ) // then run the saga sagaMiddleware.run(mySaga) // render the application ``` 噗呲，可以看出，Redux-Saga 的引用方式跟 Redux-Thunk 一样简单。但是，请抱着接受一定复杂性的形式继续学习。 下面我们操作 store 目录下的 index.js 文件，进行 Redux-Saga 的引用： src/store/index.js 代码详情 ```js // 1. 引入 applyMiddleware 和 compose 进行多个中间件的处理 import { createStore, applyMiddleware, compose } from 'redux'; import reducer from './reducer'; // 2. 引入 redux-saga 的 createSagaMiddleware import createSagaMiddleware from 'redux-saga'; // 6. 创建并引用 store 下的 sagas.js 文件 import todoSaga from './sagas'; // 3. 调用 createSagaMiddleware 方法 const sagaMiddleware = createSagaMiddleware(); // 4. 定义 composeEnhancers const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose; // 5. 调用 composeEnhancers 进行多中间件处理 const enhancer = composeEnhancers( applyMiddleware(sagaMiddleware), ); const store = createStore( reducer, enhancer ); // 7. 使用 todoSaga sagaMiddleware.run(todoSaga); export default store; ``` src/store/sagas.js 代码详情 ```js // 8. 使用 generator 函数定义 todoSaga function* todoSaga() { } // 9. 将 generator 函数导出去 export default todoSaga; ``` 如此，我们就完成了 Redux-Saga 的引用，大致做了如下步骤： 引入 applyMiddleware 和 compose 进行多个中间件的处理 引入 redux-saga 的 createSagaMiddleware 调用 createSagaMiddleware 方法 定义 composeEnhancers 调用 composeEnhancers 进行多中间件处理 创建并引用 store 下的 sagas.js 文件的 todoSaga 通过 sagaMiddleware 使用 todoSaga 使用 generator 函数定义 sagas.js 文件 将 generator 函数导出去 同时我们观察下页面，也不存在报错，说明我们引用对了。 下面我们将 componentDidMount() 方法中的 axios.get() 这些异步接口提取到 src/store/sagas.js 中进行处理： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import 'antd/dist/antd.css'; import store from './store'; // 1. 删除 initListAction 以及下面的 axios，并引入 actionCreators.js 中的 getInitList import { getChangeInputValue, getAddTodoItem, getDeleteTodoItem, getInitList } from './store/actionCreators'; import TodoListUI from './TodoListUI'; class TodoList extends Component { constructor(props) { super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleAddItem = this.handleAddItem.bind(this); this.handleInputKeyUp = this.handleInputKeyUp.bind(this); this.handleDeleteItem = this.handleDeleteItem.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); } render() { return ( ); } componentDidMount() { // 5. 调用 getInitList，并使用 dispatch 将 action 派发出去。这时候不仅 reducer.js 可以接收到这个 action，我们的 sagas.js 也可以接收到这个 action。 const action = getInitList(); store.dispatch(action); } handleInputChange(e) { const action = getChangeInputValue(e.target.value); store.dispatch(action); } handleStoreChange() { this.setState(store.getState()); } handleAddItem() { const action = getAddTodoItem(); store.dispatch(action); } handleInputKeyUp(e) { if(e.keyCode === 13) { this.handleAddItem(); } } handleDeleteItem(index) { const action = getDeleteTodoItem(index); store.dispatch(action); } } export default TodoList; ``` src/store/actionCreators.js 代码详情 ```js // 2. 导入 actionTypes.js 中的 GET_INIT_LIST import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM, INIT_LIST_ACTION, GET_INIT_LIST } from './actionTypes'; export const getChangeInputValue = (value) => ({ type: CHANGE_INPUT_VALUE, value }) export const getAddTodoItem = () => ({ type: ADD_TODO_ITEM }) export const getDeleteTodoItem = (index) => ({ type: DELETE_TODO_ITEM, index }) export const initListAction = (data) => ({ type: INIT_LIST_ACTION, data }) // 3. 使用 GET_INIT_LIST export const getInitList = () => ({ type: GET_INIT_LIST }); ``` src/store/actionTypes.js 代码详情 ```js export const CHANGE_INPUT_VALUE = 'change_input_value'; export const ADD_TODO_ITEM = 'add_todo_item'; export const DELETE_TODO_ITEM = 'delete_todo_item'; export const INIT_LIST_ACTION = 'init_list_action'; // 4. 定义 GET_INIT_LIST 并导出给 actionTypes.js 使用 export const GET_INIT_LIST = 'get_init_list'; ``` src/store/sagas.js 代码详情 ```js // 6. 引用 redux-saga/effets 中的 takeEvery // 13. 由于我们在 sagas.js 中没有引用到 store，所以不能使用 store.dispatch()，但是 redux-saga 给我们提供了 put 方法来代替 store.dispatch() 方法 import { takeEvery, put } from 'redux-saga/effects'; // 7. 引入 GET_INIT_LIST 类型 import { GET_INIT_LIST } from './actionTypes'; // 11. 将 TodoList.js 的 axios 引入迁移到 sagas.js 中 import axios from 'axios'; // 12. 引入 actionCreator.js 中的 initListAction import { initListAction } from './actionCreators' // 8. 使用 generator 函数 function* todoSaga() { // 9. 这行代码表示，只要我们接收到 GET_INIT_LIST 的类型，我们就执行 getInitList 方法 yield takeEvery(GET_INIT_LIST, getInitList); } // 10. 定义 getInitList 方法 function* getInitList() { try { // 14. 在 sagas.js 中处理异步函数 const res = yield axios.get('https://www.easy-mock.com/mock/5ca803587e5a246db3d100cb/todolis'); const action = initListAction(res.data.todolist); // 15. 等 action 处理完之后，在执行 put 方法 yield put(action); } catch (error) { console.log(\"接口请求失败，请检查 todolist 接口。\"); } } export default todoSaga; ``` 这样，我们就把调用接口的异步请求函数，抽取到了 sagas.js 文件中，期间我们做了： TodoList.js —— 删除 initListAction 以及下面的 axios，并引入 actionCreators.js 中的 getInitList actionCreators.js —— 导入 actionTypes.js 中的 GET_INIT_LIST actionTypes.js —— 使用 GET_INIT_LIST actionTypes.js —— 定义 GET_INIT_LIST 并导出给 actionTypes.js 使用 TodoList.js —— 调用 getInitList，并使用 dispatch 将 action 派发出去。这时候不仅 reducer.js 可以接收到这个 action，我们的 sagas.js 也可以接收到这个 action。 引用 redux-saga/effets 中的 takeEvery 引入 GET_INIT_LIST 类型 使用 generator 函数 通过 takeEvery，表示只要我们接收到 GET_INIT_LIST 的类型，我们就执行 getInitList 方法 定义 getInitList 方法 将 TodoList.js 的 axios 引入迁移到 sagas.js 中 引入 actionCreator.js 中的 initListAction 由于我们在 sagas.js 中没有引用到 store，所以不能使用 store.dispatch()，但是 redux-saga 给我们提供了 put 方法来代替 store.dispatch() 方法，所以我们引用 put 方法。 在 sagas.js 中处理异步函数 等 action 处理完之后，在执行 put 方法：yield put(action) 如此，我们就成功将 TodoList 中异步请求接口抽取到了 sagas.js 中，从而对接口进行统一管理。 在 src/store/sagas.js 中，我们还通过 try...catch... 方法，对接口进行处理，当接口不存在或者请求异常的时候，我们将知道该接口出错了。 总结：至此，我们就完成了 Redux-Saga 的引用及其使用，小伙伴们可以多进行尝试，进一步熟悉 Redux-Saga。 参考文献：generator - 廖雪峰 十六 进阶：React-Redux 返回目录 在之前的章节中，我们使用了 React，也使用了 Redux，以及接触了 Redux 的中间件：Redux-Thunk 和 Redux-Saga。 那么，本章节讲解下 React-Redux。 什么是 React-Redux。 它是一个第三方模块，更方便我们在 React 中使用 Redux。 在这里，由于 React-Base 目录是 React 与 Redux 分开的，所以我们复制一份 Simplify 目录的基础代码到 React-Redux 目录中，并进行 TodoList 改造，从而开始我们的 React-Redux 之旅。 将 Simplify 改造成 TodoList 的方法可参考 第三章 初始化项目、第四章 使用 Ant Design 以及 第五章 使用 Redux。 下面 jsliang 贴出自己的初始化后的代码： src/index.js 代码详情 ```js import React from 'react'; import ReactDOM from 'react-dom'; import TodoList from './TodoList'; ReactDOM.render(, document.getElementById('root')); ``` src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import { Input, Button, List } from 'antd'; import 'antd/dist/antd.css'; import store from './store'; class TodoList extends Component { constructor(props) { super(props); this.state = store.getState(); } render() { return ( TodoList 提交 ({index + 1} - {item})} /> ); } } export default TodoList; ``` src/index.css 代码详情 ```css .todo { width: 1000px; margin: 20px auto 0; padding: 30px; border: 1px solid #ccc; border-radius: 10px; } .todo-title { text-align: center; } .todo-action .todo-input { width: 200px; } .todo-action .todo-submit { margin-left: 10px; } .todo-list { margin-top: 30px; } ``` src/store/index.js 代码详情 ```js import { createStore } from 'redux'; import reducer from './reducer'; const store = createStore(reducer); export default store; ``` src/store/reducer.js 代码详情 ```js const defaultState = { inputValue: '', list: [ '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ] } export default (state = defaultState, action) => { return state; } ``` 此时页面展示为第四章最后的页面样子： React Redux：GitHub 地址 安装 react-redux：npm i react-redux -S 是时候展现真正的技术了！ 我们在 src/index.js 中引用 react-redux： src/index.js 代码详情 ```js import React from 'react'; import ReactDOM from 'react-dom'; import TodoList from './TodoList'; // 1. 引入 react-redux 的 Provider import { Provider } from 'react-redux'; // 3. 引入 store import store from './store'; // 2. 使用 Provider 重新定义 App const App = ( // 4. Provider 连接了 store，那么 Provider 里面的组件，都可以获取和使用 store 中的内容 ) // 5. 直接渲染 App ReactDOM.render(App, document.getElementById('root')); ``` 接着可以在 src/TodoList.js 中使用： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import { Input, Button, List } from 'antd'; import 'antd/dist/antd.css'; // 6. 在 TodoList 中，我们就不需要使用 import store from store 以及定义 constructor 获取 store 了，而是通过 react-redux 的 connect 来获取 import { connect } from 'react-redux'; class TodoList extends Component { render() { return ( TodoList {/* 10. 使用 inputValue */} 提交 {/* 12. 使用 list */} ({index + 1} - {item})} /> ); } } // 8. 定义 mapStateToProps 方法，把 store 里面的数据，映射成组件里面的 props，其中参数 state 就是 store 里面的数据 const mapStateToProps = (state) => { return { // 9. 定义 inputValue inputValue: state.inputValue, // 11. 定义 list list: state.list } } // 7. 导出 connect 方法，让 TodoList 和 store 做连接，需要对应两个规则，即：mapStateToProps 和 export default connect(mapStateToProps, null)(TodoList); ``` 现在，我们发现代码仍能正常运行，我们分析下我们做了什么步骤： 引入 react-redux 的 Provider 使用 Provider 重新定义 App 引入 store Provider 连接了 store，那么 Provider 里面的组件，都可以获取和使用 store 中的内容 直接渲染 App 在 TodoList.js 中，我们就不需要使用 import store from store 以及定义 constructor 获取 store 了，而是通过 react-redux 的 connect 来获取 导出 connect 方法，让 TodoList.js 和 store 做连接，需要对应两个规则，即：mapStateToProps 和 ** 定义 mapStateToProps 方法，把 store 里面的数据，映射成组件里面的 props，其中参数 state 就是 store 里面的数据 定义 inputValue 使用 inputValue 定义 list 使用 list 如此，我们就完成了 store 通过 react-redux 在 TodoList.js 中的引用。 下面我们再试试修改 store 的值： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import { Input, Button, List } from 'antd'; import 'antd/dist/antd.css'; import { connect } from 'react-redux'; class TodoList extends Component { render() { return ( TodoList {/* 3. 给 Input 绑定 onChange 事件 handleInputChange，此时我们通过 this.props 来绑定方法 */} 提交 ({index + 1} - {item})} /> ); } } const mapStateToProps = (state) => { return { inputValue: state.inputValue, list: state.list } } // 2. 定义 mapDispatchToProps 方法，该方法即是 TodoList.js 将 store.dispatch 方法映射到 props 上，所以我们就可以通过 this.props 来定义方法 // 4. 这里我们传递了 dispatch，所以就可以使用 store.dispatch 方法 const mapDispatchToProps = (dispatch) => { return { // 5. 定义 handleInputChange 方法 handleInputChange(e) { const action = { type: 'change_input_value', value: e.target.value } // 6. 将 action 派发到 reducer.js dispatch(action); } } } // 1. 使用 mapDispatchToProps 方法 export default connect(mapStateToProps, mapDispatchToProps)(TodoList); ``` 在修改 src/reducer.js： src/reducer.js 代码详情 ```js const defaultState = { inputValue: '', list: [ '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ] } export default (state = defaultState, action) => { // 7. 判断传递过来的 action.type 是哪个，进行深拷贝，获取 action.value 的值，并返回 newState if(action.type === 'change_input_value') { const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; } return state; } ``` 这时候，我们做了 7 个步骤： 在 TodoList.js 中使用了 mapDispatchToProps 方法 定义 mapDispatchToProps 方法，该方法即是 TodoList.js 将 store.dispatch 方法映射到 props 上，所以我们就可以通过 this.props 来定义方法 给 Input 绑定 onChange 事件 handleInputChange，此时我们通过 this.props 来绑定方法 在 mapDispatchToProps 中我们传递了 dispatch，所以就可以使用 store.dispatch 方法 定义 handleInputChange 方法 将 action 派发到 reducer.js 判断传递过来的 action.type 是哪个，进行深拷贝，获取 action.value 的值，并返回 newState 至此，我们就简单过了一遍 React-Redux 的使用，下面我们的 Button 按钮点击提交，以及点击 Item 项进行 TodoList 的 list 项删除功能，我们就不一一讲解了，感兴趣的小伙伴可以自行实现下，并通过下载 jsliang 的代码进行参照： React 系列文章代码地址 十七 总结 返回目录 现在，我们完成了所有的知识点、代码及其讲解，是时候可以放松聊聊了：这篇文章中我们学会了啥： Ant Design 的使用 Redux 的引入及使用 UI 组件、容器组件、无状态组件以及为了一些大型项目进行的代码抽取封装 Axios 在 React 中的使用 为了方便管理 Axios 接口代码，我们使用了 Redux 的中间件 Redux-Thunk 和 Redux-Thunk 使用 React-Redux 再过了遍 Redux 的使用，并学习 React-Redux 的使用 至此，我们就成功完结这篇文章，进入到 React 下个环节的升级进阶了。 如果小伙伴们感觉 jsliang 写得不错，记得给个 【赞】 或者给 jsliang 的文档库点个 【star】，你们的 【赞】 或者 【star】 是我满满的动力，哈哈，React 系列下篇再见！ jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-24 11:41:52 "},"JavaScript-library/React/ReactDemoThree-JianShu.html":{"url":"JavaScript-library/React/ReactDemoThree-JianShu.html","title":"✔ React Demo Three - 简书","keywords":"","body":"React Demo Three - 简书 Create by jsliang on 2019-4-7 19:37:41Recently revised in 2019-04-23 09:40:45 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 本文章最终成果： 本来这只是篇纯粹的仿简书首页和文章详情页的文章，但是中间出了点情况（第十九章有提到），所以最终出来的是简书和掘金的混合体~ 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 初始化项目目录 四 创建 React 头部组件 五 编写简书头部导航 六 设置输入框动画 七 优化代码 八 使用 redux-devtools-extension 插件 九 优化：抽取 reducer.js 十 优化：抽取 action 十一 优化：immutable.js 十二 优化：redux-immutable 十三 功能实现：热门搜索 十四 代码优化 十五 解决历史遗留问题 十六 功能实现：换一换 十七 功能优化  17.1 换一换图标旋转  17.2 避免聚焦重复请求 十八 React 路由  18.1 路由（一）  18.2 路由（二） 十九 页面实现：二级导航栏 二十 页面实现：首页  20.1 多层级组件引用 store  20.2 完善整个首页 二十一 总结 二 前言 返回目录 岁月如梭，光阴荏苒。 既然决定了做某事，那就坚持下去。 相信，坚持必定有收获，不管它体现在哪个方面。 React 的学习，迈开 TodoList，进一步前行。 三 初始化项目目录 返回目录 首先，引入 Simplify 目录的内容到 JianShu 文件夹。或者前往文章 《React Demo One - TodoList》 手动进行项目简化。 我们的最终目录如下所示： 小伙伴们可以自行新建空文件，在后续不会因为不知道该文件放到哪，从而导致思路错乱。 然后，我们通过： 安装依赖：npm i 运行项目：npm run start 跑起项目来，运行结果如下所示： 接着，我们在 src 目录下引入 reset.css，去除各种浏览器的差异性影响。 src/reset.css 代码详情 ```js /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /* * 图片自适应 - image responsize * 1. 清空浏览器对图片的设置 * 2. 图片 的情况下，图片会撑高 div，这么设置可以清除该影响 */ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: 1em } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: 1em } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: 1em } /* Internet Explorer */ ``` 顺带创建一个空的全局样式 index.css 文件。 并在 index.js 中引入 reset.css 和 index.css。 src/index.js 代码详情 ```js import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; import './reset.css'; import './index.css'; ReactDOM.render(, document.getElementById('root')); ``` 四 创建 React 头部组件 返回目录 首先，在 src 目录下，新建 common 目录，并在 common 目录下，新建 header 目录，其中的 index.js 内容如下： src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; class Header extends Component { render() { return ( Header ) } } export default Header; ``` 然后，我们在 App.js 中引入 header.js： src/App.js 代码详情 ```js import React, { Component } from 'react'; import Header from './common/header'; class App extends Component { render() { return ( ); } } export default App; ``` 最后，页面显示为： 由此，我们完成了 Header 组件的创建。 五 编写简书头部导航 返回目录 首先，我们编写 src/common/header 下的 index.js： src/common/heder/index.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { constructor(props) { super(props); this.state = { inputFocus: true } this.searchFocusOrBlur = this.searchFocusOrBlur.bind(this); } render() { return ( 首页 下载App Aa 登录 注册 写文章 ) } searchFocusOrBlur(e) { const inputFocus = this.state.inputFocus; this.setState( () => ({ inputFocus: !inputFocus })) } } export default Header; ``` 然后，我们添加 CSS 样式： src/common/heder/index.css 代码详情 ```css header { width: 100%; height: 58px; display: flex; align-items: center; border-bottom: 1px solid #ccc; font-size: 17px; } .headef_left-img { width: 100px; height: 56px; } .header_center { width: 1000px; margin: 0 auto; display: flex; justify-content: space-between; } .nav-item { margin-right: 30px; display: flex; align-items: center; } .header_center-left { display: flex; } .header_center-left-home { color: #ea6f5a; } .header_center-left-search { position: relative; } .header_center-left-search input { width: 240px; padding: 0 40px 0 20px; height: 38px; font-size: 14px; border: 1px solid #eee; border-radius: 40px; background: #eee; } .header_center-left-search .input-active { width: 280px; } .header_center-left-search i { position: absolute; top: 8px; right: 10px; } .header_center-left-search .icon-active { padding: 3px; top: 4px; border-radius: 15px; border: 1px solid #ea6f5a; } .header_center-left-search .icon-active:hover { cursor: pointer; } .header_center-right { display: flex; color: #969696; } .header_right-register, .header_right-write { width: 80px; text-align: center; height: 38px; line-height: 38px; border: 1px solid rgba(236,97,73,.7); border-radius: 20px; font-size: 15px; color: #ea6f5a; background-color: transparent; } .header_right-write { margin-left: 10px; padding-left: 10px; margin-right: 0px; color: #fff; background-color: #ea6f5a; } ``` 接着，由于图标这些，我们可以抽取到公用样式表中，所以我们在 src 目录下添加 common.css： src/common.css 代码详情 ```css .icon { display: inline-block; width: 20px; height: 21px; margin-right: 5px; } .icon-home { background: url('./resources/img/icon-home.png') no-repeat center; background-size: 100%; } .icon-write { background: url('./resources/img/icon-write.png') no-repeat center; background-size: 100%; } .icon-download { background: url('./resources/img/icon-download.png') no-repeat center; background-size: 100%; } .icon-search { background: url('./resources/img/icon-search.png') no-repeat center; background-size: 100%; } ``` 当然，我们需要位置存放图片，所以需要在 src 目录下，新建 recourses 目录，recourses 目录下存放 img 文件夹，该文件夹存放这些图标文件。 最后，我们在 src 下的 index.js 中引用 common.css src/index.js 代码详情 ```js import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; import './reset.css'; import './index.css'; import './common.css'; ReactDOM.render(, document.getElementById('root')); ``` 至此，我们页面展示为： 六 设置输入框动画 返回目录 参考地址：react-transition-group 安装动画库：npm i react-transition-group -S 修改代码： src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; // 1. 引入动画库 import { CSSTransition } from 'react-transition-group'; import './index.css'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { constructor(props) { super(props); this.state = { inputBlur: true } this.searchFocusOrBlur = this.searchFocusOrBlur.bind(this); } render() { return ( 首页 下载App {/* 2. 通过 CSSTransition 包裹 input */} Aa 登录 注册 写文章 ) } searchFocusOrBlur(e) { const inputBlur = this.state.inputBlur; this.setState( () => ({ inputBlur: !inputBlur })) } } export default Header; ``` src/common/header/index.css 代码详情 ```css header { width: 100%; height: 58px; display: flex; align-items: center; border-bottom: 1px solid #ccc; font-size: 17px; } .headef_left-img { width: 100px; height: 56px; } .header_center { width: 1000px; margin: 0 auto; display: flex; justify-content: space-between; } .nav-item { margin-right: 30px; display: flex; align-items: center; } .header_center-left { display: flex; } .header_center-left-home { color: #ea6f5a; } .header_center-left-search { position: relative; } /* 3. 编写对应的 CSS 样式 */ .slide-enter { transition: all .2s ease-out; } .slide-enter-active { width: 280px; } .slide-exit { transition: all .2s ease-out; } .silde-exit-active { width: 240px; } /* 3. 结束 */ .header_center-left-search input { width: 240px; padding: 0 40px 0 20px; height: 38px; font-size: 14px; border: 1px solid #eee; border-radius: 40px; background: #eee; } .header_center-left-search .input-active { width: 280px; } .header_center-left-search i { position: absolute; top: 8px; right: 10px; } .header_center-left-search .icon-active { padding: 3px; top: 4px; border-radius: 15px; border: 1px solid #ea6f5a; } .header_center-left-search .icon-active:hover { cursor: pointer; } .header_center-right { display: flex; color: #969696; } .header_right-register, .header_right-write { width: 80px; text-align: center; height: 38px; line-height: 38px; border: 1px solid rgba(236,97,73,.7); border-radius: 20px; font-size: 15px; color: #ea6f5a; background-color: transparent; } .header_right-write { margin-left: 10px; padding-left: 10px; margin-right: 0px; color: #fff; background-color: #ea6f5a; } ``` 这样，经过四个操作步骤： 安装动画库：npm i react-transition-group -S 引入动画库 通过 CSSTransition 包裹 input 编写对应的 CSS 样式 我们就成功实现了 CSS 动画插件的引入及使用，此时页面显示为： 七 优化代码 返回目录 安装 Redux：npm i redux -S 安装 React-Redux：npm i react-redux -S 开始在代码中加入 Redux 和 React-Redux 首先，创建 store 文件夹，并在里面创建 index.js 和 reducer.js： src/store/index.js 代码详情 ```js import { createStore } from 'redux'; import reducer from './reducer'; const store = createStore(reducer); export default store; ``` src/store/reducer.js 代码详情 ```js const defaultState = { inputBlur: true }; export default (state = defaultState, action) => { return state; } ``` 接着，在 App.js 中引用 react-redux 以及 store/index.js： src/App.js 代码详情 ```js import React, { Component } from 'react'; import { Provider } from 'react-redux'; import Header from './common/header'; import store from './store'; class App extends Component { render() { return ( ); } } export default App; ``` 然后，修改 src 下 common 中 header 里面 index.js 中的内容： src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { render() { return ( 首页 下载App Aa 登录 注册 写文章 ) } } const mapStateToProps = (state) => { return { inputBlur: state.inputBlur } } const mapDispathToProps = (dispatch) => { return { searchFocusOrBlur() { const action = { type: 'search_focus_or_blur' } dispatch(action); } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 再来，我们再修改下 reducer.js，获取并处理 src/index.js 中 dispatch 过来的值： src/store/reducer.js 代码详情 ```js const defaultState = { inputBlur: true }; export default (state = defaultState, action) => { if(action.type === 'search_focus_or_blur') { const newState = JSON.parse(JSON.stringify(state)); newState.inputBlur = !newState.inputBlur return newState; } return state; } ``` 此时，我们完成了修改的步骤。同时，这时候因为 src 下 common 中 header 里面的 index.js 中只有 render 方法体，它构成了无状态组件，所以我们将其转换成无状态组件： src/common/header/index.js 代码详情 ```js import React from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import homeImage from '../../resources/img/header-home.png'; const Header = (props) => { return ( 首页 下载App Aa 登录 注册 写文章 ) } const mapStateToProps = (state) => { return { inputBlur: state.inputBlur } } const mapDispathToProps = (dispatch) => { return { searchFocusOrBlur() { const action = { type: 'search_focus_or_blur' } dispatch(action); } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 最后，我们完成了 Redux、React-Redux 的引用及使用，以及对 header/index.js 的无状态组件的升级。 由于我们只是将必要的数据存储到 state 中，所以样式和功能无变化，故不贴出效果图。 八 使用 redux-devtools-extension 插件 返回目录 修改 src/store/index.js 如下： src/store/index.js 代码详情 ```js import { createStore, compose } from 'redux'; import reducer from './reducer'; const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose; const store = createStore(reducer, composeEnhancers()) export default store; ``` 这时候，我们就成功开启之前安装过的 redux-devtools-extension 插件。 使用一下： 九 优化：抽取 reducer.js 返回目录 在项目开发中，我们会发现 reducer.js 随着项目的开发越来越庞大，最后到不可维护的地步。 该视频的慕课讲师也提到：当你的一个 js 文件代码量超过 300 行，说明它的设计从一开始来说就是不合理的。 所以，我们要想着进一步优化它。 首先，我们在 header 目录下，新建 store，并新建 reducer.js，将 src/store 的 reducer.js 中的内容剪切到 header/store/reducer.js 中： src/common/header/store/reducer.js 代码详情 ```js // 1. 将 reducer.js 转移到 header/store/reducer.js 中 const defaultState = { inputBlur: true }; export default (state = defaultState, action) => { if(action.type === 'search_focus_or_blur') { const newState = JSON.parse(JSON.stringify(state)); newState.inputBlur = !newState.inputBlur return newState; } return state; } ``` 然后，我们修改 src/store/reducer.js 的内容为： src/store/reducer.js 代码详情 ```js // 2. 通过 combineReducers 整合多个 reducer.js 文件 import { combineReducers } from 'redux'; import headerReducer from '../common/header/store/reducer'; const reducer = combineReducers({ header: headerReducer }) export default reducer; ``` 最后，我们修改 src/common/header/index.js 内容： src/common/header/index.js 代码详情 ```js // 代码省略 。。。 const mapStateToProps = (state) => { return { // 3. 因为引用的层级变了，所以需要修改 state.inputBlur 为 state.header.inputBlue inputBlur: state.header.inputBlur } } // 代码省略 。。。 ``` 在这里，我们需要知道的是：之前我们只有一层目录，所以修改的是 state.inputBlur。 但是，因为通过 combineReducers 将 reducer.js 进行了整合，所以需要修改为 state.header.inputBlur 至此，我们就完成了 reducer.js 的优化。 十 优化：抽取 action 返回目录 首先，在 header 的 store 中新建 actionCreators.js 文件： src/common/header/store/actionCreators.js 代码详情 ```js // 1. 定义 actionCreators export const searchFocusOrBlur = () => ({ type: 'search_focus_or_blur' }) ``` 然后，我们在 header 中的 index.js 文件引入 actionCreators.js，并在 mapDispathToProps 方法体中将其 dispatch 出去： src/common/header/index.js 代码详情 ```js import React from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; // 2. 以 actionCreators 的形式将所有 action 引入进来 import * as actionCreators from './store/actionCreators'; import homeImage from '../../resources/img/header-home.png'; const Header = (props) => { return ( 首页 下载App Aa 登录 注册 写文章 ) } const mapStateToProps = (state) => { return { inputBlur: state.header.inputBlur } } const mapDispathToProps = (dispatch) => { return { searchFocusOrBlur() { // 3. 使用 actionCreators dispatch(actionCreators.searchFocusOrBlur()); } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 接着，因为我们在 actionCreators.js 中使用的 type 是字符串，所以我们同样在 store 中创建 actionTypes.js，将其变成常量： src/common/header/store/actionTypes.js 代码详情 ```js export const SEARCH_FOCUS_OR_BLUR = 'search_focus_or_blur'; ``` 再然后，我们在 actionCreators.js 中引入 actionTypes.js： src/common/header/store/actionCreators.js 代码详情 ```js // 4. 引入常量 import { SEARCH_FOCUS_OR_BLUR } from './actionTypes'; // 1. 定义 actionCreators // 5. 将 action 中的字符串修改为常量 export const searchFocusOrBlur = () => ({ type: SEARCH_FOCUS_OR_BLUR }) ``` 再接着，我们修改下 header 目录中 store 下的 reducer.js，因为我们的字符串变成了常量，所以这里也需要做相应变更： src/common/header/store/reducer.js 代码详情 ```js // 6. 引入常量 import * as actionTypes from './actionTypes' const defaultState = { inputBlur: true }; export default (state = defaultState, action) => { // 7. 使用常量 if(action.type === actionTypes.SEARCH_FOCUS_OR_BLUR) { const newState = JSON.parse(JSON.stringify(state)); newState.inputBlur = !newState.inputBlur return newState; } return state; } ``` 然后，我们现在 header/store 目录下有：actionCreators.js、actionTypes.js、reducer.js 三个文件，如果我们每次引入都要一个一个找，那是相当麻烦的，所以我们在 header/store 目录下再新建一个 index.js，通过 index.js 来管理这三个文件，这样我们其他页面需要引入它们的时候，我们只需要引入 store 下的 index.js 即可。 src/common/header/store/index.js 代码详情 ```js // 8. 统一管理 store 目录中的文件 import * as actionCreators from './actionCreators'; import * as actionTypes from './actionTypes'; import reducer from './reducer'; export { actionCreators, actionTypes, reducer }; ``` 此时，值得注意的是，这时候我们需要处理下 header/index.js 文件： 代码详情 ```js import React from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; // 2. 以 actionCreators 的形式将所有 action 引入进来 // import * as actionCreators from './store/actionCreators'; // 9. 引入 store/index 文件即可 import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; // 代码省略 ``` 最后，再处理下 src/store/reducer.js，因为它引用了 common/header/store 中的 reducer.js： 代码详情 ```js import { combineReducers } from 'redux'; // 10. 修改下引用方式 import { reducer as headerReducer } from '../common/header/store'; const reducer = combineReducers({ header: headerReducer }) export default reducer; ``` 至此，我们就完成了本次的优化抽取。 十一 优化；immutable.js 返回目录 在我们工作的过程中，如果一不小心，就会修改了 reducer.js 中的数据（平时开发的时候，我们会通过 JSON.parse(JSON.stringify()) 来进行深拷贝，获取一份额外的来进行修改）。 所以，这时候，我们就需要使用 immutable.js，它是由 Facebook 团队开发的，用来帮助我们生产 immutable 对象，从而限制 state 不可被改变。 安装 immutable.js：npm i immutable -S。 案例 immutable.js： const { Map } = require('immutable'); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = map1.set('b', 50); map1.get('b') + \" vs. \" + map2.get('b'); // 2 vs. 50 看起来很简单，我们直接在简书 Demo 中使用： src/common/header/store/reducer.js 代码详情 ```js import * as actionTypes from './actionTypes' // 1. 通过 immutable 引入 fromJS import { fromJS } from 'immutable'; // 2. 对 defaultState 使用 fromJS const defaultState = fromJS({ inputBlur: true }); export default (state = defaultState, action) => { if(action.type === actionTypes.SEARCH_FOCUS_OR_BLUR) { // const newState = JSON.parse(JSON.stringify(state)); // newState.inputBlur = !newState.inputBlur // return newState; // 4. 通过 immutable 的方法来 set state 的值 // immutable 对象的 set 方法，会结合之前 immutable 对象的值和设置的值，返回一个全新的对象 return state.set('inputBlur', !state.get('inputBlur')); } return state; } ``` src/common/header/index.js 代码详情 ```js import React from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; const Header = (props) => { return ( 首页 下载App Aa 登录 注册 写文章 ) } const mapStateToProps = (state) => { return { // 3. 通过 immutable 提供的 get() 方法来获取 inputBlur 属性 inputBlur: state.header.get('inputBlur') } } const mapDispathToProps = (dispatch) => { return { searchFocusOrBlur() { dispatch(actionCreators.searchFocusOrBlur()); } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 我们大致做了四个步骤，从而完成了 immutable.js 的引用及使用： 通过 import immutable 引入 fromJS 对 defaultState 使用 fromJS 这时候我们就不能直接修改 matStateToProps 中的值了，而是 通过 immutable 提供的 get() 方法来获取 inputBlur 属性 通过 immutable 的方法来 set state 的值。immutable 对象的 set 方法，会结合之前 immutable 对象的值和设置的值，返回一个全新的对象 这样，我们就成功保护了 state 的值。 十二 优化：redux-immutable 返回目录 当然，在上面，我们保护了 header 中的 state，我们在代码中： inputBlur: state.header.get('inputBlur') 这个 header 也是 state 的值，所以我们也需要对它进行保护，所以我们就需要 redux-immutable 安装 redux-immutable：npm i redux-immutable -S 使用 redux-immutable： src/store/reducer.js 代码详情 ```js // import { combineReducers } from 'redux'; // 1. 通过 redux-immutable 引入 combineReducers 而非原先的 redux import { combineReducers } from 'redux-immutable'; import { reducer as headerReducer } from '../common/header/store'; const reducer = combineReducers({ header: headerReducer }) export default reducer; ``` src/common/header/index.js 代码详情 ```js // 代码省略。。。 const mapStateToProps = (state) => { return { // 2. 通过同样的 get 方法来获取 header inputBlur: state.get('header').get('inputBlur') } } // 代码省略。。。 ``` 这样，通过简单的三个步骤，我们就保护了主 state 的值： 安装 redux-immutable：npm i redux-immutable -S 通过 redux-immutable 引入 combineReducers 而非原先的 redux 通过同样的 get 方法来获取 header 十三 功能实现：热门搜索 返回目录 本章节完成三个功能： 写热门搜索显示隐藏 安装 redux-thunk 使用 React 中 Node 提供的作假数据的功能，在 public/api 下写个文件 headerList.json，并做假数据，使用方式为 axios.get('/api/headerList.json').then() 首先，我们完成热门搜索的显示隐藏： src/common.css 代码详情 ```css .icon { display: inline-block; width: 20px; height: 21px; margin-right: 5px; } .icon-home { background: url('./resources/img/icon-home.png') no-repeat center; background-size: 100%; } .icon-write { background: url('./resources/img/icon-write.png') no-repeat center; background-size: 100%; } .icon-download { background: url('./resources/img/icon-download.png') no-repeat center; background-size: 100%; } .icon-search { background: url('./resources/img/icon-search.png') no-repeat center; background-size: 100%; } .display-hide { display: none; } .display-show { display: block; } ``` src/common/header/index.css 代码详情 ```css header { width: 100%; height: 58px; display: flex; align-items: center; border-bottom: 1px solid #ccc; font-size: 17px; } /* 头部左边 */ .header_left-img { width: 100px; height: 56px; } /* 头部中间 */ .header_center { width: 1000px; margin: 0 auto; display: flex; justify-content: space-between; } .nav-item { margin-right: 30px; display: flex; align-items: center; } /* 头部中间左部 */ .header_center-left { display: flex; } /* 头部中间左部 - 首页 */ .header_center-left-home { color: #ea6f5a; } /* 头部中间左部 - 搜索框 */ .header_center-left-search { position: relative; } .slide-enter { transition: all .2s ease-out; } .slide-enter-active { width: 280px; } .slide-exit { transition: all .2s ease-out; } .silde-exit-active { width: 240px; } .header_center-left-search input { width: 240px; padding: 0 45px 0 20px; height: 38px; font-size: 14px; border: 1px solid #eee; border-radius: 40px; background: #eee; } .header_center-left-search .input-active { width: 280px; } .header_center-left-search .icon-search { position: absolute; top: 8px; right: 10px; } .header_center-left-search .icon-active { padding: 3px; top: 4px; border-radius: 15px; border: 1px solid #ea6f5a; } /* 头部中间左部 - 热搜 */ .header_center-left-search .icon-active:hover { cursor: pointer; } .header_center-left-hot-search:before { content: \"\"; left: 27px; width: 10px; height: 10px; transform: rotate(45deg); top: -5px; z-index: -1; position: absolute; background-color: #fff; box-shadow: 0 0 8px rgba(0,0,0,.2); } .header_center-left-hot-search { position: absolute; width: 250px; left: 0; top: 125%; padding: 15px; font-size: 14px; background: #fff; border-radius: 4px; box-shadow: 0 0 8px rgba(0, 0, 0, 0.2); } .header_center-left-hot-search-title { display: flex; justify-content: space-between; color: #969696; } .header_center-left-hot-search-change { display: flex; justify-content: space-between; align-items: center; } .icon-change { display: inline-block; width: 20px; height: 14px; background: url('../../resources/img/icon-change.png') no-repeat center; background-size: 100%; } .icon-change:hover { cursor: pointer; } .header_center-left-hot-search-content span { display: inline-block; margin-top: 10px; margin-right: 10px; padding: 2px 6px; font-size: 12px; color: #787878; border: 1px solid #ddd; border-radius: 3px; } .header_center-left-hot-search-content span:hover { cursor: pointer; } /* 头部中间右部 */ .header_center-right { display: flex; color: #969696; } /* 头部右边 */ .header_right-register, .header_right-write { width: 80px; text-align: center; height: 38px; line-height: 38px; border: 1px solid rgba(236,97,73,.7); border-radius: 20px; font-size: 15px; color: #ea6f5a; background-color: transparent; } .header_right-write { margin-left: 10px; padding-left: 10px; margin-right: 0px; color: #fff; background-color: #ea6f5a; } ``` src/common/header/index.js 代码详情 ```js import React from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; const Header = (props) => { return ( 首页 下载App {/* 添加热搜模块 */} 热门搜索 换一批 考研 慢死人 悦心 一致 是的 jsliang Aa 登录 注册 写文章 ) } const mapStateToProps = (state) => { return { inputBlur: state.get('header').get('inputBlur') } } const mapDispathToProps = (dispatch) => { return { searchFocusOrBlur() { dispatch(actionCreators.searchFocusOrBlur()); } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 由此，我们完成了热门搜索的显示隐藏： PS：由于页面逐渐增大，所以我们 header 中使用无状态组件已经满足不了我们要求了，我们需要将无状态组件改成正常的组件： src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { render() { return ( 首页 下载App 热门搜索 换一批 考研 慢死人 悦心 一致 是的 jsliang Aa 登录 注册 写文章 ) } } const mapStateToProps = (state) => { return { inputBlur: state.get('header').get('inputBlur') } } const mapDispathToProps = (dispatch) => { return { searchFocusOrBlur() { dispatch(actionCreators.searchFocusOrBlur()); } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 然后，由于我们的数据是从接口模拟过来的，而在上一篇文章说过，如果要对接口代码进行管理，最好使用 Redux-Thunk 和 Redux-Saga，这里我们使用 Redux-Thunk： 安装 redux-thunk：cnpm i redux-thunk -S 安装 axios：cnpm i axios -S 在这里，我们要知道 create-react-app 的配置是包含 Node.js 的，所以我们可以依靠 Node.js 进行开发时候的 Mock 数据。 下面开始开发： src/store/index.js 代码详情 ```js // 2. 引入 redux 的 applyMiddleware，进行多中间件的使用 import { createStore, compose, applyMiddleware } from 'redux'; // 1. 引入 redux-thunk import thunk from 'redux-thunk'; import reducer from './reducer'; const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose; // 3. 通过 applyMiddleware 同时使用 redux-thunk 和 redux-dev-tools const store = createStore(reducer, composeEnhancers( applyMiddleware(thunk) )); export default store; ``` 引入 redux-thunk 引入 redux 的 applyMiddleware，进行多中间件的使用 通过 applyMiddleware 同时使用 redux-thunk 和 redux-dev-tools 这样，我们就可以正常使用 redux-thunk 了。 src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { render() { return ( 首页 下载App 热门搜索 换一批 {/* 15. 遍历输出该数据 */} { this.props.list.map((item) => { return {item} }) } Aa 登录 注册 写文章 ) } } const mapStateToProps = (state) => { return { inputBlur: state.get('header').get('inputBlur'), // 14. 获取 reducer.js 中的 list 数据 list: state.get('header').get('list') } } const mapDispathToProps = (dispatch) => { return { searchFocusOrBlur() { // 4. 派发 action 到 actionCreators.js 中的 getList() 方法 dispatch(actionCreators.getList()); dispatch(actionCreators.searchFocusOrBlur()); } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` src/common/header/store/actionCreators.js 代码详情 ```js import * as actionTypes from './actionTypes' // 7. 引入 axios import axios from 'axios'; // 11. 引入 immutable 的类型转换 import { fromJS } from 'immutable'; export const searchFocusOrBlur = () => ({ type: actionTypes.SEARCH_FOCUS_OR_BLUR }) // 10. 定义 action，接受参数 data，同时因为我们使用了 Immutable，所以需要将获取的数据转换为 immutable 类型 const changeList = (data) => ({ type: actionTypes.GET_LIST, data: fromJS(data) }) // 5. 编写 getList 的 action，由于需要 actionTypes 中定义，所以前往 actionTypes.js 中新增 export const getList = () => { return (dispatch) => { // 8. 调用 create-react-app 中提供的 Node 服务器，从而 mock 数据 axios.get('/api/headerList.json').then( (res) => { if(res.data.code === 0) { const data = res.data.list; // 由于数据太多，我们限制数据量为 15 先 data.length = 15; // 12. 派发 changeList 类型 dispatch(changeList(data)); } }).catch( (error) => { console.log(error); }); } } ``` src/common/header/store/actionTypes.js 代码详情 ```js export const SEARCH_FOCUS_OR_BLUR = 'header/search_focus_or_blur'; // 6. 新增 actionType export const GET_LIST = 'header/get_list'; ``` src/common/header/store/reducer.js 代码详情 ```js import * as actionTypes from './actionTypes' import { fromJS } from 'immutable'; const defaultState = fromJS({ inputBlur: true, // 9. 给 header 下的 reducer.js 提供存储数据的地方 list: [] }); export default (state = defaultState, action) => { if(action.type === actionTypes.SEARCH_FOCUS_OR_BLUR) { return state.set('inputBlur', !state.get('inputBlur')); } // 13. 判断 actionTypes 是否为 GET_LIST，如果是则执行该 action if(action.type === actionTypes.GET_LIST) { return state.set('list', action.data); } return state; } ``` public/api/headerList.json 代码详情 ```js { \"code\": 0, \"list\": [\"区块链\",\"小程序\",\"vue\",\"毕业\",\"PHP\",\"故事\",\"flutter\",\"理财\",\"美食\",\"投稿\",\"手帐\",\"书法\",\"PPT\",\"穿搭\",\"打碗碗花\",\"简书\",\"姥姥的澎湖湾\",\"设计\",\"创业\",\"交友\",\"籽盐\",\"教育\",\"思维导图\",\"疯哥哥\",\"梅西\",\"时间管理\",\"golang\",\"连载\",\"自律\",\"职场\",\"考研\",\"慢世人\",\"悦欣\",\"一纸vr\",\"spring\",\"eos\",\"足球\",\"程序员\",\"林露含\",\"彩铅\",\"金融\",\"木风杂谈\",\"日更\",\"成长\",\"外婆是方言\",\"docker\"] } ``` 通过下面步骤： 派发 action 到 actionCreators.js 中的 getList() 方法 编写 getList 的 action，由于需要 actionTypes 中定义，所以前往 actionTypes.js 中新增 新增 actionType 引入 axios 调用 create-react-app 中提供的 Node 服务器，从而 mock 数据 给 header 下的 reducer.js 提供存储数据的地方 定义 action，接受参数 data，同时因为我们使用了 Immutable，所以需要将获取的数据转换为 immutable 类型 引入 Immutable 的类型转换 派发 changeList 类型 判断 actionTypes 是否为 GET_LIST，如果是则执行该 action 获取 reducer.js 中的 list 数据 遍历输出该数据 这样，我们就成功地获取了 mock 提供的数据： 十四 代码优化 返回目录 reducer.js 中使用 switch...case... 替换掉 if... 语句。 src/common/header/store/reducer.js 代码详情 ```js import * as actionTypes from './actionTypes' import { fromJS } from 'immutable'; const defaultState = fromJS({ inputBlur: true, list: [] }); export default (state = defaultState, action) => { switch(action.type) { case actionTypes.SEARCH_FOCUS_OR_BLUR: return state.set('inputBlur', !state.get('inputBlur')); case actionTypes.GET_LIST: return state.set('list', action.data); default: return state; } } ``` 十五 解决历史遗留问题 返回目录 在这里，我们解决下历史遗留问题：在我们失焦于输入框的时候，我们的【热门搜索】模块就会消失，从而看不到我们点击【换一换】按钮的效果，所以我们需要修改下代码，在我们鼠标在【热门模块】中时，这个模块不会消失，当我们鼠标失焦且鼠标不在热门模块中时，热门模块才消失。 src/common/header/store/reducer.js 代码详情 ```js import * as actionTypes from './actionTypes' import { fromJS } from 'immutable'; const defaultState = fromJS({ inputFocus: false, // 1. 设置鼠标移动到热门模块为 false mouseInHot: false, list: [], }); export default (state = defaultState, action) => { switch(action.type) { case actionTypes.SEARCH_FOCUS: return state.set('inputFocus', true); case actionTypes.SEARCH_BLUR: return state.set('inputFocus', false); case actionTypes.GET_LIST: return state.set('list', action.data); // 6. 在 reducer.js 中判断这两个 action 执行设置 mouseInHot case actionTypes.ON_MOUSE_ENTER_HOT: return state.set('mouseInHot', true); case actionTypes.ON_MOUSE_LEAVE_HOT: return state.set('mouseInHot', false); default: return state; } } ``` src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { render() { return ( 首页 下载App {/* 8. 在判断中加多一个 this.props.mouseInHot，这样只要有一个为 true，它就不会消失 */} 热门搜索 换一批 { this.props.list.map((item) => { return {item} }) } Aa 登录 注册 写文章 ) } } const mapStateToProps = (state) => { return { inputFocus: state.get('header').get('inputFocus'), list: state.get('header').get('list'), // 7. 在 index.js 中获取 mouseInHot: state.get('header').get('mouseInHot'), } } const mapDispathToProps = (dispatch) => { return { searchFocus() { dispatch(actionCreators.getList()); dispatch(actionCreators.searchFocus()); }, searchBlur() { dispatch(actionCreators.searchBlur()); }, // 3. 定义 onMouseEnterHot 和 onMouseLeaveHot 方法 onMouseEnterHot() { dispatch(actionCreators.onMouseEnterHot()); }, onMouseLeaveHot() { dispatch(actionCreators.onMouseLeaveHot()); }, } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` src/common/header/store/actionCreators.js 代码详情 ```js import * as actionTypes from './actionTypes' import axios from 'axios'; import { fromJS } from 'immutable'; export const searchFocus = () => ({ type: actionTypes.SEARCH_FOCUS }) export const searchBlur = () => ({ type: actionTypes.SEARCH_BLUR }) // 4. 在 actionCreators.js 中定义这两个方法：onMouseEnterHot 和 onMouseLeaveHot export const onMouseEnterHot = () => ({ type: actionTypes.ON_MOUSE_ENTER_HOT, }) export const onMouseLeaveHot = () => ({ type: actionTypes.ON_MOUSE_LEAVE_HOT, }) export const getList = () => { return (dispatch) => { axios.get('/api/headerList.json').then( (res) => { if(res.data.code === 0) { const data = res.data.list; // 由于数据太多，我们限制数据量为 15 先 data.length = 15; dispatch(changeList(data)); } }).catch( (error) => { console.log(error); }); } } const changeList = (data) => ({ type: actionTypes.GET_LIST, data: fromJS(data) }) ``` src/common/header/store/actionTypes.js 代码详情 ```js export const SEARCH_FOCUS = 'header/search_focus'; export const SEARCH_BLUR = 'header/search_blur'; export const GET_LIST = 'header/get_list'; // 5. 在 actionTypes.js 中新增 action 类型 export const ON_MOUSE_ENTER_HOT = 'header/on_mouse_enter_hot'; export const ON_MOUSE_LEAVE_HOT = 'header/on_mouse_leave_hot'; ``` 我们先看实现： 然后我们看看实现逻辑： 在 reducer.js 中设置鼠标移动到热门模块为 false 在 index.js 中设置移入为 onMouseEnterHot，移出为 onMouseLeaveHot 在 index.js 中 mapDispathToProps 定义 onMouseEnterHot 和 onMouseLeaveHot 方法 在 actionCreators.js 中定义这两个方法：onMouseEnterHot 和 onMouseLeaveHot 在 actionTypes.js 中新增 action 类型 在 reducer.js 中判断这两个 action 执行设置 mouseInHot 在 index.js 中 mapStateToProps 获取 mouseInHot 在 index.js 中的判断中加多一个 this.props.mouseInHot，这样只要有一个为 true，它就不会消失 注意：由于之前设置的 this.props.inputFoucsOrBlur 会造成聚焦和失焦都会调用一次接口，而且逻辑比较复杂，容易出错，所以这里我们进行了修改，将其分为聚焦和失焦两部分。 十六 功能实现：换一换 返回目录 下面我们开始做换一换功能： src/common/header/store/reducer.js 代码详情 ```js import * as actionTypes from './actionTypes' import { fromJS } from 'immutable'; const defaultState = fromJS({ inputFocus: false, mouseInHot: false, list: [], // 1. 在 reducer.js 中设置页数和总页数 page: 1, totalPage: 1, }); export default (state = defaultState, action) => { switch(action.type) { case actionTypes.SEARCH_FOCUS: return state.set('inputFocus', true); case actionTypes.SEARCH_BLUR: return state.set('inputFocus', false); case actionTypes.GET_LIST: // 4. 我们通过 merge 方法同时设置多个 state 值 return state.merge({ list: action.data, totalPage: action.totalPage }); case actionTypes.ON_MOUSE_ENTER_HOT: return state.set('mouseInHot', true); case actionTypes.ON_MOUSE_LEAVE_HOT: return state.set('mouseInHot', false); // 11. 判断 action 类型，并进行设置 case actionTypes.CHANGE_PAGE: return state.set('page', action.page + 1); default: return state; } } ``` src/common/header/store/actionCreators.js 代码详情 ```js import * as actionTypes from './actionTypes' import axios from 'axios'; import { fromJS } from 'immutable'; export const searchFocus = () => ({ type: actionTypes.SEARCH_FOCUS }) export const searchBlur = () => ({ type: actionTypes.SEARCH_BLUR }) export const onMouseEnterHot = () => ({ type: actionTypes.ON_MOUSE_ENTER_HOT, }) export const onMouseLeaveHot = () => ({ type: actionTypes.ON_MOUSE_LEAVE_HOT, }) export const getList = () => { return (dispatch) => { axios.get('/api/headerList.json').then( (res) => { if(res.data.code === 0) { const data = res.data.list; // 2. 由于数据太多，我们之前限制数据量为 15，这里我们去掉该行代码 // data.length = 15; dispatch(changeList(data)); } }).catch( (error) => { console.log(error); }); } } const changeList = (data) => ({ type: actionTypes.GET_LIST, data: fromJS(data), // 3. 我们在这里计算总页数 totalPage: Math.ceil(data.length / 10) }) // 9. 定义 changePage 方法 export const changePage = (page) => ({ type: actionTypes.CHANGE_PAGE, page: page, }) ``` src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { render() { return ( 首页 下载App 热门搜索 {/* 7. 进行换页功能实现，传递参数 page 和 totalPage */} this.props.changePage(this.props.page, this.props.totalPage)}> 换一批 { // 6. 在 index.js 中进行计算： // 一开始显示 0-9 共 10 条，换页的时候显示 10-19 ……以此类推 this.props.list.map((item, index) => { if(index >= (this.props.page - 1) * 10 && index {item} } else { return ''; } }) } Aa 登录 注册 写文章 ) } } const mapStateToProps = (state) => { return { inputFocus: state.get('header').get('inputFocus'), list: state.get('header').get('list'), mouseInHot: state.get('header').get('mouseInHot'), // 5. 在 index.js 中 mapStateToProps 获取数据 page: state.get('header').get('page'), totalPage: state.get('header').get('totalPage'), } } const mapDispathToProps = (dispatch) => { return { searchFocus() { dispatch(actionCreators.getList()); dispatch(actionCreators.searchFocus()); }, searchBlur() { dispatch(actionCreators.searchBlur()); }, onMouseEnterHot() { dispatch(actionCreators.onMouseEnterHot()); }, onMouseLeaveHot() { dispatch(actionCreators.onMouseLeaveHot()); }, // 8. 调用 changePage 方法 changePage(page, totalPage) { if(page === totalPage) { page = 1; dispatch(actionCreators.changePage(page)); } else { dispatch(actionCreators.changePage(page)); } } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` src/common/header/store/actionTypes.js 代码详情 ```js export const SEARCH_FOCUS = 'header/search_focus'; export const SEARCH_BLUR = 'header/search_blur'; export const GET_LIST = 'header/get_list'; export const ON_MOUSE_ENTER_HOT = 'header/on_mouse_enter_hot'; export const ON_MOUSE_LEAVE_HOT = 'header/on_mouse_leave_hot'; // 10. 定义 action export const CHANGE_PAGE = 'header/change_page'; ``` 此时我们代码思路是： 在 reducer.js 中设置页数 page 和总页数 totalPage 在 actionCreators.js 中，之前由于数据太多，我们之前限制数据量为 15，这里我们去掉该行代码 在 actionCreators.js 这里计算总页数 在 reducer.js 中通过 merge 方法同时设置多个 state 值 在 index.js 中 mapStateToProps 获取数据 在 index.js 中进行计算：一开始显示 0-9 共 10 条，换页的时候显示 10-19 ……以此类推 在 index.js 中进行换页功能实现，传递参数 page 和 totalPage 在 index.js 调用 changePage 方法，进行是否重置为第一页判断，并 dispatch 方法 在 actionCreators.js 中定义 changePage 方法 在 actionTypes.js 中定义 action 在 reducer.js 中判断 action 类型，并进行设置 如此，我们就实现了换一换功能： 十七 功能优化 返回目录 17.1 换一换图标旋转 返回目录 src/common/header/index.css 代码详情 ```css header { width: 100%; height: 58px; display: flex; align-items: center; border-bottom: 1px solid #ccc; font-size: 17px; } /* 头部左边 */ .header_left-img { width: 100px; height: 56px; } /* 头部中间 */ .header_center { width: 1000px; margin: 0 auto; display: flex; justify-content: space-between; } .nav-item { margin-right: 30px; display: flex; align-items: center; } /* 头部中间左部 */ .header_center-left { display: flex; } /* 头部中间左部 - 首页 */ .header_center-left-home { color: #ea6f5a; } /* 头部中间左部 - 搜索框 */ .header_center-left-search { position: relative; } .slide-enter { transition: all .2s ease-out; } .slide-enter-active { width: 280px; } .slide-exit { transition: all .2s ease-out; } .silde-exit-active { width: 240px; } .header_center-left-search input { width: 240px; padding: 0 45px 0 20px; height: 38px; font-size: 14px; border: 1px solid #eee; border-radius: 40px; background: #eee; } .header_center-left-search .input-active { width: 280px; } .header_center-left-search .icon-search { position: absolute; top: 8px; right: 10px; } .header_center-left-search .icon-active { padding: 3px; top: 4px; border-radius: 15px; border: 1px solid #ea6f5a; } /* 头部中间左部 - 热搜 */ .header_center-left-search .icon-active:hover { cursor: pointer; } .header_center-left-hot-search:before { content: \"\"; left: 27px; width: 10px; height: 10px; transform: rotate(45deg); top: -5px; z-index: -1; position: absolute; background-color: #fff; box-shadow: 0 0 8px rgba(0,0,0,.2); } .header_center-left-hot-search { position: absolute; width: 250px; left: 0; top: 125%; padding: 15px; font-size: 14px; background: #fff; border-radius: 4px; box-shadow: 0 0 8px rgba(0, 0, 0, 0.2); } .header_center-left-hot-search-title { display: flex; justify-content: space-between; color: #969696; } .header_center-left-hot-search-change { display: flex; justify-content: space-between; align-items: center; } .icon-change { display: inline-block; width: 20px; height: 14px; background: url('../../resources/img/icon-change.png') no-repeat center; background-size: 100%; /* 1. 在 index.css 中添加动画 */ transition: all .2s ease-in; transform-origin: center center; } .icon-change:hover { cursor: pointer; } .span-change:hover { cursor: pointer; } .header_center-left-hot-search-content span { display: inline-block; margin-top: 10px; margin-right: 10px; padding: 2px 6px; font-size: 12px; color: #787878; border: 1px solid #ddd; border-radius: 3px; } .header_center-left-hot-search-content span:hover { cursor: pointer; } /* 头部中间右部 */ .header_center-right { display: flex; color: #969696; } /* 头部右边 */ .header_right-register, .header_right-write { width: 80px; text-align: center; height: 38px; line-height: 38px; border: 1px solid rgba(236,97,73,.7); border-radius: 20px; font-size: 15px; color: #ea6f5a; background-color: transparent; } .header_right-write { margin-left: 10px; padding-left: 10px; margin-right: 0px; color: #fff; background-color: #ea6f5a; } ``` src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { render() { return ( 首页 下载App 热门搜索 {/* 2. 在 index.js 中给 i 标签添加 ref，并通过 changePage 方法传递过去 */} this.props.changePage(this.props.page, this.props.totalPage, this.spinIcon)}> {this.spinIcon = icon}}> 换一批 { this.props.list.map((item, index) => { if(index >= (this.props.page - 1) * 10 && index {item} } else { return ''; } }) } Aa 登录 注册 写文章 ) } } const mapStateToProps = (state) => { return { inputFocus: state.get('header').get('inputFocus'), list: state.get('header').get('list'), mouseInHot: state.get('header').get('mouseInHot'), page: state.get('header').get('page'), totalPage: state.get('header').get('totalPage'), } } const mapDispathToProps = (dispatch) => { return { searchFocus() { dispatch(actionCreators.getList()); dispatch(actionCreators.searchFocus()); }, searchBlur() { dispatch(actionCreators.searchBlur()); }, onMouseEnterHot() { dispatch(actionCreators.onMouseEnterHot()); }, onMouseLeaveHot() { dispatch(actionCreators.onMouseLeaveHot()); }, changePage(page, totalPage, spinIcon) { // 3. 在 index.js 中设置它原生 DOM 的 CSS 属性 if(spinIcon.style.transform === 'rotate(360deg)') { spinIcon.style.transform = 'rotate(0deg)'; } else { spinIcon.style.transform = 'rotate(360deg)'; } if(page === totalPage) { page = 1; dispatch(actionCreators.changePage(page)); } else { dispatch(actionCreators.changePage(page)); } } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 这里我们通过三个步骤实现了图标旋转： 在 index.css 中添加动画 在 index.js 中给 i 标签添加 ref，并通过 changePage 方法传递过去 在 index.js 中设置它原生 DOM 的 CSS 属性 实现效果如下： 17.2 避免聚焦重复请求 返回目录 在代码中，我们每次聚焦，都会请求数据，所以我们需要根据 list 的值来判断是否请求数据： src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { render() { return ( 首页 下载App this.props.searchFocus(this.props.list)} onBlur={this.props.searchBlur} /> 热门搜索 this.props.changePage(this.props.page, this.props.totalPage, this.spinIcon)}> {this.spinIcon = icon}}> 换一批 { this.props.list.map((item, index) => { if(index >= (this.props.page - 1) * 10 && index {item} } else { return ''; } }) } Aa 登录 注册 写文章 ) } } const mapStateToProps = (state) => { return { inputFocus: state.get('header').get('inputFocus'), list: state.get('header').get('list'), mouseInHot: state.get('header').get('mouseInHot'), page: state.get('header').get('page'), totalPage: state.get('header').get('totalPage'), } } const mapDispathToProps = (dispatch) => { return { searchFocus(list) { // 2. 判断 list 的 size 是不是等于 0，是的话才请求数据（第一次），不是的话则不请求 if(list.size === 0) { dispatch(actionCreators.getList()); } dispatch(actionCreators.searchFocus()); }, searchBlur() { dispatch(actionCreators.searchBlur()); }, onMouseEnterHot() { dispatch(actionCreators.onMouseEnterHot()); }, onMouseLeaveHot() { dispatch(actionCreators.onMouseLeaveHot()); }, changePage(page, totalPage, spinIcon) { if(spinIcon.style.transform === 'rotate(360deg)') { spinIcon.style.transform = 'rotate(0deg)'; } else { spinIcon.style.transform = 'rotate(360deg)'; } if(page === totalPage) { page = 1; dispatch(actionCreators.changePage(page)); } else { dispatch(actionCreators.changePage(page)); } } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 在这里，我们做了两个步骤： 给 searchFocus 传递 list 在 searchFocus 中判断 list 的 size 是不是等于 0，是的话才请求数据（第一次），不是的话则不请求 这样，我们就成功避免聚焦重复请求。 十八 React 路由 返回目录 18.1 路由（一） 返回目录 什么是路由？ 前端路由就是根据 URL 的不同，显示不同的内容。 安装 React 的路由：npm i react-router-dom -S 安装完毕之后，我们只需要修改下 src/App.js，就可以体验到路由： src/App.js 代码详情 ```js import React, { Component } from 'react'; import { Provider } from 'react-redux'; import Header from './common/header'; import store from './store'; // 1. 引入 React 路由的 BrowserRouter 和 Route import { BrowserRouter, Route } from 'react-router-dom'; class App extends Component { render() { return ( {/* 2. 在页面中使用 React 路由 */} HOME}> DETAIL}> ); } } export default App; ``` 在这里我们仅需要做两个步骤： 引入 React 路由的 BrowserRouter 和 Route 在页面中使用 React 路由 这样，我们就实现了路由： 18.2 路由（二） 返回目录 在 src 下新建 pages 文件夹，然后在该文件夹下新建文件夹和文件： src/pages/detail/index.js src/pages/home/index.js 它们的内容如下： src/pages/detail/index.js 代码详情 ```js import React, { Component } from 'react' class Detail extends Component { render() { return ( Detail ) } } export default Detail; ``` src/pages/home/index.js 代码详情 ```js import React, { Component } from 'react' class Home extends Component { render() { return ( Home ) } } export default Home; ``` 在有 header 的经验下，我们应该知道，我们希望在 URL 输入路径 localhost:3000 的时候，访问 home 组件；在输入 localhost:3000/detail 的时候，访问 detail 组件。 到这步，我们仅需要修改下 src/App.js，就可以实现目标： src/App.js 代码详情 ```js import React, { Component } from 'react'; import { Provider } from 'react-redux'; import Header from './common/header'; import store from './store'; import { BrowserRouter, Route } from 'react-router-dom'; // 1. 引入 Home、Detail 组件 import Home from './pages/home'; import Detail from './pages/detail'; class App extends Component { render() { return ( {/* 2. 在页面中引用组件 */} ); } } export default App; ``` 现在，我们切换下路由，就可以看到不用的页面，这些页面我们也可以通过编辑对应的 index.js 来修改了。 十九 页面实现：二级导航栏 返回目录 由于前面有过编程经验了，所以在这里我们就不多说废话，直接进行实现。 「简书」因违反《网络安全法》《互联网信息服务管理办法》《互联网新闻信息服务管理规定》等相关法律法规，严重危害互联网信息传播秩序，根据网信主管部门要求，从 2019 年 4 月 13 日 0 时至 4 月 19 日 0 时，暂停更新 PC 端上的内容，并对所有平台上的内容进行全面彻底的整改。 没法，本来想根据简书的首页继续编写的，但是恰巧碰到简书出问题了，只好拿掘金的首页和详情页来实现了。 我们将掘金首页划分为 3 个模块：顶部 TopNav、左侧 LeftList、右侧 RightRecommend。所以我们在 home 下面新建个 components 目录，用来存放这三个组件。同时，在开发 common/header 的时候，我们也知道，还需要一个 store 文件夹，用来存放 reducer.js 等： - pages - detail - index.js - home - components - LeftList.js - RightRecommend.js - TopNav.js - store - actionCreators.js - actionTypes.js - index.js - reducer.js - index.css - index.js src/index.css 代码详情 ```css body { background: #f4f5f5; } ``` src/App.js 代码详情 ```js import React, { Component } from 'react'; import { Provider } from 'react-redux'; import Header from './common/header'; import store from './store'; import { BrowserRouter, Route } from 'react-router-dom'; import Home from './pages/home'; import Detail from './pages/detail'; class App extends Component { render() { return ( ); } } export default App; ``` src/common/header/index.css 代码详情 ```css header { position: fixed; top: 0; left: 0; width: 100%; height: 58px; display: flex; align-items: center; border-bottom: 1px solid #f1f1f1; font-size: 17px; background: #fff; } /* 头部左边 */ .header_left-img { width: 100px; height: 56px; } /* 头部中间 */ .header_center { width: 1000px; margin: 0 auto; display: flex; justify-content: space-between; } .nav-item { margin-right: 30px; display: flex; align-items: center; } /* 头部中间左部 */ .header_center-left { display: flex; } /* 头部中间左部 - 首页 */ .header_center-left-home { color: #ea6f5a; } /* 头部中间左部 - 搜索框 */ .header_center-left-search { position: relative; } .slide-enter { transition: all .2s ease-out; } .slide-enter-active { width: 280px; } .slide-exit { transition: all .2s ease-out; } .silde-exit-active { width: 240px; } .header_center-left-search { z-index: 999; } .header_center-left-search input { width: 240px; padding: 0 45px 0 20px; height: 38px; font-size: 14px; border: 1px solid #eee; border-radius: 40px; background: #eee; } .header_center-left-search .input-active { width: 280px; } .header_center-left-search .icon-search { position: absolute; top: 8px; right: 10px; } .header_center-left-search .icon-active { padding: 3px; top: 4px; border-radius: 15px; border: 1px solid #ea6f5a; } /* 头部中间左部 - 热搜 */ .header_center-left-search .icon-active:hover { cursor: pointer; } .header_center-left-hot-search:before { content: \"\"; left: 27px; width: 10px; height: 10px; transform: rotate(45deg); top: -5px; z-index: -1; position: absolute; background-color: #fff; box-shadow: 0 0 8px rgba(0,0,0,.2); } .header_center-left-hot-search { position: absolute; width: 250px; left: 0; top: 125%; padding: 15px; font-size: 14px; background: #fff; border-radius: 4px; box-shadow: 0 0 8px rgba(0, 0, 0, 0.2); } .header_center-left-hot-search-title { display: flex; justify-content: space-between; color: #969696; } .header_center-left-hot-search-change { display: flex; justify-content: space-between; align-items: center; } .icon-change { display: inline-block; width: 20px; height: 14px; background: url('../../resources/img/icon-change.png') no-repeat center; background-size: 100%; transition: all .2s ease-in; transform-origin: center center; } .icon-change:hover { cursor: pointer; } .span-change:hover { cursor: pointer; } .header_center-left-hot-search-content span { display: inline-block; margin-top: 10px; margin-right: 10px; padding: 2px 6px; font-size: 12px; color: #787878; border: 1px solid #ddd; border-radius: 3px; } .header_center-left-hot-search-content span:hover { cursor: pointer; } /* 头部中间右部 */ .header_center-right { display: flex; color: #969696; } /* 头部右边 */ .header_right-register, .header_right-write { width: 80px; text-align: center; height: 38px; line-height: 38px; border: 1px solid rgba(236,97,73,.7); border-radius: 20px; font-size: 15px; color: #ea6f5a; background-color: transparent; } .header_right-write { margin-left: 10px; padding-left: 10px; margin-right: 0px; color: #fff; background-color: #ea6f5a; } ``` src/pages/home/index.js 代码详情 ```js import React, { Component } from 'react'; import LeftList from './components/LeftList'; import RightRecommend from './components/RightRecommend'; import TopNav from './components/TopNav'; import './index.css'; class Home extends Component { render() { return ( ) } } export default Home; ``` src/pages/home/index.css 代码详情 ```css /* 主体 */ .container { width: 960px; margin: 0 auto; } .main-container { display: flex; } /* 顶部 */ .top-nav { position: fixed; left: 0; top: 59px; width: 100%; height: 46px; line-height: 46px; z-index: 100; box-shadow: 0 1px 2px 0 rgba(0,0,0,.05); font-size: 14px; background: #fff; } .top-nav-list { display: flex; width: 960px; margin: auto; position: relative; } .top-nav-list-item a { height: 100%; align-items: center; display: flex; flex-shrink: 0; color: #71777c; padding-right: 12px; } .active a { color: #007fff; } .top-nav-list-right { position: absolute; top: 0; right: 0; } /* 主内容 */ .main-container { margin-top: 120px; } /* 左侧 */ .left-list { width: 650px; height: 1000px; background: #fff; } /* 右侧 */ .right-recommend { width: 295px; height: 1000px; margin-left: 15px; background: #fff; } ``` src/pages/home/components/TopNav.js 代码详情 ```js import React, { Component } from 'react'; import { Link } from 'react-router-dom'; class TopNav extends Component { render() { return ( 推荐 关注 后端 前端 Android IOS 人工智能 开发工具 代码人生 阅读 标签管理 ) } } export default TopNav; ``` src/pages/home/components/LeftList.js 代码详情 ```js import React, { Component } from 'react' class LeftList extends Component { render() { return ( 左侧 ) } } export default LeftList; ``` src/pages/home/components/RightRecommend.js 代码详情 ```js import React, { Component } from 'react' class RightRecommend extends Component { render() { return ( 右侧 ) } } export default RightRecommend; ``` 此时，页面显示为： 二十 页面实现：首页 返回目录 20.1 多层级组件引用 store 返回目录 在我们规划中，App 是主组件，下面有 header | home | detail，然后 home 下面有 LeftList | RightRecommend，那么 App/home/leftList 如何引用 store 呢？ src/pages/home/components/LeftList.js 代码详情 ```js import React, { Component } from 'react'; import { Link } from 'react-router-dom'; // 1. 在 LeftList 中引入 react-redux 的 connect import { connect } from 'react-redux'; import { actionCreators } from '../store'; class LeftList extends Component { render() { return ( 热门 | 最新 | 评论 本周最热 · 本月最热 · 历史最热 {/* 5. 循环输出 props 里面的数据 */} { this.props.list.map((item) => { return ( 热· 专栏· { item.get('user').get('username') } · 一天前· { item.get('tags').map((tagsItem, index) => { if (index === 0) { return tagsItem.get('title'); } else { return null; } }) } {item.get('title')} {item.get('likeCount')} {item.get('commentsCount')} ) }) } ) } componentDidMount() { this.props.getLeftList(); } } // 3. 在 LeftList 中定义 mapStateToProps const mapStateToProps = (state) => { return { list: state.get('home').get('leftNav') } }; // 4. 在 LeftList 中定义 mapDispathToProps const mapDispathToProps = (dispatch) => { return { getLeftList() { dispatch(actionCreators.getLeftList()); } } }; // 2. 在 LeftList 中使用 connect export default connect(mapStateToProps, mapDispathToProps)(LeftList); ``` 20.2 完善整个首页 返回目录 当然，如果仅仅是运行上面的代码，你会发现它是报错的。 是的，因为它只是全部代码的一部分，所以需要你去完善它。当然，你也可以直接获取全部代码： React 系列文章代码地址 不管如何，你实现的最终成果如下所示： 二十一 总结 返回目录 写到这里，我们已经完成了一个首页的开发。 在这个开发中，我们学习到了非常多。 当然，后面 jsliang 自己也是偷懒了，慕课原视频中还有： 加载更多功能实现 跳转到顶部功能实现 详情页开发 登录页开发 登录鉴权功能实现 单页面异步加载组件（react-loadable） …… 这里不一一列举了，因为 jsliang 感觉它们重复性很大，我们只需要在下一个项目中去实践，相信能获得更清晰的印象。（当然，前提是你跟 jsliang 一样有动力深入学习） 那么，到这里我们就宣布结束啦，我们下篇文章见！ jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-23 14:34:33 "},"JavaScript-library/React/ReactDemoFour-JueJin.html":{"url":"JavaScript-library/React/ReactDemoFour-JueJin.html","title":"✔ React Demo Four - 掘金","keywords":"","body":"React Demo Four - 掘金 Create by jsliang on 2019-5-15 08:25:08Recently revised in 2019-05-15 15:57:20 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文 二 前言 返回目录 首先，经过前面的一系列折腾，发觉自己的时间远远没有想象中的那么充足，又因为这三周的工作，搞得自己 “精疲力竭”、“无法动弹”，越发感到暴躁与疲惫（可能有天气的小小影响）。 同时，经过前面的贴代码，以及文章反馈远没有自己想象中的高，jsliang 觉得自己可能做了无用功，于是在 React 系列 4 仿掘金 的更新上感觉动力不足——也许你会觉得这句话非常扯淡，jsliang 的动力怎么会跟文章反馈挂钩了…… 再来就是，看到身边的同事/小伙伴都在刷 LeetCode、看 React 源码、学 Java、搞 Egg……越发觉得自己落了下乘，所以在暴躁的同时也在犹豫彷徨，我究竟想成就一个怎样的未来：jsliang 的未来在哪？ 这么说来，思来想去，目前自己可以走三条路： 深造：一路走到黑，完善 React 系列栈，并配合 Node、MySQL 打造自己的网站，毕竟深度学习才能让自己在某个领域成为 “砖家”，可以想象的是，深入学习 React 的大佬是可以自己搭建公司的 React 脚手架，自己开发插件，自己优化项目等。 广度：扩宽自己思维，学算法，探索 LeetCode 等网站。有句话叫做：一流的数学，二流的算法。数学咱就算了，没这头脑，但是搞搞算法应该可以吧，并且算法这玩意真的挺有用的，有时候工作总觉得某方面没处理好，没准就是算法的影响。 转行：这也许是最没有出息的想法。众所周知编程是一行吃青春饭的地儿，年轻的时候进了这个行业是能拿到高回报的。可是，毕竟是青春饭碗，过了这个年纪往往就意味着有淘汰风险，毕竟身体比不了年轻人，精力、思考等也比不上。所以，就算 jsliang 在本命年也深深感到这个危机。但是，转行要转哪去？除了编程我还有啥能力，不可得知。 因此，这本身就是个值得深思的问题。而且，我们还有生活，我们的努力就是为了更好的生活，如果你的努力带来的是 996-ICU，一年甚至几年的努力工作、努力学习换不来住一次医院，换不来房子的首付，想想这是很可怕的事情。 最后，说到这里小伙伴们心里应该有谱了，至于 jsliang 的想法或者你对自己的未来有想法了想找个人来个中肯的建议，你可以联系 jsliang： QQ：1741020489 微信： 三 正文 返回目录 实现效果： 源码下载：React 系列文章代码地址 使用技术： \"dependencies\": { \"axios\": \"^0.18.0\", \"react\": \"^16.8.6\", \"react-dom\": \"^16.8.6\", \"react-loadable\": \"^5.5.0\", \"react-redux\": \"^7.0.2\", \"react-router-dom\": \"^5.0.0\", \"react-scripts\": \"3.0.0\", \"redux\": \"^4.0.1\", \"redux-saga\": \"^1.0.2\" }, 其中数据处理方面没有使用，即：react-loadable、react-redux、redux、redux-saga 这四个没有使用到，下篇文章可能尝试完善做好。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 16:51:36 "},"JavaScript-library/React/ReactDemoFive-AroundYuanGang.html":{"url":"JavaScript-library/React/ReactDemoFive-AroundYuanGang.html","title":"✘ React Demo Five - 员岗周边","keywords":"","body":"React Demo Five - 员岗周边 Create by jsliang on 2019-5-16 22:09:22Recently revised in 2019-05-17 16:46:45 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 二 前言 返回目录 突然想起一个词，叫：食在广州。 而我，广漂，衣食住行都围绕广州番禺区的【员岗地铁站】。 所以，兴致而来，开发一个多端登录的 App，记录附近的点点滴滴。 React 系列文章地址 Node 系列文章地址 由于文章有这两个前置，如果不熟悉 React 或者 Node 开发的一套，请先去学习对应的前置。 三 开发思路与进度 返回目录 [ ] 功能结构划分 [ ] 衣 [ ] 食 [ ] 住 [ ] 行 3.2 食 对一些饭点的介绍 点击地图的饭点，可以查看到对应饭点的菜单（建议堂食、不建议堂食） 可以获取饭点的外卖电话、点餐 App（美团，大众，饿了么……） 可以评价饭点的饭菜 店家可以更新自己的菜单（收费） jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 19:39:43 "},"JavaScript-library/Angular/":{"url":"JavaScript-library/Angular/","title":"☆ Angular","keywords":"","body":"Angular create by jsliang on 2018-9-5 11:33:18Recently revised in 2019-2-11 09:55:35 前言 AngularJS 诞生于 2009 年，由 Misko Hevery 等人创建，后为 Google 所收购。是一款优秀的前端 JS 框架，已经被用于 Google 的多款产品当中。 AngularJS 有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。 由于 AngularJS 有着诸多不便，AngularJS 在 2.0 版本进行了重写，于是有了现在的 Angular。 目录 章节名 导航 Demo1 股票管理网站 Demo2 企业开发平台 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Angular/AngularDemoOne-taskmgr.html":{"url":"JavaScript-library/Angular/AngularDemoOne-taskmgr.html","title":"✘ Angular Demo One - 打造企业级协作平台","keywords":"","body":"Angular Demo One - 打造企业级协作平台 create by jsliang on 2018-9-5 11:56:07Recently revised in 2019-2-11 10:05:39 目录 章节名 导航 第一章 环境搭建 第二章 项目工程结构介绍 UI 第三章 UI整体布局 More... 已断更！缺乏对应基础，补基础去了！ 第一章 环境搭建 1. 安装 Angular： npm i @angular/cli -g _ _ ____ _ ___ / \\ _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | '_ \\ / _` | | | | |/ _` | '__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/ Angular CLI: 6.1.5 Node: 8.11.2 OS: win32 x64 Angular: ... Package Version ------------------------------------------------------ @angular-devkit/architect 0.7.5 @angular-devkit/core 0.7.5 @angular-devkit/schematics 0.7.5 @schematics/angular 0.7.5 @schematics/update 0.7.5 rxjs 6.3.2 typescript 2.9.2 2. 安装 VS Code 插件： Debugger for Chrome、Angular 6 Snippets 3. 安装开发插件： 安装 Chrome 关于 Angular 的开发插件：点击前往 4. 常用命令： npm i -S —— 软件开发依赖 npm i -D —— 软件生产依赖 ng new —— 新建 Angular项目 ng build -prod —— 生产环境编译 ng server —— 启动开发服务器 5. Mock Rest API： json-server: 用户快速搭建 REST API 的利器。 安装：npm i json-server -g，版本为 0.14.0 。 启动：json-server /json 文件位于的目录/*.json。 支持 GET， POST， PUT， PATCH， DELETE 等 REST 命令。 6. 测试 REST API： 几种常用的 API 测试工具： 使用 Postman 测试常用的 API：地址 使用 VS Code 的 REST Client 插件 此刻， jsliang 的 node 等版本为：node : 8.11.2npm : 6.3.0cnpm : 6.0.0 第二章 项目工程结构介绍 2.1 文件组织约定 目录结构按相对独立的功能划分 src/app 下第一层子目录中除了模块，还有领域对象、动画和工具文件夹 资源存放在 src/assets 目录下 2.2 命名约定 模块和组件的类文件都使用 index.ts 的命名约定 2.3 新建项目 ng new taskmgr -si --style=scss —— 新建 angular 项目 // 注： -si === --skip-install cnpm i —— 安装依赖 ng g m core —— 创建核心模块 ng g m shared —— 创建分享模块 2.4 添加代码 taskmgr/src/app/core/core.module.ts // 原代码 import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [ CommonModule ], declarations: [] }) export class CoreModule { } // 更新后代码 import { NgModule, SkipSelf } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [ CommonModule ], declarations: [] }) export class CoreModule { constructor(parent: CoreModule) { if(parent) { throw new Error(\"模块已经存在，不能再次加载！\"); } } } taskmgr/src/app/shared/shared.module.ts // 原代码 import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [ CommonModule ], declarations: [] }) export class SharedModule { } // 更新后代码 import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [ CommonModule ], exports: [ CommonModule ], declarations: [] }) export class SharedModule { } taskmgr/src/app/app.module.ts // 原代码 import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } // 更新后代码 import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { CoreModule } from './core/core.module'; import { AppComponent } from './app.component'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, CoreModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } 第三章 UI整体布局 3.1 修改代码 ng g c core/header --spec=false ng g c core/footer --spec=false ng g c core/sidebar --spec=false taskmgr/src/app/app.component.html // 源代码 Welcome to {{ title }}! Here are some links to help you start: Tour of Heroes CLI Documentation Angular blog // 修改后 taskmgr/src/app/core/core.module.ts // 源代码 // 修改后 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/Angular/AngularDemoTwo-stock-management-platform.html":{"url":"JavaScript-library/Angular/AngularDemoTwo-stock-management-platform.html","title":"✘ Angular Demo Two - Angular 股票管理平台","keywords":"","body":"Angular Demo Two - Angular 股票管理平台 create by jsliang on 2018年9月5日17:28:51Recently revised in 2018年9月6日16:47:36 前言 AngularJS 诞生于 2009 年，由 Misko Hevery 等人创建，后为 Google 所收购。是一款优秀的前端 JS 框架，已经被用于 Google 的多款产品当中。 AngularJS 有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。 由于 AngularJS 有着诸多不便，AngularJS 在 2.0 版本进行了重写，于是有了现在的 Angular。 目录 章节名 导航 第一章 介绍 第二章 开始 Angular 开发 第三章 路由和导航 第四章 依赖注入 第五章 绑定、响应式编程和管道 第六章 组件间通讯 第七章 表单处理 第八章 与服务器通讯 第九章 构建和部署 第一章 - 介绍 Angular 是一个开发平台。它能帮你更轻松的构建 Web 应用。Angular 集声明式模板、依赖注入、端到端工具和一些最佳实践于一身，为你解决开发方面的各种挑战。Angular 为开发者提升构建 Web、手机或桌面应用的能力。 1.1 Angular 的优点 跨平台 渐进式应用：充分利用现代 Web 平台的各种能力，提供 App 式体验。高性能、离线使用、免安装。 原生：借助来自Ionic、NativeScript和React Native中的技术与思想，构建原生移动应用。 桌面：借助你已经在Web开发中学过的能力，结合访问原生操作系统API的能力，创造能在桌面环境下安装的应用，横跨Mac、Windows和Linux平台。 速度与性能 代码生成：Angular会把你的模板转换成代码，针对现代JavaScript虚拟机进行高度优化，轻松获得框架提供的高生产率，同时又能保留所有手写代码的优点。 统一平台：在服务端渲染应用的首屏，像只有HTML和CSS的页面那样几乎瞬间展现，支持 Node.js®、.NET、PHP，以及其它服务器，为通过SEO来优化站点铺平了道路。 代码拆分：借助新的组件路由器，Angular可以实现快速加载。自动代码拆分机制可以让用户仅仅加载那些用于渲染所请求页面的代码。 生产率 模板：通过简单而强大的模板语法，快速创建UI视图。 Angular CLI：命令行工具：快速进入构建环节、添加组件和测试，然后立即部署。 各种 IDE：在常用IDE和编辑器中获得智能代码补全、实时错误反馈及其它反馈等特性。 完整开发故事 测试：使用Karma进行单元测试，让你在每次存盘时都能立即知道是否弄坏了什么。Protractor则让你的场景测试运行得又快又稳定。 动画：通过Angular中直观简便的API创建高性能复杂编排和动画时间线 —— 只要非常少的代码。 可访问性：通过支持ARIA的组件、开发者指南和内置的一体化测试基础设施，创建具有完备可访问性的应用。 1.2 AngularJS 架构与 Angular 架构 AngularJS 的架构： 为何 AngularJS 被抛弃 饱受诟病的性能问题。通过检查进行数据更新，当数据不断增加时，检查的效率就不断降低。页面加载速度也会变慢。 落后于当前web发展理念(如组件式的开发) 对手机端的支持不是太友好。由于angularJS是09年诞生的，因此并没有考虑到手机端的适配，首先是性能问题，手机平台的硬件资远远比不上电脑平台。 于是，就有了 Angular 的开发： 组件( Component )：是 Angular 应用的基本构建块，可以把一个组件理解为一段带有业务逻辑和数据的HTML 服务：用来封装可重用的业务逻辑 指令：允许你向 HTML 元素添加自定义行为 模块：将应用中不同部分组织成一个 Angular 框架可以理解的单页。 第二章 - 开始 Angular 开发 2.1 安装 Angular 安装 Angular-cli ：npm i @angular/cli -g 新建 Angular 项目：ng new project 安装 Node 依赖：npm i 运行 Angular 项目：npm run start 2.2 Angular-CLI 目录介绍 + e2e —— 自动化配置文件及用例 demo，自动测试使用 + node_modules —— 安装依赖包 + src —— 项目文件目录 + app —— 应用组件和模块 - app.component.css —— 根组件样式 - app.component.html —— 根组件页面 - app.component.spec.ts —— 测试用例的例子 - app.component.ts —— 根组件 - app.module.ts —— 根模块 + assets —— 静态文件目录，图片、第三方库等 - .gitkeep —— assets 目录用于存放图片等静态资源文件，构建时会拷贝到发布包里。新创建时一般为空，由于 git 会忽略空文件夹，放置 .gitkeep 这个空文件可以保证目录得到管理 + environments —— 开发模式和生产模式的配置文件，可以将接口的路径写在这里 - environment.prod.ts —— 生产环境 - environment.ts —— 开发环境 - browserslist —— 该项目的浏览器兼容情况 - favicon.ico —— 项目页面迷你小图标 - index.html —— 启动页 - karma.conf.js —— karma 是单元测试的执行器，karma.conf.js 是 karma 的配置文件 - main.ts —— 入口文件 - polyfills.ts —— 兼容性，可以根据需要开放兼容 IE10 和 ES6、 ES7 的语法 - style.css —— 全局样式 - test.ts —— 测试用例 - tsconfig.app.json —— typescript 配置文件 - tsconfig.spec.json —— typescript 配置文件 - tslint.json —— tslint 语法校验配置文件 - .editorconfig —— editorconfig 配置文件，规范开发用的 - .gitignore —— git 忽略文件，配置 .gitignore 可以忽略诸如 node_modules 此类的包 - angular.json —— angular 配置文件 - package.json —— 项目依赖配置文件，npm 根据该文件安装依赖包 - README.md —— 初始化新手教程，其实就是官方的 readMe - tsconfig.json —— typescript 配置文件 - tslint.json —— tslint 语法校验配置文件 2.3 Angular 运行流程 在我们启动 npm run start 的过程中，Angular 做了什么事呢？这边我们讲解下： 首先，Angular-CLI 根据 npm run start，打开 package.json 这个文件： package.json { \"name\": \"stock-management-platform\", \"version\": \"0.0.0\", \"scripts\": { \"ng\": \"ng\", \"start\": \"ng serve\", \"build\": \"ng build\", \"test\": \"ng test\", \"lint\": \"ng lint\", \"e2e\": \"ng e2e\" }, \"private\": true, \"dependencies\": { \"@angular/animations\": \"^6.1.0\", \"@angular/common\": \"^6.1.0\", \"@angular/compiler\": \"^6.1.0\", \"@angular/core\": \"^6.1.0\", \"@angular/forms\": \"^6.1.0\", \"@angular/http\": \"^6.1.0\", \"@angular/platform-browser\": \"^6.1.0\", \"@angular/platform-browser-dynamic\": \"^6.1.0\", \"@angular/router\": \"^6.1.0\", \"core-js\": \"^2.5.4\", \"rxjs\": \"^6.0.0\", \"zone.js\": \"~0.8.26\" }, \"devDependencies\": { \"@angular-devkit/build-angular\": \"~0.7.0\", \"@angular/cli\": \"~6.1.5\", \"@angular/compiler-cli\": \"^6.1.0\", \"@angular/language-service\": \"^6.1.0\", \"@types/jasmine\": \"~2.8.6\", \"@types/jasminewd2\": \"~2.0.3\", \"@types/node\": \"~8.9.4\", \"codelyzer\": \"~4.2.1\", \"jasmine-core\": \"~2.99.1\", \"jasmine-spec-reporter\": \"~4.2.1\", \"karma\": \"~1.7.1\", \"karma-chrome-launcher\": \"~2.2.0\", \"karma-coverage-istanbul-reporter\": \"~2.0.0\", \"karma-jasmine\": \"~1.1.1\", \"karma-jasmine-html-reporter\": \"^0.2.2\", \"protractor\": \"~5.4.0\", \"ts-node\": \"~5.0.1\", \"tslint\": \"~5.9.1\", \"typescript\": \"~2.7.2\" } } 然后发现这文件告诉 Angular-CLI，执行 ng serve，即 npm run start === ng serve。然后，它定义了主入口为 main.js，那么，我们以此寻找，发现有个 main.ts，可以想到是 TypeScript 编译成 JavaScript，所以我们首先打开 main.ts 进行查看。 在 main.ts 中： main.ts // 关闭 Angular 的开发模式 import { enableProdMode } from '@angular/core'; // 使用哪个模块来启动应用 import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; // 导入主模块 import { AppModule } from './app/app.module'; // 导入环境配置 import { environment } from './environments/environment'; // 如果是生产环境，就调用下面方法 if (environment.production) { enableProdMode(); } // 设置启动模块为 AppModule platformBrowserDynamic().bootstrapModule(AppModule) .catch(err => console.log(err)); 我们可以看到，它设置了启动模块为 APPModule ，所以，我们通过路径 src/app/app.module 找到 app.module.ts 这个文件。 我们打开 app.module.ts ： // 这是 Angular 的模块文件 import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; @NgModule({ // 声明模块、指令以及管道 declarations: [ // 模块组件： AppComponent AppComponent ], // 导入的模块 imports: [ // 浏览器模块 BrowserModule ], // 模块中提供的服务 providers: [], // 声明模块主组件 bootstrap: [AppComponent] }) export class AppModule { } 在这里，我们可以看到它的主组件为 AppComponent ，所以我们找到 AppComponent 的路径为 src/app/app.component.ts ，因此我们打开该文件。 我们打开 app.component.ts ： // 从 angular 核心中引用 Component 这个装饰器 import { Component } from '@angular/core'; // 定义装饰器 @Component({ selector: 'app-root', // 挂载 dom 节点 templateUrl: './app.component.html', // 模板 html 文件 styleUrls: ['./app.component.css'] // 模板 css 样式文件 }) // 控制器 export class AppComponent { title = '股票管理平台'; // AppComponent 控制器有个 title 值 } OK，从装饰器中我们可以看到，我们这个组件，挂载到 index.html 的 app-root 这个节点中，而且其模板文件由 app.component.html 与 app.component.css 这两个文件形成。 由此，我们知道，通过编写 app.component.html 和 app.component.css ，我们形成了一个 app 的组件(可以看成为一块 HTML 片段，而 index.html 是一个页面)，挂载到 index.html 中。这样，我们就能够编写SPA模式的页面了。 模拟的 index.html 股票管理平台 --> 欢迎来到{{ title }}! 2.4 Angular 组件 第三章 - 开发准备 3.1 安装依赖 安装引用 jquery 和 bootstrap： 股票管理平台 安装 TS 类型描述文件： npm i @types/jquery @types/bootstrap -D (由于 TypeScript 中不支持 $ ，所以我们需要先安装类型描述文件，让 TypeScript 认识 jQuery 和 Bootstrap ，以免它报错) 3.2 新建组件 新建导航栏组件： ng g component navbar 新建尾部组件： ng g component footer 查询表单组件： ng g component search 新建轮播图组件： ng g component carousel 新建产品信息组件： ng g component product 新建星级评价组件： ng g component stars 查看是否有生成新的组件： 此时，发现 app.module.ts 变为： // 这是 Angular 的模块文件 import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; import { NavbarComponent } from './navbar/navbar.component'; import { FooterComponent } from './footer/footer.component'; import { SearchComponent } from './search/search.component'; import { CarouselComponent } from './carousel/carousel.component'; import { ProductComponent } from './product/product.component'; import { StarsComponent } from './stars/stars.component'; @NgModule({ // 声明模块、指令以及管道 declarations: [ //, NavbarComponent, FooterComponent, SearchComponent, CarouselComponent, ProductComponent, StarsComponent, AppComponent ], // 导入的模块 imports: [ // 浏览器模块 BrowserModule ], // 模块中提供的服务 providers: [], // 声明模块主组件 bootstrap: [AppComponent] }) export class AppModule { } 3.3 开始开发 app.component.html navbar.component.html 管理平台 在线竞拍 关于我们 联系我们 网站地图 navbar.component.css .navbar { margin-bottom: 30px; } footer.component.html jsliang Angular 入门实战 @2018 search.component.html 商品名称 商品价格 商品类别 搜索 carousel.component.html #holder_165b232526b text { fill: #555; font-weight: normal; font-family: Helvetica, monospace; font-size: 40pt } First slide #holder_165b2325267 text { fill: #444; font-weight: normal; font-family: Helvetica, monospace; font-size: 40pt } Second slide #holder_165b232526d text { fill: #333; font-weight: normal; font-family: Helvetica, monospace; font-size: 40pt } Third slide Previous Next product.component.ts import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-product', templateUrl: './product.component.html', styleUrls: ['./product.component.css'] }) export class ProductComponent implements OnInit { private products: Array; constructor() { } ngOnInit() { this.products = [ new Product(1, \"第一个商品\", 1.99, 1.5, \"这是第一个商品，这是 jsliang 学习 Angular入门实战时创建的\", [\"硬件设备\"]), new Product(1, \"第二个商品\", 2.99, 2.5, \"这是第二个商品，这是 jsliang 学习 Angular入门实战时创建的\", [\"图书\", \"后端\"]), new Product(1, \"第三个商品\", 3.99, 3.5, \"这是第三个商品，这是 jsliang 学习 Angular入门实战时创建的\", [\"硬件设备\"]), new Product(1, \"第四个商品\", 4.99, 4.5, \"这是第四个商品，这是 jsliang 学习 Angular入门实战时创建的\", [\"电子产品\", \"硬件设备\"]), new Product(1, \"第五个商品\", 5.99, 5.5, \"这是第五个商品，这是 jsliang 学习 Angular入门实战时创建的\", [\"电子产品\"]), new Product(1, \"第六个商品\", 6.99, 1.5, \"这是第六个商品，这是 jsliang 学习 Angular入门实战时创建的\", [\"图书\", \"前端\"]) ] } } export class Product { constructor( public id: number, public title: string, public price: number, public rating: number, public desc: string, public categories: Array ) { } } product.component.html #holder_165b232526d text { fill: #333; font-weight: normal; font-family: Helvetica, monospace; font-size: 40pt } Third slide {{ product.price }}元 {{ product.title }} {{ product.desc }} 第四章 - 路由 4.1 Route 名称 简介 使用 Routes 路由配置，保存着哪个 URL 对应展示哪个组件，以及在哪个 RouterOutlet 中展示组件 import {HomeComponent} from \"./home/home.component\"; const routes: Routes = [{ path: 'home', component: HomeComponent }] RouterOutlet 在 HTML 中标记路由内容呈现位置的占位符指令 Router 负责在运行时执行路由的对象，可以通过调用其 navigate() 和 navigateByUrl() 方法来导航到一个指定的路由。 -> constructor(private router: Router) {} -> toProductDetails() {this.router.navigate(['/product'])} RouterLink 在 HTML 中声明路由导航用的指令 > ActivatedRoute 当前激活的路由对象，保存着当前路由的信息，如路由地址，路由参数等。 * 4.2 解析图 4.3 传递数据 在路由时传递数据的方法有： 在查询参数中传递数据 /product?id=1&name=2 => ActivatedRoute.queryParams[id] 在路由路径中传递参数 {path:/product/:id} => /product/1 => ActivatedRoute.params[id] 在路由配置中传递参数 {path:/product, component:ProductComponent, data:[{isProd:true}]} => ActivatedRoute.data[0][isProd] 4.4 路由+传递数据 商品详情 商品详情 4.5 路由重定向 在用户访问一个特定的地址时，将其重定向到另一个特定的地址 www.aaa.com => www.aaa.com/home www.aaa.com/x => www.aaa.com/y {path:'', redirectTo:'/home', pathMatch:'full'} 4.6 子路由 { path: 'home', component: HomeComponent, children: [ { path: '/xxx', component: XxxComponent } { path: '/yyy', component: YyyComponent } ] } 4.7 辅助路由 { path: 'xxx', component: XxxComponent, outlet: \"aux\" } { path: 'yyy', component: YyyComponent, outlet: \"aux\" } Xxx Yyy 4.8 辅助路由实现 辅助路由案例整体思路 在 app 组件的模板上再定义一个插座来显示聊天面板 单独开发一个聊天室插件，只显示在新定义的插座上。 通过路路由参数控制新电脑是否显示聊天面板。 第五章 - 绑定、响应式编程和管道 5.1 本节内容 数据绑定 响应式编程 管道 第六章 - 组件间通讯 6.1 本节内容 输入输出属性 中间人模式 组件生命周期 第七章 - 表单处理 7.1 本节内容 模板式表单 响应式表单 表单校验 第八章 - 表单处理 8.1 本节内容 创建 web 服务器 使用 Http 协议与服务器通讯 使用 WebSocket 协议与服务器通讯 构建和部署 9.1 本节内容 构建和部署 多环境支撑 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/ECharts/":{"url":"JavaScript-library/ECharts/","title":"☆ ECharts","keywords":"","body":"ECharts Create by jsliang on 2018-11-28 10:53:08Recently revised in 2019-2-11 11:09:57  Echarts + Vue 折腾。 一 前言  ECharts 官网  ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。 二 简介 2.1 丰富的可视化类型  ECharts 提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。  除了已经内置的包含了丰富功能的图表，ECharts 还提供了自定义系列，只需要传入一个renderItem函数，就可以从数据映射到任何你想要的图形，更棒的是这些都还能和已有的交互组件结合使用而不需要操心其它事情。  你可以在下载界面下载包含所有图表的构建文件，如果只是需要其中一两个图表，又嫌包含所有图表的构建文件太大，也可以在在线构建中选择需要的图表类型后自定义构建。 2.2 多种数据格式无需转换直接使用  ECharts 内置的 dataset 属性（4.0+）支持直接传入包括二维表，key-value 等多种格式的数据源，通过简单的设置 encode 属性就可以完成从数据到图形的映射，这种方式更符合可视化的直觉，省去了大部分场景下数据转换的步骤，而且多个组件能够共享一份数据而不用克隆。  为了配合大数据量的展现，ECharts 还支持输入 TypedArray 格式的数据，TypedArray 在大数据量的存储中可以占用更少的内存，对 GC 友好等特性也可以大幅度提升可视化应用的性能。 2.3 千万数据的前端展现  通过增量渲染技术（4.0+），配合各种细致的优化，ECharts 能够展现千万级的数据量，并且在这个数据量级依然能够进行流畅的缩放平移等交互。  几千万的地理坐标数据就算使用二进制存储也要占上百 MB 的空间。因此 ECharts 同时提供了对流加载（4.0+）的支持，你可以使用 WebSocket 或者对数据分块后加载，加载多少渲染多少！不需要漫长地等待所有数据加载完再进行绘制。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/ECharts/CurriculumVitae.html":{"url":"JavaScript-library/ECharts/CurriculumVitae.html","title":"✔ ECharts 打造在线个人简历","keywords":"","body":"ECharts 打造在线个人简历 Create by jsliang on 2018-12-5 11:48:56Recently revised in 2019-2-11 11:08:28 Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址 互联网冬天？裁员？跳槽？ 最近频繁听身边朋友说公司裁员、员工跳槽的事情，然后帮几个还没毕业的小师弟修改了几份简历，结果嘛，enmmm...... 咱使用 Vue + ECharts + ElementUI 来打造份在线个人简历，并将它部署到免费的服务器上去吧！ 最终成品线上地址：点击查看 涉及技术： Vue Vue-Router ECharts ElementUI HTML/HTML5 CSS/CSS3 JavaScript/ES6 一 目录  不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 整体搭建  3.1 基础配置  3.2 安装 ECharts  3.3 安装 ElementUI  3.4 总体配置 四 分步实现  4.1 part1 - 基本信息  4.2 part2 - 好友分布  4.3 part3 - 技能特长  4.4 part4 - 文章成就  4.5 part5 - 工作经验  4.6 part6 - 编程技能  4.7 part7 - 求职意向 五 总结 二 前言 返回目录  在使用 Vue + ECharts 编写公司报表项目的时候，突如其来有个 idea，想到好像可以写个在线简历。 于是，就去做了。 文章中的见解仅代表个人观点，不代表 “最优想法”，请文明评论、科学参考。 如有更好建议，可加 jsliang 的文档库 QQ 群讨论：798961601。 谢谢~ 三 整体搭建 返回目录  工欲善其事，必先利其器。 在我们进行愉快折腾之前，我们需要将代码的环境搭建好，才能如鱼得水，更好地开发。 3.1 基础配置 返回目录  首先，我们在指定目录下，通过控制台（终端）新建一个 Vue-Cli 项目： vue init webpack  然后，我们使用 npm i 安装 Vue-Cli 的依赖，生成 node_modules 文件夹。 最后，我们引入 CSS reset，并清理下红框内文件，之后项目变为如下所示：  此刻我们的一些文件发生了变动： HelloWorld.vue export default { name: 'HelloWorld', data () { return { } } } App.vue export default { name: 'App' } main.js import Vue from 'vue' import App from './App' import router from './router' Vue.config.productionTip = false // 引入样式重置 import '../static/css/reset.css' new Vue({ el: '#app', router, components: { App }, template: '' }) reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /** 图片自适应 - image responsize **/ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .26rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .26rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .26rem } /* Internet Explorer */  当然，怕小伙伴们嫌麻烦，不想敲代码。 所以 jsliang 直接上传了基础代码，需要的小伙伴直接下载即可：  ECharts 打造在线个人简历分支 - 基础配置 3.2 安装 ECharts 返回目录  既然说了用 ECharts 来写，那么，我们肯定要搞下 ECharts 的安装啦~  首先，我们在项目中安装 ECharts 依赖： npm i echarts -S  然后，你可以选择按需引用还是全局引用（个人建议使用按需引用）： 全局引用  ECharts 初始化应在钩子函数 mounted() 中，这个钩子函数是在 el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。 项目/src/main.js import Vue from 'vue' import App from './App' import router from './router' // 引入echarts import echarts from 'echarts' Vue.prototype.$echarts = echarts Vue.config.productionTip = false new Vue({ el: '#app', router, components: { App }, template: '' }) 项目/src/components/HelloWorld.vue export default { name: 'hello', data () { return { msg: 'Welcome to Your Vue.js App' } }, mounted(){ this.drawLine(); }, methods: { drawLine(){ // 基于准备好的dom，初始化echarts实例 let myChart = this.$echarts.init(document.getElementById('myChart')) // 绘制图表 myChart.setOption({ title: { text: '在Vue中使用echarts' }, tooltip: {}, xAxis: { data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); } } } 按需引用  如果我们使用全局引用。将 ECharts 图表打包，会导致体积过大，所以项目中最好按需引入。 在这里我们使用 requrie 引用而不是 import，是因为 import 必须写全路径，比较麻烦。 项目/src/components/HelloWorld.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); // 引入柱状图组件 require(\"echarts/lib/chart/bar\"); // 引入提示框和title组件 require(\"echarts/lib/component/tooltip\"); require(\"echarts/lib/component/title\"); export default { name: 'hello', data() { return { msg: 'Welcome to Your Vue.js App' } }, mounted() { this.drawLine(); }, methods: { drawLine() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById('myChart')) // 绘制图表 myChart.setOption({ title: { text: 'ECharts 入门示例' }, tooltip: {}, xAxis: { data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); } } };  最后，我们只需要 npm run dev 启动项目，打开 localhost:8080 即可：  当然，仅仅带进门，可能小伙伴们还可能会感觉懵逼：下一步我要怎么做？ 所以，jsliang 顺带讲讲 ECharts 如何上手： 照着上面案例敲一遍 过一遍它的上手文档：5 分钟上手 ECharts 查看它的各种实例，并从自己要做的简单的图做起 在步骤 3 中，碰到不懂的属性值，记得随时查看文档：文档 - 配置项手册  如此，小伙伴们就可以更好上手 ECharts 啦~ 3.3 安装 ElementUI 返回目录  考虑到 UI 是我，开发还是我。 那么，尽情使用 UI 框架吧！这里偷懒用 ElementUI 咯。 然后，为了使项目尽可能小巧，jsliang 打算按需引入 ElementUI： 安装 ElementUI：npm i element-ui -S 安装 babel-plugin-component：npm i babel-plugin-component -D 修改 .babelrc： .babelrc { \"presets\": [ [\"env\", { \"modules\": false, \"targets\": { \"browsers\": [\"> 1%\", \"last 2 versions\", \"not ie 按需引入 Row 与 Col： main.js import Vue from 'vue' import App from './App' import router from './router' Vue.config.productionTip = false // 引入样式重置 import '../static/css/reset.css' // 引入及使用 ElementUI import {Row, Col} from 'element-ui'; Vue.use(Row).use(Col); new Vue({ el: '#app', router, components: { App }, template: '' })  这样，就可以在项目中使用这两个组件了： 项目/src/components/HelloWorld.vue 代码片段 111 222 333 3.4 总体配置 返回目录  该需要的东东，都差不多准备好了。 那么，我们的简历，长啥样呢？ 由于手里木有成品 “参考” 和 “借鉴”，所以去网上看看别人的 ECharts 都长啥样吧：  如图，jsliang 觉得这图的布局不错，所以下载下来了它的 png 版本和 psd 版本。 然后，怕小伙伴们难以想象要怎么操作，我用 PS 修改下它的 psd 吧：  很好，这个在线个人简历要怎么做就一目了然了。  下面我们开始切图仔工作：  首先，创建 7 个 components，并删除 HelloWorld.vue：  jsliang 太懒，名字就懒得想了，从左到右，从上到下，依次命名 7 个框的名字为 PartOne 到 PartSeven 吧。 PartOne.vue 代码示例 第一部分 export default { } 说到这里，有的小伙伴可能觉得复制粘贴或者手写 Vue-Cli 代码特别烦，所以这里推荐使用 VS Code 的插件：Vue VSCode Snippets。通过在页面上敲：vbase，就可以快速生成 Vue-Cli 的基础代码了。  然后，我们在 index.js 中定义这些文件，并在 App.vue 引用它们： 项目/src/router/index.js import Vue from 'vue' import Router from 'vue-router' Vue.use(Router) const PartOne = () => import('@/components/PartOne'); const PartTwo = () => import('@/components/PartTwo'); const PartThree = () => import('@/components/PartThree'); const PartFour = () => import('@/components/PartFour'); const PartFive = () => import('@/components/PartFive'); const PartSix = () => import('@/components/PartSix'); const PartSeven = () => import('@/components/PartSeven'); export default new Router({ routes: [ { path: '/', components: { PartOne: PartOne, PartTwo: PartTwo, PartThree: PartThree, PartFour: PartFour, PartFive: PartFive, PartSix: PartSix, PartSeven: PartSeven } }, { path: '/PartOne', name: 'PartOne', component: PartOne }, { path: '/PartTwo', name: 'PartTwo', component: PartTwo }, { path: '/PartThree', name: 'PartThree', component: PartThree }, { path: '/PartFour', name: 'PartFour', component: PartFour }, { path: '/PartFive', name: 'PartFive', component: PartFive }, { path: '/PartSix', name: 'PartSix', component: PartSix }, { path: '/PartSeven', name: 'PartSeven', component: PartSeven }, ] }) 项目/src/App.vue export default { name: 'App' }  此时，通过 npm run dev，我们可以在 localhost:8080/#/ 中可以看到我们已成功进行了布局：  最后，我们通过 CSS 的渲染，成功实现我们的总体布局： 此刻的项目结构图： App.vue export default { name: \"App\", data() { return { bannerXSSM: require(\"./assets/img/banner_640.png\"), bannerMD: require(\"./assets/img/banner_1000.png\"), bannerLGXL: require(\"./assets/img/banner.png\"), }; } }; body { background: #011128; color: #fff; } .app { width: 100%; } .part { padding: 20px; } .banner img { width: 100%; height: 80px; } p { text-align: center; } main.js import Vue from 'vue' import App from './App' import router from './router' Vue.config.productionTip = false // 引入样式重置 import '../static/css/reset.css' // 引入 ElementUI 响应式断点 import 'element-ui/lib/theme-chalk/display.css'; // 引入及使用 ElementUI import {Row, Col} from 'element-ui'; Vue.use(Row).use(Col); new Vue({ el: '#app', router, components: { App }, template: '' }) PartOne.vue ( PartTwo 及其他 6 个文件雷同) 第一部分 export default { name: \"partOne\" }; .part-one { width: 100%; height: 500px; border: 15px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; }  这样，我们就成功完成了高尚的切图仔工作，可以继续下一步咯：  为了防止小伙伴们晕乎，保险起见 jsliang 将总体配置的代码提交到了分支，需要的小伙伴直接下载即可：  ECharts 打造在线个人简历分支 - 完整配置 四 分步实现 返回目录  提问：简历一般有什么内容？ 回答： 基本信息：姓名、工作年限、学历、格言、年龄、联系电话、电子邮箱、GitHub、掘金…… 求职意向：职位、城市、薪资、准备入职时间…… 工作经验：…… 个人技能：熟悉 HTML5、CSS3、JavaScript…… 教育背景/荣誉证书（这两样没有很出彩的地方的话，jsliang 建议就忽略不写了）  所以，我们就着这几方面来编写我们的简历吧~ 4.1 part1 - 基本信息 返回目录  话不多说，先上代码： PartOne.vue 姓&emsp;&emsp;名：梁峻荣 学&emsp;&emsp;历：本科 工作年限：1 年 年&emsp;&emsp;龄：23 联系电话：18818881888 电子邮箱：1741020489@qq.com 博&emsp;&emsp;客：jsliang.top 掘&emsp;&emsp;金：jsliang GitHub：LiangJunrong export default { name: \"partOne\", data() { return { headImage: require('../assets/img/head_image.png') } } }; a { color: deepskyblue; } a:hover { color: rgb(118, 190, 248); } p { line-height: 30px; } .part-one { width: 100%; height: 500px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; padding-left: 10px; } .part-one-image { width: 150px; height: 150px; }  实现效果：  如上，这只是个简单的信息填充，就不多说了。 4.2 part2 - 好友分布 返回目录  话不多说，先上代码： PartTwo.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); // 引用中国地图 require(\"echarts/map/js/china.js\"); export default { name: \"partTwo\", data() { return {}; }, mounted() { this.drawECharts(); }, methods: { drawECharts() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById(\"part-two\")); // 排行前五城市 let myFirendCity = [ { name: \"广州\", value: [\"113.23\", \"23.16\", \"9\"] }, { name: \"深圳\", value: [\"114.07\", \"22.62\", \"12\"] }, { name: \"上海\", value: [\"121.48\", \"31.22\", \"10\"] }, { name: \"西安\", value: [\"108.95\", \"34.27\", \"4\"] }, { name: \"北京\", value: [\"116.46\", \"39.92\", \"12\"] }, ]; // 好友分布省份 let myFriendProvince = [ { name: \"山东\", value: 1 }, { name: \"四川\", value: 1 }, { name: \"广东\", value: 21 }, { name: \"广西\", value: 1 }, { name: \"北京\", value: 12 }, { name: \"甘肃\", value: 1 }, { name: \"上海\", value: 10 }, { name: \"陕西\", value: 4 }, { name: \"湖北\", value: 1 }, { name: \"湖南\", value: 1 }, { name: \"山西\", value: 1 }, { name: \"辽宁\", value: 2 }, { name: \"江苏\", value: 1 }, { name: \"河北\", value: 3 }, { name: \"海南\", value: 1 }, { name: \"河南\", value: 1 } ]; myChart.setOption({ // 标题 title: { text: \"前端好友分布\", textStyle: { color: \"#fff\" }, subtext: \"微信统计\", subtextStyle: { color: \"#fff\" }, x: \"center\" }, // 移动显示 tooltip: { trigger: \"item\", // 鼠标移动过去显示 formatter: function(params) { if (params.value[2] == undefined) { if(!params.name) { return \"该地区暂无好友\"; } else { return params.name + \" : \" + params.value; } } else { return params.name + \" : \" + params.value[2]; } } }, // 左边注记 visualMap: { text: [\"\", \"好友数\"], min: 0, max: 30, // 是否能通过手柄显示 calculable: true, inRange: { color: [\"#e4e004\", \"#ff5506\", \"#ff0000\"] }, textStyle: { color: \"#fff\" } }, // geo geo: { map: \"china\" }, // 数据 series: [ // 排行前五城市 { name: \"排行前五\", type: \"effectScatter\", coordinateSystem: \"geo\", symbolSize: function(val) { return val[2] * 2; }, showEffectOn: \"render\", rippleEffect: { brushType: \"stroke\" }, hoverAnimation: true, label: { normal: { formatter: \"{b}\", position: \"right\", show: true, color: \"#fff\" } }, itemStyle: { normal: { color: \"#ddb926\", shadowBlur: 10, shadowColor: \"#333\" } }, // 类似于 z-index zlevel: 1, data: myFirendCity, }, // 好友分布省份 { name: \"好友数\", type: \"map\", mapType: \"china\", // 是否允许缩放 roam: false, label: { // 显示省份标签 normal: { formatter: myFirendCity, show: false, textStyle: { color: \"#fff\" } }, // 对应的鼠标悬浮效果 emphasis: { show: false } }, itemStyle: { normal: { borderWidth: 0.5, // 区域边框宽度 borderColor: \"#fff\", // 区域边框颜色 areaColor: \"deepskyblue\" // 区域颜色 }, // 对应的鼠标悬浮效果 emphasis: { borderWidth: 1, borderColor: \"#fff\", areaColor: \"#00aeff\" } }, // 数据 data: myFriendProvince } ] }); } } }; .part-two { width: 100%; height: 500px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; }  实现效果：  首先，我们引用了 ECharts 及它的中国地图： let echarts = require(\"echarts/lib/echarts\"); require(\"echarts/map/js/china.js\");  然后，我们初始化 DOM 和数据： let myChart = echarts.init(document.getElementById(\"part-two\")); let myFriendData = [ { name: \"山东\", value: 1 }, { name: \"四川\", value: 1 }, { name: \"广东\", value: 21 }, { name: \"广西\", value: 1 }, { name: \"北京\", value: 12 }, { name: \"甘肃\", value: 1 }, { name: \"上海\", value: 5 }, { name: \"陕西\", value: 4 }, { name: \"湖北\", value: 1 }, { name: \"湖南\", value: 1 }, { name: \"山西\", value: 1 }, { name: \"辽宁\", value: 2 }, { name: \"江苏\", value: 1 }, { name: \"河北\", value: 3 }, { name: \"海南\", value: 1 }, { name: \"河南\", value: 1 } ];  最后，我们通过 setOption 实现了地图的描绘，上面配置仅是个人配置方法，详细的方法请参考：ECharts 配置。 4.3 part3 - 技能特长 返回目录  说到简历，还记得之前看过一份，印象特深，因为人家就是用 Word 中用图表展示的。所以，咱也试试： PartThree.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); export default { name: \"partThree\", data() { return {}; }, mounted() { this.drawECharts(); }, methods: { drawECharts() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById(\"part-three\")); myChart.setOption({ // 标题 title: { // 标题文本 text: \"技能分布图\", // 标题样式 textStyle: { color: \"#fff\" }, // 标题位置 x: \"center\" }, // 移动显示 tooltip: { trigger: \"item\", // 显示文字样式 formatter: \"{a} {b} : {d}%\" }, // 注记 legend: { x: \"center\", y: \"bottom\", textStyle: { color: \"#fff\" }, data: [ \"HTML5\", \"CSS3\", \"JavaScript\", \"jQuery\", \"Vue\", \"Node\", \"微信小程序\", \"其他\" ] }, // 注记显示手柄 calculable: true, // 图形系列 series: [ { name: \"技能分布\", type: \"pie\", radius: [30, 110], roseType: \"area\", data: [ { value: 15, name: \"HTML5\" }, { value: 15, name: \"CSS3\" }, { value: 20, name: \"JavaScript\" }, { value: 20, name: \"jQuery\" }, { value: 20, name: \"Vue\" }, { value: 15, name: \"Node\" }, { value: 25, name: \"微信小程序\" }, { value: 15, name: \"其他\" } ] } ], // 颜色调整 color: ['#00bfff', '#00ffdd', '#207ffc', '#00aeff', \"#00eeff\", \"#006eff\", \"#0099ff\", \"#0066ff\"] }); } } }; .part-three { width: 100%; height: 500px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; }  如上，我们就设置好了： 4.4 part4 - 文章成就 返回目录  有时候就是想偷懒，也想不起自己还有啥好吹水的了，于是贴个自己的前端文档库的成就吧： PartFour.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); export default { name: \"partFour\", data() { return {}; }, mounted() { this.drawECharts(); }, methods: { drawECharts() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById(\"part-four\")); myChart.setOption({ // 标题 title: { // 标题文本 text: \"文章成就统计\", // 标题文本样式 textStyle: { color: \"#fff\" }, // 标题位置 x: \"center\" }, // 图形布局 grid: { // 距离底部高度 bottom: \"20\" }, // 横轴 xAxis: { show: false, type: \"category\", data: [\"Github 提交：\\n1141\", \"Github Star数：\\n269\", \"掘金点赞量：\\n1508\", \"掘金关注者：\\n234\"], axisLine: { lineStyle: { color: \"#fff\" } }, axisLabel: { // 横轴信息全部显示 interval: 0 } }, // 纵轴 yAxis: { type: \"value\", axisLine: { lineStyle: { color: \"#fff\" } }, axisLabel: { // 横轴信息全部显示 interval: 0 } }, // 图形系列 series: [ { // 图类型 type: \"bar\", // 数据 data: [1141, 269, 1508, 234], // 文本 label: { show: true, position: \"top\", color: \"#fff\", formatter: \"{b}\" }, // 柱条样式 itemStyle: { color: \"deepskyblue\" }, zlevel: 1 } ] }); } } }; .part-four { width: 100%; height: 310px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } 4.5 part5 - 前端研发 返回目录  简历一大重点，就是工作经验啦： PartFive.vue 工作经验 广州**科技股份有限公司 | 2018/05 - 至今 工作内容：日常操作 jQuery 编写活动页、微信小程序、Vue + ECharts 报表制作…… 项目成就： &emsp;1. 企业宝小程序。使用原生代码进行微信小程序的开发，代码已完成，尚在审核，尚未上线。 &emsp;2. ECharts 报表汇总。使用 Vue + ECharts 进行报表设计，正在开发。 &emsp;3. jQuery 活动页及 H5 活动页。 export default { name: \"partFive\", data() { return { partFive: \"part-five\", curWidth: 0 }; }, beforeMount() { this.curWidth = document.documentElement.clientWidth || document.body.clientWidth; if(this.curWidth a { color: deepskyblue; } a:hover { color: rgb(118, 190, 248); } .part-five { width: 100%; height: 310px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .part-five-responsive { width: 100%; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .text-center { text-align: center; } .text-small { font-size: 0.9em; color: rgb(253, 239, 239); }  结果显示为： 4.6 part6 - 编程技能 返回目录  除了工作经验，我们还需要 show 一下我们的编程技能都有什么： PartSix.vue 编程技能 前端：HTML/HTML5、CSS/CSS3、JS/ES6、jQuery、Vue、微信小程序…… 后端：Node、PHP 其他：MongoDB、MySQL、Sqlserver export default { name: \"partSix\", data() { return { partSix: \"part-six\", curWidth: 0 }; }, beforeMount() { this.curWidth = document.documentElement.clientWidth || document.body.clientWidth; if(this.curWidth .part-six { width: 100%; height: 310px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .part-six-responsive { width: 100%; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .text-center { text-align: center; } .font-small { font-size: .9em; } .font-bold { font-weight: bold; color: deepskyblue; }  成果如下图所示： 4.7 part7 - 求职意向 返回目录  最后，当然要表明我们的求职意向，好让 HR 小姐姐知道我们想要什么啦~ PartSeven.vue 求职意向 期望职位：前端工程师 工作技能：Vue 目标城市：广州、深圳、杭州、上海 期望薪资：10K - 15K 入职时间：随时入职 export default { name: \"partSeven\", data() { return { partSeven: \"part-seven\", curWidth: 0 }; }, beforeMount() { this.curWidth = document.documentElement.clientWidth || document.body.clientWidth; if(this.curWidth .part-seven { width: 100%; height: 310px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .part-sevev-responsive { width: 100%; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .text-center { text-align: center; } .text-small { font-size: .9em; } .font-bold { text-align: center; color: deepskyblue; }  结果如下图所示：  至此，所有代码编写完毕，偷懒的小伙伴可以去下面地址下载所有代码： ECharts 打造在线个人简历 五 总结 返回目录  最后再看下我们的最终成品：  OK，到这里，也是时候将这份成品放到我们的线上啦：  使用 GitHub Pages 和 VuePress 搭建网站  我们只需要搭建个 GitHub Pages 的账号，就可以部署这份在线简历咯~ 当然 jsliang 有自己的服务器哈，就没使用 GitHub Pages 了，感兴趣的小伙伴可以跟着上面的文章折腾去~ 所以，这篇文章就结束啦！ 番外：  哈哈，jsliang 已经 预 感 到 了：  你的好友喷子小哥上线啦！ “哇，这样用 ECharts 的吗？还能不能更 low 点？！” “哇，Vue 这样写的吗？你懂不懂 Vue？” “哇，……”  enm......所以我不管怎么说，都说不过这些大佬的，所以有的评论就不回复啦，哈哈~  最后，在此祝小伙伴们找到更好的工作~ 小伙伴们如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址 撰文不易，如果文章对小伙伴有帮助，希望小伙伴们给勤劳敲代码、辛苦撰文的 jsliang 进行微信/支付宝打赏，你们的每一次打赏都是最好的鼓励，谢谢~ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/ECharts/CurriculumVitaeImprove.html":{"url":"JavaScript-library/ECharts/CurriculumVitaeImprove.html","title":"✔ ECharts 打造在线个人简历 【升级版】","keywords":"","body":"ECharts 打造在线个人简历 【升级版】 Create by jsliang on 2018-12-11 10:21:27Recently revised in 2019-2-11 11:07:47  在发表文章 ECharts 打造在线个人简历 （GitHub版 / 掘金版） 后，迎来了各位大佬的吐槽： 根本没有一点技术含量，体现不出较高的前端水准。 可以用 Canvas 做动态背景么？应该会更炫酷。 百度的 AntV 也不错，值得一试。 边框能不能更炫酷点，用 CSS3 的动画来实现。 GitHub 的 start 数和掘金的点赞数能不能用爬虫爬出来啊，这样会不会更牛逼点。  综上，我决定结合这些建议，将它化为可行性，再升级打造过！ …… …… …… 才怪咧！jsliang 稳食艰难，抽不出功夫啊~  目前正在折腾这两篇文章： Node 基础：从 0 到 1 打造 Node 扎实基础，实现 Web 服务的部署以及仿 Express 深入了解 Node 以及使用原生 Node 编写个简单的企业网站。 JavaScript 之 构造函数与原型对象：进一步深入了解，加深 JavaScript 的学习及使用。  同时，愁着下面两点： 写文章耗时。基本是：写文章时间 = 学习敲代码的时间 * 1.5。因为我不仅要自己懂，还要化繁为简，讲得小伙伴们也懂，我也印象深刻点。 明年想跳槽换 10K+ 的工作。但是时间不够，技术没法沉淀，现在在朝着自己 8 月份布的局，努力学习提升中，毕竟资本提不上去没资格跟 HR 要更好的薪资。  所以，除非有 特殊安排，要不在线简历这块是没那么快更新的咯，哈哈~  最后的最后，引用我之前那句话：  不折腾的前端，和咸鱼有什么区别  相信按奈不住的小伙伴，可以根据 jsliang 的文章，结合上面更改的建议，自己动手搞个更炫酷的简历的，加油~ 更多精彩，尽在 jsliang 的文档库 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/ECharts/EChartsVue.html":{"url":"JavaScript-library/ECharts/EChartsVue.html","title":"✔ ECharts + Vue 折腾记","keywords":"","body":"ECharts + Vue 折腾记 Create by jsliang on 2018-11-28 11:01:39Recently revised in 2019-2-11 11:09:30  Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址  技术官网就是躺坑的地儿！ 翻遍百度文，一把辛酸泪~ 整合网上的 Vue + ElementUI，Vue + ECharts，ECharts + 百度地图 API……的文章，带你走非一般的道路。 一 目录  不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文  3.1 Vue  3.2 Echarts  3.3 ElementUI  3.4 百度地图 四 精细入微  4.1 百度地图调整  4.2 样式问题集 二 前言 返回目录  现在是大数据和云计算的时代，所以数据可视化逐渐变成一种趋势。 而 ECharts 对于制作的图表可以满足小伙伴们的创造力，它具备华丽的外衣，且实用。 在这里，jsliang 将通过 ECharts + Vue 进行折腾。 如果小伙伴们对 Vue 还不太熟，这里可能没法带你飞喔~前置条件：Vue、Npm、Webpack  参考文献： ECharts Demo | ECharts 官网 ElementUI | ElementUI 官网 在 vue-cli 项目中使用 echarts | 博客园 - 搞前端的李蚊子 Vue：在 Vue 中使用 echarts | 简书 - Mr_Treasure 在 VUE 项目中使用 ECharts 画 K 线图和面积图 | CSDN - zgh0711 在 vue 中添加 Echarts 图表使用详解 | PHP 中文网 - 小云云 v-charts | 饿了么 vue-echarts | npm 在 vue 中，应该直接使用 echarts 还是 vue-echarts | Vue 论坛 - JasonBai007 在 vue 项目中引入高德地图及其 UI 组件 | CSDN - shuaizi96 vue 引入高德地图 echarts 百度地图引用报错 A parser-blocking, cross site (i.e. different eTLD+1) script | CSDN - 雨中畅游 vue 引入公共css文件 | CSDN - Smartsunsing 调用百度地图api 去掉地图左下角LOGO或文字 | CSDN - 陈小黏 Echarts数据可视化系列文章 | CSDN - 数据架构师 几种css炫酷背景欣赏 | CSDN - 小圣贤君 三 正文 返回目录  Now, let's go~ 如果你觉得自己的 npm 下载速度过慢，请使用 cnpm： 安装：npm install -g cnpm --registry=https://registry.npm.taobao.org 使用：cnpm i 插件 -g 3.1 Vue 返回目录  Vue 参考文档： 介绍 Vue.js | Vue 官网 介绍 Vue Router | Vue Router 官网  步骤： 安装 vue-cli：npm i vue-cli -g 初始化 Vue 项目：vue init webpack 开启开发模式：npm run dev 打开浏览器，查看网页： http://localhost:8080 3.2 Echarts 返回目录  首先，我们在项目中安装 ECharts 依赖： npm i echarts -S  然后，你可以选择按需引用还是全局引用： 全局引用  ECharts 初始化应在钩子函数 mounted() 中，这个钩子函数是在 el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。 项目/src/main.js import Vue from 'vue' import App from './App' import router from './router' // 引入echarts import echarts from 'echarts' Vue.prototype.$echarts = echarts Vue.config.productionTip = false new Vue({ el: '#app', router, components: { App }, template: '' }) 项目/src/components/HelloWorld.vue export default { name: 'hello', data () { return { msg: 'Welcome to Your Vue.js App' } }, mounted(){ this.drawLine(); }, methods: { drawLine(){ // 基于准备好的dom，初始化echarts实例 let myChart = this.$echarts.init(document.getElementById('myChart')) // 绘制图表 myChart.setOption({ title: { text: '在Vue中使用echarts' }, tooltip: {}, xAxis: { data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); } } } 按需引用  如果我们使用全局引用。将 ECharts 图表打包，会导致体积过大，所以项目中最好按需引入。 在这里我们使用 requrie 引用而不是 import，因为 import 必须写全路径，比较麻烦。 项目/src/components/HelloWorld.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); // 引入柱状图组件 require(\"echarts/lib/chart/bar\"); // 引入提示框和title组件 require(\"echarts/lib/component/tooltip\"); require(\"echarts/lib/component/title\"); export default { name: 'hello', data() { return { msg: 'Welcome to Your Vue.js App' } }, mounted() { this.drawLine(); }, methods: { drawLine() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById('myChart')) // 绘制图表 myChart.setOption({ title: { text: 'ECharts 入门示例' }, tooltip: {}, xAxis: { data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); } } };  最后，我们只需要 npm run dev 启动项目，打开 localhost:8080 即可。 3.3 ElementUI 返回目录  考虑到项目没有 UI 设计稿。那么，就需要引用一款 Vue 的 UI 框架了，偷懒用 ElementUI 吧。 然后，为了使项目尽可能小巧，jsliang 打算按需引入 ElementUI： 安装 ElementUI：npm i element-ui -S 安装 babel-plugin-component：npm i babel-plugin-component -D 修改 .babelrc： .babelrc { \"presets\": [ [\"env\", { \"modules\": false, \"targets\": { \"browsers\": [\"> 1%\", \"last 2 versions\", \"not ie 按需引入 Row 与 Col： main.js import Vue from 'vue' import App from './App' import router from './router' Vue.config.productionTip = false import {Row, Col} from 'element-ui'; Vue.use(Row).use(Col); new Vue({ el: '#app', router, components: { App }, template: '' })  这样，就可以在项目中使用这两个组件了。 3.4 百度地图 返回目录  引用百度地图很简单，但是结合 Vue + ECharts 来使用百度地图，很难。现在我们过一遍如何使用： 引用百度地图： 项目/index.html ECharts 图表 注意：srcipt 引用的链接，需要你去百度地图 API 那里获得，因为 ak 对应的是个人的 API 地址，这里不可能泄露给你的。百度地图 API 在组件中使用它： 模板表格 // 注意在 index.html 引入全局的百度地图 JS // script src=\"\"http://api.map.baidu.com/getscript?v=3.0&ak=Xjmh9v5jGa******6ZVf0PU2ueSedr5F\" // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); // 引入百度扩展 require(\"echarts/extension/bmap/bmap\"); export default { name: \"temp\", data() { return {}; }, mounted() { this.drawTempMap(); }, methods: { drawTempMap() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById(\"temp-chart\")); // 创建地图实例 var map = new BMap.Map(\"temp-chart\"); // 绘制图表 myChart.setOption({ // 加载 bmap 组件 bmap: { // 百度地图中心经纬度 center: [116.46, 39.92], // 百度地图缩放 zoom: 4, // 是否开启拖拽缩放，可以只设置 'scale' 或者 'move' roam: true, // 百度地图的自定义样式，见 http://developer.baidu.com/map/jsdevelop-11.htm mapStyle: {} }, series: [ { type: \"scatter\", // 使用百度地图坐标系 coordinateSystem: \"bmap\", // 数据格式跟在 geo 坐标系上一样，每一项都是 [经度，纬度，数值大小，其它维度...] data: [ [116.46, 39.92, 1] ] } ] }); } } }; .temp-chart { width: 300px; height: 300px; }  这样，我们就可以在我们的 ECharts 畅通无阻地使用百度地图了。 四 精细入微 返回目录  有时候，一些小细节总会困惑你。 在这里，jsliang 将贴出自己解决的小细节。 结合 Ctrl + F 搜索关键字喔~ 4.1 百度地图调整 返回目录 问：为什么开发的时候控制台报 warning？ api?v=3.0&ak=Xjmh9v5jGa*****6ZVf0PU2ueSedr5F:1 A parser-blocking, cross site (i.e. different eTLD+1) script, http://api.map.baidu.com/getscript?  答： 这时候你的引用地址应该是：  你只需要将 api 改成 getscript 即可解决它的 warning 警告： 问：如何去除百度地图左下角的信息（logo 和 文字）？  答：  你只需要在全局样式里写上下面这段话就可以屏蔽它： App.vue .BMap_cpyCtrl, .BMap_noprint, .anchorBL { display: none !important; } 4.2 样式问题集 返回目录 问：为什么 Chrome 上的 body 会有 8px 的 margin 值？或者 img 不贴边之类的。 答：  这是浏览器自带的样式喔，去掉方式：  首先，在项目的 static 目录上，新建 css 文件夹，然后新建 reset.css，内容如下所示： 项目/static/css/reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /** 图片自适应 - image responsize **/ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .26rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .26rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .26rem } /* Internet Explorer */  然后，在项目目录的 src 目录下的 main.js 文件中添加下面的语句，就可以引用 css 样式，清空浏览器的内置了： 项目/src/main.js import '../static/css/reset.css' /**引入样式重置 */  Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/design-pattern/":{"url":"JavaScript-library/design-pattern/","title":"☆ 设计模式","keywords":"","body":"设计模式手册 - 0 - 目录和简介 create by jsliang on 2018-8-21 11:30:00Recently revised in 2019-2-11 11:12:507 项目实例 点我前往 目录 章节名 导航 第一章 部署开发环境 第二章 面向对象与设计模式初探 第三章 工厂模式 第四章 单例模式 第五章 适配器模式 第六章 装饰器模式 第七章 代理模式 第八章 外观模式 第九章 观察者模式 第十章 迭代器模式 第十一章 状态模式 第十二章 其他模式 第十三章 综合应用 其他模式中包含：原型模式、桥接模式、组合模式、享元模式、策略模式、模板方法模式、职责连模式、命令模式、备忘录模式、中介者模式、访问者模式、解释器模式这12种不常用模式 关于面试 面试中能说出第二章至第十一章的模式，一般来说设计模式方面是满分了，当然不排除是高级工程师，但是高级工程师是不会看我这篇文章的，所以 jsliang 就不担心被打脸了 关于工作日常使用 如果是常用的设计模式，最好就是结合自己的理解，列个列表，在工作中大胆尝试使用，而不是学习完就丢一边。如果是非常用的设计模式，那就应该视业务场景选择性使用。 使用场景 如果是业务性很强的，压根没时间写点好的JavaScript。一般来说，直接用面向对象写法，怎么方便怎么来。所以就有了“活动说明直接整张图丢上去，文字都也不弄出来”“能上图的就上图，写个文字都是罪” 然后，如果是长久使用的，要考虑维护的，还是用面向对象思路封装好来，随时调用。 知识普及： Webpack babel-core：把es6中的新语法（箭头函数、rest参数等）解析成ast这种形式，然后配合各个插件分析语法进行相应的处理。 babel-loader：一种loader解析器，配合Webpack解析ES6编写的js文件。 babel-preset-*：babel-reset-2015包含了es6对应的新语法，如果配置了babel-reset-latest，则包含了es2015、es2016、es2017的插件（之后可能包括es2018等）。注：在安装过程中jsliang发现，官方已不建议使用babel-preset-*系列了，而是推荐使用下面介绍的babel-preset-env包。 babel-polyfill：实现浏览器对不支持API的兼容（兼容旧环境、填补）。 babel-preset-env：如果不做任何配置，该loader等同于bable-preset-latest，如果你需要根据不同浏览器或者node版本进行配置，推荐使用babel-preset-env进行配置使用 详情介绍 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"JavaScript-library/design-pattern/design-pattern-chapter01.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter01.html","title":"✘ 设计模式手册 - 1 - 部署开发环境","keywords":"","body":"设计模式手册 - 1 - 部署开发环境 create by jsliang on 2018年8月22日11:19:00Recently revised in 2019-05-20 17:31:21 第一章 部署开发环境  为什么要部署个开发环境呢？我就不能直接将es6转成es5直接使用吗？回答是：可以啊！链接拿去，里面告诉你怎么配置babel，将es6转es5。如果你觉得还要配置babel，也是挺麻烦的，链接拿去，里面已经设置好了，直接在线将es8、es7、es6转es5，去吧少年~ 但是，怎么说呢，工欲善其事，必先利其器。一切的编程就是为了偷懒，所以jsliang配置个Webpack的es6环境，就是想： 偷懒。每次写完代码按Ctrl+C，就可以在另一个显示屏（jsliang两个显示屏的）直接看到编译结果了，而不是用命令行将ES6转为ES5. 还是偷懒。有时候写个小项目，用原生搞的话，ES5有时候写起来不爽啊，能耍耍ES6就好了，到时候还要搞事情，转ES5、手机查看啥的，还不如直接配置好，到时候直接用啦。 还是还是偷懒。要知道有些个玩意，叫vue-cli、react-cli、angular-cli，而且目前jsliang所知的，就是vue-cli是单页面SPA配置，到时候你要去搞多页面，还是需要学Webpack，所以事先学学，到时候就不用焦头烂额，又学react又搞Webpack啦~对了，顺带打个广告，Webpack的多页面配置jsliang已经配置好了，Webpack学习链接拿去、多页面配置链接拿去。  好嘞，jsliang强行解释一通，不管你接不接受，反正我是接受了，部署开发环境走起~ 1.1 打包JavaScript  本节实现目的：部署个能打包JavaScript的环境： 执行命令行：npm init -y，初始化package.json文件。 执行命令行：cnpm i webpack webpack-cli -D，安装webpack及其命令行工具webpack-cli。 在根目录下新建src文件夹，并在里面新建index.js文件，该文件打印了个100。 index.js console.log(100); 在根目录下新建webpack.dev.config.js文件。 webpack.dev.config.js module.exports = { entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname, filename: './dist/src/index.js' }, } 在webpack.dev.config.js中，我们做了两件事： 告知webpack我们的入口文件（需要被解析的ES6文件）在根目录的src下的index.js； 告知webpack我们的出口文件（被解析后的ES5文件）需要打包到的位置是相对于当前目录的dist/src下的index.js。 修改package.json文件。 package.json { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack --config ./webpack.dev.config.js --mode development\" }, \"keywords\": [ \"javascript\", \"design\", \"pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", } } 在这里，我们修改了\"scripts\"部分，告知npm在npm run dev的时候，记得使用webpack命令，用开发模式来解析配置文件webpack.dev.config.js。 执行命令行：npm run dev，可以查看到在根目录中生成了个dist文件夹，该文件夹下存有一个src文件夹，里面包含了个index.js。本处有点小瑕疵，这里是src文件夹，但是到了后面变成了js文件夹，因为这是打包后的js存放的地方，当然这里是不影响使用的，下面我们会提到。 此时目前目录如下： 1.2 动态打包JavaScript  本节实现目的：部署个能按Ctrl+C，就能自动更新代码的Webpack环境。 执行命令行：cnpm i webpack-dev-server html-webpack-plugin -D，安装Webpack的devServer，这个能启动开发模式实时监控代码的webpack配置。同时，安装html-webpack-plugin，这个能解析HTML的插件。 新建dist/index.html文件，由于这个HTML文件无特殊之处，所以这里不做过多讲解： index.html jsliang的设计模式 jsliang的设计模式 根据我们安装的webpack-dev-server与html-webpack-plugin这两个配置，修改webpack.dev.config.js，使其能解析HTML文件和监控dist目录。 webpack.dev.config.js const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'development', // 开发模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname, filename: './dist/src/index.js' }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ], devServer: { // 开发服务 contentBase: path.join(__dirname, './dist'), // 根目录 open: true, // 自动打开浏览器 port: 8080, // 端口 //host: \"192.168.1.107\" // WiFi IPV4地址，打开可共享到手机 } } 修改package.json，告知npm，我们不用webpack这个比较low的方式了，请给我用webpack-dev-server来启动npm run dev。 package.json { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack-dev-server --config ./webpack.dev.config.js\" }, \"keywords\": [ \"javascript\", \"design\", \"pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"html-webpack-plugin\": \"^3.2.0\", \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", \"webpack-dev-server\": \"^3.1.5\" } } 执行命令行：npm run dev，发现浏览器自动打开http://localhost:8080(启动WiFi的情况下应该是打开类似于http://192.168.1.107:8080/)的网址： 此时文件目录为： 1.3 自动打包ES6  本节实现目的：部署个能按Ctrl+C，就能自动打包ES6为ES5，并且能自动更新代码的Webpack环境。 执行命令行：cnpm i babel-core babel-loader babel-polyfill babel-preset-env -D，安装ES6对应的解析配置，执行完毕后package.json会自动新增依赖包： package.json { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack-dev-server --config ./webpack.dev.config.js --mode development\" }, \"keywords\": [ \"javascript\", \"design\", \"pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-polyfill\": \"^6.26.0\", \"babel-preset-env\": \"^1.7.0\", \"html-webpack-plugin\": \"^3.2.0\", \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", \"webpack-dev-server\": \"^3.1.5\" } } 新建.babelrc文件，该文件为ES6解析到ES5必须使用的文件（注，现在市面上大部分浏览器还不能完全直接解析ECMA Script2015语法，所以只能将ES6转为ES5，就用到了.babelrc文件）： .babelrc { \"presets\": [ \"env\" ], \"plugins\": [ ] } 修改webpack.dev.config.js，添加module，告知webpack在加载js文件的时候，需要使用babel-loader。 webpack.dev.config.js const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'development', // 开发模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname, filename: './dist/src/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ], devServer: { // 开发服务 contentBase: path.join(__dirname, './dist'), // 根目录 open: true, // 自动打开浏览器 port: 8080, // 端口 host: \"192.168.1.107\" // WiFi IPV4地址，打开可共享到手机 } } 修改index.js，这里我们换成ES6语法（如果你还没学过ES6，你只需要知道这里弹窗显示了jsliang即可，内容可以忽略）： index.js class Person { constructor(name) { this.name = name; } getName() { return this.name; } } let person = new Person(\"jsliang\"); alert(person.getName()); 执行命令行：npm run dev，即可看到HTML页面弹窗显示 jsliang 。 1.4 完善配置  本节实现目的：npm run dev命令下，部署个能按Ctrl+C，就能自动打包ES6为ES5，并且能自动更新代码的Webpack环境。npm run build命令下，能打包文件到dist目录。 经过上面的努力，终于可以在多终端（电脑+手机）实时查看自己编写的ES6代码了。然而，还是有点小瑕疵。例如：无法将代码打包应用于生产；打包js的目录名称叫src……。所以，Let's Go! 再搞个生产环境，让我们完美结束这份Webpack配置吧~ 新增webpack.prod.config.js，用作打包生产： webpack.prod.config.js const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'production', // 生产模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname + '/dist', filename: './js/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ] } 修改下package.json，使其能使用命令行npm run build： package.json { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack-dev-server --config ./webpack.dev.config.js\", \"build\": \"webpack --config ./webpack.dev.config.js\" }, \"keywords\": [ \"javascript\", \"design pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-polyfill\": \"^6.26.0\", \"babel-preset-env\": \"^1.7.0\", \"html-webpack-plugin\": \"^3.2.0\", \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", \"webpack-dev-server\": \"^3.1.5\" } } 完善下webpack.dev.config.js： wepbakc.dev.config.js const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'development', // 开发模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname + '/dist', filename: './js/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ], devServer: { // 开发服务 contentBase: path.join(__dirname, './dist'), // 监控的目录 open: true, // 自动打开浏览器 port: 9000, // 端口 host: \"192.168.1.107\" // WiFi IPV4地址，打开可共享到手机 } } 检查下其他文件，看看是否与jsliang一致： src/index.js class Person { constructor(name) { this.name = name; } getName() { return this.name; } } let person = new Person(\"jsliang\"); alert(person.getName()); .babelrc { \"presets\": [ \"env\" ], \"plugins\": [ ] } index.html jsliang的设计模式 jsliang的设计模式 执行命令行npm run dev或者npm run build,然后查看目录：OK，都能成功运行，生产环境部署完毕，接下来我们愉快地玩耍设计模式吧！ jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:31:22 "},"JavaScript-library/design-pattern/design-pattern-chapter02.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter02.html","title":"✘ 设计模式手册 - 2 - 面向对象","keywords":"","body":"设计模式手册 - 2 - 面向对象 create by jsliang on 2018年8月24日08:00:00Recently revised in 2019-05-20 17:31:39 未完善版，待完善。 第二章 面向对象 2.1 概念  什么是面向对象？大概1000个人有1001个解释。在这里，jsliang也不去做着1001种解释了，你看着烦我写着累，所以咱用大俗话强行解释一通，懂的就过了，不懂的还不查百度/Chrome就是你的过了。 说起面向对象，我们就要结合面向过程来说了。下面我们有一个游戏场景：  游戏过程： 皮皮虾打开自己的控制面板，检查了下自己状态； 皮皮虾往画面右边走了两步； 皮皮虾夹了下象拔蚌； 皮皮虾受到了象拔蚌的甩鞭反击； 皮皮虾打开自己的控制面板，检查了下自己状态； 皮皮虾发现状态不对，赶紧逃跑。  面向过程： 描绘一只皮皮虾，一个象拔蚌，一个战斗场景; 编写弹窗，显示皮皮虾状态; 编写动画，皮皮虾在游戏场景向右移动两步; 编写动画，皮皮虾攻击象拔蚌; 编写动画，象拔蚌攻击皮皮虾; 编写弹窗，弹窗显示皮皮虾状态; 编写动画，皮皮虾退出战斗场景； 编写动画，败北动画。  面向对象： 准备： 皮皮虾库。存放了皮皮虾的属性状态、动作…… 象拔蚌库。存放了象拔蚌的属性状态、动作…… 游戏场景库。存放了二维坐标、移动动画、战败场景、胜利场景…… 调用了皮皮虾的属性状态。 调用了皮皮虾的属性状态中的头像，调用了游戏场景库中的移动动画，传了两个二位坐标，皮皮虾从左移到右，顺带调用了皮皮虾的跑步动作。 调用了皮皮虾的攻击动作，耍出一套降象十八剪。 调用了象拔蚌的攻击动作，顺带调用了皮皮虾的受击动作。 调用了皮皮虾的属性状态。 调用了皮皮虾败北的动作，顺带调用了场景库的战败场景。  你可能会说，不对啊！面向对象还要做准备，这样不是比面向过程更复杂吗？如果你游戏就这么个场景，那么，使用面向对象就得不偿失了，毕竟做准备也要花功夫的。但是，如果你的游戏，还有火影大战海贼王，也是调用同样的游戏场景库，如果你使用面向过程，是不是要复制粘贴或者重新写过，但是面向对象只需要调用已经写好的游戏场景库，从而省下了大笔时间。 这么说你可能还迷糊，说了那么多话，面向对象究竟长啥样？别急，我们代码的世界见： class Person { constructor(name, age) { this.name = name; this.age = age; } eat() { alert(`${this.name} eat something`); } speak() { alert(`My name is ${this.name}, age ${this.age}`) } } let jsliang = new Person(\"jsliang\"); jsliang.eat(); let JavaScriptLiang = new Person(\"JavaScriptLiang\"); JavaScriptLiang.speak();  在这段代码中，我们使用了封装了个Person的类（如果小伙伴你仅知道ES5，没见过ES6的语法，建议先去看下ES6），然后，jsliang调用了eat这个吃饭的动作，JavaScriptLiang调用了speak这个说话的动作，下次run()、sleep()这些我们也可以放进去，从而实现每个人都可以有属于自己的一套动作。这就是面向对象写法。 很好，经这么一说，jsliang算是勉强过了一遍什么是面向过程和面向对象了。如果小伙伴还是不懂，嗯，如果你没看到开篇那句话的话，那你还是不懂吧~先跟着jsliang撸一遍面向对象再说！ 2.2 三要素 2.2.1 继承  继承，简单来说，就是子类继承父类。继承可将公共方法抽离出来，提高复用，减少冗余。 //父类： 人类Person class People { constructor(name, age) { this.name = name; this.age = age; } eat() { alert(`${this.name} eat something`); } speak() { alert(`My name is ${this.name}, age ${this.age}`); } } //子类： 学生Student class Student extends People { constructor(name, age, id) { super(name, age); this.id = id; } study() { alert(`${this.name} ID is ${this.id}`); } } let jsliang = new People(\"jsliang\", 23); jsliang.speak(); // 在这里，子类学生继承了父类人类，学生既可以调用study()类 // 也可以调用父类中的eat()和speak() let studentLiang = new Student(\"jsliang\", 18, \"003\"); studentLiang.study(); studentLiang.eat(); 2.2.2 封装  封装，简单来说，就是数据的权限和保密。封装的作用有：1、减少耦合，不该外露的不外露；2、利于数据、接口的权限管理 封装有三个关键字：public(完全开放)、protected(对子类开放)、private(对自己开放)。 目前来说，ES6不支持封装，而TypeScript支持。所以，为了做到封装效果，我们可以约定下划线 _ 开头的属性是 private (实际不安全) //父类： 人类Person class People { public name; public age; protected weight; // 定义 protected 属性。受保护的，只有自己和其子类能访问，并且只能在类里面访问，外部调用不会成功 constructor(name, age) { this.name = name; this.age = age; this.weight = 120; } eat() { alert(`${this.name} eat something`); } speak() { alert(`My name is ${this.name}, age ${this.age}`); } } //子类： 学生Student class Student extends People { public id; private girlfriend // 定义private属性 constructor(name, age, id) { super(name, age); this.id = id; this.girlfriend = 'xiaoli' //由于 girlfriend 字段是私有的，所以 People 无法获取，而且只有在 Student 这个类的内部才能访问，外部是无法知道的。但是会有个 bug ，如果你 New 出无数个学生，然后所有学生的女朋友都会叫 xiaoli ，但是这些学生不知道。 } study() { alert(`${this.name} ID is ${this.id}`); } getWeight() { alert(`$this.weight`); // 由于 weight 是受保护的，只有父类和继承它的子类能访问，所以学生类也可以访问体重。 } } let xiaoming = new Student('xiaoming', 10, '001'); xiaoming.getWeight(); alert(xiaoming.girlfriend); // 语法error,因为girlfriend是受保护的 2.2.3 多态  多态，同一接口不同实现。在JavaScript中应用极少，因为多态是需要结合后端语言的接口、重写、重载等功能。多态的优点：1、保持子类的开放性和灵活性；2、面向接口编程；3、JavaScript引用极少。 class People { constructor(name) { this.name = name; } saySomething() { alert(`Hello, my name is ${this.name}`); } } class A extends People { constructor(name) { super(name); } saySomething() { alert(`Hello, my name is A.`); } } class B extends People { constructor(name) { super(name); } saySomething() { alert(`Hello, my name is B`); } } let a = new A('a'); a.saySomething(); let b = new B('b'); b.saySomething();  在上面的例子中，我们可以看出，A 类继承了 People 类，同时，A 类重写了 saySomething() 方法，B 类也是如此，因而，做到了多态效果。 2.2.4 应用  jQuery是使用面向对象编写的。 class jQuery { constructor(selector) { let slice = Array.prototype.slice; let dom = slice.call(document.querySelectorAll(selector)); let len = dom ? dom.length : 0; for(let i = 0; i 2.3 设计原则 什么是设计？设计即是按照哪一种思路或者标注来实现功能。功能相同的代码，可以有不同设计方案来实现。如果仅仅是几行代码，设计可能会浪费时间。但是，伴随着需求的增加，设计的作用就体现出来了。 有哪些设计原则？ 准则1：小即是美。在一开始的时候，jQuery仅仅只有90KB左右。然后，到了Vue.js这边，就只剩30KB左右。而现在，听说有个6KB的js文件，能做到非常好的JavaScript性能。所以，将来的JavaScript一定会往小而精的方面发展，在内核小而美的基础上，发展周边生态。同时，我们的周边生态，一定是有意义的，有作用的，从而产生各部分之和大于它们的原集合，要不然我们就不需要对框架进行分离了，我们直接将周边生态内置于框架内就行了。我们不仅要做到JavaScript框架的小而美，在代码中，我们应该也尽量用精炼的单词，编写精简的代码。 准则2：让每个程序只做好一件事。代码不是万能钥匙，能开车，能开锁。我们的代码，最好能指定某某部分代码实现某个功能，做到分工合理。如果有部分代码，既可以画canvas，又可以操作dom，听起来很美好，实际上，当你接替上一任程序猿的时候，你要把它的具体功能实现猜一遍，它是做这件事的？还是那件事？同时，每个程序，如果是进行数字操作的，那么，就不应做弹窗返回个字符串之类的操作，以免造成混淆。 准则3：快速建立原型。编程界有个词，叫做敏捷开发。当客户提出一个需求的时候，如果你不先通过建立原型，满足用户的需求。随着时间迁移，客户可能会根据市场变化，而修改他原本的决定，从而导致你一直跟着客户变动。所以，在客户提出需求的一刻，我们应该快速建立原型，满足客户的基本需求，然后在进行深度开发。 准则4：舍弃高效率而取可移植性。如果你从事于某个具体行业，该行业可能做了大量的重复性工作。那么，你应该考虑，朝可移植性进行开发，虽然前期可能浪费一些效率，但是，后期的效率提升是值得拥有的。同时，我们在进行可移植性设计的时候，应该尽可能满足绝大多数用户的需求，避免为了极个别的用户，而抛弃大部队。如果花费20%的成本解决80%的需求，那么我们就是胜利的。如果为了20%的需求，浪费掉80%的成本，那么，我们就是失败的。 准则5：采用纯文本来存储数据。大部分人都知道，计算机只认识010101这个二进制数值，文本是二进制的升级版1，图片是二进制的升级版2，视频是二进制的升级版*……所以，越贴近二进制的东东，越小且越容易被计算机识别，因而我们推荐采用纯文本来实现数据存储。效率快存储方便。 准则6：避免强制性的用户界面。现在是以用户为主的时代。如果是00年以前，计算机流行不普遍的时候，强制用户接受某软件、某网站，可以轻松做到。但是，现在如果你的界面做得不好，你的功能开发地不完美，你又不去修改，那么，客户就会离你而去，因为你的竞争对手已经把你的问题给解决了。所以，我们应该避免强制性的用户界面，实现界面可调整，实现功能可定制化，允许用户定制环境，从而赢取更多的客户。 准则7：让每个程序都称为过滤器。 什么是5大设计原则？五大设计原则为：SOLID。 S - 单一职责原则：1、一个程序只做好一件事；2、如果功能过于复杂就拆分开，让每个部分保持独立。 O - 开放封闭原则：1、对扩展开放，对修改封闭；2、增加需求时，扩展新代码，而非修改已有代码；3、这是软件的终极目标。 L - 李？里氏替换原则：1、子类能覆盖父类；2、父类能出现的地方子类就能出现。 I - 接口独立原则：1、保持接口的单一独立，避免出现“胖接口”；2、JavaScript中没有接口（TypeScript例外），使用较少；3、类似于单一职责原则，这里更关注接口。 D - 依赖导致？倒置原则：1、面对接口编程，依赖于抽象而不依赖于具体；2、使用方只关注接口而不关注具体类的实现。  在设计原则中，S O 体现较多，详细介绍；而L I D 体现较少，但是需要了解其用意。 有没有具体例子？有的： // 加载图片 function loadImg(src) { var promise = new Promise(function (resolve, reject) { var img = document.createElement('img'); img.onload = function() { resolve(img); }; img.onerror = function() { reject('图片加载失败'); }; img.src = src; }); return promise; } var src = 'https://www.imooc.com/static/img/index/logo_new.png'; var result = loadImg(src); result.then(function(img) { // part1 console.log('ing.width', img.width); return img; }).then(function(img) { // part2 console.log('img.height', img.height); }).catch(function(ex) { // 统一捕获异常 console.log(ex); }) 在这里，实现了单一职责原则和开放封闭原则。 单一职责原则：每个 then 中的逻辑只做好一件事。 开放封闭原则：如果新增需求，扩展 then 。 对扩展开放，对修改封闭。 2.4 设计模式 何为设计？ 何为模式？ 如何从设计到模式？ 设计模式分为多少种？23种，大致可以分为创建型、组合型、行为型。 创建型：1、工厂模式（工厂方法模式，抽象工厂模式，建造者模式）；2、单例模式；3、原型模式 结构型：1、适配器模式；2、装饰器模式；3、代理模式；4、外观模式；5、桥接模式；6、组合模式；7、享元模式。 行为型-1：1、策略模式；2、模板方法模式；3、观察者模式；4、迭代器模式；5、职责连模式；6、命令模式。 行为型-2：1、备忘录模式；2、状态模式；3、访问者模式；4、中介者模式；5、解释器模式。 如何学习设计模式？ 明白每个设计的道理和用意； 通过经典应用体会它的真正使用场景； 编码时多思考，尽量模仿。 2.5 实例 题目一： 打车时，可以打专车或者快车。任何车都有车牌号和名称。 不同车价格不同，快车每公里1元，专车每公里2元。 行程开始时，显示车辆信息。 行程结束时，显示打车金额（假定行程就5公里）。  问：1、画出UML类图；2、用ES6语法写出该示例。 答： UML类图 ES6代码 class Car { constructor(number, name) { this.number = number; this.name = name; } } class Kuaiche extends Car { constructor(number, name) { super(number, name); this.price = 1; } } class Zhuanche extends Car { constructor(number, name) { super(number, name); this.price = 2; } } class Trip { constructor(car) { this.car = car; } start() { console.log(`行程开始，名称： ${this.car.name}, 车牌号：${this.car.price}`); } end() { console.log(`行程结束，价格：` + (this.car.price * 5)); } } let car = new Kuaiche(100, '桑塔纳'); let trip = new Trip(car); trip.start(); // 行程开始，名称： 桑塔纳, 车牌号：1 trip.end(); // 行程结束，价格：5 题目二： 某停车场，分3层，每层100车位 每个车位都能监控到车辆的驶入和离开 车辆进入前，显示每层的空余车位数量 车辆进入时，摄像头可识别车牌号和时间 车辆出来时，出口显示器显示车牌号和停车时长  问：1、画出UML类图；2、用ES6语法写出该示例。 答： UML类图 ES6代码 // 车辆 class Car { constructor(num) { this.num = num; } } // 入口 摄像头 class Camera { shot(car) { return { num: car.num, inTime: Date.now() } } } // 出口显示屏 class Screen { show(car, inTime) { console.log('车牌号', car.num); console.log('停车时间', Date.now() - inTime); } } // 停车场 class Park { constructor(floors) { this.floors = floors || []; this.camera = new Camera(); this.screen = new Screen(); this.carList = {}; // 存储摄像头拍摄返回的车辆信息 } in(car) { // 通过摄像头获取信息 const info = this.camera.shot(car); // 停到某个停车位 const i = parseInt(Math.random() * 100 % 100); const place = this.floors[0].places[i]; place.in(); info.places = place; // 记录信息 this.carList[car.num] = info; } out(car) { // 获取信息 const info = this.carList[car.num]; // 将停车位清空 const place = info.places; place.out(); // 显示时间 this.screen.show(car, info.inTime); // 清空记录 delete this.carList[car.num]; } emptyNum() { return this.floors.map(floor => { return `${floor.index} 层还有 ${floor.emptyPlaceNum()} 个空闲车位。`; }).join('\\n'); } } // 楼层 class Floor { constructor(index, places) { this.index = index; this.places = places || []; } emptyPlaceNum() { let num = 0; this.places.forEach(p => { if(p.empty) { num = num + 1; } }) return num; } } // 车位 class Place { constructor() { this.empty = true; } in() { this.empty = false; } out() { this.empty = true; } } // 测试 // 初始化停车场 const floors = []; for(let i = 0; i jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:33:00 "},"JavaScript-library/design-pattern/design-pattern-chapter03.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter03.html","title":"✘ 设计模式手册 - 3 - 工厂模式","keywords":"","body":"设计模式手册 - 3 - 工厂模式 create by jsliang on 2018年8月22日11:19:00Recently revised in 2019-05-20 17:34:16 第三章 工厂模式 3.1 使用介绍 将 new 操作单独封装。 遇到 new 时，就要考虑是否使用工厂模式。 举个例子：  你去购买汉堡，只需要跟服务员点餐，做汉堡这些步骤你就不用理会了。然后下一个人去购买汉堡，也是只需要点餐，至于餐厅怎么操作的，就不需要去关心了。在这里，餐厅封装了做汉堡的工作，只需要“接受点餐”、“送餐给顾客”就可以了。 3.2 UML类图及其实现 class Product { constructor(name) { this.name = name; } init() { alert(\"init\"); } fun1() { alert(\"fun1\"); } fun2() { alert(\"fun2\"); } } class Creator { create(name) { return new Product(name); } } // 测试 let creator = new Creator(); let p = creator.create(\"p1\"); p.init(); // init p.fun1(); // fun1 3.3 使用场景 jQuery - $(\"div\") React.createElement vue 异步组件 jQuery class jQuery { constructor(selector) { let slice = Array.prototype.slice; let dom = slice.call(document.querySelectorAll(selector)); let len = dom ? dom.length : 0; for(let i = 0; i React var profile = {[user.firstName, user.lastName].join(' ')} var profile = React.createElement(\"div\", null, React.createElement(\"img\", {src: \"avatar.png\", className: \"profile\"}), React.createElement(\"h3\", null, [user.firstName, user.lastName].join(\" \")); ); class Vnode(tag, attr, children) { // ...省略内部代码... } React.createElement = function(tag, attrs, children) { return new Vnode(tag, attrs, children); } Vue Vue.component('async-example', function(resolve, reject) { setTimeout(function() { resolve({ template: 'I am async!' }) }, 1000) }) 3.4 设计原则验证 构造函数和创建者分离 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:34:55 "},"JavaScript-library/design-pattern/design-pattern-chapter04.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter04.html","title":"✘ 设计模式手册 - 4 - 单例模式","keywords":"","body":"设计模式手册 - 4 - 单例模式 create by jsliang on 2018年8月27日09:15:18Recently revised in 2019-05-20 17:58:32 第四章 单例模式 系统中被唯一使用 一个类只有一个实例 单例模式中需要用到private，而ES6中没有private，所以需要TypeScript 4.1 代码实现 class SingleObject { login() { console.log(\"login...\"); } } SingleObject.getInstance = (function() { let instance; return function() { if(!instance) { instance = new SingleObject(); } return instance; } })() // 测试：注意这里只能使用静态函数 getInstance ，不能 new SingleObject() !!! let obj1 = SingleObject.getInstance(); obj1.login(); // login... let obj2 = SingleObject.getInstance(); obj2.login(); // login... console.log(obj1 == obj2); // true （两者必须完全相等） 4.2 使用场景 jQuery 只有一个 $ ，这就是单例模式的一个例子 登录框 购物车 vuex 和 redux 中的 store jQuery单例模式 // jQuery 只有一个 '$' if (window.jQuery != null) { return window.jQuery; } else { // 初始化 } 如果引用了jQuery，那就不做任何操作；如果没有引用，那就初始化引用。 登录框模拟 class LoginForm { constructor() { this.state = \"hide\"; } show() { if(this.state === \"show\") { alert(\"已经显示\"); return; } this.state = \"show\"; console.log(\"登录框显示成功\"); } hide() { if(this.state === \"hide\") { alert(\"已经隐藏\"); return; } this.state = \"hide\"; console.log(\"登录框隐藏成功\"); } } LoginForm.getInstance = (function() { let instance; return function() { if(!instance) { instance = new LoginForm(); } return instance; } })(); let login1 = LoginForm.getInstance(); login1.show(); let login2 = LoginForm.getInstance(); login2.hide(); console.log(\"login1 === login2\", login1 === login2); // login1 === login2 true 4.3 设计原则验证 符合单一职责原则，只实例化唯一的对象 没法具体开放封闭原则，但是绝对不违反开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:58:33 "},"JavaScript-library/design-pattern/design-pattern-chapter05.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter05.html","title":"✘ 设计模式手册 - 5 - 适配器模式","keywords":"","body":"设计模式手册 - 5 - 适配器模式 create by jsliang on 2018年8月27日09:15:18Recently revised in 2019-05-20 17:36:14 第五章 适配器模式 旧接口格式和使用者不兼容 中间加一个适配转换接口 5.1 UML类图 5.2 代码实现 class Adaptee { specificRequest() { return \"德国标准的插头\"; } } class Target { constructor() { this.adaptee = new Adaptee(); } request() { let info = this.adaptee.specificRequest(); return `${info} -> 转换器 -> 中国标准的插头`; } } // 测试 let target = new Target(); console.log(target.request()); // 德国标准的插头 -> 转换器 -> 中国标准的插头 5.3 使用场景 封装旧接口 vue computed 封装旧接口 // 自己封装的 ajax ，使用方式如下： ajax({ url: 'getData', type: 'Post', dataType: 'json', data: { id: '123' } }).done(function() { }) // 由于历史原因，代码中全都是： // $.ajax({...}) // 做一层适配器 var $ = { ajax: function(options) { return this.ajax(options); } } vue computed Vue Computed 顺序： {{message}} 逆序： {{reversedMessage}} var vm = new Vue({ el: \"#app\", data: { message: \"hello\" }, computed: { reversedMessage: function() { return this.message.split('').reverse().join(''); } } }) 5.4 设计原则验证 将旧接口和使用者进行分离 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:36:33 "},"JavaScript-library/design-pattern/design-pattern-chapter06.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter06.html","title":"✘ 设计模式手册 - 6 - 装饰器模式","keywords":"","body":"设计模式手册 - 6 - 装饰器模式 create by jsliang on 2018年8月30日09:54:33Recently revised in 2019-05-20 17:36:50 第六章 装饰器模式 为对象添加新功能 不改变其原有的结构和功能 手机壳可以简单的看做是一个装饰器模式 6.1 UML类图 6.2 代码实现 class Circle { draw() { console.log(\"画一个圆形\"); } } class Decorator { constructor(circle) { this.circle = circle; } draw() { this.circle.draw(); this.setRedBorder(circle); } setRedBorder() { console.log(\"设置红色边框\"); } } // 测试代码 let circle = new Circle(); circle.draw(); // 画一个圆形 let dec = new Decorator(circle); dec.draw(); // 画一个圆形 // 设置红色边框 6.3 使用场景 ES7 装饰器：  ES7装饰器的三个步骤： npm install babel-plugin-transform-decorators-legacy -D 设置.babelrc配置 { \"presets\": [ \"env\" ], \"plugins\": [ [\"transform-decorators-legacy\"] ] } 然后测试该配置是否生效： // 一个简单的 demo // @testDec 对 Demo 这个 class 的装饰，装饰的方法就是使用 testDec() 这个函数 @testDec class Demo { } function testDec(target) { target.isDec = true; } alert(Demo.isDec); // true  在这里简化下装饰器语法： // 装饰器的原理 @decorator class A {} // 等同于 class A {} A = decorator(A) || A; 装饰类  在这里，我们还可以传参数： // 一个简单的 demo // @testDec 对 Demo 这个 class 的装饰，装饰的方法就是使用 testDec() 这个函数 @testDec(false) class Demo { } function testDec(isDec) { return function(target) { target.isDec = isDec; } } alert(Demo.isDec); // false  然后，我们再根据mixin进行一个示例 function mixins(...list) { return function(target) { Object.assign(target.prototype, ...list); } } const Foo = { foo() { alert('foo') } } @mixins(Foo) class MyClass { } let obj = new MyClass(); obj.foo(); // foo 装饰方法  @readonly 只读属性 class Person { constructor() { this.first = \"A\"; this.last = \"B\"; } // 装饰方法 @readonly name() { return `${this.first} ${this.last}` } } function readonly(target, name, descriptor) { /** * descriptor 属性描述对象 (Object.defineProperty 中会用到)，原来的值如下： * { * value: specifiedFunction, * enumerable: false, * configurable: true, * writable: true * } */ descriptor.writable = false; return descriptor; } var p = new Person(); console.log(p.name()); // A B // 如果设置 p.name = function() {}; 这样子就会报错，因为 name 被我们设置为只读属性  例子2： class Math { // 装饰方法 @log add(a, b) { return a + b; } } function log(target, name, descriptor) { var oldValue = descriptor.value; descriptor.value = function() { console.log(`Calling ${name} with`, arguments); return oldValue.apply(this, arguments); }; return descriptor; } const math = new Math(); const result = math.add(2, 4); // 执行 add 时，会自动打印日志，因为有 @log 装饰器 console.log(\"result\", result); /** * Calling add with Arguments(2) [2, 4, callee: (...), Symbol(Symbol.iterator): ƒ] * result 6 */ 其实，上面的方法，都封装到第三方插件里面去了： core-decorators。这个是第三方开源的lib，提供了常用的装饰器。感兴趣的还可以拜读下官方说明：查看详情  使用 core-decorators 的方式 安装 core-decorators ： npm i core-decorators -S 然后开始编码： readonly： 只读 import { readonly } from 'core-decorators'; class Person { @readonly name() { return 'zhang'; } } let p = new Person(); alert(p.name()); // zhang depercate： 废弃的警告 // 废弃的 API import { deprecate } from 'core-decorators'; class Person { @deprecate faceplam() { } @deprecate(\"We stopped faceplaming\") faceplamHard() { } @deprecate(\"We stopped faceplaming\", {url: \"http://jsliang.top\"}) faceplamHarder() { } } let person = new Person(); person.faceplam(); // deprecate.js:31 DEPRECATION Person#faceplam: This function will be removed in future versions. person.faceplamHard(); // DEPRECATION Person#faceplamHard: We stopped faceplaming person.faceplamHarder(); // deprecate.js:31 DEPRECATION Person#faceplamHarder: We stopped faceplaming // See http://jsliang.top for more details.**** 6.4 设计原则验证 将现有对象和装饰器进行分离，两者独立存在 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:37:57 "},"JavaScript-library/design-pattern/design-pattern-chapter07.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter07.html","title":"✘ 设计模式手册 - 7 - 代理模式","keywords":"","body":"设计模式手册 - 7 - 代理模式 create by jsliang on 2018年8月30日15:47:00Recently revised in 2019-05-20 17:38:16 第七章 代理模式 使用者无权访问目标对象 中间加代理，通过代理做授权和控制 关于代理模式，可以简单理解下 国外网站。有些国外网站被墙了的，需要我们通过一些能访问国外站点的代理服务器去访问 公司网络。有些公司有自己的内容，如果我们在家要访问，那么就需要通过代理，才能访问到。 明星经纪人。如果你要找明星演戏，你是找不到本人的，这时候你需要找它的代理：经纪人。去详谈合作事务，谈妥当后经纪人会帮你转告明星，开始工作。 7.1 UML类图 7.2 代码演示  代理模式中，代理的类提供的接口必须跟被代理的类名一样。 class ReadImg { constructor(fileName) { this.fileName = fileName; this.loadFromDisk(); // 初始化即从硬盘中加载，模拟 } display() { console.log(\"display... \" + this.fileName); } loadFromDisk() { console.log(\"loading... \" + this.fileName); } } class ProxyImg { constructor(fileName) { this.realImg = new ReadImg(fileName); } display() { this.realImg.display(); } } // 测试 let proxyImg = new ProxyImg(\"1.png\"); proxyImg.display(); // loading... 1.png // display... 1.png 7.3 使用场景 网页事件代理 jQuery $.proxy 网页时间代理 HelloWorld a1 a2 a3 a4 a5 $(function() { var div1 = document.getElementById(\"div1\"); div1.addEventListener(\"click\", function(e) { var target = e.target; if(target.nodeName === \"A\") { alert(target.innerHTML); } }) }) $.proxy HelloWorld .red { color: green; } a1 a2 a3 a4 a5 Hello World! $(function() { $(\"#div1\").click(function() { var _this = this; setTimeout(function() { console.log(this); $(_this).css(\"background-color\", \"yellow\"); }, 1000) }) // 使用 $.proxy 解决，这样就少定义一个变量 $(\"#div2\").click(function() { // var fn = function() { // $(this).css(\"background-color\", \"yellow\"); // } // fn = $.proxy(fn, this); // setTimeout(fn, 1000); // 下面代码等效于上面代码 setTimeout($.proxy(function() { $(this).css(\"background-color\", \"yellow\") }, this), 1000); }) }) ES6 Proxy // 明星 let star = { name: \"张××\", age: 25, phone: 'star - 13910733521' } // 经纪人 let agent = new Proxy(star, { get: function(target, key) { if(key === \"phone\") { // 返回经纪人自己的手机号 return 'agent - 18611112222'; } if(key === \"price\") { // 明星不报价，经纪人报价 return 120000; } return target[key]; }, set: function(target, key, val) { if(key === \"customPrice\") { if(val 7.4 设计原则验证 代理类和目标类分离，隔离开目标类和使用者 符合开放封闭原则 7.5 代理模式 VS 适配器模式 适配器模式：提供一个不同的接口（如不同版本的插头） 代理模式：提供一模一样的接口 7.6 代理模式 VS 装饰器模式 装饰器模式：扩展功能，原有功能不变且可直接使用 代理模式：显示原有功能，但是经过限制或者阉割之后的 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:39:02 "},"JavaScript-library/design-pattern/design-pattern-chapter08.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter08.html","title":"✘ 设计模式手册 - 8 - 外观模式","keywords":"","body":"设计模式手册 - 8 - 外观模式 create by jsliang on 2018年8月30日15:47:00Recently revised in 2019-05-20 17:39:23 第八章 外观模式 为子系统中的一组接口提供了一个高层接口 使用者使用这个高层接口  例子1： 去医院看病，接待员去挂号、门诊、划价、取药，而我们不需要亲手去找 8.1 设计原则元整 不符合单一职责和开放封闭原则，因此谨慎使用，不可滥用 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:39:25 "},"JavaScript-library/design-pattern/design-pattern-chapter09.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter09.html","title":"✘ 设计模式手册 - 9 - 观察者模式","keywords":"","body":"设计模式手册 - 9 - 观察者模式 create by jsliang on 2018年8月30日15:47:00Recently revised in 2019-05-20 17:40:14 第九章 观察者模式 发布 & 订阅 一对多 9.1 实例场景 点咖啡，点好之后坐等被叫 9.2 UML类图 9.3 代码场景 网页绑定事件 Promise jQuery callbacks nodejs 自定义事件 网页绑定事件 btn // 等待按钮被点击，被点击就触发 $(\"#btn1\").click(function() { console.log(1); }) $(\"#btn1\").click(function() { console.log(2); }) $(\"#btn1\").click(function() { console.log(3); }) Promise function loadImg(src) { var promise = new Promise(function(resolve, reject) { var img = document.createElement(\"img\"); img.onload = function() { resolve(img); } img.onerror = function() { reject(\"图片加载失败\"); } img.src = src; }) return promise; } var src = \"http://www.imooc.com/static/img/index/logo_new.png\"; var result = loadImg(src); result.then(function(img) { console.log(\"width\", img.width); // width 252 return img; }).then(function(img) { console.log(\"height\", img.height); // height 144 }) jQuery callbacks var callbacks = $.Callbacks(); // 注意大小写 callbacks.add(function(info) { console.log(\"fn1\", info); }) callbacks.add(function(info) { console.log(\"fn2\", info); }) callbacks.add(function(info) { console.log(\"fn3\", info); }) callbacks.fire(\"gogogo!\"); // fn1 gogogo! // fn2 gogogo! // fn3 gogogo! callbacks.fire(\"fire!\"); // fn1 fire! // fn2 fire! // fn3 fire! nodejs 自定义事件 代码1 const EventEmitter = require(\"events\").EventEmitter; const emitter1 = new EventEmitter(); emitter1.on(\"some\", () => { // 监听 some 事件 console.log(\"some event is occured 1\"); }) emitter1.on(\"some\", () => { // 监听 some 事件 console.log(\"some event is occured 2\"); }) // 触发 some 事件 emitter1.emit(\"some\"); // some event is occured 1 // some event is occured 2 代码2 const EventEmitter = require(\"events\").EventEmitter; const emitter = new EventEmitter(); emitter.on(\"showName\", () => { // 监听 some 事件 console.log(\"event occured\", name); }) emitter.emit(\"showName\", \"jsliang\"); // emit 时候可以传递参数过去 // event occured 代码3 const EventEmitter = require('events').EventEmitter; // 任何构造函数都可以继承 EventEmitter 的方法 on emit class Dog extends EventEmitter { constructor(name) { super(); this.name = name; } } var simon = new Dog(\"simon\"); simon.on(\"bark\", function() { console.log(this.name, \" barked\"); }) setInterval(function() { simon.emit(\"bark\"); }, 1000) // simon barked // simon barked // simon barked // ... 代码4 // Stream 用到了自定义事件 var fs = require(\"fs\"); var readStream = fs.createReadStream(\"./dist/js/index.js\"); // 读取文件的 Stream var length = 0; readStream.on(\"data\", function(chunk) { length += chunk.toString().length(); }) readStream.on(\"end\", function() { console.log(length); }) 9.4 设计原则验证 主题和观察者分离，不是主动触发而是被动监听，两者解耦 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:40:48 "},"JavaScript-library/design-pattern/design-pattern-chapter10.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter10.html","title":"✘ 设计模式手册 - 10 - 迭代器模式","keywords":"","body":"设计模式手册 - 10 - 迭代器模式 create by jsliang on 2018年8月30日15:47:00Recently revised in 2019-05-20 17:41:10 第十章 迭代器模式 顺序访问一个集合 使用者无需知道集合的内部结构（封装） 10.1 代码演示 HelloWorld jQuery each jQuery each jQuery each $(function () { var arr = [1, 2, 3]; var nodeList = document.getElementsByTagName(\"p\"); var $p = $(\"p\"); function each(data) { var $data = $(data); // 生成迭代器 $data.each(function (key, val) { console.log(key, val); }) } each(arr); // 0 1 // 1 2 // 2 3 each(nodeList); // 0 ​jQuery each​​ // 1 ​jQuery each​​ // 2 ​jQuery each​​ each($p); // 0 ​jQuery each​​ // 1 ​jQuery each​​ // 2 ​jQuery each​​ }) 10.2 UML类图 10.3 使用场景 jQuery each ES6 Iterator: 为何存在？ES6 语法中，有序集合的数据类型已经有很多。Array Map Set String TypedArray arguments NodeList。需要有一个统一的遍历接口来遍历所有数据类型。（注意，object不是有序集合，可以用Map代替）。是什么？以上数据类型，都有 [Symbol.iterator] 属性。属性值是函数，执行函数返回一个迭代器。这个迭代器就有next方法可顺序迭代子元素。可运行 Array.prototype[Symbol.iterator] 来测试。 jQuery each HelloWorld jQuery each jQuery each jQuery each $(function() { var arr = [1, 2, 3]; var nodeList = document.getElementsByTagName(\"p\"); var $p = $(\"p\"); // 要对这三个变量进行遍历，需要写三个遍历方法 // 第一 arr.forEach(function(item) { console.log(item); // 1 // 2 // 3 }) // 第二 var i, length = nodeList.length; for(i = 0; i jQuery each // jQuery each // jQuery each } // 第三 $p.each(function(key, p) { console.log(key, p); // 0 jQuery each // 1 jQuery each // 2 jQuery each }) }) ES6 Iterator // 旧写法： // function each(data) { // // 生成遍历器 // let iterator = data[Symbol.iterator](); // // console.log(iterator.next()); // 有数据： {value: \"1\", done: false} // // console.log(iterator.next()); // // console.log(iterator.next()); // // console.log(iterator.next()); // 无数据： Cannot read property 'Symbol(Symbol.iterator)' of undefined // let item = {done: false}; // while(!item.done) { // item = iterator.next(); // if(!item.done) { // console.log(item.value); // } // } // } // `Symbol.iterator` 并不是每个人斗志 // 也不是每个人都需要封装一个 each方法 // 因此有了 `for...of` 语法， `for...of`是遍历迭代器的 function each(data) { // 带有遍历器特性的对象： data[Symbol.iterator] 有值 for(let item of data) { console.log(item); } } let arr = [1, 2, 3, 4]; let nodeList = document.getElementsByTagName(\"p\"); let m = new Map(); m.set(\"a\", 100); m.set(\"b\", 200); each(arr); // 1 // 2 // 3 // 4 each(nodeList); // jsliang的设计模式 each(m); // (2) [\"a\", 100] // (2) [\"b\", 200] 10.4 ES6 Iterator 与 Generator Iterator 的价值不限于上述几个类型的遍历 还有 Generator 函数的使用 即只要返回的数据符合 Iterator 接口的要求 即可使用 Iterator 语法，这就是迭代器模式 Generator 应用不是那么广泛了，使用场景比较少 10.5 设计原则验证 迭代器对象和目标对象分离 迭代器将使用者与目标对象隔离开 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:41:32 "},"JavaScript-library/design-pattern/design-pattern-chapter11.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter11.html","title":"✘ 设计模式手册 - 11 - 状态模式","keywords":"","body":"设计模式手册 - 11 - 状态模式 create by jsliang on 2018年9月3日10:30:19Recently revised in 2019-05-20 17:42:49 第十章 状态模式 一个对象有状态变化 每次状态变化都会触发一个逻辑 不能总是用 if...else... 来控制 场景：交通信号灯不同颜色的变化 11.1 UML图 11.2 代码演示 // 状态：红灯、绿灯、蓝灯 class State { constructor(color) { this.color = color; } handle(context) { console.log(`turn to ${this.color} light.`); // 设置状态 context.setState(this); } } // 主体 class Context { constructor() { this.state = null; } // 状态获取 getState() { return this.state; } setState(state) { this.state = state; } } // test let context = new Context(); let green = new State(\"green\"); let yellow = new State(\"yellow\"); let red = new State(\"red\"); // 绿灯亮了 green.handle(context); console.log(context.getState()); // 打印状态 // turn to green light. // State {color: \"green\"} // 黄灯亮了 yellow.handle(context); console.log(context.getState()); // 打印状态 // turn to yellow light. // State {color: \"yellow\"} // 红灯亮了 red.handle(context); console.log(context.getState()); // 打印状态 // turn to red light. // State {color: \"red\"} 11.3 场景 有限状态机 写一个简单的Promise 有限状态机 有限个状态、以及在这些状态之间的变化 如交通信号灯 使用开源 lib： javascipt-state-machine: 详情 javascript-state-machine 来做状态模式： 安装：npm i javascript-state-machine 代码：es6 webpack 环境下 index.html jsliang的设计模式 jsliang的设计模式 --> index.js import StateMachine from 'javascript-state-machine' // 初始化状态机模型 var fsm = new StateMachine({ init: \"收藏\", // 初始状态，待收藏 transitions: [ { name: \"doStore\", from: \"收藏\", to: \"取消收藏\" }, { name: \"deleteStore\", from: \"取消收藏\", to: \"收藏\" } ], methods: { // 监听执行收藏 onDoStore: function() { alert(\"收藏成功\"); // 可以 post 请求 updateText(); }, // 监听取消收藏 onDeleteStore: function() { alert(\"已取消收藏\"); // 可以 post 请求 updateText(); } } }) let $btn = $(\"#btn\"); // 点击事件 $btn.click(function() { if(fsm.is(\"收藏\")) { fsm.doStore(); } else { fsm.deleteStore(); } }) // 更新文案 function updateText() { $btn.text(fsm.state); } // 初始化文案 updateText(); 写一个简单的 Promise 回顾 Promise 的语法 分析：Promise 就是一个有限状态机 写代码 测试验证 function loadImg(src) { const promise = new Promise(function(resolve, reject) { var img = document.createElement(\"img\"); img.onload = function() { resolve(img); } img.onerror = function() { reject(); } img.src = src; }) return promise; } var src = \"http://www.imooc.com/static/img/index/logo_new.png\"; var result = loadImg(src); result.then(function(img) { console.log(\"success 1\"); }, function() { console.log(\"failed 1\"); }) // success 1 result.then(function(img) { console.log(\"success 2\"); }, function() { console.log(\"failed 2\"); }) // success 2 /** * 如果地址错误，则： * logo_new1.png:1 GET http://www.imooc.com/static/img/index/logo_new1.png 404 (Not Found) * failed 1 * failed 2 */ Promise 就是有限状态机 Promise 三种状态： pending fullfilled rejected pending -> fullfilled 或者 pending -> rejected 不能逆向变化 import StateMachine from 'javascript-state-machine'; // 状态机模型 var fsm = new StateMachine({ init: \"pending\", transitions: [ { name: \"resolve\", from: \"pending\", to: \"fullfilled\" }, { name: \"reject\", from: \"pending\", to: \"rejected\" } ], methods: { // 监听 resolve 成功 onResolve: function(state, data) { // 参数：state - 当前状态示例；data - fsm.resolve(xxx) 执行时传递过来的参数 data.successList.forEach(fn => fn()); }, // 失败 onReject: function(state, data) { // 参数：state - 当前状态示例；data - fsm.reject(xxx) 执行时传递过来的参数 data.failList.forEach(fn => fn()); } } }) // 定义 Promise class MyPromise { constructor(fn) { this.successList = []; this.failList = []; fn(() => { // resolve 函数 fms.resolve(this); }, () => { // reject 函数 fsm.reject(this); }) } then(successFn, failFn) { this.successList.push(successFn); this.failList.push(failFn); } } // 测试代码 function loadImg(src) { const promise = new Promise(function(resolve, reject) { let img = document.createElement(\"img\"); img.onload = function() { resolve(img); } img.onerror = function() { reject(); } img.src = src; }) return promise; } let src = \"http://www.imooc.com/static/img/index/logo_new.png\"; let result = loadImg(src); result.then(function() { console.log(\"ok1\"); }, function() { console.log(\"fail1\"); }) // ok1 result.then(function() { console.log(\"ok2\"); }, function() { console.log(\"fail2\"); }) // ok2 11.4 设计原则验证 将状态对象和主题对象分离，状态的变化逻辑单独处理 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:42:50 "},"JavaScript-library/design-pattern/design-pattern-chapter12.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter12.html","title":"✘ 设计模式手册 - 12 - 其他模式","keywords":"","body":"设计模式手册 - 12 - 其他模式 create by jsliang on 2018年9月3日11:53:05Recently revised in 2019-05-20 17:42:42 第十二章 其他模式  这里讲解前11章之外，比较少用的模式。 原型模式、桥接模式、组合模式、享元模式、策略模式、模板方法模式、职责连模式、命令模式、备忘录模式、中介者模式、访问者模式、解释器模式 12.1 原型模式 clone 自己，生成一个新对象 Java 默认有 clone 接口，不用自己实现 对比 JS 中的原型 prototype： prototype 可以理解为 ES6 class 的一种底层原理 而 class 是实现面向对象的基础，并不是服务于某个模式 若干年后如果 ES6 全面普及，大家可能会忽略掉 prototype 但是 Object.create 却会长久存在 // `Object.create` 用到了原型模式的思想（虽然不是 java 中的 clone ） // 基于一个原型创建一个对象 var prototype = { getName: function() { return this.first + \" \" + this.last; }, say: function() { console.log(\"hello\"); } } // 基于原型创建 x let x = Object.create(prototype); x.first = \"A\"; x.last = \"B\"; alert(x.getName()); // A B x.say(); // hello 12.2 桥接模式 用户把抽象化与实现化解耦 使得二者可以独立变化 原实例场景 class ColorShape { yellowCircle() { console.log(\"yellow circle\"); } redCircle() { console.log(\"red circle\"); } yellowTriangle() { console.log(\"yellow triangle\"); } redTriangle() { console.log(\"red triangle\"); } } // 测试 let cs = new ColorShape(); cs.yellowCircle(); // yellow circle cs.redCircle(); // red circle cs.yellowTriangle(); // yellow triangle cs.redTriangle(); // red triangle 使用桥接模式 class Color { constructor(name) { this.name = name; } } class Shape { constructor(name, color) { this.name = name; this.color = color; } draw() { console.log(`${this.color.name} ${this.name}`); } } // 测试代码 let red = new Color(\"red\"); let yellow = new Color(\"yellow\"); let circle = new Shape(\"circle\", red); circle.draw(); // red circle let triangle = new Shape(\"triangle\", yellow); triangle.draw(); // yellow triangle 设计原则验证 抽象和实现分离，解耦 符合开放封闭原则 12.3 组合模式 生成树形结构，表示“整体-部分”关系 让整体和部分都具有一致的操作模式 123 456 { tag: \"div\", attr: { id: \"div1\", className: \"container\" }, children: [ { tag: \"p\", attr: {}, children: [\"123\"] }, { tag: \"p\", attr: {}, children: [\"456\"] } ] } 整体和单个节点的操作是一致的 整体和单个节点的数据结构也保持一致 设计原则验证 将整体和单个节点的操作抽象出来 符合开放封闭原则 12.4 享元模式 共享内存（主要考虑内存，而非效率） 相同的数据，共享使用 `标签，对内存开销太大 --> a1 a2 a3 a4 var div1 = document.getElementById(\"div1\"); div1.addEventListener(\"click\", function(e) { var target = e.target; if(e.nodeName === \"A\") { alert(target.innerHTML); } }) 设计原则验证 将相同的部分抽象出来 符合开放封闭原则 12.5 策略模式 不同策略分开处理 避免出现大量 if...else... 或者 switch...case... 原代码实现 class User { constructor(type) { this.type = type; } buy() { if(this.type === \"ordinary\") { console.log(\"普通用户购买\"); } else if(this.type === \"member\") { console.log(\"会员用户购买\"); } else if(this.type === \"vip\") { console.log(\"vip 用户购买\"); } } } 策略模式代码实现针对不用的用户，设计不用的类，从而解耦用户等级 class OrdinaryUser { buy() { console.log(\"普通用户购买\"); } } class MemberList { buy() { console.log(\"会员用户购买\"); } } class VipUser { buy() { console.log(\"vip 用户购买\"); } } var u1 = new OrdinaryUser(); u1.buy(); var u2 = new MemberList(); u2.buy(); var u3 = new VipUser(); u3.buy(); // 测试代码 var u1 = new User(\"ordinary\"); u1.buy(); // 普通用户购买 var u2 = new User(\"member\"); u2.buy(); // 会员用户购买 var u3 = new User(\"vip\"); u3.buy(); // vip 用户购买 设计原则验证 不同策略，分开处理，而不是混合在一起 符合开放封闭原则 12.6 模板方法模式 class Action { handle() { handle1(); handle2(); handle3(); } handle1() { console.log(\"1\"); } handle2() { console.log(\"2\"); } handle3() { console.log(\"3\"); } } let action = new Action(); action.handle(); 12.7 职责连模式 一步操作可能分为多个职责来完成 把这些角色都分开，然后用一个链串起来 将发起者和各个处理者进行隔离 // 请假审批，需要组长审批、经理审批、最后总监审批 class Action { constructor(name) { this.name = name; this.nextAction = null; } setNextAction(action) { this.nextAction = action; } handle() { console.log(`${this.name} 审批`); if(this.nextAction != null) { this.nextAction.handle(); } } } let a1 = new Action(\"组长\"); let a2 = new Action(\"经理\"); let a3 = new Action(\"总监\"); a1.setNextAction(a2); a2.setNextAction(a3); a1.handle(); // 组长 审批 // 经理 审批 // 总监 审批 使用场景 职责链模式和业务结合较多，JS 中能联想到链式操作 jQuery 的链式操作， Promise.then 的链式操作 设计原则验证 发起者于各个处理者进行隔离 符合开放封闭原则 12.8 命令模式模式 执行命令时，发布者和执行者分开 中间加入命令对象，作为中转站 将军发布命令，先告诉副官，由副官进行传达，而不是将军一个一个告诉军队 董事长实施战略，先告诉经理，至于各部门如何协调，让经理进行排期。 // 接受者 class Receiver { exec() { console.log(\"执行\"); } } // 命令者 class Command { constructor(receiver) { this.receiver = receiver; } cmd() { console.log(\"触发命令\"); this.receiver.exec(); } } // 触发者 class Invoker { constructor(command) { this.command = command; } invoke() { console.log(\"开始\"); this.command.cmd(); } } // 士兵 let soldier = new Receiver(); // 小号手 let trumpeter = new Command(soldier); // 将军 let general = new Invoker(trumpeter); general.invoke(); // 开始 // 触发命令 // 执行 JS 中的应用 网页富文本编辑器操作，浏览器封装了一个命令对象 document.execCommand(\"bold\") document.execCommand(\"undo\") 设计原则验证 命令对象于执行对象分开，解耦 符合开放封闭原则 12.9 备忘录模式 随时记录一个对象的状态变化 随时可以恢复之前的某个状态（如撤销功能） // 状态备忘 class Memento { constructor(content) { this.content = content; } getContent() { return this.content; } } // 备忘列表 class CareTaker { constructor() { this.list = []; } add(memento) { this.list.push(memento); } get(index) { return this.list[index]; } } // 编辑器 class Editor { constructor() { this.content = null; } setContent(content) { this.content = content; } getContent() { return this.content; } saveContentToMemento() { return new Memento(this.content); } getContentFromMemento(memento) { this.content = memento.getContent(); } } // 测试代码 let editor = new Editor(); let careTaker = new CareTaker(); editor.setContent(\"111\"); editor.setContent(\"222\"); careTaker.add(editor.saveContentToMemento()); // 存储备忘录 editor.setContent(\"333\"); careTaker.add(editor.saveContentToMemento()); // 存储备忘录 editor.setContent(\"444\"); console.log(editor.getContent()); // 444 editor.getContentFromMemento(careTaker.get(1)); // 撤销 console.log(editor.getContent()); // 333 editor.getContentFromMemento(careTaker.get(0)); // 撤销 console.log(editor.getContent()); // 222 /** * 这里是预知了要撤销的步骤 * 假如，不知道要存储了多少条备忘录 * 而我们要一步步回撤，则需要怎么做？ * 个人想法就是还需要一个计步器 * 就是你存了多少备忘录，则记起来 * 当你需要回撤的时候，直接读取最近的备忘条数 * 即可回撤到最近一步操作 */ 设计原则验证 状态对象与使用者分开，解耦 符合开放封闭原则 12.10 中介者模式 中介者原理 class Mediator { constructor(a, b) { this.a = a; this.b = b; } setA() { let number = this.b.number; this.a.setNumber(number * 100); } setB() { let number = this.a.number; this.b.setNumber(number / 100); } } class A { constructor() { this.number = 0; } setNumber(num, m) { this.number = num; if(m) { m.setB(); } } } class B { constructor() { this.number = 0; } setNumber(num, m) { this.number = num; if(m) { m.setA(); } } } // 测试 let a = new A(); let b = new B(); let m = new Mediator(a, b); a.setNumber(100, m); console.log(a.number, b.number); // 100 1 b.setNumber(100, m); console.log(a.number, b.number); // 10000 100 设计原则验证 将各关联对象通过中介者隔离 符合开放封闭原则 12.11 访问者模式 将数据操作和数据结构进行分离 使用场景不多 12.12 解释器模式 描述语言语法如何定义，如何解释和编译 用于专业场景 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:44:13 "},"JavaScript-library/design-pattern/design-pattern-chapter13.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter13.html","title":"✘ 设计模式手册 - 13 - 综合应用","keywords":"","body":"设计模式手册 - 13 - 综合应用 create by jsliang on 2018年9月4日09:37:55Recently revised in 2019-05-20 17:44:37 第十三章 综合应用-购物车  最后，我们使用 jQuery 做一个模拟购物车的示例。 功能如下： 显示购物列表 加入购物车 从购物车删除 涉及的设计模式： 工厂模式 单例模式 装饰器模式 观察者模式 状态模式 模板方法模式 代理模式 13.1 UML类图 13.2 编程环境搭建  如果小伙伴有跟着 部署开发环境 搭建了属于自己的设计模式环境，那么，就让我们优化一下直接跑起我们的综合应用就OK了~如果小伙伴没有去做，那么先跟着 部署开发环境 先跑一遍，再回来做我们的综合应用吧！前往：第一章 部署开发环境  OK，Here we go! 我们目前的目录 目录文件  在这里，我们先过一遍我们的文件，没有配置设计模式环境的小伙伴可以照上面的图新建过文件目录，配置好的小伙伴看看代码和 jsliang 的代码是否一致：  dist - 打包后的文件存放地方  dist/js - 该文件夹为打包后的 js 文件存储位置，这里的 index.js 系自动生成，无需新增该文件  dist/index.html - 打包后的 index.html ，一般是依据原有的 index.html ，打包时 webpack 往里面添加 \\ ，这里我们需要添加下列代码进去。 jsliang的设计模式 Hello 综合应用！ --> -->  node_modules - npm 安装包，在拷贝了其他文件的代码后，我们 npm i 会自动生成  src/index.js - 被打包的 js 文件，暂时不需要添加代码  .babelrc - es6、es7 代码转为 es5 代码所必需的文件 { \"presets\": [ \"env\" ], \"plugins\": [ [\"transform-decorators-legacy\"] ] }  package.json - 项目的依据，所依赖的插件都在这里提示 { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack-dev-server --config ./webpack.dev.config.js\", \"build\": \"webpack --config ./webpack.dev.config.js\" }, \"keywords\": [ \"javascript\", \"design pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-plugin-transform-decorators-legacy\": \"^1.3.5\", \"babel-polyfill\": \"^6.26.0\", \"babel-preset-env\": \"^1.7.0\", \"html-webpack-plugin\": \"^3.2.0\", \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", \"webpack-dev-server\": \"^3.1.5\" }, \"dependencies\": { \"core-decorators\": \"^0.20.0\", \"javascript-state-machine\": \"^3.1.0\", \"jquery\": \"^3.3.1\" } }  webpack.dev.config.js - webpack 开发模式下会使用到的 loader 以及插件等配置 const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'development', // 开发模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname + '/dist', filename: './js/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ], devServer: { // 开发服务 contentBase: path.join(__dirname, './dist'), // 监控的目录 open: true, // 自动打开浏览器 port: 9000, // 端口 // host: \"192.168.1.87\" // WiFi IPV4地址，打开可共享到手机 } }  webpack.prod.config.js - 生产环境，打包文件到 dist 目录，然后发布到服务器上即可生效访问 const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'production', // 生产模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname + '/dist', filename: './js/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ] } 复制粘贴完这些代码之后，我们就可以跑起项目来了！ 安装 npm 包：npm i 进入开发模式：npm run dev 生产模式打包：npm run build  很好，上面就是我们原有的目录，让我们往里面新增代码，配置综合应用的环境吧： 搭建完后的目录  如图，我们需要往 src 目录下新增 api 文件夹及其 list.json 以及 src 目录下的 App.js。  然后，我们需要往 webpack.dev.config.js 中的 devServer 添加解决跨域的代码，因为我们将采用其他端口作为我们的 API 地址： proxy: { \"/api/*\": { // url 中匹配到 \"/api\" 之前的东西，将其全部替换成下面 target 中的东西，从而解决跨域问题 target: \"http://localhost:8880\" } }  此刻我们的 index.js 、App.js 以及 list.json 文件内容如下： index.js - 启动文件，通过 index.js 访问 App.js 这个主入口 import App from './demo/App.js' let app = new App('app'); app.init(); App.js - 项目主入口 export default class App { constructor(id) { } init() { console.log(\"初始化成功！\"); } } list.json - api接口文件，提供书籍清单 [ { \"id\": 1, \"name\": \"《JS 基础面试题》\", \"price\": 149, \"discount\": 1 }, { \"id\": 2, \"name\": \"《JS 高级面试题》\", \"price\": 366, \"discount\": 1 }, { \"id\": 3, \"name\": \"《React 模拟大众点评 webapp》\", \"price\": 248, \"discount\": 0 }, { \"id\": 4, \"name\": \"《zepto 设计与源码解读》\", \"price\": 0, \"discount\": 0 } ]  到这里，我们一切准备就绪，只需要执行两步即可： cd 到 demo 目录中，打开接口服务： cd src/demo http-server -p 8880 这时候我们打开下面地址，会发现该 api 接口成功开启： 打开开发模式： npm run start 这时候浏览器会自动打开 localhost:9000 ，如果没有打开，请在浏览器输入 http://localhost:9000 即可访问到：  好的，到此为止，我们已经完美部署了我们综合应用的开发环境，让我们继续前进吧！ 13.3 代码剖析 步骤1 inde.js import App from './demo/App.js' let app = new App('app'); app.init(); App.js import $ from 'jquery' export default class App { constructor(id) { this.$el = $(\"#\" + id); } // 初始化购物车 initShoppingCart() { console.log(\"初始化购物车\"); } // 初始化列表 initList() { console.log(\"初始化列表\"); } init() { this.initShoppingCart(); this.initList(); } } 步骤2 步骤3 ShoppingCart.js export default class ShoppingCart { constructor(app) { } init() { } } List.js export default class ShoppingCart { constructor(app) { } init() { } } App.js import $ from 'jquery' import ShoppingCart from './ShoppingCart/ShoppingCart.js' import List from './List/List.js' export default class App { constructor(id) { this.$el = $(\"#\" + id); } // 初始化购物车 initShoppingCart() { let shoppingCart = new ShoppingCart(this); shoppingCart.init(); } // 初始化列表 initList() { let list = new List(this); list.init(); } init() { this.initShoppingCart(); this.initList(); } } 步骤4 List.js import $ from 'jquery' export default class ShoppingCart { constructor(app) { this.app = app; this.$el = $(''); } // 获取数据 loadData() { } // 生成列表 initItemList(data) { } // 渲染 render() { } init() { } } 步骤5 config.js export const GET_LIST = '/api/list.json' 步骤6 List.js import $ from 'jquery' import { GET_LIST } from '../config/config.js' export default class ShoppingCart { constructor(app) { this.app = app; this.$el = $(''); } // 获取数据 loadData() { // 返回 Promise 实例 return fetch(GET_LIST).then(result => { return result.json(); }); } // 生成列表 initItemList(data) { data.map(itemData => { // 创建一个 Item 然后 init }) } // 渲染 render() { this.app.$el.append(this.$el); } init() { this.loadData().then(data => { this.initItemList(data); }).then(() => { // 渲染 this.render(); }) } } 步骤7 GetCart.js class Cart { constructor() { this.list = []; } add(data) { this.list.push(data); } del(id) { this.list = this.list.filter(item => { if(item.id === id) { return false; } return true; }) } getList() { return this.list.map(item => { return item.name; }).join('\\n'); } } // 返回单例 let getCart = (function() { let cart; return function() { if(!cart) { cart = new Cart(); } return cart; } })() export default getCart; 步骤8 Item.js import $ from 'jquery'; import getCart from '../ShoppingCart/GetCart.js'; export default class Item { constructor(list, data) { this.list = list; this.data = data; this.$el = $(''); this.cart = getCart(); } initContent() { let $el = this.$el; let data = this.data; $el.append($(`名称：${data.name}`)); $el.append($(`价格：${data.name}`)); } initBtn() { let $el = this.$el; let $btn = $('test'); $btn.click(() => { // 添加到购物车 // 从购物车移除 }) $el.append($btn); } // 添加到购物车 addToCartHandle() { this.cart.add(this.data); } // 从购物车删除 deleteFromCartHandle() { this.cart.del(this.data.id); } render() { this.list.$el.append(this.$el); } init() { this.initContent(); this.initBtn(); this.render(); } } 步骤9 CreateItem.js import Item from './Item.js' // 补充：优惠商品的处理逻辑 // 工厂函数 export default function(list, itemData) { return new Item(list, itemData); } List.js import $ from 'jquery' import { GET_LIST } from '../config/config.js' import createItem from './CreateItem.js' export default class ShoppingCart { constructor(app) { this.app = app; this.$el = $(''); } // 获取数据 loadData() { // 返回 Promise 实例 return fetch(GET_LIST).then(result => { return result.json(); }); } // 生成列表 initItemList(data) { // data.map(itemData => { // // 创建一个 Item 然后 init // let item = createItem(this, itemData); // item.init(); // return item; // }) data.forEach(itemData => { // 创建一个 Item 然后 init let item = createItem(this, itemData); item.init(); }) } // 渲染 render() { this.app.$el.append(this.$el); } init() { this.loadData().then(data => { this.initItemList(data); }).then(() => { // 渲染 this.render(); }) } } 步骤10 Item.js import $ from 'jquery'; import getCart from '../ShoppingCart/GetCart.js'; // 引用第三方插件实现状态模式 import StateMachine from 'javascript-state-machine'; export default class Item { constructor(list, data) { this.list = list; this.data = data; this.$el = $(''); this.cart = getCart(); } initContent() { let $el = this.$el; let data = this.data; $el.append($(`名称：${data.name}`)); $el.append($(`价格：${data.price}`)); } initBtn() { let $el = this.$el; let $btn = $(''); let _this = this; let fsm = new StateMachine({ init: '加入购物车', transitions: [ { name: 'addToCart', from: '加入购物车', to: '从购物车删除' }, { name: 'deleteFromCart', from: '从购物车删除', to: '加入购物车' } ], methods: { // 加入购物车 onAddToCart: function() { _this.addToCartHandle(); updateText(); }, // 从购物车删除 onDeleteFromCart: function() { _this.deleteFromCartHandle(); updateText(); } } }) function updateText() { $btn.text(fsm.state); } $btn.click(() => { if(fsm.is('加入购物车')) { fsm.addToCart(); } else { fsm.deleteFromCart(); } }) updateText(); $el.append($btn); } // 添加到购物车 addToCartHandle() { this.cart.add(this.data); } // 从购物车删除 deleteFromCartHandle() { this.cart.del(this.data.id); } render() { this.list.$el.append(this.$el); } init() { this.initContent(); this.initBtn(); this.render(); } } 步骤11 步骤12 ShoppingCart.js import $ from 'jquery'; import getCart from './GetCart.js' export default class ShoppingCart { constructor(app) { this.app = app; this.$el = $('').css({ 'padding-bottom': '10px;', 'border-bottom': '1px solid #ccc' }) this.cart = getCart(); } initBtn() { let $btn = $('购物车'); $btn.click(() => { this.showCart(); }) this.$el.append($btn); } showCart() { alert(this.cart.getList()); } render() { this.app.$el.append(this.$el); } init() { this.initBtn(); this.render(); } } 步骤13 CreateItem.js import Item from './Item.js' function createDiscount(itemData) { // 用代理做折扣显示 return new Proxy(itemData, { get: function(target, key, receiver) { if(key === 'name') { return `${target[key]} 【折扣】`; } if(key === 'price') { return target[key] * 0.8; } return target[key]; } }) } // 工厂函数 export default function(list, itemData) { if(itemData.discount) { itemData = createDiscount(itemData); } return new Item(list, itemData); } 步骤14 log.js export function log(type) { return function(target, name, descriptor) { let oldValue = descriptor.value; descriptor.value = function() { // 在此统一打印日志 console.log(`日志上报 ${type}`); // 执行原有的方法 return oldValue.apply(this, arguments); } return descriptor; } } Item.js import $ from 'jquery'; import getCart from '../ShoppingCart/GetCart.js'; // 引用第三方插件实现状态模式 import StateMachine from 'javascript-state-machine'; import { log } from '../util/log.js' export default class Item { constructor(list, data) { this.list = list; this.data = data; this.$el = $(''); this.cart = getCart(); } initContent() { let $el = this.$el; let data = this.data; $el.append($(`名称：${data.name}`)); $el.append($(`价格：${data.price}`)); } initBtn() { let $el = this.$el; let $btn = $(''); let _this = this; let fsm = new StateMachine({ init: '加入购物车', transitions: [ { name: 'addToCart', from: '加入购物车', to: '从购物车删除' }, { name: 'deleteFromCart', from: '从购物车删除', to: '加入购物车' } ], methods: { // 加入购物车 onAddToCart: function() { _this.addToCartHandle(); updateText(); }, // 从购物车删除 onDeleteFromCart: function() { _this.deleteFromCartHandle(); updateText(); } } }) function updateText() { $btn.text(fsm.state); } $btn.click(() => { if(fsm.is('加入购物车')) { fsm.addToCart(); } else { fsm.deleteFromCart(); } }) updateText(); $el.append($btn); } // 添加到购物车 @log('add') // 装饰器模式 addToCartHandle() { this.cart.add(this.data); } // 从购物车删除 @log('del') deleteFromCartHandle() { this.cart.del(this.data.id); } render() { this.list.$el.append(this.$el); } init() { this.initContent(); this.initBtn(); this.render(); } } 13.4 总结  项目中使用到的模式： 工厂模式：$('×××')，创建商品 单例模式：购物车 装饰器模式：打点统计 观察者模式：网页事件，Promise 状态模式：添加到购物车 & 从购物车删除 模板方法模式：渲染有统一的方法，内部包含了各模块渲染 代理模式：打折商品信息处理 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:47:34 "},"other-library/":{"url":"other-library/","title":"★ 其他资料室","keywords":"","body":"其他资料室 Create by jsliang on 2018-10-28 11:07:33Recently revised in 2019-5-20 08:25:29 All the articles that can not be classified are stored here 这里存放了目前所有无法分类的文章 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 "},"other-library/Git/":{"url":"other-library/Git/","title":"☆ Git","keywords":"","body":"Git Create by jsliang on 2018-10-25 15:14:00Recently revised in 2019-04-02 21:31:22 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文 二 前言 返回目录 一直以来，jsliang 对 Git 的操作，仅限于：git add .、git commit -m \"更新信息\"、git push 这三个，偶尔还会创建操作个分支。 但是，仅仅是这些是不够的。所以，跟随 廖雪峰 等大神的 Git 教程进行一波自我更新： 《Git 教程 - 廖雪峰》 什么是 Git Git 是目前世界上最先进的分布式版本控制系统。 这么说也许你很懵逼，没关系，我们用毕业论文来讲讲： 如上图。写过毕业论文的小伙伴，应该记忆深刻：《毕业论文》《毕业论文完成版》《毕业论文最终版》《毕业论文最最终版》…… 令人抓狂无比，当我们需要在 最最最最终版 找到之前文件中早早被删除的信息时，我们更加抓狂了：卧槽，我写到哪去了！ 这时候，如果有个软件之类的东西帮我们记录就好了： 文件名 更新信息 时间 毕业论文 第一版，整体内容搭建 2019-3-28 08:41:04 毕业论文完成版 第二版，完成了大部分内容，并进行了排版 2019-3-29 08:41:46 毕业论文最终版 第三版，对第二版进行了删减 2019-3-30 08:42:21 毕业论文最最终版 第四版，对第三版进行了新增 2019-3-31 08:42:42 ... ... ... 毕业论文最最最最终版 第六版，对整了下格式 2019-4-2 08:43:17 OK，这时候我们会发觉，我们要找到被删减的内容，只需要去第二版中查找就行了，这就是为何会有版本管理工具的原因。 而 Git，就是目前较盛行的版本管理工具。 集中式与分布式 历史总是前进的，在 Git 之前，还是有其他的版本管理系统： VSS：最老的版本有锁，需要锁住才能编辑，提交时解锁，独占修改，小规模最好用，大规模最难用。 CSV：代表协作版本系统或者并发版本系统同，是一种版本控制系统，提交失败时解决冲突比较麻烦。 SVN：目标是想取代 CSV，相对于 CSV 采用了分支管理系统，配置成 HTTP 服务时比较简单，稳定。 Git：相对于 SVN 多一个本地库。 历史总是被湮没，每次找资料，都找不全 关于版本管理工具的历史推进，咱在此就不做详述，如果有小伙伴找到比较全的资源，可以发出来分享下。 关于 SVN 和 Git，其实涉及两种管理系统的比较，即：集中式与分布式。 什么是集中式？集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 什么是分布式？区别于集中式版本控制系统，分布式版本控制系统中没有 “中央服务器”，每个人的电脑都是一个完整的版本库。既然你的电脑是一个完整的版本库，假设你改了文件 A，你的同事也改了文件 A，你们需要协作，这时候只需要将各自修改推送给对方，双方就知道对方修改了什么了。这就好比诸葛亮和周瑜在攻打曹操的时候，各自在手心写了一个字，写完之后亮给对方看，相视一笑：嗯，这 b 跟老子想得一样。 而 SVN 和 Git，分别作为集中式与分布式的代表之一。 Git 安装 对于 Git 安装，2018 年 jsliang 入职公司的时候已经安装过，又因为 廖雪峰 大佬已经安排的明明白白了，故不多此一举，贴上安装步骤文章： 《安装 Git》 Git 新建版本库 什么是版本库？ 版本库又名仓库，英文名 repository，可以简单理解为一个目录，这个目录里面的所有文件都可以被 Git 管理起来，用于追踪每个文件的修改、删除。 创建目录：mkdir learngit 前进到这个目录：cd learngit 显示当前目录：pwd 初始化仓库：git init 显示 .git：ls -ah 这时候会出来一个隐藏文件，叫 .git，这个目录就是 Git 用来跟踪管理版本库的，请不要手动修改里面的文件。 添加文件，新建 README.md： README.md Git 学习 === 将文件添加到仓库：git add README.md（git add . 是提交当前目录所有文件） 将文件提交到仓库：git commit -m \"Add a README\" 此处 -m 输入的是本次提交的说明，方便你根据说明查找需要的历史版本 修改文件内容： README.md Git 学习 === > Create by **jsliang** on **2019-3-29 09:08:48** > Recently revised in **2019-3-29 09:08:53** 查看结果：git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: README.md no changes added to commit (use \"git add\" and/or \"git commit -a\") 此刻可以看出，我们查看到了 README.md 被修改了。 查看版本差异：git diff index b379f95..78fb1fe 100644 --- a/README.md +++ b/README.md @@ -1,2 +1,5 @@ Git 学习 -=== \\ No newline at end of file +=== + +> Create by **jsliang** on **2019-3-29 09:09:03** +> Recently revised in **2019-3-29 09:09:07** \\ No newline at end of file 这时候，我们添加了时间，做了新的更改，所以我们又可以进行新一轮的提交： git add . git commit -m \"添加时间\" 我们再添加下证书并提交： README.md Git 学习 === > Create by **jsliang** on **2019-3-29 09:09:03** > Recently revised in **2019-3-29 09:09:07** > jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 git add . git commit -m \"添加协议\" 当我们做的事儿越多，越不可能记住几个字的更改，所以我们需要查找历史记录，见证我们成长的点滴：git log commit 7b88d86f3e079e048c3e5444f91616b826f553a0 (HEAD -> master) Author: jsliang Date: Fri Mar 29 09:21:35 2019 +0800 添加协议 commit 05abb578724b7d8cef860aa4280b0e19241c02a8 Author: jsliang Date: Fri Mar 29 09:14:16 2019 +0800 添加时间 commit 655433cc64356a8f9dc12e9a94808a25e844c0eb Author: jsliang Date: Fri Mar 29 09:03:59 2019 +0800 回退到上一个版本：git reset --hard HEAD^ HEAD is now at 05abb57 添加时间 注意，git log 显示的记录中，commit 后面的就是 HEAD，Git 通过 HEAD 控制版本 如果误回退了呢？尝试回退版本号：git reset --hard 7b88d86 HEAD is now at 7b88d86 添加协议 OK，现在它又回来了。记住：如果你操作失误回退了，请不要关闭命令行窗口，还有机会补救！ 找不到版本号，想恢复新版本：git reflog 7b88d86 (HEAD -> master) HEAD@{0}: reset: moving to 7b88d86 05abb57 HEAD@{1}: reset: moving to HEAD^ 7b88d86 (HEAD -> master) HEAD@{2}: commit: 添加协议 05abb57 HEAD@{3}: commit: 添加时间 可以看到，这里把前面版本的版本号显示出来了。 Git 命令 git fetch 从一个或多个其他存储库中获取分支和/或标签(统称为“引用”)以及完成其历史所必需的对象。 远程跟踪分支已更新(Git术语叫做commit)，需要将这些更新取回本地，这时就要用到git fetch命令。 git 取消忽略文件大小写的更改 在当前项目，输入 git config core.ignorecase false 即可关闭 git 忽略文件大小写的配置。 git 删除文件夹 删除 target 文件夹：git rm -r --cached target 提交更改：git commit -m \"删除 target 目录\" 确认更改：git push git 覆盖上一次 commit 提交信息 git commit -amend -m \"New commit\" git 分支 创建分支：git branch cheny 切换到分支：git checkout cheny 添加修改代码到缓存：git add . 提交：git commit -m \"修改\" 提交到分支：git push origin cheny/git push --set-upstream origin cheny 同时配置 GitLab 和 GitHub 缘由：公司使用 GitLab，个人使用 GitHub，因此需要配置下 Git，方便上传到公司的 GitLab 项目和个人的 GitHub 项目上。 参考文献： 同一台电脑同时使用gitlab和github 配置同时使用 Gitlab 和 Github 的开发环境 Mac 配置步骤 CD 到用户根目录下的 .ssh 文件夹中：cd .ssh 生成 GitLab 秘钥：ssh-keygen -t rsa -C \"注册 gitlab 账户的邮箱\"，提示后输入 id_rsa_gitlab，这样就在 .ssh 目录下生成了 GitLab 的秘钥。 生成 GitHub 秘钥：ssh-keygen -t rsa -C \"注册 github 账户的邮箱\"，提示后输入 id_rsa_github，这样就在 .ssh 目录下生成了 GitHub 的秘钥。 这时候我们 .ssh 目录中有文件： id_rsa_github.pub id_rsa_gitlab.pub id_rsa_github id_rsa_gitlab 提供公钥给服务器 复制 ~/.ssh/id_rsa_gitlab.pub文件内容，进入gitlab / profile / SSH Keys，将公钥内容添加至 gitlab 。 复制 ~/.ssh/id_rsa_github.pub文件内容，进入github / setting / SSH and GPG keys / New SSH key 将公钥内容添加至 github 。 在 .ssh 中添加 config 文件（文本文件，不存在后缀），内容为： config Host github.com HostName github.com User githubuser@xyz.com IdentityFile ~/.ssh/id_rsa_github Host gitlab.com HostName gitlab.com User gitlabuser@xyz.com IdentityFile ~/.ssh/id_rsa_gitlab 这时候我们 .ssh 目录中有文件： id_rsa_github.pub id_rsa_gitlab.pub id_rsa_github id_rsa_gitlab config （可选）在 GitHub 或者 GitLab 仓库大目录中使用下面三条命令： git init git config --global user.name \"githubuser\" git config --global user.email \"githubuser@xyz.com\" 在项目文件夹中使用以下命令： git clone 项目地址 新增/修改文件 git add . git commit -m \"修改配置\" git push 在终端输入账号密码信息后，就会提示上传成功了，最终项目目录中有文件： config id_rsa_github.pub id_rsa_gitlab.pub id_rsa_github id_rsa_gitlab known_hosts 配置 .gitignore 在我们使用Git的过程中，有时候喜欢建一些文件给自己查看使用而不是给大众使用，或者说像是 node_modules 这些文件不希望上传到代码仓库的，这时候就需要设置响应的忽略规则，来忽略这些文件的提交。 全局生效 定义全局 .gitignore 文件，将其放在任意位置即可生效 git config --global core.excludesfile ~/.gitignore 忽略规则 忽略掉所有文件名是 test.html 的文件 test.html 忽略掉 node_modules 文件夹 node_modules 忽略掉所有生成的备份文件 *.*~ 忽略所有 .o 和 .a 文件 *.[oa] 详细用法看文档：详情 VS Code 隐藏 node_modules 值得一提的就是，我们不仅要忽略它的上传，在 Visio Studio Code 这个编辑器中，如果我们也需要忽略它的话，就需要进行相应的设置，VS Code 隐藏工作区中的 node_modules 文件夹： 主菜单 -> 文件 -> 首选项 -> 用户设置： \"file.exclude\": { \"node_modules/\": true } jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"other-library/LeetCode/":{"url":"other-library/LeetCode/","title":"☆ LeetCode","keywords":"","body":"LeetCode Create by jsliang on 2019-5-16 22:12:29Recently revised in 2019-5-16 22:31:12 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 简单难度攻略 四 中等难度攻略 五 困难难度攻略 二 前言 返回目录 LeetCode 是个题库，里面有很编程多面试的题目，可以在线编译运行。 在这里，你可以使用 C、C++、Java、Python、PHP、JavaScript 共 14 种编程语言进行解题。 在这里，你可以接触到许许多多算法相关的知识，并且提升自己的职业竞争能力，在面试的时候秀一秀自己的代码。 三 简单难度攻略 返回目录 题目 原题地址 解题攻略 001 - 两数之和（two-sum） #1 原题 #1 解题 007 - 整数反转（reverse-integer） #7 原题 #7 解题 四 中等难度攻略 返回目录 暂无 五 困难难度攻略 返回目录 暂无 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 09:46:49 "},"other-library/LeetCode/Easy/":{"url":"other-library/LeetCode/Easy/","title":"LeetCode - 简单模式","keywords":"","body":"LeetCode - 简单模式 Create by jsliang on 2019-05-20 18:59:51Recently revised in 2019-05-20 18:59:55 LeetCode 简单难度攻略 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:03:21 "},"other-library/LeetCode/Easy/001-两数之和（two-sum）.html":{"url":"other-library/LeetCode/Easy/001-两数之和（two-sum）.html","title":"✔ 001 - 两数之和（two-sum）","keywords":"","body":"001 - 两数之和（two-sum） Create by jsliang on 2019-05-16 22:19:13Recently revised in 2019-05-17 15:10:49 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 LeetCode 攻略地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 解题  3.1 解法 - for()  3.2 解法 - indexOf()  3.3 解法 - Map 二 前言 返回目录 难度：简单 涉及知识：数组、哈希表 题目地址：https://leetcode-cn.com/problems/two-sum/ 题目内容： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 三 解题 返回目录 官方题解：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/ 解题千千万，官方独一家，上面是官方使用 Java 进行的题解。 小伙伴可以先自己在本地尝试解题，再看看官方解题，最后再回来看看 jsliang 讲解下使用 JavaScript 的解题思路。 3.1 解法 - for() 返回目录 解题代码： var twoSum = function(nums, target) { for (let i = 0; i 执行测试： nums：[1, 3, 2, 5, 6] target: 8 return： [1, 3] 解题思路：使用双重 for 循环破解。 第一遍过滤 nums 数组，标记为 i。 第二遍再次过滤 nums 数组，标记为 i + 1，因为我们是对数组中的两个数字相加，所以不能重复使用同一个数字。 判断第二次遍历的数字中，它是否等于 target - nums[i]，如果成立就返回两个数字的索引。（并不考虑后面还有可成立的答案）。 3.2 解法 - indexOf() 返回目录 解题代码： var twoSum = function(nums, target) { let result = []; nums.map((item, index) => { if (nums.indexOf(target - item) > -1 && nums.indexOf(target - item) != index) { result = [index, nums.indexOf(target - item)].sort((a, b) => a > b); } }); return result; }; 执行测试： nums：[4, 3, 2, 5, 6] target: 8 return： [2, 4] 知识点： map()：遍历数组，item 返回遍历项，index 返回当前索引。map() 详细介绍 indexOf()：判断数组中是否存在判断条件中的值。如果存在，则返回第一次出现的索引；如果不存在，则返回 -1。indexOf() 详细介绍 sort()：排序，保持返回数组的数字为顺序排列。sort() 详细介绍 解题思路： 首先，我们开辟一块内存 result。 然后，我们通过 map() 遍历 nums，并使用 indexOf() 寻找除当前 item 的 index 之外和 item 相加之和为 target 的结果。 最后，我们返回查找的最新结果，该结果进行了排序（[4, 2] 的返回通过 sort() 排序变成 [2, 4]） 例如，在上面测试 twoSum([1, 3, 2, 5, 6], 8) 的结果就有： [1, 3] [2, 4] [3, 1] [4, 2] 我们取最后一次的结果并排序返回，即：[2, 4] 进一步思考：如果我们将 map() 换成 for()，你知道该如何操作么？ 3.3 解法 - Map 返回目录 解题代码： var twoSum = function(nums, target) { let map = new Map(); for (let i = 0; i 执行测试： nums：[4, 3, 2, 5, 6] target: 8 return： [1, 3] 知识点： Map：保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。Map 详细介绍 解题思路： 首先，我们需要了解 Map 这个对象。 它可以通过 set() 的形式，以 [key, value] 的形式保存一组数据。（题目中对应 key 就是存入的 target - nums[i] 值，value 就是索引） 它可以通过 get() 的形式，获取到传入 key 值对应的 value。 它可以通过 has() 的形式，判断 Map 对象里面是否存储了传入 key 对应的 value。 然后，我们遍历 nums 数组。 最后，我们判断 nums[i] 是否存在于 Map 对象中。没有的话，就存入 target - nums[i] 到 Map 中。有的话，因为上次存入的是 target- nums[i]，有点类似于解题的钥匙，既然我们看到 nums[i] 存在于 Map 中，它是解题的钥匙，所以我们只需要返回 [map.get(nums[i]), i] 这组值即可。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:06:50 "},"other-library/LeetCode/Easy/007-整数反转（reverse-integer）.html":{"url":"other-library/LeetCode/Easy/007-整数反转（reverse-integer）.html","title":"✔ 007 - 整数反转（reverse-integer）","keywords":"","body":"007 - 整数反转（reverse-integer） Create by jsliang on 2019-05-19 09:42:39Recently revised in 2019-05-19 16:04:13 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 LeetCode 攻略地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 解题  3.1 解法 - 转字符串  3.2 解法 - 数学算法 二 前言 返回目录 难度：简单 涉及知识：数组、数学 题目地址：https://leetcode-cn.com/problems/reverse-integer/ 题目内容： 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 三 解题 返回目录 官方题解：https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/ 解题千千万，官方独一家，上面是官方使用 C++ / Java 进行的题解。 小伙伴可以先自己在本地尝试解题，再看看官方解题，最后再回来看看 jsliang 讲解下使用 JavaScript 的解题思路。 3.1 解法 - 转字符串 返回目录 解题代码： var reverse = function(x) { // 转数组 let numberToArray = String(Math.abs(x)).split(''); // 转字符串 let result = ''; for (const i = 0; i 0 ? Number(result) : - Number(result); // 超 [-Math.pow(2, 31), Math.pow(2, 31) - 1] 判断 if (result > Math.pow(2, 31) - 1 || result 执行测试： x：-1234 return： -4321 LeetCode Submit： ✔ Accepted ✔ 1032/1032 cases passed (88 ms) ✔ Your runtime beats 99.53 % of javascript submissions ✔ Your memory usage beats 46.01 % of javascript submissions (35.8 MB) 知识点： String：将其他值转成字符串。String 详细介绍 Number：将其他值转成数字值。Number 详细介绍 pop()：pop() 方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。pop() 详细介绍 Math：JS 中的内置对象，具有数学常数和函数的属性和方法。Math 详细介绍 解题思路： 首先，将传入的数字 x 转换成字符串，并分割成数组。 然后，遍历该数组，将最后一个取出来放到 result 中。 最后，判断这个 result 是否超过题目限制，如果超过则变成 0 。 进一步思考： 3.2 解法 - 数学算法 返回目录 解题代码： var reverse = function(x) { let result = 0; let y = Math.abs(x); while (y != 0) { result = result * 10 + y % 10; y = Math.floor(y / 10); if (result > Math.pow(2, 31) - 1 || result 0 ? result : -result; }; 执行测试： x：-1234 return： -4321 LeetCode Submit： ✔ Accepted ✔ 1032/1032 cases passed (108 ms) ✔ Your runtime beats 97.4 % of javascript submissions ✔ Your memory usage beats 23.63 % of javascript submissions (36 MB) 知识点： Math：JS 中的内置对象，具有数学常数和函数的属性和方法。Math 详细介绍 解题思路： 首先，我们初始化数值。 然后，我们需要知道的是，一个数对 10 取余，可以得到这个数的个位数；一个数乘于 10 并加上一个个位数，可以将这个数字放到末尾。 最后，我们判断一开始传入的数值正负，再返回对应结果即可。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:05:33 "},"public-repertory/":{"url":"public-repertory/","title":"★ 共用资料","keywords":"","body":"共用资料 create by jsliang on 2018-10-28 12:10:36Recently revised in 2019-5-20 08:26:08 All the file sharing resources are stored here. 这里存放了所有文件共享的资源。 目录 文件名 存放内容 css 文档使用到的css文件 img 文档使用到的图片 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 "}}