{"./":{"url":"./","title":"起始","keywords":"","body":"Document Library - 文档库 Here is the jsliang's learning and working experience document on programming. If you have doubts about this, please send an email to 1741020489@qq.com. 这里存放了jsliang的学习、工作中关于编程的经验文档。如果你对此有疑惑，请发邮件到 1741020489@qq.com。 一 前言 本文档库始建于 2018-08-20。 如想知道 jsliang 最新学习进度，请前往 撰文思路 进行查看。 如想知道 jsliang 各种新奇玩意，请前往 网站清单 进行查看。 如想参与 jsliang 组织的小竞赛，请前往 个人竞赛 进行查看。 建文档库的初始目的：记录一下 jsliang 的在折腾学习某个黑科技的时候的操作笔记。 因为，如果你学习而不写文章、不做笔记，某天你突发奇想，需要用到某个之前你用过的黑科技……那样的话，还需要 百度 / google 一遍，太累了！太浪费人生了！ 所以，集一生洪荒之力，写一个编程文档库，存放，我编程生涯的点点滴滴。 不折腾的前端，跟咸鱼有什么区别！ 二 文件目录 文件名 存放内容 CSS-library CSS 文档仓库 HTML-library HTML 文档仓库 JavaScript-library JavaScript 文档仓库 other-library 其他文档仓库(整站制作/微信小程序) public-repertory 文档仓库使用到的图片、CSS文件等…… 三 个人网站 目录 介绍 jsliang.top jsliang 的网站列表 cv.jsliang.top 通过 ECharts + Vue 打造个人线上简历 playregex.jsliang.top 通过游戏来了解正则表达式 lucky.jsliang.top 悠闲刮刮乐，仅供娱乐 deadline.jsliang.top jsliang 的工作时间轴 webpack.jsliang.top Webpack 学习成果，Webpack 多页面配置 game.jsliang.top 一个小游戏，只兼容 PC，适配移动端失败 company.jsliang.top Node 打造企业网站，支持注册、登录及留言 work.jsliang.top jsliang 工作成果，给领导或者工作小伙伴查看 四 反馈 QQ 群 如果对该文档库的某篇文章存有疑惑，如果有些问题想看下 jsliang 折腾过没有，请加 QQ 群：798961601。jsliang 在群里将第一时间根据小伙伴的疑问进行解答~ 五 推荐学习方法 建议小伙伴们有机会可以给自己配个显示器，也就 5/600 元，用起来也舒服。 jsliang 的开发配置为手提（16G / 6核 / 12线程 / 7200RMB） + 显示器 （21.5寸 / 1080P / 650RMB)。对前端开发的来说，这个价还是用得起的，而且自己的配置，自己用得会比较舒服。 最后，祝小伙伴们在编程生涯中找到自己的节奏，工资步步高升。 办公场景 学习场景 六 云服务器推广 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎加 QQ：1741020489 骚扰欢迎点击 云服务器推广 查看了解更多！ 七 打赏 撰文不易，如果文章对小伙伴有帮助，希望小伙伴们给勤劳敲代码、辛苦撰文的 jsliang 进行微信/支付宝打赏，你们的每一次打赏都是最好的鼓励，谢谢~ 八 文档协议 document library of jsliang by 梁峻荣 is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.Based on a work at https://github.com/LiangJunrong/document-library.Permissions beyond the scope of this license may be available at https://creativecommons.org/licenses/by-nc-sa/2.5/cn/. jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 15:44:36 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"SUMMARY.html":{"url":"SUMMARY.html","title":"目录","keywords":"","body":"文档库目录 起始 目录 留言板 CSS 资料室 CSS 基础 ✔ CSS 重置 CSS 布局 ✔ Flex 布局 HTML 资料室 JavaScript 资料室 JavaScript ✔ 方法 - indexOf() ✔ 方法 - map() ✔ 方法 - pop() ✔ 方法 - sort() ✔ 对象 - Map ✔ 对象 - Math ✔ 对象 - Number ✔ 对象 - String ✔ 删除数组项目的技巧 ✘ ES6学习 - 1 - Promise ✘ JavaScript 之 构造函数与原型对象 jQuery ✔ jQuery 基础 ✔ jQuery 工作常用解决方案 Vue ✔ Vue 基础 ✔ Vue 官方文档二三事 ✔ Vue 开发准备 ✘ Axios ✘ VueCli2 ✘ VueCli3 ✘ Vue Router ✘ Vuex ✘ Vue SSR 服务端渲染 ✔ Vue 上传文件 ✔ Vue 部署优化 ✘ Vue 源码剖析 ✔ Vue Demo - 功成千骨 ✘ Vue Demo Two - 新闻 SPA ✘ Vue Demo Three - 千人千魔 React ✘ React 基础 ✘ React 开发准备 ✘ React 知识点清单 ✔ React List - Create React App ✔ React List - React Redux ✔ React List - React Router ✔ React Demo One - TodoList ✔ React Demo Two - TodoList 升级 ✔ React Demo Three - 简书 ✔ React Demo Four - 掘金 ✘ React Demo Five - 员岗周边 Angular ✘ Angular Demo One - 打造企业级协作平台 ✘ Angular Demo Two - Angular 股票管理平台 ECharts ✔ ECharts 打造在线个人简历 ✔ ECharts 打造在线个人简历 【升级版】 ✔ ECharts + Vue 折腾记 设计模式 ✘ 设计模式手册 - 1 - 部署开发环境 ✘ 设计模式手册 - 2 - 面向对象 ✘ 设计模式手册 - 3 - 工厂模式 ✘ 设计模式手册 - 4 - 单例模式 ✘ 设计模式手册 - 5 - 适配器模式 ✘ 设计模式手册 - 6 - 装饰器模式 ✘ 设计模式手册 - 7 - 代理模式 ✘ 设计模式手册 - 8 - 外观模式 ✘ 设计模式手册 - 9 - 观察者模式 ✘ 设计模式手册 - 10 - 迭代器模式 ✘ 设计模式手册 - 11 - 状态模式 ✘ 设计模式手册 - 12 - 其他模式 ✘ 设计模式手册 - 13 - 综合应用 其他资料室 Git HTTP 面试 面试 - 道听途说 ✔ 第一篇 - 阿里系公司第一轮电面题 面试 - 亲身经历 ✔ jsliang 的 2019 面试准备 ✔ 2019 面试实战 - Round One ✔ 2019 面试实战 - Round Two ✔ 2019 面试实战 - Round Three ✔ 面试知识点 - JS 原型与原型链 ✔ 面试知识点 - JS 防抖与节流 ✔ 面试知识点 - 图片 LeetCode LeetCode - 简单模式 ✔ 001 - 两数之和（two-sum） ✔ 007 - 整数反转（reverse-integer） 独白 ✔ 暴走前端 - GitHub 竞赛 ✔ 提问的艺术 ✔ 稳食艰难 - 云服务器推广 ✔ 朝花夕拾 ✔ 朝花夕拾 - 工作与生活 ✔ 朝花夕拾 - 生日 ✔ 朝花夕拾 - 徒步 ✔ 朝花夕拾 - 搬家 ✔ jsliang 日常 ✔ jsliang 日常 - 2019-05 ✔ jsliang 日常 - 2019-04 ✔ 历史 - 2018年11月-2019年3月进阶指南 Node ✘ Koa ✔ Node 基础 Npm 正则表达式 短杂文 ✔ 关于协议 ✔ Chrome 插件 ✔ 浅谈个人对前端历史的理解 ✔ GitBook ✔ Java Server Pages ✘ JSTL 学习 ✔ Markdown ✔ 旧网站 - ThinkPHP 建站的文章 ✔ 旧网站 - 整站感言 ✔ 旧网站 - 基于 ThinkPHP 和 bootstrap 的整站开发 ✔ 旧网站 - HTML + CSS + JavaScript 基础学习 ✔ 旧网站 - PHP 基础学习 ✔ 旧网站 - Bootstrap 学习 ✔ 旧网站 - ThinkPHP 学习 ✔ 旧网站 - MySQL 学习 ✔ 旧网站 - 下一站：vue ✔ 旧网站 - 心有所动，路有所行 ✔ 旧网站 - Vue 第一站：从安装到打包 ✔ 旧网站 - 给自己留一份感动 ✔ 旧网站 - 4 步搞定简易 GIF 图 ✔ 旧网站 - 菜鸟：世界太大，给自己留 50G 空间 ✔ 旧网站 - 5 月心得 ✔ 旧网站 - pug 模板引擎 ✔ 旧网站 - 2017年10月10日 ✔ 旧网站 - gulpUncss 清除样式 ✔ 旧网站 - Vue 基础 分享 - 前端解疑 分享 - 2018 前端开发分享 VSCode 常用操作和配置 MySQL 网站 网站 - Vue + Node + MongoDB 演练 网站 - Vue + Node + MongoDB 学习笔记 云服务器建站 使用 GitHub Pages 和 VuePress 搭建网站 Vue + Koa2 + MongoDB 搭建商城 微信小程序 微信小程序开发流程 微信小程序 bug 集中营 微信小程序之奇技淫巧 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-22 17:11:36 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"MessageBoard.html":{"url":"MessageBoard.html","title":"留言板","keywords":"","body":"留言板 Create by jsliang on 2019-05-21 10:54:20Recently revised in 2019-05-22 17:36:30 不折腾的前端，和咸鱼有什么区别 欢迎小伙伴们加 jsliang 聊天吹水： 加 jsliang 的 QQ 资料群：798961601。 加 jsliang 的个人 QQ：1741020489 加 jsliang 的个人微信： jsliang 每周会抽取一些精辟留言或者交流内容在下方列出（后期可能给予红包奖励喔~），欢迎小伙伴们的吐槽。 精辟留言 2019/05 jsliang：“不折腾的前端，和咸鱼有什么区别” Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-22 17:39:58 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"CSS-library/":{"url":"CSS-library/","title":"CSS 资料室","keywords":"","body":"CSS 资料室 Create by jsliang on 2018-10-28 10:49:09Recently revised in 2019-5-20 08:23:35 Here is an article about CSS. 这里存放了关于 CSS 的文章。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"CSS-library/CSSBase/":{"url":"CSS-library/CSSBase/","title":"CSS 基础","keywords":"","body":"CSS 基础 Create by jsliang on 2019-5-20 08:34:15Recently revised in 2019-5-20 08:34:18 记录 CSS 基础相关的资料 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"CSS-library/CSSBase/CSSReset.html":{"url":"CSS-library/CSSBase/CSSReset.html","title":"✔ CSS 重置","keywords":"","body":"CSS Reset Create by jsliang on 2018-12-23 20:12:08Recently revised in 2019-04-25 17:46:46 各式各样浏览器总有一些让人感觉难以接受的样式， 不管是 jQuery 还是 Vue，使用前最好重置一下样式： reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /* * 图片自适应 - image responsize * 1. 清空浏览器对图片的设置 * 2. 图片 的情况下，图片会撑高 div，这么设置可以清除该影响 */ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .32rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .32rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .32rem } /* Internet Explorer */ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-25 17:46:47 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"CSS-library/Layout/":{"url":"CSS-library/Layout/","title":"CSS 布局","keywords":"","body":"CSS 布局 Create by jsliang on 2019-5-20 08:35:56Recently revised in 2019-5-20 08:35:59 记录 CSS 布局相关的资料 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"CSS-library/Layout/Flex.html":{"url":"CSS-library/Layout/Flex.html","title":"✔ Flex 布局","keywords":"","body":"Flex 布局 create by jsliang on 2019-3-27 13:36:02Recently revised in 2019-3-27 13:42:10 万丈高楼平地起，熟悉 Flex 需要先了解下面这 7 个 CSS 属性： /* 设置 Flex 模式 */ display: flex; /* 决定元素是横排还是竖着排，要不要倒序 */ flex-direction: column; /* 决定元素换行格式，一行排不下的时候如何排 */ flex-wrap: wrap; /* flex-flow = flex-direction + flex-wrap */ flex-flow: column wrap; /* 同一排下对齐方式，空格如何隔开各个元素 */ justify-content: space-between; /* 同一排下元素如何对齐，顶部对齐、中部对齐还是其他 */ align-items: center; /* 多行对齐方式 */ align-content: space-between; 下面我们详细分析这些元素的情况： flex-direction：决定主轴的方向 row - （默认）水平方向，起点在左端 row-reverse - 水平方向，起点在右端 column - 垂直方向，起点在上沿 column-reverse - 垂直方向，起点在下沿 display: flex; flex-direction: row | row-reverse | column | column-reverse; flex-wrap：一条轴线（一行）排不下时如何解决 nowrap - （默认）不换行 wrap - 换行，第一行在上方 wrap-reverse - 换行，第一行在下方 display: flex; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow：flex-flow = flex-direction + flex-wrap。即 flex-flow 是这两个属性的合集 row nowrap - （默认）水平方向，起点在左端，不换行 display: flex; flex-flow: || ;  详解参考 1 和 2 justify-content：定义项目在主轴上的对齐方式 flex-start - 左边对齐 flex-end - 右边对齐 center - 居中对齐 space-between - 两端对齐，空格在中间 space-around - 空格环绕 display: flex; justify-content: flex-start | flex-end | center | space-between | space-around; align-items：定义项目在交叉轴上如何对齐 flex-start - 顶部对齐，即文字图片等顶部同一条线上 flex-end - 底部对其，即文字图片等底部在同一条线上 center - 中间对其，即文字图片不管多高，都拿它们的中间放在同一条线上 stretch - 将文字图片充满整个容器的高度，强制统一 baseline - 将每项的第一行文字做统一在一条线上对齐 display: flex; align-items: flex-start | flex-end | center | stretch | baseline; align-content：定义多根轴线的对齐方式。如果只有一根轴线（只有一行），该属性不起作用 flex-start - 这几行顶部对齐 flex-end - 这几行底部对齐 center - 这几行居中对齐 stretch - 这几行进行扩展或者缩放，从而填满容器高 space-between - 这几行中间使用空格进行填充 space-around - 这几行两边及中间进行填充 display: flex; align-content: flex-start | flex-end | center | space-between | space-around | stretch; jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"HTML-library/":{"url":"HTML-library/","title":"HTML 资料室","keywords":"","body":"HTML 资料室 Create by jsliang on 2018-10-28 10:50:22Recently revised in 2019-5-20 08:24:19 Here is an article about HTMl 这里存放了关于HTML的文章 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/":{"url":"JavaScript-library/","title":"JavaScript 资料室","keywords":"","body":"JavaScript 资料室 Create by jsliang on 2018-10-28 10:51:18Recently revised in 2019-5-20 08:24:52 Here is an article about JavaScript 这里存放了关于 JavaScript 的文章 目录 Angular ES6 ECharts JavaScript React Vue 设计模式 jQuery jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/JavaScript/":{"url":"JavaScript-library/JavaScript/","title":"JavaScript","keywords":"","body":"JavaScript 知识点 Create by jsliang on 2018-12-11 09:21:24Recently revised in 2019-05-20 18:20:34 万丈高楼平地起 地基还得自己起 记录 JavaScript 各个知识点 MDN 是个非常实用的网站，有不懂的知识点可尽管搜索： MDN 搜索页 下面知识点不分先后，如果有目的查找，请使用 Ctrl/Command + F： 类型 名称 简介 地址 方法 indexOf() 判断数组中是否存在判断条件中的值。如果存在，则返回第一次出现的索引；如果不存在，则返回 -1。 indexOf() 详细介绍 方法 map() 遍历数组，item 返回遍历项，index 返回当前索引。 map() 详细介绍 方法 pop() 从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 pop() 详细介绍 方法 sort() 排序，数字 1-9，字母 a-z。 sort() 详细介绍 类型 名称 简介 地址 对象 Map 保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。 Map 详细介绍 对象 Math 内置对象，它具有数学常数和函数的属性和方法。不是一个函数对象。 Math 详细介绍 对象 Number 可以将其他类型的值转为数字。 Number 详细介绍 对象 String 将其他格式转成字符串。 String 详细介绍 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 18:57:22 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/JavaScript/Function/indexOf.html":{"url":"JavaScript-library/JavaScript/Function/indexOf.html","title":"✔ 方法 - indexOf()","keywords":"","body":"方法 - indexOf() Create by jsliang on 2019-05-17 11:30:04Recently revised in 2019-05-17 14:37:49 原文：MDN - indexOf() 功能：indexOf() 方法返回调用 String 对象中第一次出现的指定值的索引。 语法：indexOf(searchValue, fromIndex) searchValue：查找的值 formIndex：开始查找的位置 返回值：如果找到了，则返回第一次出现的索引；如果没找到，则返回 -1。 代码： 'I am jsliang'.indexOf('a', 4); // 9 [1, 3, 1, 4].indexOf(1, 1); // 2 '怪盗 jsliang'.indexOf('我'); // -1 扩展：如果需要查找到最后一次出现指定值的索引，可以使用 lastIndexOf()。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 18:55:14 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/JavaScript/Function/map.html":{"url":"JavaScript-library/JavaScript/Function/map.html","title":"✔ 方法 - map()","keywords":"","body":"方法 - map() Create by jsliang on 2019-05-17 11:30:04Recently revised in 2019-05-17 14:50:46 原文：MDN - map() 功能：map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法：map((item, index) => {}) item：遍历的项 index：该次遍历项的索引 返回值：一个新数组，每个元素都是回调函数的结果。 代码： [1, 2, 3, 4].map(item => item * 2) // [2, 4, 6, 8] [{ name: 'jsliang', age: 24, }, { name: '梁峻荣', age: 124 }].map((item, index) => { return `${index} - ${item.name}`; }) // ['0 - jsliang', '1 - 梁峻荣'] jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 18:55:34 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/JavaScript/Function/pop.html":{"url":"JavaScript-library/JavaScript/Function/pop.html","title":"✔ 方法 - pop()","keywords":"","body":"方法 - pop() Create by jsliang on 2019-05-19 11:40:27Recently revised in 2019-05-19 11:40:30 原文：MDN - pop() 功能：pop() 方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 语法： arr.pop()：返回从数组中删除的元素 返回值：一个新数组，每个元素都是回调函数的结果。 代码： let arr = [1, 2, 3, 4]; for(let i = 0, time = 1; i jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 18:55:54 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/JavaScript/Function/sort.html":{"url":"JavaScript-library/JavaScript/Function/sort.html","title":"✔ 方法 - sort()","keywords":"","body":"方法 - sort() Create by jsliang on 2019-05-17 11:31:56Recently revised in 2019-05-17 14:57:45 原文：MDN - sort() 功能：sort() 对数组的元素进行排序，并返回数组。 语法：sort(function) function：按某种顺序进行排列的函数。 返回值：排序后的数组。 代码： [4, 2, 5, 1, 3].sort(), // [1, 2, 3, 4, 5] [4, 2, 5, 1, 3].sort((a, b) => a jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 18:56:16 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/JavaScript/Object/Map.html":{"url":"JavaScript-library/JavaScript/Object/Map.html","title":"✔ 对象 - Map","keywords":"","body":"对象 - Map Create by jsliang on 2019-05-17 11:45:35Recently revised in 2019-05-17 15:05:47 原文：MDN - Map 功能：Map 对象保存键值对。 方法： new Map()：新建一个 Map 对象 Map.prototype.has(key)：返回布尔值。表示 Map 实例是否包含键对应的值。 Map.prototype.set(key, value)：返回该 Map 对象。设置 Map 对象中键的值。 Map.prototype.get(key)：返回键对应的值，如果不存在，则返回 undefined。 Map.prototype.delete(key)：如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false。 代码： var twoSum = function(nums, target) { let map = new Map(); for (let i = 0; i jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 11:22:20 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/JavaScript/Object/Math.html":{"url":"JavaScript-library/JavaScript/Object/Math.html","title":"✔ 对象 - Math","keywords":"","body":"对象 - Math Create by jsliang on 2019-05-19 11:32:44Recently revised in 2019-05-19 11:32:47 原文：MDN - Math 功能：Math 是一个内置对象，它具有数学常数和函数的属性和方法。不是一个函数对象。 方法： Math.abs(x)：返回 x 的绝对值。 Math.ceil(x)：返回 x 向上取整后的值。x = 99.1; result = 100 Math.floor(x)：返回小于 x 的最大整数。x = 99.1; result = 99 Math.pow(x,y)：返回 x 的 y 次幂。 Math.round(x)：返回四舍五入后的整数。 代码： Math.abs(-999); // 999 Math.ceil(99.1); // 100 Math.floor(99.1); // 99 Math.pow(2, 3); // 8 Math.round(99.5); // 100 Math.round(99.4); // 99 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 11:39:55 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/JavaScript/Object/Number.html":{"url":"JavaScript-library/JavaScript/Object/Number.html","title":"✔ 对象 - Number","keywords":"","body":"对象 - Number Create by jsliang on 2019-05-19 11:17:28Recently revised in 2019-05-19 11:17:31 原文：MDN - Number 功能：Number 可以将其他类型的值转为数字。 方法： new Map()：新建一个 Map 对象 Number(x)：将其他类型的值转为数字 Number.MAX_SAFE_INTEGER：JavaScript 中最大的安全整数 (2 的 53 次方 - 1)。 Number.MIN_SAFE_INTEGER：JavaScript 中最小的安全整数 (-(2 的 53 次方 - 1)). 代码： Number(\"123\") // 123 Number(\"\") // 0 Number(\"0x11\") // 17 Number(\"0b11\") // 3 Number(\"0o11\") // 9 Number(\"foo\") // NaN Number(\"100a\") // NaN jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 11:21:51 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/JavaScript/Object/String.html":{"url":"JavaScript-library/JavaScript/Object/String.html","title":"✔ 对象 - String","keywords":"","body":"对象 - String Create by jsliang on 2019-05-19 11:17:49Recently revised in 2019-05-19 11:22:42 原文：MDN - String 功能：String 将其他值生成或转换成字符串。 方法： String(thing)：将 thing 转成字符串。 代码： String(123); // '123' String(true); // 'true' jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-19 11:26:32 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/JavaScript/Other/DeleteArrrayItem.html":{"url":"JavaScript-library/JavaScript/Other/DeleteArrrayItem.html","title":"✔ 删除数组项目的技巧","keywords":"","body":"删除数组项目的技巧 Create by jsliang on 2019-4-5 09:56:19Recently revised in 2019-4-6 10:34:11 /** * 这里使用了三种写法 * 1. map + splice * 2. splice + findIndex * 3. filter */ // 1. map + splice 写法 deleteInfo(recycleItem) { this.todoInfos.map((item, index) => { if(item.id == recycleItem.id) { this.todoInfos.splice(index, 1); } }) }, // 2. splice + findIndex 写法 deleteInfo(recycleItem) { this.todoInfos.splice( this.todoInfos.findIndex( v => v.id === recycleItem.id), 1); }, // 3. filter 写法 deleteInfo(recycleItem) { this.todoInfos = this.todoInfos.filter( (x) => { return x.id != recycleItem.id; }) } Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 11:19:23 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/JavaScript/Other/Promise.html":{"url":"JavaScript-library/JavaScript/Other/Promise.html","title":"✘ ES6学习 - 1 - Promise","keywords":"","body":"ES6学习 - 1 - Promise create by jsliang on 2018-8-23 14:26:38Recently revised in 2018-12-23 20:35:05 PS：由于工作突然来活，Promise学习暂且放下，jsliang会利用下班时间慢慢补充。 学习导言  在学习Promise前，我们先理解两组词：单线程和多线程、同步和异步。 单线程和多线程：在你选购电脑的时候，也许会时不时听导购员跟你推荐：“这台机子是6核12线程的” “这台机子是4核8线程的”……啪啦啪啦介绍一番，然后你就纳闷了，什么是线程？线程是干什么的？……哎~停！专业的解释小伙伴们可以去看专业的回答：线程、单线程和多线程、单线程和多线程的区别。在这里，我们通过一个通俗易懂的小场景，带大家去理解单线程和多线程： 图（一堆钱） 图（单线程抢钱） 图（多线程抢钱） 解释：通过这个小场景，我们明白了单线程和多线程是什么样子的。下面我们继续了解同步和异步。 同步和异步：文章1、文章2、文章3 在理解了 单线程和多线程、同步和异步的基础上，我们来看看单线程的JavaScript是如何通过Promise来实现异步操作的。 借鉴与领悟  今天我们看看邵哥关于Promise的文章，理解下Promise的世界。先行观赏 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 11:19:25 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/JavaScript/Other/prototype&constructor.html":{"url":"JavaScript-library/JavaScript/Other/prototype&constructor.html","title":"✘ JavaScript 之 构造函数与原型对象","keywords":"","body":"JavaScript 之 构造函数与原型对象 Create by jsliang on 2018-12-11 09:27:44Recently revised in 2018-12-25 20:43:57 “每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例都包含一个指向原型对象的内部指针。”—— 《JavaScript 高级程序设计》 一 目录  不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文  3.1 箭头函数  3.2 不能使用箭头函数的场景  3.3 构造函数和原型对象 四 总结 二 前言 返回目录  在编写学习 Node 基础 中，写到 Node 仿 Express 的时候，我写了这么一段代码： let Application = () => { // ... } Application.prototype.get = (path, handle) => { // ... }  然后代码死活跑不起来，于是我就去问大佬，大佬默默回了句： “构造函数不能用箭头函数呀”  我一愣： 为什么不能用构造函数？ 什么时候我不能使用构造函数？ 箭头函数的解释是什么咯？ 什么是构造函数？ ……  所以，在下面，咱一一分析这些问题。 三 正文 返回目录  参考文献： 箭头函数 | 廖雪峰的官网 什么时候你不能使用箭头函数？ | 简书 - 王仕军 js深入理解构造函数和原型对象 | 博客园 - 快饿死的鱼 一句话总结JS构造函数、原型和实例的关系 | CSDN - 夜色芜染 箭头函数 | MDN 3.1 箭头函数 返回目录  ES6 标准新增了一种新的函数：Arrow Function(箭头函数)。 为什么叫箭头函数？ x => x * x;  因为它的定义用的就是一个箭头。上面代码相当于： function(x) { return x * x; }  那么，它的作用是什么呢：箭头函数相当于匿名函数，并且简化了函数定义。而箭头函数内部的 this 是词法作用域，由上下文确定： var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = function () { return new Date().getFullYear() - this.birth; // this 指向 window 或 undefined }; return fn(); } };  在上文的代码中： return new Date().getFullYear() - this.birth;  这里的 this 指向 window 或 undefined，从而使 JavaScript 函数对 this 的绑定没有得到预期的结果。 那么，我们可以尝试使用箭头函数： var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = () => new Date().getFullYear() - this.birth; // this 指向 obj 对象 return fn(); } }; obj.getAge(); // 25  这就是箭头函数及其大致作用。 3.2 不能使用箭头函数的场景 返回目录  什么时候不能使用箭头函数呢？ 定义对象方法 定义原型方法 定义构造函数 定义事件回调函数  首先，在定义对象方法中，举例： const calculator = { array: [1, 2, 3], sum: () => { console.log(this === window); // => true return this.array.reduce((result, item) => result + item); } }; console.log(this === window); // => true // Throws \"TypeError: Cannot read property 'reduce' of undefined\" calculator.sum();  如上，它会报错，因为 this 的指向不对，需要修改为： const calculator = { array: [1, 2, 3], sum() { console.log(this === calculator); // => true return this.array.reduce((result, item) => result + item); } }; calculator.sum(); // => 6  然后，在定义原型方法上，也需要注意不能滥用箭头函数： function Cat(name) { this.name = name; } Cat.prototype.sayCatName = () => { console.log(this === window); // => true return this.name; }; const cat = new Cat('Mew'); cat.sayCatName(); // => undefined  这里需要修改为： function Cat(name) { this.name = name; } Cat.prototype.sayCatName = function () { console.log(this === cat); // => true return this.name; }; const cat = new Cat('Mew'); cat.sayCatName(); // => 'Mew'  接着，在定义事件回调函数时，也需要注意 this 的指向： const button = document.getElementById('myButton'); button.addEventListener('click', () => { console.log(this === window); // => true this.innerHTML = 'Clicked button'; });  修正为： const button = document.getElementById('myButton'); button.addEventListener('click', function() { console.log(this === button); // => true this.innerHTML = 'Clicked button'; });  最后，在定义构造函数上： const Message = (text) => { this.text = text; }; // Throws \"TypeError: Message is not a constructor\" const helloMessage = new Message('Hello World!');  修正为： const Message = function(text) { this.text = text; }; const helloMessage = new Message('Hello World!'); console.log(helloMessage.text); // => 'Hello World!'  综合 3.1 与 3.2 的内容，我们可以清晰明白，虽然使用箭头函数，能够精简代码，并在一定程度上有所帮助。 但是，我们不能因为追求简洁的代码，而提升我们的代码维护难度和造成多种 bug。 量力而行才是最好的。 3.3 构造函数和原型对象 返回目录   四 总结 返回目录   jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 11:19:26 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/jQuery/":{"url":"JavaScript-library/jQuery/","title":"jQuery","keywords":"","body":"jQuery Create by jsliang on 2018-11-4 10:38:08Recently revised in 2018-12-23 20:39:34 记录 jQuery 学习及 jQuery 工作日常 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/jQuery/jQueryBase.html":{"url":"JavaScript-library/jQuery/jQueryBase.html","title":"✔ jQuery 基础","keywords":"","body":"jQuery 基础 Create by jsliang on 2018-05-07 15:56:17Recently revised in 2019-2-11 11:18:19  jQuery 操作 DOM 的那一套，还是非常值得关注的。我那时候一直想看 妙味 的 jQuery 剖析，我会员都买了，但是那会又去折腾小程序了，所以就没空了。  其实我觉得，jQuery 不是说丢就能丢的，只是前端新人，都觉得 Vue、React 工作好找，就学点 JavaScript 皮毛，去折腾那个去了。但是，讲真原生 JavaScript 还是要操作 DOM 的，DOM 操作哪家强，前端技术找 jQuery。  而且，一些开发中，直接用 jQuery 暴力拆迁，还是挺快的。我觉得我以后不用 jQuery 的原因，可能是项目涉及的数据量太大，操作 DOM 太多的时候，我才会更换成 Vue 这些。  最后的最后，一句话吧：没有最屌的技术，只有最适合项目的技术。 一 目录  不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 尝试 四 兼容 五 jQuery 语法 六 jQuery 选择器  6.1 元素选择器  6.2 #ID 选择器  6.3 .class 选择器  6.4 其他用法 七 DOM 事件  7.1 mouseover 与 mouseenter  7.2 键盘事件顺序 八 jQuery 效果  8.1 显示/隐藏  8.2 淡入/淡出  8.3 滑动  8.4 动画  8.5 停止动画  8.6 链 九 捕获 十 设置 十一 添加元素 十二 删除元素 十三 CSS 类 十四 CSS() 方法 十五 尺寸 十六 祖先选择器 十七 后代选择器 十八 同胞选择器 十九 过滤选择器 二十 load 二十一 get() 和 post() 二十二 Ajax 二十三 JSONP 二十四 无冲突 - noConflict 二十五 jQuery 实例 二十六 选择器扩展  26.1 基本选择器  26.2 层次选择器  26.3 过滤选择器（重点）   26.3.1 内容过滤选择器   26.3.2 可见性过滤选择器  26.4 属性过滤选择器  26.5 状态过滤选择器  26.6 表单选择器 二十七 插件扩展  27.1 jQuery Validate  27.2 jQuery Accordion  27.3 jQuery Autocomplete  27.4 jQuery Growl  27.5 jQuery Password Validation  27.6 jQuery Prettydate  27.7 jQuery Treeview 二 前言 返回目录  本文最初用 word 记录于 2018-05-07。 那时候还是前端职场新人，想在想起还是非常感谢带我的前端小姐姐的指导。 这篇文章是在 jQuery 教程 | 菜鸟教程 学习的过程中的记录笔记。 如需系统学习 jQuery，建议参考网上现成的系统的 jQuery 网站教程/视频教程。 本文仅供 jQueryer 复习自己所学知识。 三 尝试 返回目录  jQuery是一个轻量级的 \"写的少，做的多\" 的 JavaScript 库。  jQuery 的引用： 百度 CDN： jQuery 官网 CDN： BootCDN：  尝试： index.html 尝试引用jQuery - 2018年5月7日16:20:50 点我？消失给你看哦~ 继续点试试？ 再点试试？ $(document).ready(function(){ $(\"p\").click(function(){ $(this).hide(); }); }); 四 兼容 返回目录  jQuery 版本 2 以上不支持 IE6，7，8 浏览器。 如果需要支持 IE6/7/8，那么请选择 1.9。 你还可以通过条件注释在使用 IE6/7/8 时只包含进1.9。 五 jQuery 语法 返回目录  基础语法： $(selector).action()。在jQuery中，$=jQuery  ready： 写法1：$(document).ready(function(){ // 开始写 jQuery 代码... }); 写法2：$(function(){ // 开始写 jQuery 代码... }); 六 jQuery 选择器 返回目录  jQuery 选择器可以帮助我们更好地选择 DOM 元素。 6.1 元素选择器 返回目录  在页面中选取所有 元素: js 代码片段 $(\"p\") 实例： $(document).ready(function(){ $(\"button\").click(function(){ $(\"p\").hide(); }); }); 6.2 #ID 选择器 返回目录  通过 id 选取元素语法如下：$(\"#test\") js 代码片段 $(document).ready(function(){ $(\"button\").click(function(){ $(\"#test\").hide(); }); }); 6.3 .class 选择器 返回目录  jQuery 类选择器可以通过指定的 class 查找元素：$(\".test\") js 代码片段 $(document).ready(function(){ $(\"button\").click(function(){ $(\".test\").hide(); }); }); 6.4 其他用法 返回目录 语法 描述 $(\"*\") 选取所有元素 $(this) 选取当前 HTML 元素 $(\"p.intro\") 选取 class 为 intro 的 元素 $(\"p:first\") 选取第一个 元素 $(\"ul li:first\") 选取第一个 元素的第一个 元素 $(\"ul li:first-child\") 选取每个 元素的第一个 元素 $(\"[href]\") 选取带有 href 属性的元素 $(\"a[target='_blank']\") 选取所有 target 属性值等于 \"_blank\" 的 元素 $(\"a[target!='_blank']\") 选取所有 target 属性值不等于 \"_blank\" 的 元素 $(\":button\") 选取所有 type=\"button\" 的 元素 和 元素 $(\"tr:even\") 选取偶数位置的 元素 $(\"tr:odd\") 选取奇数位置的 元素 七 DOM 事件 返回目录 鼠标事件 键盘事件 表单事件 文档/窗口事件 click - 点击 keypress - 键被按下 submit - 表单提交 load - 全部加载（1.8已废弃） dbclick - 双击 keydown - 键按下的过程 change - 文本改变 resize - 浏览器窗口大小调试 mouseenter - 鼠标进入 keyup - 键被松开 focus - 获得焦点 scroll - 滚动 mouseleave - 鼠标离开   blur - 失去焦点 unload - 离开页面（1.8已废弃） 7.1 mouseover 与 mouseenter 返回目录  mouseover 事件在鼠标移动到选取的元素及其子元素上时触发。 mouseenter 事件只在鼠标移动到选取的元素上时触发。 mouseleave 与 mouseout同样。 7.2 键盘事件顺序 返回目录 keydown - 键按下的过程  ↓↓↓↓↓ keypress - 键被按下  ↓↓↓↓↓ keyup - 键被松开 八 jQuery 效果 返回目录  jQuery 可以使用其事件，做一些好玩的事情 8.1 显示/隐藏 返回目录  语法： 隐藏：$(selector).hide(speed,callback); 显示：$(selector).show(speed,callback); 切换：$(selector).toggle(speed,callback); speed：速度（毫秒） callback：完成后显示的函数 index.html 显示与隐藏 如果你点击“隐藏” 按钮，我将会消失。 隐藏 显示 $(function () { $(\"#hide\").click(function () { $(\"p\").hide(5000); }); $(\"#show\").click(function () { $(\"p\").show(1000); }); }); 8.2 淡入/淡出 返回目录  语法： 淡入：$(selector).fadeIn(speed,callback); 淡出：$(selector).fadeOut(speed,callback); 切换：$(selector).fadeToggle(speed,callback); 渐变：$(selector).fadeTo(speed,opacity,callback); speed：速度 opacity：透明度 callback：回调函数 index.html 淡入与淡出 .container { width: 320px; margin: 0 auto; } #red { width: 100px; height: 100px; background: red; } #green { width: 100px; height: 100px; background: green; } #blue { width: 100px; height: 100px; background: blue; } #fadeIn { display: none; } 淡入 淡出 渐变 $(function(){ $(\"#fadeToggle\").click(function(){ $(\"#blue\").fadeToggle(1000,function(){ $(\"#green\").fadeToggle(500,function(){ $(\"#red\").fadeToggle(200) }); }); $(\"#fadeIn\").toggle(); $(\"#fadeOut\").toggle(); }); $(\"#fadeTo\").click(function(){ $(\"#red\").fadeTo(500,0.3); $(\"#green\").fadeTo(1000,0.5); $(\"#blue\").fadeTo(\"slow\",0.1); }) }); 8.3 滑动 返回目录  语法： $(selector).slideDown(speed,callback); $(selector).slideUp(speed,callback); $(selector).slideToggle(speed,callback); speed：时间 callback：回调函数 index.html 显示与隐藏 #toggleHide { display: none; } 显示 隐藏 如果你点击“隐藏” 按钮，我将会消失。 $(function () { $(\"#toggle\").click(function () { $(\"#toggleHide\").toggle() $(\"#toggleShow\").toggle(); $(\"p\").toggle(1000); }); }); 8.4 动画 返回目录  语法： $(selector).animate({params},speed,callback); params：css 属性（键值对形式，-号替换为驼峰 → border-radius=borderRadius:'15px'） speed：时间 callback：回调函数  操作： 能操作单个属性 能操作多个属性 值能使用相对值（+=、-=） 属性值能为\"show\"、\"hide\" 或 \"toggle\"等 编写多个animate能使用队列功能 index.html 动画 .container { width: 320px; margin: 0 auto; text-align: center; } #circle { width: 100px; height: 100px; border-radius: 50px; background: rgb(243, 207, 5); display: inline-block; position: relative; } #stop { display: none; } start! stop! $(function () { var start; $(\"#stop\").click(function(){ clearInterval(start); $(\"#start\").show(); $(\"#stop\").hide(); }); $(\"#start\").click(function(){ start = setInterval(\"runBall()\", 1000); $(\"#start\").hide(); $(\"#stop\").show(); }); }); function runBall() { $(\"#circle\").animate({ left: '-=110px', top: '+=150px', backgroundColor: 'red' }); $(\"#circle\").animate({ left: '110px', backgroundColor: 'rgb(5, 243, 172)' }); $(\"#circle\").animate({ left: '0', top: '0', backgroundColor: 'rgb(243, 207, 5)' }); }; 8.5 停止动画 返回目录  语法： $(selector).stop(stopAll,goToEnd); stopAll：默认 false。true：停止包括后续 animate 的所有动作 goToEnd：默认 false。true：直接跳到该动作末尾，同时停止后面动作 index.html 停止动画 .container { width: 320px; margin: 0 auto; } #text { background: #b9f309; position: relative; } #text p { text-indent: 2em; } 开始 停止 停止所有 停止动画，但完成动作 点击 \"开始\" 按钮开始动画。 点击 \"停止\" 按钮停止当前激活的动画，但之后我们能再动画队列中再次激活。 点击 \"停止所有\" 按钮停止当前动画，并清除动画队列，所以元素的所有动画都会停止。 点击 \"停止动画，但完成动作\" 快速完成动作，并停止它。 $(function () { $(\"#start\").click(function () { $(\"#text\").animate({ top: '200px' }, 1000); $(\"#text\").animate({ top: '0' }, 1000); }); $(\"#stopDefault\").click(function(){ $(\"#text\").stop(); }) $(\"#stopAll\").click(function(){ $(\"#text\").stop(true); }) $(\"#stopToEnd\").click(function(){ $(\"#text\").stop(true,true); }) }); 8.6 链 返回目录  jQuery可以通过链的形式，链接多个动作。  修改8.4动画的代码： js 代码片段 function runBall() { $(\"#circle\").animate({ left: '-=110px', top: '+=150px', backgroundColor: 'red' }).animate({ left: '110px', backgroundColor: 'rgb(5, 243, 172)' }).animate({ left: '0', top: '0', backgroundColor: 'rgb(243, 207, 5)' }); }; 九 捕获 返回目录 text()：捕获文本 html()：捕获HTML val()：捕获表单文本值 attr()：捕获属性值 index.html 捕获 .container { width: 320px; margin: 0 auto; } 显示文本 显示HTML 显示表单值 显示属性 这是段落中的粗体 文本。 梁峻荣的网站 $(function(){ $(\"#showText\").click(function(){ alert(\"显示文本：\"+$(\"#text\").text()); }); $(\"#showHtml\").click(function(){ alert(\"显示HTML：\"+$(\"#text\").html()); }); $(\"#showVal\").click(function(){ alert(\"显示表单值：\"+$(\"#webSkill\").val()); }); $(\"#showAttr\").click(function(){ alert(\"显示属性：\"+$(\"#myBlog\").attr(\"target\")); }); }); 十 设置 返回目录 text()：捕获文本 html()：捕获HTML val()：捕获表单文本值 attr()：捕获属性值   在设置方面，这4个方法还提供回调函数。 index.html 设置 .container { width: 320px; margin: 0 auto; } 修改文本 这是段落中的 粗体 文本。 修改HTML 这是段落中的 粗体 文本。 修改表单值 修改属性1 梁峻荣的网站 修改属性2 便捷校园 $(function(){ $(\"#changeText\").click(function(){ $(\"#text\").text(\"Hello World!\"); }); $(\"#changeHtml\").click(function(){ $(\"#htmlText\").html(\"Hello World！\"); }); $(\"#changeVal\").click(function(){ $(\"#webSkill\").val(\"Hello World!\"); }); $(\"#changeAttr1\").click(function(){ $(\"#myBlog1\").text(\"便捷校园\").attr(\"href\", \"http://www.liangjunrong.com:3000\"); }); $(\"#changeAttr2\").click(function(){ $(\"#myBlog2\").text(\"梁峻荣的网站\").attr({ \"href\":\"http://www.liangjunrong.com\", \"target\":\"\" }); }); }); 十一 添加元素 返回目录 append() - 在被选的元素的结尾插入内容 prepend() - 在被选的元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容 index.html 添加元素 #container { background: red; } append追加文本 after追加文本 这是一个段落。 Hello World! function appendText() { var txt1 = \"文本。\"; // 使用 HTML 标签创建文本 var txt2 = $(\"\").text(\"文本。\"); // 使用 jQuery 创建文本 var txt3 = document.createElement(\"p\"); txt3.innerHTML = \"文本。\"; // 使用 DOM 创建文本 text with DOM $(\"#container\").append(txt1, txt2, txt3); // 追加新元素 } function afterText() { var txt1 = \"文本。\"; // 使用 HTML 标签创建文本 var txt2 = $(\"\").text(\"文本。\"); // 使用 jQuery 创建文本 var txt3 = document.createElement(\"p\"); txt3.innerHTML = \"文本。\"; // 使用 DOM 创建文本 text with DOM $(\"#container\").after(txt1, txt2, txt3); // 追加新元素 } 十二 删除元素 返回目录 remove() - 删除被选元素（及其子元素）（可附加参数） empty() - 从被选元素中删除子元素 index.html 删除元素 .container { width: 320px; margin: 0 auto; } #text { width: 200px; height: 200px; background: rgb(255, 217, 0); } remove元素 empty元素 remove部分元素 Hello World! Hello World! Liang~ Hello GuangZhou! $(function(){ $(\"#remove\").click(function(){ $(\"#text\").remove(); }); $(\"#empty\").click(function(){ $(\"#text\").empty(); }); $(\"#removeFew\").click(function(){ $(\"p\").remove(\".pText\"); }); }); 十三 CSS 类 返回目录 addClass() - 向被选元素添加一个类或多个类 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - 设置或返回样式属性 index.html CSS类 .container { width: 320px; margin: 0 auto; } .changeClass { background: rgb(0, 255, 179); } 添加样式 Hello World! 我叫梁峻荣！ $(function () { $(\"#addClass\").click(function () { $(\"#changeClass\").toggleClass(\"changeClass\"); }); }); 十四 CSS() 方法 返回目录  语法： 返回CSS： css(\"propertyname\"); 修改CSS： css(\"propertyname\",\"value\"); index.html CSS类 .container { width: 320px; margin: 0 auto; } p { background: red; } 获取CSS 修改CSS 这是一个段落。 $(function () { $(\"#getCss\").click(function () { alert($(\"p\").css(\"background\")); }); $(\"#changeCss\").click(function () { $(\"p\").css({ \"background\": \"red\", \"fontSize\": \"30px\" }); }); }); 十五 尺寸 返回目录 width() - 元素宽度 height() - 元素高度 innerWidth() - padding+元素 宽度 innerHeight() - padding+元素 高度 outerWidth() - border+padding+元素 宽度 outerHeight() - border+padding+元素 高度 index.html 尺寸 .container { width: 320px; margin: 0 auto; text-align: center; } .box { width: 220px; height: 220px; padding: 10px; border: 5px solid #ccc; background: rgb(6, 193, 240); display: inline-block; } 显示width 显示height 显示innerWidth 显示innerHeight 显示outerWidth 显示outerHeight $(function(){ $(\"#showWidth\").click(function(){ var width = \"div的width是：\" + $(\".box\").width() + \"\"; $(\"#width\").html(width); }); $(\"#showHeight\").click(function(){ var height = \"div的height是：\" + $(\".box\").height() + \"\"; $(\"#height\").html(height); }); $(\"#showInnerWidth\").click(function(){ var innerWidth = \"div的innerWidth是：\" + $(\".box\").innerWidth() + \"\"; $(\"#innerWidth\").html(innerWidth); }); $(\"#showInnerHeight\").click(function(){ var innerHeight = \"div的innerHeight是：\" + $(\".box\").innerHeight() + \"\"; $(\"#innerHeight\").html(innerHeight); }); $(\"#showOuterWidth\").click(function(){ var outerWidth = \"div的outerWidth是：\" + $(\".box\").outerWidth() + \"\"; $(\"#outerWidth\").html(outerWidth); }); $(\"#showOuterHeight\").click(function(){ var outerHeight = \"div的outerHeight是：\" + $(\".box\").outerHeight() + \"\"; $(\"#outerHeight\").html(outerHeight); }); }); 十六 祖先选择器 返回目录 parent() - 上一级父元素 parents() - 上至html标签 parentsUntil() - 介于目前元素与选择元素之间的所有标签。 index.html 祖先 .container { width: 320px; margin: 0 auto; text-align: center; } .ancestorsClass { color: rgb(0, 0, 0); border: 2px solid rgb(0, 247, 255); } body （曾曾祖父元素） div （曾祖父元素） parent parents parents刷选 parentsUntil 清空 ul （祖父元素） li （父元素） span $(function(){ $(\"#parent\").click(function(){ $(\"span\").parent().addClass(\"ancestorsClass\"); }); $(\"#parents\").click(function(){ $(\"span\").parents().addClass(\"ancestorsClass\"); }); $(\"#parentsSelect\").click(function(){ $(\"span\").parents(\"ul\").addClass(\"ancestorsClass\"); }); $(\"#parentUntil\").click(function(){ $(\"span\").parentsUntil(\"div\").addClass(\"ancestorsClass\"); }); $(\"#clear\").click(function(){ $(\"span\").parents().removeClass(\"ancestorsClass\"); }); }); 十七 后代选择器 返回目录 children() - 所选元素的所有直接子元素 find() - 找到符合条件的子元素 index.html 后代 .container { width: 320px; margin: 0 auto; text-align: center; } .boxClass { font-size: 2em; color: rebeccapurple; } children find Hello World! !dlroW olleH $(function(){ $(\"#children\").click(function(){ $(\"#box\").children(\"p.p1\").addClass(\"boxClass\"); }); $(\"#find\").click(function(){ $(\"#box\").find(\"*\").addClass(\"boxClass\"); }); }); 十八 同胞选择器 返回目录 siblings() - 被选元素的所有同胞元素 next() - 被选元素的下一个元素 nextAll() - 被选元素的下面所有元素 nextUntil() - 被选元素到后面指定元素中间的所有元素 prev() - 被选元素的前一个元素 prevAll() - 被选元素的前面所有元素 prevUntil() - 被选元素到前面指定元素中间的所有元素 index.html 同胞 .container { width: 320px; margin: 0 auto; text-align: center; } .textClass { border: 2px solid rgb(0, 255, 221); border-radius: 20px; } sibling next nextAll nextUntil prev prevAll prevUntil clear Hello! Hello! Hello! Hello! Hello! Hello! $(function () { $(\"#sibling\").click(function () { $(\"h3\").siblings(\"h4\").addClass(\"textClass\"); }); $(\"#next\").click(function () { $(\"h1\").next().addClass(\"textClass\"); }); $(\"#nextAll\").click(function () { $(\"h1\").nextAll().addClass(\"textClass\"); }); $(\"#nextUntil\").click(function () { $(\"h3\").nextUntil(\"h6\").addClass(\"textClass\"); }); $(\"#prev\").click(function () { $(\"h6\").prev().addClass(\"textClass\"); }); $(\"#prevAll\").click(function () { $(\"h6\").prevAll().addClass(\"textClass\"); }); $(\"#prevUntil\").click(function () { $(\"h6\").prevUntil(\"h3\").addClass(\"textClass\"); }); $(\"#clear\").click(function () { $(\"#box\").children().removeClass(\"textClass\"); }); }); 十九 过滤选择器 返回目录 first() - 第一个匹配条件的元素 last() - 最后一个匹配条件的元素 eq() - 符合索引号的元素 filter() - 匹配filter里条件的元素 not() - 去掉not里符合条件的元素后的其他元素 index.html 过滤 .container { width: 320px; margin: 0 auto; text-align: center; } .textClass { border: 2px solid rgb(0, 255, 221); border-radius: 20px; } first last eq filter not clear Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! $(function(){ $(\"#first\").click(function(){ $(\"#box h3\").first().addClass(\"textClass\"); }); $(\"#last\").click(function(){ $(\"#box h3\").last().addClass(\"textClass\"); }); $(\"#eq\").click(function(){ $(\"#box\").children().eq(2).addClass(\"textClass\"); }); $(\"#filter\").click(function(){ $(\"#box\").children().filter(\"h3\").addClass(\"textClass\"); }); $(\"#not\").click(function(){ $(\"#box\").children().not(\"h3\").addClass(\"textClass\"); }); $(\"#clear\").click(function(){ $(\"#box\").children().removeClass(\"textClass\"); }) }); 二十 load 返回目录  语法：$(selector).load(URL,data,callback); URL：请求加载的URL data：查询字符串键值对集合 callback：load() 方法完成后所执行的函数名称 responseTxt - 包含调用成功时的结果内容 statusTxt - 包含调用的状态 xhr - 包含XMLHttpRequest对象 二十一 get() 和 post() 返回目录  get - 从指定的资源请求数据 post - 向指定的资源提交要处理的数据  语法： $.get(URL,callback); URL：请求的 URL callback：请求成功后所执行的函数名 二十二 Ajax 返回目录  语法：$.ajax({name:value, name:value, ... })  方法 1： js 代码片段1 $.ajax({ url: host + '/addressInfo', type: 'get', dataType: 'json', data: { addressName: $serA } }).done(function (res) { console.log(res); }).fail(function () { console.log(\"error\"); }).always(function () { console.log(\"complete\"); });  方法 2： js 代码片段2 $.ajax({ url: host + '/olduser/up', type: 'get', dataType: 'json', data: { userName: $(\"#search-name\").val(), adsl: $(\"#search-id\").val() }, success:function(res){ if(res.code == 0) { \"#search-name\").val()) + \"&adsl=\" + escape($(\"#search-id\").val()); } else { alert(res.msg); } } }) 二十三 JSONP 返回目录  跨域读取数据，请用 JSONP。 注意：JSONP 与 Ajax 没任何关系！JSONP 是利用 script 标签来 get 到被包裹的 json 数据。 index.html JSONP $.getJSON(\"http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=?\", function (data) { var html = ''; for (var i = 0; i ' + data[i] + ''; } html += ''; $('#divCustomers').html(html); }); 二十四 无冲突 - noConflict 返回目录  当 jQuery 和其他的 JavaScript 框架同时将$作为简写的使用，可以考虑使用noConflict()方法解决冲突。 二十五 jQuery 实例 返回目录  总结前面的 jQuery 实例：https://www.runoob.com/jquery/jquery-examples.html 二十六 选择器扩展 返回目录  选择器的扩展大全 26.1 基本选择器 返回目录 $(\"#id\") // ID选择器 $(\"div\") // 元素选择器 $(\".classname\") // 类选择器 $(\".classname,.classname1,#id1\") // 组合选择器 26.2 层次选择器 返回目录 $(\"#id>.classname \") // 子元素选择器 $(\"#id .classname \") // 后代元素选择器 $(\"#id + .classname \") // 紧邻下一个元素选择器 $(\"#id ~ .classname \") // 兄弟元素选择器 26.3 过滤选择器（重点） 返回目录 $(\"li:first\") // 第一个 li $(\"li:last\") // 最后一个 li $(\"li:even\") // 挑选下标为偶数的 li $(\"li:odd\") // 挑选下标为奇数的 li $(\"li:eq(4)\") // 下标等于 4 的 li $(\"li:gt(2)\") // 下标大于 2 的 li $(\"li:lt(2)\") // 下标小于 2 的 li $(\"li:not(#runoob)\") // 挑选除 id=\"runoob\" 以外的所有 li 26.3.1 内容过滤选择器 返回目录 $(\"div:contains('Runob')\") // 包含 Runob 文本的元素 $(\"td:empty\") // 不包含子元素或者文本的空元素 $(\"div:has(selector)\") // 含有选择器所匹配的元素 $(\"td:parent\") // 含有子元素或者文本的元素 26.3.2 可见性过滤选择器 返回目录 $(\"li:hidden\") // 匹配所有不可见元素，或 type 为 hidden 的元素 $(\"li:visible\") // 匹配所有可见元素 26.4 属性过滤选择器 返回目录 $(\"div[id]\") // 所有含有 id 属性的 div 元素 $(\"div[id='123']\") // id属性值为123的div 元素 $(\"div[id!='123']\") // id属性值不等于123的div 元素 $(\"div[id^='qq']\") // id属性值以qq开头的div 元素 $(\"div[id$='zz']\") // id属性值以zz结尾的div 元素 $(\"div[id*='bb']\") // id属性值包含bb的div 元素 $(\"input[id][name$='man']\") //多属性选过滤，同时满足两个属性的条件的元素 26.5 状态过滤选择器 返回目录 $(\"input:enabled\") // 匹配可用的 input $(\"input:disabled\") // 匹配不可用的 input $(\"input:checked\") // 匹配选中的 input $(\"option:selected\") // 匹配选中的 option 26.6 表单选择器 返回目录 $(\":input\") //匹配所有 input, textarea, select 和 button 元素 $(\":text\") //所有的单行文本框，$(\":text\") 等价于$(\"[type=text]\")，推荐使用$(\"input:text\")效率更高，下同 $(\":password\") //所有密码框 $(\":radio\") //所有单选按钮 $(\":checkbox\") //所有复选框 $(\":submit\") //所有提交按钮 $(\":reset\") //所有重置按钮 $(\":button\") //所有button按钮 $(\":file\") //所有文件域 二十七 插件扩展 返回目录  配合 jQuery 的插件，可以更好的进行工作。 27.1 jQuery Validate 返回目录  说明：jQuery Validate是在jQuery基础上扩展的为表单提供验证功能的插件。 网址：https://www.runoob.com/jquery/jquery-plugin-validate.html 27.2 jQuery Accordion 返回目录  说明：jQuery Accordion插件用于创建折叠菜单 网址：https://www.runoob.com/jquery/jquery-plugin-accordion.html 27.3 jQuery Autocomplete 返回目录  说明：jQuery Autocomplete插件根据用户输入值进行搜索和过滤 网址：https://www.runoob.com/jquery/jquery-plugin-autocomplete.html 27.4 jQuery Growl 返回目录  说明：jQuery Growl用户做消息提醒 网址：https://www.runoob.com/jquery/jquery-plugin-message.html 27.5 jQuery Password Validation 返回目录  说明：jQuery Password Validation 在jQuery Validation 的基础上扩展，专门对密码进行验证 网址：https://www.runoob.com/jquery/jquery-plugin-password-validation.html 27.6 jQuery Prettydate 返回目录  说明：jQuery Prettydate为表单提供验证功能 网址：https://www.runoob.com/jquery/jquery-plugin-prettydate.html 27.7 jQuery Treeview 返回目录  说明：jQuery Treeview提供无序灵活的可折叠树形菜单 网址：https://www.runoob.com/jquery/jquery-plugin-treeview.html jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/jQuery/jQueryFrequentlyUsed.html":{"url":"JavaScript-library/jQuery/jQueryFrequentlyUsed.html","title":"✔ jQuery 工作常用解决方案","keywords":"","body":"jQuery 工作常用解决方案 Create by jsliang on 2018-11-4 10:37:33Recently revised in 2019-2-11 11:18:40  Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址  记录工作中，使用 jQuery、HTML、CSS 等技术的技巧，包括但不限于：rem 适配、css reset、活动边框、弹窗等。  比较琐碎，各取所需。 一 JavaScript 1.1 jQuery 引入  CDN： 1.2 双引号与单引号的使用规范  在平时的时候，能使用双引号就用双引号。 在拼接字符串的时候，使用单引号裹住。 1.3 移动端rem适配  直接在 index.html 中引用该 js 文件即可。 mobile-terminal-adaptation.js /* * 2018年7月25日10:38:23 * 移动端rem适配，px:rem = 100:1 * 该适配兼容UC竖屏转横屏出现的BUG * 自定义设计稿的宽度：designWidth * 最大宽度:maxWidth * 这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750) */ ! function (e, t) { function n() { var n = l.getBoundingClientRect().width; t = t || 540, n > t && (n = t); var i = 100 * n / e; r.innerHTML = \"html{font-size:\" + i + \"px;}\" } var i, d = document, o = window, l = d.documentElement, r = document.createElement(\"style\"); if (l.firstElementChild) l.firstElementChild.appendChild(r); else { var a = d.createElement(\"div\"); a.appendChild(r), d.write(a.innerHTML), a = null } n(), o.addEventListener(\"resize\", function () { clearTimeout(i), i = setTimeout(n, 300) }, !1), o.addEventListener(\"pageshow\", function (e) { e.persisted && (clearTimeout(i), i = setTimeout(n, 300)) }, !1), \"complete\" === d.readyState ? d.body.style.fontSize = \"16px\" : d.addEventListener( \"DOMContentLoaded\", function (e) { d.body.style.fontSize = \"16px\" }, !1) }(1000, 1000); 1.4 jQuery ajax  方法1： $.ajax({ url: host + '/addressInfo', type: 'get', dataType: 'json', data: { addressName: $serA } }).done(function (res) { console.log(res); }).fail(function () { console.log(\"error\"); }).always(function () { console.log(\"complete\"); });  方法2： $.ajax({ url: host + '/olduser/up', type: 'get', dataType: 'json', data: { userName: $(\"#search-name\").val(), adsl: $(\"#search-id\").val() }, success:function(res){ if(res.code == 0) { $(\"#search-name\").val() + \"&adsl=\" + escape($(\"#search-id\").val()); } else { alert(res.msg); } } }) 1.5 URL加码及解码  加码： window.location = \"adslList.htm?name=\" + escape(name) + \"&idNo=\" + escape(idNo);  解码： function getUrlParam(name) { var reg = new RegExp(\"(^|&)\"+ name +\"=([^&]*)(&|$)\"); var r = window.location.search.substr(1).match(reg); if(r!=null)return unescape(r[2]); return null; } console.log(\"url name=\" + getUrlParam(\"name\") + \",url idNo=\" + getUrlParam(\"idNo\")); 1.6 常用正则表达式 使用方式：if(!/^((\\d{8})|(1[35784]\\d{9}))$/.test($(\"#user-phone\").val())){ alert('请填写11位手机号码或8位固话号码'); return false; } 密码强度 必须包含数字+小写字母+大写字母的密码，位数在8-10位之间： ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 只能是字母、数字和下划线： ^\\w+$ 校验中文： ^[\\u4e00-\\u9fa5]{0,}$ Email验证： [\\w!#$%&'*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])? 身份证验证 ^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$ 手机号验证：以1开头，第二位数是3/4/5/7/8的11位手机号码 ^1[3,4,5,7,8]\\d{9}$ 二 HTML 2.1 搜索跳转到百度 皮皮虾我们溜 三 CSS 3.1 设置input的placeholder reset.css /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #727272; } /* Webkit browsers */ input::-moz-placeholder { color: #727272; } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #727272; } /* Internet Explorer */ 3.2 使图片根据不同设备自适应 reset.css /** 图片自适应 - image responsize **/ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; } 3.3 垂直居中  首先，父元素设置relative； 然后，需要定位的元素设置absolute； 最后，垂直居中的top为50%，margin-top为该元素高度的负一半的高度值。 .search-result-area { position: relative; padding: 0 36px; } .previous-page, .next-page { position: absolute; top:50%; margin-top: -36px; } .previous-page { left: 0; } .next-page { right: 0; } 3.4 左右两栏布局 div1不变，div2浮动，div2的margin-left为div1的宽度。 div1+div2浮动，父级overflow=hidden。 父级relative定位，子级absolute定位。 3.5 css reset /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /* * 图片自适应 - image responsize * 1. 清空浏览器对图片的设置 * 2. 图片 的情况下，图片会撑高 div，这么设置可以清除该影响 */ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .32rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .32rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .32rem } /* Internet Explorer */ 3.6 li前面点换成图片 ul{ list-style-image: url(img/5.jpg); } 3.7 制作div的边框 .content:before { content: \" \"; display: block; width: 100%; height: 3.46rem; background: url(\"../images/mobile-frame-top.jpg\") no-repeat center; background-size: 100%; position: absolute; left: 0; top: 0; z-index: 9; } .content { position: relative; background: url(\"../images/mobile-frame-content.jpg\") repeat-y center; background-size: 100% auto; width: 10rem; padding: 3.46rem 1.37rem 2.26rem; font-size: .3rem; } .content:after { content: \" \"; display: block; width: 100%; height: 2.26rem; background: url(\"../images/mobile-frame-bottom.png\") no-repeat center; background-size: 100%; position: absolute; left: 0; bottom: 0; z-index: 9; } 3.8 手机端背景图不能正确放大 .banner { background: url(\"../images/banner.jpg\") no-repeat; background-size: 100% auto; } 3.9 position情况下居中  left值计算：width - button宽度一半 3.10 jsliang的弹窗  如果希望弹窗不固定大小，在手机端或者 PC 端都能使用，推荐使用百分比配置。 *.html 该板块暂未开放~ 好的，我知道了 *.css /** 弹窗 - alert **/ .jsliang-prompt { display: none; } .jsliang-mask { z-index: 998; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; filter: alpha(opacity=30); -ms-filter: \"alpha(opacity=30)\"; opacity: .3; } .jsliang-alert { z-index: 999; position: fixed; top: 30%; left: 40%; width: 320px; height: 220px; box-shadow: 2px 2px 4px #A0A0A0, -2px -2px 4px #A0A0A0; background-color: #fff; padding: 25px; border-radius: 15px; text-align: center; } .jsliang-alert img { width: 120px; height: 83.8px; } .jsliang-alert p { margin-top: 10px; } .jsliang-get-it { color: #fff; background: #5bc0de; display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; font-weight: 400; line-height: 1.42857143em; white-space: nowrap; cursor: pointer; border-color: #46b8da; border: 1px solid transparent; border-radius: 4px; text-align: center; vertical-align: middle; text-decoration: none; } .jsliang-get-it:hover { background: #31b0d5; } /* end */ 3.11 常用SVG  直接引用到页面即可。 3.12 滚动条 http://www.xuanfengge.com/demo/201311/scroll/css3-scroll.html 3.13 修改select样式 *.html 请选择商铺区域 香洲 拱北 前山 横琴 斗门 金湾 *.css .activity-area-select { width: 4.3rem; height: .6rem; line-height: .6rem; margin-left: .5rem; border: 1px solid #e0e0e0; border-radius: .28rem; font-size: .24rem; float: left; } /* 修改浏览器默认select */ .activity-area-select select { /* 清除边框 - Chrome和Firefox里面的边框不一样，需要复写 */ border: none; /* 清除聚焦颜色 */ outline: none; /* 清除默认样式 */ appearance: none; -moz-appearance: none; -webkit-appearance: none; /*在选择框的最右侧中间显示小箭头图片*/ background: url(\"../images/icon-select.png\") no-repeat center right scroll transparent; /*为下拉小箭头留出一点位置，避免被文字覆盖*/ padding-left: .3rem; padding-right: 2rem; } /* 清除边框 - 清除ie的默认选择框样式清除，隐藏下拉箭头*/ .activity-area-select select::-ms-expand { display: none; outline: none; } 3.14 修改table样式 *.html 商铺名称 商铺地址 珠海粤西贸易有限公司 珠海市香洲区群华路44号（五洲康城） 珠海市香洲阑山唯佳生鲜馆 香洲区南福路199号商铺 *.css .search-result-table { border:solid #e1e1e1; border-width:1px 0px 0px 1px; } table thead, tbody tr { display: table; width: 100%; table-layout: fixed; } .search-result-table tr:nth-child(2n+2) { background: #fff7ef; } .search-result-table th { background: #ffa751; color: #fff; font-size: .24rem; height: .63rem; line-height: .63rem; border:solid #e1e1e1; border-width: 0px 1px 1px 0px; } .search-result-table tbody { display: block; height: 6.05rem; overflow-x: hidden; overflow-y: scroll; } .search-result-table td { font-size: .22rem; height: .9rem; padding-left: .22rem; border:solid #e1e1e1; border-width: 0px 1px 1px 0px; } 四 Other 4.1 VSCode 选中设置  文件 -> 设置 -> User Settings -> editor.wordSeparators 下划线选中： `~!@#$%^&*()-=+[{]}\\\\|;:'\\\",.<>/?  横杠选中： ./\\\\()\\\"':,.;<>~!@#$%^&*|+=[]{}`~? 4.2 浏览器前缀参照  -moz- 对应 Firefox, -webkit- 对应 Safari and Chrome -o- 对应 Opera -ms- 对应 Internet Explorer 4.3 git的使用  本地仓库上传到GitHub： git init git add . git commit -m \"first commit\" git remote add origin https://github.com/address git push -u origin master  更新本地仓库到GitHub git add . git commit -m \"更新\" git push -u origin master  拉取GitHub项目到本地 git clone address 4.4 VS Code 设置模板页 安装插件 HTML Snippets 文件-首选项-用户代码片段-HTML 修改文件内容为： { // Place your snippets for html here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the // same ids are connected. // Example: // \"Print to console\": { // \"prefix\": \"log\", // \"body\": [ // \"console.log('$1');\", // \"$2\" // ], // \"description\": \"Log output to console\" // } \"!!\": { \"prefix\": \"!!\", \"body\": [ \"\", \"\", \"\", \"\\t\", \"\\t\", \"\\t\", \"\\tHelloWorld\", \"\", \"\", \"\\t$1\", \"\\t\", \"\\t\", \"\", \"\" ], \"description\": \"!! - Defines a template for a html5 document\" } } 在HTML页面输入!!然后回车，即可看到新效果 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/":{"url":"JavaScript-library/Vue/","title":"Vue","keywords":"","body":"Vue Create by jsliang on 2018-10-29 11:48:55Recently revised in 2019-05-20 19:39:49  记录下关于 Vue 框架的系统学习旅途：Vue 基础 -> Vue 实战 -> Vue 源码剖析。  如果小伙伴也在学习 Vue，或者想复习下 Vue。那么，跟我一起走吧，发车啦~ 一 学习目录 目录 Vue 基础 Vue Router Vue-Cli Axios 二 写在前面 问：Vue 是啥？ 答：Vue 是前端三大流行框架之一，学前端不知道 Vue 就跟炒股不认识巴菲特一样。老铁，了解来一发？【 Go! 】 问：学 Vue 有啥用？ 答：小伙伴们应该不会跟钱过不去吧？现在企业的前端招聘要求中大都有 Vue 技能需求，所以学了拿更高工资啊。不信？点击去看看：【 Go! 】 问：有没有参考文档？ 答：关于学习 Vue 方面，最佳推荐还是官方文档，因为不管是其他文字还是视频教程，都是基于 Vue 的官方文档或者 GitHub 进行学习编写的。 Vue.js 官方文档 问：有没有参考视频？ 答： 开课吧 - Vue.js 及项目实战(2018/06)  在这里偶然发现一套来自 开课吧 的教学视频，然后发现它是今年 6 月份录制的，内容上还算是比较新，并且文件命名非常有意思，在这里咱的 Vue 基础知识先跟着它走一遍看看~ 【11-08】补充：Axios 中涉及到 Koa 提供的后端接口，还需要恶补一番 Node 基础或者 Koa 直接上手。 慕课网 - 《Vue.js 源码全方位深入解析》  还未开封，但是研究源码可能参考该套视频。 插件：Vue DevTools 三 学习旅途  在 Vue 套餐的学习旅途中： 【10-25】想用 Vue + Koa + MongoDB 搭建一套商城，于是学习 jspang 的教程。 【10-28】跟着学习了几天，发现一些基础知识真的忘得差不多了，不知道 Vue 基础知识，不知道 Node 基础知识，不知道 Koa 怎么玩，好纠结，好难受。 【10-29】敲下 Vue 的 README 文章，开始 Vue 学习。 【11-08】发现自己所有知识点都塞进一篇文章了，感觉不好，所以拆分成 VueBase、VueRouter、VueCli、Axios 这四篇文章。同时，发现自己 Axios 没法跟着教程下去了，想搞点 Node 基础，弄个 Koa 服务来帮助自己。 四 感言  【11-04】今天第一次发表该文章，收到了许许多多的评价，这里我抽取印象教深刻的两句话，说说我的想法： “我现在 觉得看别人的技术书籍都没有官方的好.因为别人吃过一遍，可能还没有消化好就出来欺世盗名...然后我们看他写的...学到的就更少了” “为什么不直接翻官方文档，然后再以别人的技术文章为辅”。  再三咀嚼这两句话，我觉得还是有道理的，就好比我在文章中，会说明我参考了哪里的视频，哪里的文章，最后推荐小伙伴们去积极查阅官方文档。 关于 欺世盗名 说法，个人觉得我不曾牛逼做到这种效果 ^_^。 我写文章的目的，仅仅是为了加深我的印象，并且将我的学习、工作经验分享出来，让其他人学习后，可以减少重复躺坑时间。 五 感谢 QQ群：364140450 的网友 青蛙表哥。非常佩服这位老哥，发表文章当天就我的代码敲了一遍，然后告诉我一些代码是可以优化的，并且对【深度监听】章节进行了自己的理解并推翻了我的代码。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:39:50 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/VueBase.html":{"url":"JavaScript-library/Vue/VueBase.html","title":"✔ Vue 基础","keywords":"","body":"Vue 基础 Create by jsliang on 2018-11-8 13:34:30Recently revised in 2019-05-20 19:35:47 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址 推荐通过 目录 以及使用 返回目录 按钮，获得更好的阅读体验。 一 目录 不折腾的前端，和咸鱼有什么区别~ 目录 一 目录 二 正文  2.1 初识 Vue  2.2 挂载数据 - data  2.3 进一步优化 el  2.4 插值表达式 - {{ }}  2.5 指令 - v-*  2.6 事件 - methods  2.7 组件 - components   2.7.1 初识组件   2.7.2 父子组件通讯   2.7.3 共用组件  2.8 过滤器 - filter   2.8.1 局部过滤   2.8.2 全局过滤  2.9 监听数据   2.9.1 侦听属性 - watch   2.9.2 计算属性 - computed   2.9.3 watch、computed 与 methods 对比  2.10 传递 DOM - slot   2.10.1 slot 单个传递   2.10.2 具名 slot  2.11 Vue 组件生命周期   2.11.1 beforeCreate & created   2.11.2 beforeMount & mounted   2.11.3 beforeUpdate & updated   2.11.4 beforeDestory & destory   2.11.5 activated & deactivated  2.12 获取 DOM 元素   2.12.1 单个 DOM 元素获取   2.12.2 组件 DOM 元素获取   2.12.3 Vue.nextTick() 三 实战 四 总结 二 正文 返回目录 饮水思源：Vue 官方文档 Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 学习版本：v2.5.21编写时间：2019-1-10 如版本更迭太大或者时间小伙伴们看到这篇文章太久没更新，小伙伴们请查看 Vue 官方文档学习最新的 Vue。 2.1 初识 Vue 返回目录 那么，Vue 是怎么折腾的呢？ 话不多说，我们直接来看代码实现： index.html Vue 学习 new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: '#app', // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` Hello World ` }) 现在，我们解析下代码运行： 首先，创建一个空白的 html 模板文件，通过 CDN 引用 Vue： Vue 一般分两个版本：开发版本：开发中有友好的错误提示。生产版本：上线部署使用的版本，代码包比较小 index.html 代码片段 然后，我们编写一个挂载点，即我们的 Vue，最终会在哪个 DOM 里面进行操作： 最后，我们通过 New 一个 Vue 实例对象，对我们 id 为 app 的 DOM 节点进行操作： new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容。 // 最外层必须有一层包裹，例如 template: ` Hello World ` }) 这样，我们最终就显示了 Vue 的简单引用，是不是觉得非常简单： 2.2 挂载数据 - data 返回目录 如果 Vue 仅仅是只有 template 这个模板装载，那么它跟 jQuery 就显得没多大差别了，下面我们使用下 Vue 的 data 进行数据渲染： index.html Vue 学习 new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: '#app', // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` {{ text }} `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 text: 'Hello World!' } } }) 在这里，我们可以看到，我们在 template 中加了一个 标签，通过 {{ text }} 形式，引入了一个叫 text 的 data 数据： {{ text }} 接着我们在 中定义了 text 的内容，从而实现数据渲染： data() { return { // template 中要使用的数据 text: 'Hello World!' } } 这样，我们就知道了，我们不仅可以通过模板 template 来渲染 标签，我们也可以将 js 中定义的数据或者变量，通过操作 data 从而改变 html 里面的内容。 2.3 进一步优化 el 返回目录 在 2.1 章节 及 2.2 章节中，我们使用 el 的方式是： el: '#app', 该 el 挂载形式，在 Vue 内部运行机制中，它会根据你传入的值，进行查找： 如果传入的是 #app，那它就判断查找 id 为 app 的节点； 如果传入的是 .app，那它就查找 class 为 app 的节点； 如果传入的是节点名 div，那它就查找节点名…… 大家应该清楚，这样判断查找是需要时间的，多执行一个判断都是罪恶。 所以我们可以： el: document.getElementById('app'), 这般操作，使得 Vue 直接将挂载点挂载到 id 上去，从而获得更好的加载速度。这算是对 el 的一个小优化。 2.4 插值表达式 - {{ }} 返回目录 如果小伙伴有点印象，应该还记得，我们在章节 2.2 中通过 {{ }} 这个插值表达式的使用，在 data 中对其里面的数据进行操作。 下面，我们进一步讲解这个插值表达式 {{ }} 还可以进行哪种骚操作： 对象：{{ {name: 'jack'} }} 字符串 {{ 'Hello World!' }} 布尔值： {{ isTrue == -1 }} 三元表达式： {{ isTrue ? '正确' : '错误' }} 光字面理解是不够的，我们通过代码进行操作演示： index.html Vue 学习 new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` {{ text }} {{ {name: 'jack'} }} {{ 'Hello World!' }} {{ isTrue == -1 }} {{ isTrue ? '真' : '假' }} `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 text: 'Hello World!', isTrue: true } } }) 它在浏览器的展示为： 关键代码讲解： 标签中 --> {{ text }} {{ {name: 'jack'} }} {{ 'Hello World!' }} {{ isTrue == -1 }} {{ isTrue ? '真' : '假' }} 通过三元表达式的运用，我们可以做到一些判断：数组最后一个元素、是否动态显示隐藏等。 2.5 指令 - v-* 返回目录 在 Vue 中，如果单单使用 {{}} 这种插值表达式，是满足不了我们对数据的操作欲望的。所以，Vue 以 v-if、v-bind 等形式，提供了一些对于页面 + 数据的更为方便的操作：指令 v-text v-html v-if v-else-if v-else v-show v-bind v-click v-model v-for 这里采用一个页面展示所有指令，如果小伙伴想逐个详细了解指令，推荐去官网查看学习：Vue 指令 那么，上面的指令都是怎么使用的呢？这里通过一个 index.html 及一张图向大家演示其基本用法： index.html Vue 学习 /* 颜色样式：红、绿、蓝 */ .color-red { color: red; } .color-blue { color: blue; } .color-green { color: green; } new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` v-text 演示 v-html 演示 v-if -> v-else-if -> v-else 演示 Hello v-If Hello v-else-if Hello v-else v-show 演示 v-bind:××× -> :××× 演示 v-click -> @click 演示 v-on:click - 点击直接改变 vBind 的值 v-on:click - 点击通过事件改变 vBind 的值 v-model 演示 {{ vModel }} v-for 演示 {{index+1}}. {{item.name}} - {{item.age}} `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 // v-text 及 v-html 使用数据 vTextOrHtml: '我是红的', // v-if 使用数据 vIf: 2, // v-show 使用数据 isTrue: false, // v-bind 使用数据 vBind: \"Hello v-bind\", // v-bind 通过动态绑定 class 修改样式 colorRed: 'color-red', // v-bind 的 :属性 的使用形式 other1: 'other1', // 同上 other2: 'other2', // v-model 使用数据 vModel: 'Hello v-model', // v-for 使用数据 vFor: [{ name: '张三', // 姓名 age: 22, // 年龄 classStyle: \"color-red\" // 样式 }, { name: '李四', age: 23, classStyle: \"color-blue\" }, { name: '王五', age: 24, classStyle: \"color-green\" } ] } } }) 我们看下页面： 在这里，我们对代码进行下讲解： Hello v-If Hello v-else-if Hello v-else > --> v-on:click - 点击直接改变 vBind 的值 v-on:click - 点击通过事件改变 vBind 的值 {{ vModel }} {{index+1}}. {{item.name}} - {{item.age}} v-bind 和 v-model 的区别： v-bind：将 Vue 中的数据同步到页面，即该值大部分用于前端向浏览器传固定数据。v-bind 可以给任何属性赋值，是从 Vue 到页面的单向数据流，即 Vue -> html。 v-model：双向数据绑定，前端向浏览器传数据，用户操作浏览器的更改前端可以察觉到。v-model 只能给具有 value 属性的元素进行双向数据绑定（必须使用的是有 value 属性的元素），即 Vue -> html -> Vue 关于 Vue 的指令，这里咱先对它进行了个全面的简单了解，知道它是如何使用的。想详细学习的小伙伴，记得前往官方文档：Vue 文档 2.6 事件 - methods 返回目录 在上一章 2.5 中，我们通过在 button 中使用 v-on:click 时，给它绑定了事件方法。 但是，在 2.5 中，我们大体讲述了事件方法的使用，但是我们只是一知半解。 在这里，我们抽取出来做下讲解： index.html Vue 学习 new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` 添加行内样式 `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { addStyle(e) { e.toElement.style.background = \"red\" } } }) 此时页面的点击效果如下所示： 此刻我们分析下页面： 首先，在上面的 中，我们通过 @click 绑定了事件 addStyle： 添加行内样式 接着，方法的编写，需要写到与 data 同级的 methods 中： methods: { // 方法 addStyle: function(e) { e.toElement.style.background = \"red\" } } 然后，我们通过传递参数 e，可以获取到点击的时候的元素，通过查找，我们发现它的样式所在的目录结构如下： - button - toElement - style - background 最后，我们在用户点击按钮的时候，直接修改了它的背景。 2.7 组件 - components 返回目录 敲黑板！敲黑板！敲黑板！ 组件是 Vue 学习的重点，组件化的 SPA 或者 SSR 页面的制作，使得我们开发起来更加随心应手。 2.7.1 初始组件 返回目录 在上面的章节中，我们一直使用 template: `` 的形式，编写 html 标签。但是，随着项目的不断扩大，如果全部代码都写在一个 template 中，那么我们修改起来就复杂了。所以，我们应该想办法对它进行划分，例如将一个页面划分为 header、content、footer 三部分。这样，我们需要修改 nav 的时候，只需要在 header 中修改就可以了。 页面结构 - app - header - content - footer 这样的思想，在 Vue 中体现为组件（组合起来的部件）。那么，在 Vue 中，需要如何做，才能比较好的做到组件的划分呢？ 首先，我们捋捋逻辑： 在前面的章节中，在 Vue 的定义上，我们将首个 template 挂载到了 id 为 app 的节点上。然后将 template 划分为三个块：header、content、footer。 在这里，我们将 #app 的 template 叫做父组件，header 等叫子组件，就好比父亲下面有三个儿子一样。 然后，我们尝试从 new Vue 中抽离单个组件出来： index.html Vue 学习 // 声明入口组件 var App = { template: `我是入口组件` } new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: '', // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 app: App } }) 这时候页面如下所示： 接着，我们分析下进行的三部曲： 在 component 中定义并抽离 App 在 new Vue 外定义 App 在 template 中使用 App 这样，我们就做到了单个组件的抽离，及 new Vue 是 App 的父组件，App 是 new Vue 的子组件。 最后，既然上面做到了单个组件的抽离，现在我们实现多个组件的抽离： index.html Vue学习 // 声明头部组件 var MyHeader = { template: `我是头部` }; // 声明内容组件 var MyContent = { template: `我是躯体` }; // 声明底部组件 var myFooter = { template: `我是底部` } new Vue({ el: document.getElementById('app'), components: { // 声明要用的组件们 // key 是组件名，value 是组件对象 'my-header': MyHeader, 'my-content': MyContent, 'my-footer': myFooter }, template: ` ` }) 这样，我们就做到了组件的抽离。 注意：template 有且只有一个根节点，如果没有根节点，Vue 会给你报错。 template: ` ` 上面那种写法是错误的，谨记。 做到这里，我们又可以愉快玩耍了，而且 myHeader、myContent、myFooter 中是可以跟 new Vue 一样写 data、methods 的哦~ 例如： var MyHeader = { data() { return { // ... 定义数据 } }, template: `我是头部`, methods: { // 定义方法 } }; 2.7.2 父子组件通讯 返回目录 既然前面章节已经划分了父子组件，那么在这里，我们讲件更有趣的事：父子组件通讯。 在组件间，我们 new Vue 相当于父亲（父组件），他有自己的 data。然后，子组件也会有自己的 data。 假如某天，父亲找到自己的儿子，想告诉他：“其实你不是我亲生的，你的姓名是***”。 那么，在 Vue 中，我们要怎么做，才能让它的儿子（子组件），知道它的姓究竟是什么呢？我们来看代码： index.html Vue 学习 // 子组件 var Son = { template: ` 我的名字：{{name}} `, props: ['name'] } new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 name: '皮皮虾' } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 son: Son } }) 编写完代码后，我们可以在浏览器看到，浏览器显示出了：我的名字：皮皮虾，这几个大字。 哦了，原来父亲的儿子姓 皮。同时，我们也就知道了，在父组件中的数据，通过 v-bind:*** 的形式，将父组件中的 data，发送给子组件。而子组件呢，通过 props 的定义，获取到了父亲的数据。 这样我们就做到了父组件传递数据给子组件。 2.7.3 共用组件 返回目录 在上面中，我们提到： - App - my-header - my-content - my-footer 在 App 这个组件上，我们挂载了三个子组件：myHeader、myContent、myFooter。 但是，如果某天，出现了一个女孩（共有组件），这个女孩的名字叫：beautifulGirl。然后不仅三个儿子（子组件）想追求她，就连父亲（父组件）也想追求她（够疯狂）。 那么，在 Vue 中，是通过什么方式，使父亲和儿子都有机会接触到这个女孩呢？（父子组件如何能够都可以使用共用组件） index.html Vue 学习 // 声明头部组件 var MyHeader = { template: ` 我是头部，我想了解 ` }; // 声明内容组件 var MyContent = { template: ` 我是内容区，我想了解 ` }; // 声明底部组件 var myFooter = { template: ` 我是底部，我想了解 ` } // 声明共用组件 Vue.component('beautiful-girl', { template: `—— 美丽女孩 ——` }) new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 'my-header': MyHeader, 'my-content': MyContent, 'my-footer': myFooter, } }) 在这里，我们通过 Vue.component('组件名',{ }) 的形式，注册了个全局组件 beautiful-girl，这样，父子组件都可以直接调用该组件，从而在浏览器显示为： 现在，父亲和儿子都可以和漂亮女孩沟通了。究竟是父亲给他们的儿子找了个后妈，还是他们儿子找到自己所爱呢？敬请期待…… 2.8 过滤器 - filter 返回目录 在工作中，我们经常需要对一些后端传回来的数据进行过滤。例如：我司 Java 小哥传回来的金钱，就是分进制的，即：1元 = 100分。所以传回个 2000，其实是 20 元。那么，在 Vue 中，我们该如何对数据进行过滤呢？ 2.8.1 局部过滤 返回目录 话不多说，先上代码： index.html Vue 学习 // 声明头部组件 var MyHeader = { template: ` 我是头部，我想了解 ` }; // 声明内容组件 var MyContent = { template: ` 我是内容区，我想了解 ` }; // 声明底部组件 var myFooter = { template: ` 我是底部，我想了解 ` } // 声明共用组件 Vue.component('beautiful-girl', { template: `—— 美丽女孩 ——` }) new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` 我是钱多多，我有 {{money}} 多一点： ￥{{money | addDot}}，跟我混有出息~ `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 money: 1000000 } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 }, // 8. filters - 组件内的过滤器 filters: { addDot(money) { return (money / 1000000 + \".000000\"); } } }) 在上面，我们通过 filters 中的 addDot 方法，对数据进行了过滤，将 money 的数据，从 10000000 变成了 1.000000。 2.8.2 全局过滤 返回目录 然后，在尝试了局部 filters 的好处之后，我们还可以试试它的全局过滤器写法： index.html Vue 学习 // 全局过滤器 Vue.filter('addDot', function(money) { return (money / 1000000 + \".000000\"); }) new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` 我是钱多多，我有 {{money}} 多一点： ￥{{money | addDot}}，跟我混有出息~ `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 money: 1000000 } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 }, // 8. filters - 组件内的过滤器 filters: { } }) 最后在页面中显示为： 2.9 监听数据 返回目录 在 Vue 中，我们通过 v-model 做了双向数据绑定，即在页面的 中输入的值，在我们的 Vue 中可以获得数据；在 Vue 中定义的数据，也会即时渲染到页面中。 但是，在代码中，我们怎样才能获取到它即时输入的数据呢？ 2.9.1 侦听属性 - watch 返回目录 话不多说，先上代码： index.html Vue 学习 new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` {{money}} `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 money: '' } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 }, // 8. filters - 组件内的过滤器 filters: { }, // 9. watch - 侦听属性 watch: { // key: data 属性的属性名 money(newVal, oldVal) { console.log(newVal, oldVal); } } }) 这样，当我们输入 11 个 1 的过程中，浏览器的 Console 对应输出为： 2.9.2 计算属性 - computed 返回目录 在上面，我们讲了通过 watch 来监听 data 中 number、string 等字段的改变。但是，在 Vue 中，为了方便我们的监听操作，Vue 还定义了个方法：computed，我们可以通过 computed，监控我们在 data 中定义的全部数据。 index.html Vue学习 new Vue({ el: document.getElementById('app'), template: ` + * = {{result}} `, data: { number1: 0, number2: 0, number3: 0, result: '', }, computed: { // 如果原值不变，缓存不调函数的优化机制 result: function() { // 监视对象，写在了函数内部， // 凡是函数内部有 this. 相关属性，改变都会触发当前函数 let addSum = parseInt(this.number1) + parseInt(this.number2); let allSum = addSum * this.number3; return allSum; } } }) 其结果如下面 GIF 图所示： 2.9.3 watch、computed 与 methods 对比 返回目录 在上面，我们涉及了两个知识点：watch 与 computed。 那么，又到 “玄学” 的时刻了，都是跟监听数据打交道，我们平时使用 Vue 的时候，什么时候使用 watch，什么时候使用 computed？然后，如果我们在加上 methods，那么什么时候我们又用 methods 呢？ 首先，我们对比下 computed 与 methods： computed 是根据 data 中的数据变化，而进行的操作。即 this.任意数据 改变了，那么，computed 就会进行改变；而如果 this.任务数据 不变，那么 computed 就会执行它的缓存策略，不会更新 methods 一般是根据点击之类的事件来触发的，例如用户通过 @click=\"方法\" 来进行数据的改变。 然后，我们对比下 computed 与 watch： 如果上面章节的 computed 方法换成 watch： index.html 代码片段 // 9. watch - 侦听属性 watch: { // key: data 属性的属性名 result(newVal, oldVal) { console.log(newVal, oldVal); this.result = this.number1 + this.number2 * this.number3; } }, 你会发现，result 数据不变化了，因为这是 computed 才特有的玩意，如果你需要将上面章节的 computed 方法换成 watch，那么你需要： index.html 代码片段 // 9. watch - 侦听属性 watch: { // key: data 属性的属性名 number1(val) { this.result = parseInt(this.number1) + parseInt(this.number2) * parseInt(this.number3); }, number2(val) { this.result = parseInt(this.number1) + parseInt(this.number2) * parseInt(this.number3); }, number3(val) { this.result = parseInt(this.number1) + parseInt(this.number2) * parseInt(this.number3); } }, 如此，小伙伴应该了解到，watch 如果需要完成 computed 的功能，那么，它需要监听每一个需要改变的属性。 最后，在这里，我们大致描述下 watch 与 computed 的区分： computed 强调计算，例如 c = a + b，b 是外界传来不断变化的，因为你只要显示 c，所以使用 computed。而 watch 属性强调自身值的变化前后的动作，如果需要完成 c = a + b，那么你需要 watch 数据 a 与 b 的变化，在这两者变化的时候，在方法中执行 c = a + b。 watch 在处理异步操作或者开销较大的操作上有优势。 执行异步操作不能串行返回结果，使用 watch； 开销较大的操作，避免堵塞主线程，使用 watch； 简单且串行返回的，使用 computed。 computed 对绑定的值有依赖，如果每次操作的值不变化，则不进行计算，具有缓存特性。watch 会侦听前后变化的状态，无论操作的值是否变化，都会执行定义的函数体，所以会有 data(newVal, oldVal)。 如果小伙伴们较真上了，那么请查看官方文档：计算属性和侦听器 2.10 传递 DOM - slot 返回目录 在日常工作中，我们对一些常用的功能，例如：侧边栏、顶部导航栏等，会进行常用的封装，等我们想用的时候，就可以直接引用。那么，在 Vue 中，想实现这类功能，我们还需要了解什么？ 2.10.1 slot 单个传递 返回目录 话不多说，先上代码： index.html Vue 学习 var myLi = { template: ` ` }; Vue.component('my-li', myLi); var App = { template: ` 我是第一行 button 按钮 我是第二行 h3 标签 我是第三行 a 导航 我是第四行 span 标签 ` }; new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 app: App }, // 8. filters - 组件内的过滤器 filters: { }, // 9. watch - 侦听属性 watch: { // key: data 属性的属性名 }, // 10. computed - 计算属性 computed: { // 如果原值不变，computed 会执行缓存，即不调用方法 } }) 其结果如下图所示： 那么，上面代码中，我们干了什么？ 首先，如上代码及其结果图，我们的 new Vue 中挂载了一个组件 App。 new Vue({ el: document.getElementById('app'), components: { app: App }, template: ` ` }) 然后，该 App 的目的，是想动态引用一个 li 组件 var App = { template: ` 1 2 3 4 ` }; 接着，我们在全局定义 myLi 组件的同时，通过 插槽，使它能够动态地加载 dom 节点。 var myLi = { template: ` ` }; Vue.component('my-li', myLi); 最后，我们在 App 中，传递给它不同的 dom 节点，从而动态生成 App。 var App = { template: ` 我是第一行 button 按钮 我是第二行 h3 标签 我是第三行 a 导航 我是第四行 span 标签 ` }; 这样，我们就思路清晰地知道，如何通过 来动态地加载 dom 节点，对我们 Vue 开发又有了更好的帮助。 2.10.2 具名 slot 返回目录 在上面中，我们谈论到了单个插槽 slot 的用法。但是，如果组件想根据父组件是否传递某个变量来存放插槽的数量，要怎么做呢？ index.html Vue 学习 var mySlot = { template: ` ` }; Vue.component('my-slot', mySlot); var App = { template: ` Helo World! 按钮 链接 ` }; new Vue({ // 3. el - 挂载目标，即渲染在哪个挂载点 el: document.getElementById('app'), // 4. template - 模板，即渲染到挂载点的内容 // 最外层必须有一层包裹，例如 template: ` `, // 5. data - 数据，即在操作中需要用到的数据 // 可以理解为在 jQuery 中 var text = \"Hello World!\" // {{ text }} 为数据渲染到 DOM 的方式之一 data() { return { // template 中要使用的数据 } }, // 6. methods - 方法，即我们的页面事件 // 可以理解为在 jQuery 中定义 Function methods: { }, // 7. components - 组件名称 components: { // key 是组件名，value 是组件对象 app: App }, // 8. filters - 组件内的过滤器 filters: { }, // 9. watch - 侦听属性 watch: { // key: data 属性的属性名 }, // 10. computed - 计算属性 computed: { // 如果原值不变，computed 会执行缓存，即不调用方法 } }) 效果图如下： 下面我们分析下，我们在代码中做了啥： 首先，我们通过下面代码可以知道，第一个 li 的 slot 是未命名的默认 slot，所以它在页面中展示为 p 的数据。 var mySlot = { template: ` ` }; var App = { template: ` Helo World! 按钮 链接 ` }; 然后，再观察下 App 中的代码 按钮 和 链接，发现它们使用了 slot=\"***\"，这说明了它指定了要求组件中 的代码接收。所以第二行第三行显示为按钮和链接。 最后，由于最后一个 li 中 ，这个 name=\"three\" 在 App 组件中没有用到，所以它表现为空。 2.11 Vue 组件生命周期 返回目录 在 Vue 中，什么时候进行虚拟 dom 渲染成 dom，或者什么时候销毁代码，都是有对应的钩子的： beforeCreate created beforeMount mounted beforeUpdate updated activated deactivated beforeDestory destory 关于生命周期，Vue 官方文档是有相关图示及文档的：官方文档 - Vue 生命周期 下面我们通过代码演示，讲解这 5 组生命周期的用法。 2.11.1 beforeCreate & created 返回目录 话不多说，先上代码： index.html Vue 学习 var lifeCycle = { template: ` 我是生命周期组件 `, data: function() { return { text: 'Hello World!' } }, beforeCreate: function() { // 组件创建之前 console.log(this.text); // [Console] undefined }, created: function() { // 组件创建之后 console.log(this.text); // [Console] Hello World! } /* * 使用 lifeCycle 组件，就会触发以上的事件函数（钩子函数） * created 中可以操作数据，并且可以实现 Vue -> 页面 的影响 * 应用：发起 ajax 请求 */ } var App = { components: { 'life-cycle': lifeCycle }, template: ` ` } new Vue({ el: document.getElementById('app'), components: { app: App }, template: ` ` }) 在代码中可以看到，我们在 App 中引用了 lifeCycle 这个组件。 我们通过钩子函数 beforeCreate（组件创建之前） 与 created（组件创建之后），结合 console 发现，这两个钩子函数对于 data 来说，一个在 data 挂载前（beforeCreate），所以打印出来的是：undefined，而另外一个发生在 data 挂载后，所以打印出来的是：Hello World!。 2.11.2 beforeMount & mounted 返回目录 话不多说，先上代码： index.html Vue 学习 var lifeCycle = { template: ` 我是生命周期组件 `, data: function() { return { text: 'Hello World!' } }, beforeMount: function() { // Vue 起作用之前 console.log(document.body.innerHTML); }, mounted: function() { // Vue 起作用，装载数据到 DOM 之后 console.log(document.body.innerHTML); } } var App = { components: { 'life-cycle': lifeCycle }, template: ` ` } new Vue({ el: document.getElementById('app'), components: { app: App }, template: ` ` }) 那么，虽说它们的作用，一个是 Vue 起作用之前，一个是 Vue 起作用，装载数据到 DOM 之后。 我们应该怎样才能观察到它的作用？ 看到上图的红框，也许你会恍然大悟：“喔，beforeMount 就是我装载之前的钩子函数，而 mounted 是我装载之后的钩子函数，它是 Vue 作用以后的 DOM” 2.11.3 beforeUpdate & updated 返回目录 话不多说，先上代码： index.html Vue 学习 var lifeCycle = { template: ` 我是生命周期组件 {{text}} 点击改变 text `, data: function() { return { text: 'Hello World!' } }, // 基于数据改变，影响页面 beforeUpdate: function() { // 改变前 console.log(document.getElementById('update').innerHTML); }, updated: function() { // 改变后 console.log(document.getElementById('update').innerHTML); } /* * 在日常工作中，我们可以在事件前后拿到它的 DOM，从而做一些我们想要的操作 */ } var App = { components: { 'life-cycle': lifeCycle }, template: ` ` } new Vue({ el: document.getElementById('app'), components: { app: App }, template: ` ` }) 在解析代码前，我们先查看它的输出： 可以看出，beforeUpdate 可以获取原 DOM，而 updated 可以获取新 DOM。 它们在上面代码中变现为：获取 按钮触发的事件前后 DOM 的变化，通过这个变化，我们可以在当中做一些操作，从而更好的满足我们的业务需求。 小结：（ beforeMount & mounted ） VS （ beforeUpdate & updated ） 那么问题来了，beforeMount 这组和 beforeUpdate 都能监控到 DOM 的变化，它们有什么区别呢？ 答案是，一般我们如果需要在页面加载的时候，监控 DOM 的变化，那就使用 beforeMount 和 mounted；但是，如果我们想监控用户的操作（点击事件等），那么，我们就需要使用 beforeUpdate 和 updated，因为它们不像 beforeMount 和 mounted 只会在页面挂载初期执行一次，它们可以根据用户的操作被执行多次。 2.11.4 beforeDestory & destory 返回目录 话不多说，先上代码： index.html Vue 学习 var lifeCycle = { template: ` 我是生命周期组件 `, // 对应父组件 v-if == false 的时候，就产生下面钩子函数，销毁当前组件 beforeDestroy: function() { // 销毁之前 console.log('实例销毁之前调用。在这一步，实例仍然完全可用。'); }, destroyed: function() { // 销毁之后 console.log('Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。'); } } var App = { components: { 'life-cycle': lifeCycle }, data: function() { return { isExist: true } }, template: ` 点击改变 子组件 状态 ` } new Vue({ el: document.getElementById('app'), components: { app: App }, template: ` ` }) 在这里，我们在点击 的时候，控制台显示为： 可以看出，当我们点击 的时候，我们的 isExist 状态（第一次时）被改变为 false，从而触发了 lifeCycle 的销毁钩子函数，在控制台打印了上面两行话。 相应的，如果是当 isExist 状态变为 true 的时候，会触发我们的 beforeCreate 和 created 这两个钩子函数，有兴趣的小伙伴可以尝试一下，这里不做过多演示。 2.11.5 activated & deactivated 返回目录 经过长期的工作，我们知道，如果频繁的操作 DOM，进行影响到钩子函数 beforeCreate 和 created 及 beforeDestory 和 destory 的操作，是对我们的性能会产生影响的。我们要如何防止某部分代码的频繁操作 DOM，并且监听到它的操作呢？ index.html Vue 学习 var lifeCycle = { template: ` 我是生命周期组件 `, activated: function() { console.log(\"组件被激活了\"); }, deactivated: function() { console.log(\"组件被停用了\"); } } var App = { components: { 'life-cycle': lifeCycle }, data: function() { return { isExist: true } }, template: ` 点击改变 子组件 状态 ` } new Vue({ el: document.getElementById('app'), components: { app: App }, template: ` ` }) 在代码中，我们通过 这个 Vue 的内置组件，对我们子组件进行了包裹。 然后，当我们进入页面和点击按钮时，做到了 activated 和 deactivated 这两个钩子函数的触发： 可以看出，当我们进来页面的时候，它就告诉我们，该组件被激活了。当我们第一次点击 按钮的时候，isExist 的状态变成了 false，即该组件被停用了。最后，我们再次点击了 ，这时候控制台再次打印 组件被激活了。 小结：这时候，希望小伙伴回到生命周期章节的开头，看官方关于生命周期的解析图，它将有助于我们更加理解声明周期。如果还是不够清晰，可以点击图片旁边的按钮，进入官方文档，查看官方关于生命周期的解析。【返回加深学习】 2.12 获取 DOM 元素 返回目录 在日常开发中，可能有小伙伴会想到操作 DOM 元素。如果用原生的 document.getElementById 吧，可能太 low 了，所以，有没有类似于 jQuery 的 $(\"#id\") 之类的呢？ 2.12.1 单个 DOM 元素获取 返回目录 话不多说，先上代码： index.html Vue 学习 var App = { template: ` 按钮 `, beforeCreate: function() { // 这里不能操作数据，只是初始化了事件等…… console.log(this.$refs.btn); // [Console] undefined }, created: function() { // 可以操作数据了 console.log(this.$refs.btn); // [Console] undefined }, beforeMount: function() { // new Vue 发生装载，替换 之前 console.log(this.$refs.btn); // [Console] undefined }, mounted: function() { // 装载数据之后 console.log(this.$refs.btn.innerHTML); // [Console] 按钮 } } new Vue({ el: document.getElementById('app'), components: { app: App }, template: `` }) 我们先查看下页面： 首先，我们在组件的 DOM 部分（），写上 ref = \"btn\"。 然后，我们发现只有在 mounted 数据装载之后这个钩子函数中，通过组件对象 this.$refs.btn 可以获取到元素 这样，我们就知道在一些场景，如何可以方便地通过 Vue 获取到 DOM 元素了。 2.12.2 组件 DOM 元素获取 返回目录 在上面，我们获取到了单个 DOM 节点的部分，假如我们需要获取到整个子组件，那么要怎么做呢？ index.html Vue 学习 var tempComponent = { template: ` 我是临时组件 ` } Vue.component('temp', tempComponent); var App = { template: ` `, mounted: function() { // 装载数据之后 console.log(this.$refs.temp.$el); } } new Vue({ el: document.getElementById('app'), components: { app: App }, template: `` }) 我们先不急着分析，先看控制台打印出了什么； 在这里可以看到它打印出了一堆关于该组件的东西，其中 $children - 当前组件的子组件 $el - 当前组件的元素节点 $parent - 当前组件的父组件 $root - 获取 new Vue 实例 然后发现元素 $el是 DOM 节点的内容，我们尝试打印出来看一下： console.log(this.$refs.temp.$el); Console 我是临时组件 通过 Console 可以看出，$el 就可以打印出其中的 元素了。 2.12.3 Vue.nextTick() 返回目录 当然，我们有时候操作 DOM，是想在 data 数据变更的时候进行操作，如果是使用上面方法，有些时候是搞不定的。 那么，我们应该怎么做呢？ index.html Vue 学习 var App = { template: ` `, data: function() { return { isShow: true } }, mounted: function() { // 希望在 Vue 真正渲染 DOM 到页面之后进行下面操作 this.$nextTick(function() { this.$refs.input.focus(); }) } } new Vue({ el: document.getElementById('app'), components: { app: App }, template: `` }) 如上，通过 Vue 的全局 API Vue.nextTick()，我们在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 这个操作我们可想象下 Promise 的执行流程，会获得更好的体验。 三 实战 返回目录 那么，学到这里，我们应该进行一个简单的操练，来回顾我们所学知识了： Vue Todolist - 功成千骨教学文章 Vue Todolist - 功成千骨代码地址 Vue Todolist - 功成千骨页面演示 四 总结 返回目录 如上，我们入门了基础的 Vue，可能小伙伴们会觉得还是很晕。 但是，没关系，我们接下来在讲解 VueRouter、VueCli 的时候还是会使用 Vue 基础语法的，正如那句话：万丈高楼平地起，地基还得自己起。 多实操，多做笔记，总能熟练上去的，加油~ 后记 如果小伙伴需要存放 jsliang.top 这样的纯静态页面或者 company.jsliang.top 这样的具有 Node 后端支持的页面，推荐购买云服务器来存放。 如果小伙伴们不知道该怎么选择云服务器，可以查看 详细介绍 或者加 jsliang QQ：1741020489 咨询。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 21:03:41 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/VueOfficialDocuments.html":{"url":"JavaScript-library/Vue/VueOfficialDocuments.html","title":"✔ Vue 官方文档二三事","keywords":"","body":"Vue 官方文档二三事 Create by jsliang on 2019-1-14 10:40:32Recently revised in 2019-1-22 08:31:29 记录在阅读 Vue、VueRouter、VueCli 等官方文档时的一些笔记，仅供参考，不做意见发表。 一 目录 目录 一 目录 二 Vue  2.1 安装  2.2 指令  2.3 生命周期钩子  2.4 数据监听  2.5 样式  2.6 数组操作  2.7 事件修饰符  2.8 按键修饰符  2.9 父子组件及其通讯  2.10 过渡动画  2.11 混入  2.12 自定义指令  2.13 过滤器 三 Vue Router 四 Vue Cli 五 Vuex 六 风格规范  6.1 命名规范  6.2 全局规范  6.3 HTMl 规范  6.4 JS 规范  6.5 CSS 规范 二 Vue 返回目录 本章节内容参考自： Vue 教程 Vue API 2.1 安装 返回目录 如果是 0 基础，推荐通过 CDN 引用 Vue：BootCDN。 如果有 Node + Webpack 基础，推荐使用命令行工具：Vue Cli npm i @vue/cli -g 2.2 指令 返回目录 v-text —— 将数据解析为纯文本。另外还可以使用 {{ }}，它也会将数据解析为纯文本，与 v-text 的区别就是花括号在网络加载慢的时候会显示 {{ * }}。 v-html —— 输出真正的 HTML，在 v-html 中可以使用 HTML 标签，但是请注意防范 XSS 攻击。 v-if —— 通过值 true 或者 false 来 添加/删除标签，一般会结合三元表达式使用。与 v-show 的区别是，v-if 的标签，如果为 false 是直接删掉该节点，而 v-show 是通过 display:none 来控制标签。同时，v-if 与 v-else-if、v-else 可以配套使用。 v-show —— 通过值 true 或者 false 来切换 display 显示/隐藏标签，一般会结合三元表达式。 v-for —— 常见形式：v-for=\"(item, index) in items。item 是单个元素，index 是数组下标。其他形式：v-for=\"item of items。 v-bind —— 可以通过 v-bind 或者其简写 :bind 绑定到 HTML 的属性字段上，例如 标签动态绑定 url 的时候 :url 或者自定义属性 :disabled 或者动态绑定 class、style 中使用 :class、style 等…… v-on —— 可以通过 v-on 或者其简写 @ 来绑定到 HTML 事件上，例如点击事件 @click 或者鼠标回车事件 v-on:keyup.enter。v-on 与 methods 是一对搭档。 v-model —— 双向数据绑定。通常与 、 及 进行绑定。 v-once —— 只渲染元素和组件一次。之后重新渲染，该元素及其子元素会被视为静态内容忽略。 详细介绍：API - Vue.js 小 tips v-if 和 v-show：一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 v-if 和 v-for：永远不要把 v-if 和 v-for 同时用在同一个元素上，例如：v-for=\"user in users\" v-if=\"user.isActive\" 就是不推荐的。建议可以通过 HTML5 的标签 来分开这两者，其作用类似于微信小程序的 。如果你打死都要这么做，那么 v-for 具有比 v-if 更高的优先级。 v-model：善用三个修饰符：v-model.lazy 将 input 更新换为 change 更新；v-model.number 直接绑定数字，结合 更好使用；v-model.trim 自动过滤首尾空白字符。 2.3 生命周期钩子 返回目录 2.4 数据监听 返回目录 watch 与 computed： 对比一： computed 强调计算。例如 c = a + b，因为你只要显示 c，所以不需要理会 a 与 b 的值是否动态传入，只需要使用 computed 监察 c 即可。 watch 属性强调自身值的变化前后的动作。如果需要完成 c = a + b，那么你需要 watch 数据 a 与 b 的变化，在这两者变化的时候，在方法中执行 c = a + b。 对比二： watch 在处理异步操作或者开销较大的操作上有优势。执行异步操作不能串行返回结果、执行开销较大的操作避免堵塞主线程的时候，使用 watch。 简单且串行返回的，使用 computed。 对比三： computed 对绑定的值有依赖，如果每次操作的值不变化，则不进行计算，具有缓存特性。 watch 会侦听前后变化的状态，无论操作的值是否变化，都会执行定义的函数体，所以会有 data(newVal, oldVal)。 2.5 样式 返回目录 类型 说明 :class 动态绑定 Class，可以通过多分类：:class=\"{ a: true, 'b', c: false }，或者结合计算属性 :class=\"computedClass\"，或者通过三元表达式：:class=\"{ a ? a == 1 : a == 2 }\" :style 动态绑定行内样式，如果是 font-size 之类的，最好通过驼峰式 fontSize 来编写。如果采用 :style=\"{styleOne, styleTwo}\" 的形式，当遇到 transform 时，Vue 会自动添加相应的前缀。 2.6 数组操作 返回目录 改变原数组的方法 push() - 向数组尾部添加元素 pop() - 删除并导出数组最后一个元素 shift() - 删除并导出数组第一个元素 unshift() - 向数组开头添加元素 splice() - 向数组中添加/删除元素并返回新的数组 sort() - 排序 reverse() - 反转数组 不改变原数组的方法 filter() - 过滤数组 concat() - 拼接两至多个数组 slice() - 获取数组指定位置数据 不改变原数组的方法比改变原数组的方法高效，至于怎么姿势才爽，那就看个人感受了。 2.7 事件修饰符 返回目录 .stop - 阻止事件冒泡。例如：@click.stop=\"say\" 阻止 say 方法传递到上一级 DOM。 .prevent - 阻止默认事件。例如：@click.prevent=\"say\"，阻止点击事件，然后执行 say。 .capture - 给元素添加监听器，在一个 HTML 模块中，如果有 4 层嵌套，前 2 层使用了 .capture 修饰符，第 3/4 层未使用，点击第 4 层触发点击事件，则顺序为：1 -> 2 -> 4 -> 3，因为 .capture 会先触发。 .self - 只触发该 DOM 本身的事件。相比于 .stop 阻止事件冒泡，.self 忽略事件冒泡和捕获的影响。 .once - 事件将只会触发一次。例如：@click.once='doOnce'，doOnce 只会执行一次。 .passive - 不要阻止事件的默认行为。例如：v-on:scroll.passive=\"onScroll\"，在进行滚动的时候同时执行 onScroll，而不是等 onScroll 执行完再滚动。 2.8 按键修饰符 返回目录 v-on:keyup.13 = @click.enter .enter - 回车 .tab - Tab 键 .delete - Back Space 或者 Delete .esc - Esc 键 .space - 空格键 .up - 上箭头 .down - 下箭头 .left - 左箭头 .right - 右箭头 .ctrl - Ctrl 键 .alt - Alt 键 .shift - Shift 键 2.9 父子组件及其通讯 返回目录 基础组件的写法 全局组件与局部组件 父组件传递数据给子组件 子组件传递数据给父组件 父子组件的 v-model 实现 - 默认插槽与其具名插槽 :is 的灵活应用 缓存状态，避免重新渲染 静态赋值 props：title=\"My name is jsliang\"；动态赋值 props：:title=\"article.title + ' by ' + article.name；props 可以传入 String、Number、Boolean、Array、Object、Date、Function、Symbol 并且对其进行以上类型验证。 2.10 过渡动画 返回目录 单组件过渡 过渡 6 状态：v-enter、v-enter-active、v-enter-to、v-leave、v-leave-active、v-leave-to 过渡系统 + 第三方 CSS 动画库（Animate.css） 过渡时间：:duration 过渡钩子：@:before-enter、@:enter、@:after-enter、@:enter-cancelled、@:before-leave、@:leave、@:after-leave、@:leave-cancelled key 在 的作用 过渡模式：in-out 与 out-in 数字过渡 颜色过渡 2.11 混入 返回目录 在 Vue 中，有一群万金油般存在，高尚的临时工：mixins。 城管临时工：干着城管的活，日常冲在第一线，有问题直接背锅。 mixins，在官方的称呼是：混入。 然而，在个人理解上，更宁愿称呼它为：模具。 什么意思呢？就是当你发现 new Vue() 中的 data、methods，在多个页面重复使用的时候，你可以将它们抽取出来，然后跟 模具 一样，给需要使用的每个页面，先盖个章，留个某某到此一游的印迹，再在此基础上进行开发。 举个例子：你有一个字段 pageNo: 1，在文章列表页、商品页都定义了，你抽取出来，存放到 mixins.js 中，然后在这两个页面通过 mixins: mymixin 盖个章，让这两个页面初始数据都存有 pageNo: 1。 以后，你就是我的小弟了~ 项目目录 - src - mixins - utils src/mixins/mixins.js export default { data() { return { message: 'hello', foo: 'abc' } } } HomeHeader.vue import mymixin from '../src/mixins/mixins' new Vue({ mixins: mymixin, data: function () { return { message: 'goodbye', bar: 'def' } }, created: function () { console.log(this.$data) // => { message: \"goodbye\", foo: \"abc\", bar: \"def\" } } }) 选项混入 全局混入 extends 类似于 mixins extends 支持单个对象，mixins 支持数组 Vue.extend > Vue.component > extends > mixins，即开发的时候同时使用 extends 和 mixins，注意覆盖顺序 测试代码.html Vue 学习 var extend = { data() { return { number: 1 } } } var mixin = { data() { return { number: 2 } } } new Vue({ el: '#app', data() { return { number: 3 } }, extends: extend, mixins: [mixin], created() { // 在这里不推荐同时使用 extends 与 mixins，因为会混淆 // 如果代码是这样子的，则这里输出的是 3 // 如果 new Vue 中没定义 number，则输出的是 2（mixins 中的值） // 如果 mixins 中没定义 number，则输出的是 1（extend 中的值） console.log(this.number); // Console：3 } }) 2.12 自定义指令 返回目录 局部指令：directives 全局指令：Vue.directive 自定义指令钩子函数：bind、inserted、update、componentUpdated、unbind 作用： focus 自动聚焦 2.13 过滤器 返回目录 使用方法：{{ message | messageFilter }}，然后定义 filters: { messageFilter(value) { // ...代码 } } 局部过滤器 全局过滤器 串联过滤器 三 Vue Router 返回目录 Vue Router 的基础使用。 动态路由匹配，动态设置匹配路径，动态匹配任意路径。 路由可以嵌套匹配，每个页面都可以有自己的 。 编程式导航：不仅可以通过 来定义导航链接，也可以通过 router.push(\"...\") 的形式来实现。同时，我们还可以采用 router.replace(\"...\") 来实现路由替换，通过 router.go(n) 来实现前进或者后退多少步路由。 命名路由的两种形式：在 中通过 :to=\"{name, params}\" 或者在 router.push() 中通过 {name, params} 来定义。 一个页面可以同时存在多个 ，只需要通过给它们命名 name 就可以实现。 路由可以通过 redirect 进行重定向，或者通过 alias 取别名，从而自由地将 UI 结构映射到任意的 URL。 路由还可以进行传参，通过取代与 $route 的耦合或者通过 props 解耦。其中有三种模式：布尔模式、对象模式以及函数模式。 Vue Router 的默认模式是 hash 模式，我们可以通过 mode，将其设置为 history 模式。 通过 router.beforeEach((to, from, next) => { ... }) 来注册全局路由守卫，它会在访问某个路由前进行拦截。其中 to 为即将进入的目标，from 为当前路由即将离开的位置，next 类似于 Promise 的 resolve。在 2.5+ 版本添加了 router.beforeResolve，作用类似于 router.beforeEach 路由全局后置钩子：router.afterEach((to, from) => {})。 可以针对某个路由进行守卫，即在 new VueRouter({}) 中通过 beforeEnter: (to, from, next) => {} 进行守卫。 可以直接在路由组件中定义：beforeRouteEnter、beforeRouteUpdate 以及 beforeRouteLeave。 完整的导航解析流程： 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 Vue Router 通过定义 meta，可以制定路由鉴权，缓存，标题信息等。 通过给 添加 包裹，并给 设置不同的 name，则添加过渡效果。同时，可以根据当前路由与目标路由的关系，动态设置过渡效果。 Vue Router 的引用，可以让我们动态设置数据是在导航完成之后获取还是在导航完成之前获取。 路由可以设置滚动行为，在切换到新路由时，可以滚动到顶部或者保持原先的滚动位置。 当路由过多，组件过大的时候，我们应该把不同的路由对应的组件分割成不同的代码块，从而使这些路由被访问的时候才加载对应组件，从而提高加载效率。使用 const Foo = () => import('./Foo.vue') 即可。同时，这些组件都可以通过 /* webpackChunkName: \"***\" */ 的形式，进行命名 chunk。 四 Vue Cli 返回目录 安装：npm install -g @vue/cli 创建项目：vue create my-project 或者 vue ui 兼容 VueCli 2.0 版本：npm i @vue/cli-init，然后就可以使用 vue init webpack 了。 五 Vuex 返回目录 为什么使用 Vuex ？ 数据的综合交错，很容易使代码难以维护。 数据传参非常繁琐，尤其是兄弟组件。 什么情况下使用 Vuex ？ 开发大型应用 数据庞大且繁杂 六 风格规范 返回目录 下面精简来自 Vue 风格指南 的条例，如需详细了解请访问 Vue 风格指南。 并不期望你能规规矩矩遵守，只是想让你有一套自己的编写风格，而不是一个项目一套风格，从而害人害己。 6.1 命名规范 返回目录 组件名应该始终是多个单词的，根组件 App 除外。这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。例如：todo-item、TodoItem。 只要有能够拼接文件的构建系统，就把每个组件单独分成文件。例如： components/ |- TodoList.vue |- TodoItem.vue 单文件组件的文件名应该要么始终是单词大写开头 PascalCase，要么始终是横线连接 kebab-case。例如： components/ |- MyComponent.vue 或者 components/ |- my-component.vue 基础文件名，即应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V。例如： components/ |- BaseButton.vue |- BaseTable.vue |- BaseIcon.vue 或者 components/ |- VButton.vue |- VTable.vue |- VIcon.vue 如果某个组件，像菜单栏、左侧菜单一样，全局中只拥有一个，那就以 The 前缀命名。例如： components/ |- TheHeading.vue |- TheSidebar.vue 和父组件紧密耦合的子组件应该以父组件名作为前缀命名。例如： components/ |- TodoList.vue |- TodoListItem.vue |- TodoListItemButton.vue 组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾；并且组件名应该倾向于完整单词而不是缩写。例如： components/ |- SearchButtonClear.vue |- SearchButtonRun.vue |- SearchInputQuery.vue |- SearchInputExcludeGlob.vue |- SettingsCheckboxTerms.vue |- SettingsCheckboxLaunchOnStartup.vue 而不是 components/ |- ClearSearchButton.vue |- ExcFromSearchInput.vue |- LaunchOnStartupCheckbox.vue |- RunSearchButton.vue |- SearchInput.vue |- TermsCheckbox.vue 6.2 全局规范 返回目录 尽量别在组件模板中使用 JS 来 bb 套太多话语，毕竟 HTML 就尽量让它做 HTML 该有的事；更好的分类能使代码更加简洁易懂；并且将组件模板中多特性的元素分多行来写，看起来会更舒服点。例如： |- HTML {{ normalizedFullName }} |- JS // 复杂表达式已经移入一个计算属性 computed: { normalizedFullName: function () { return this.fullName.split(' ').map(function (word) { return word[0].toUpperCase() + word.slice(1) }).join(' ') } } 而不是 |- HTML {{ fullName.split(' ').map(function (word) { return word[0].toUpperCase() + word.slice(1) }).join(' ') }} 尽可能在 HTML、CSS 中使用双引号（\"），在 JS 中使用单引号（'）。例如： 而不是 6.3 HTMl 规范 返回目录 在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的，且使用 PascalCase 形式命名。然后在 DOM 模板中不应该闭合，且使用 kebab-case 形式命名。例如： 尽可能统一指令书写形式，例如统一用简写形式 @ 及 : 或者统一用全拼形式 v-bind 及 v-on。 6.4 JS 规范 返回目录 组件的 data 必须是一个函数。当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。例如： data() { return { name: 'jsliang' } } Prop 的定义应该尽量详细，至少指定其类型。并且在声明的时候采用 camelCase，在使用的时候采用 kekab-case。例如： props: { status: { type: String, required: true, validator: function (value) { return [ 'syncing', 'synced', 'version-conflict', 'error' ].indexOf(value) !== -1 } }, greetingText: String } 总是用 key 配合 v-for。key 的作用：a.key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。b. 在 v-for 中使用 key，方便 Vue 跟踪每个节点，从而重用和重新排序现有元素。例如： ... {{ text }} 永远不要把 v-if 和 v-for 同时用在同一个元素上。例如： {{ user.name }} 6.5 CSS 规范 返回目录 为组件样式设置作用域。给每个组件的 CSS 使用 scoped，避免组件之间的样式互相影响。 .button { border: none; border-radius: 2px; } jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:37:01 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/VuePrepare.html":{"url":"JavaScript-library/Vue/VuePrepare.html","title":"✔ Vue 开发准备","keywords":"","body":"Vue 开发准备 Create by jsliang on 2018-12-24 11:54:30Recently revised in 2019-3-13 11:11:31 在使用 VueCli 开发之前，有些步骤是重复的，如果一个一个重新写过比较麻烦，故在此记录一些常用步骤。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 大体步骤 三 详细步骤  3.1 安装 VueCli  3.2 项目目录结构  3.3 配置使用 less  3.4 重置 CSS 样式  3.5 引用左上角图标  3.6 按需引用 ElementUI  3.7 Axios 封装使用  3.8 动态引用组件  3.9 图片的引用及打包  3.10 rem 适配 二 大体步骤 返回目录 启动 VueCli 开发模式 引用重置 CSS 样式表 引用右上角 icon 图标 按需引用 ElementUI 引用并封装 Axios 三 详细步骤 返回目录 3.1 安装 VueCli 返回目录 安装 vue-cli：npm i vue-cli -g 初始化 Vue 项目：vue init webpack 开启开发模式：npm run dev 打开浏览器，查看网页： http://localhost:8080 3.2 项目目录结构 返回目录 - build —————————————————————— 构建脚本目录 - build.js —— 运行本地构建服务器，可以访问构建后的页面 - check-versions.js —— 检查版本 - utils.js —— 构建相关工具方法 - vue-loader.conf.js —— 判断是否为生产环境 - webpack.base.conf.js —— webpack 开发环境配置 - webpack.prod.conf.js —— webpack 生产环境配置 - config ————————————————————— 配置 - dev.env.js —— 开发配置 - index.js —— 配置总文件 - prod.env.js —— 打包配置 - node_modules ——————————————— Node 依赖包，请忽略 - src ———————————————————————— 主要工作区 - api —— 接口统一管理文件夹 - api.js —— 接口文件 - assets —— 需要压缩文件 - img —— 图片 - components —— 共用组件 - pages —— 页面 - router —— 路由文件夹 - index.js —— 路由文件 - style —— 样式文件 - reset.less —— 重置样式 - common.less —— 公共样式 - utils —— 工具文件夹 - md5.js —— md5 加密 App.vue ————————————————————— 根组件 main.js ————————————————————— 根组件配置 - static ————————————————————— 静态资源文件，不会被打包 - css —— CSS 文件夹 - reset.css —— 重置样式 - img —— 图片文件夹 - .babelrc ——————————————————— babel 配置，转换 ES6/7 为 ES5 - .editorconfig —————————————— 编辑器风格配置 - .gitignore ————————————————— 忽略 git 上传文件 - .postcssrc.js —————————————— 转换 CSS 的插件 - index.html ————————————————— 首页 - package.json ——————————————— 定义这个项目所需要的各种模块 - README.md —————————————————— 开搞必读文档 3.3 配置使用 less 返回目录 安装 less 和 less-loader：cnpm i less less-loader -D 添加 webpack 打包规则： build/webpack.base.conf.js { test: /\\.less$/, loader: \"style-loader!css-loader!less-loader\" } 在 style 中使用 less： .left { border: 1px solid #ccc; .left-one { font-size: 10px; } } 引用下边的 reset.less 和 common.less App.vue @import './style/reset'; @import './style/common'; 3.4 重置 CSS 样式 返回目录 引入重置样式表 static/css/reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /** 图片自适应 - image responsize **/ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .26rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .26rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .26rem } /* Internet Explorer */ 引用重置样式表 src/main.js // 引入样式重置 import '../static/css/reset.css' 3.5 引用左上角图标 返回目录 在下面目录存放 ico 图片：在线制作 ico 图标 static/img/icon.ico 引用左上角图标 index.html 3.6 按需引用 ElementUI 返回目录 安装 ElementUI：npm i element-ui -S 如果需要完整使用 ElementUI： src/main.js import Vue from 'vue' import App from './App' import router from './router' // 引用 ElementUI import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; Vue.use(ElementUI); // 引用 ElementUI 结束 Vue.config.productionTip = false new Vue({ el: '#app', router, components: { App }, template: '' }) App.vue 左一 左二 右二 右一 如果需要按需引用 ElementUI： 安装 babel 插件：cnpm i babel-plugin-component -D 修改 .babelrc： .babelrc { \"presets\": [ [\"env\", { \"modules\": false, \"targets\": { \"browsers\": [\"> 1%\", \"last 2 versions\", \"not ie 按需引入 Row 与 Col： main.js // 引入及使用 ElementUI import {Row, Col} from 'element-ui'; Vue.use(Row).use(Col); App.vue 左一 左二 右二 右一 响应式布局下基于断点的隐藏类： main.js // 引入基于断点的隐藏类 import 'element-ui/lib/theme-chalk/display.css'; 然后你就可以使用下面的 CSS 类： hidden-xs-only - 当视口在 xs 尺寸时隐藏 hidden-sm-only - 当视口在 sm 尺寸时隐藏 hidden-sm-and-down - 当视口在 sm 及以下尺寸时隐藏 hidden-sm-and-up - 当视口在 sm 及以上尺寸时隐藏 hidden-md-only - 当视口在 md 尺寸时隐藏 hidden-md-and-down - 当视口在 md 及以下尺寸时隐藏 hidden-md-and-up - 当视口在 md 及以上尺寸时隐藏 hidden-lg-only - 当视口在 lg 尺寸时隐藏 hidden-lg-and-down - 当视口在 lg 及以下尺寸时隐藏 hidden-lg-and-up - 当视口在 lg 及以上尺寸时隐藏 hidden-xl-only - 当视口在 xl 尺寸时隐藏 注： 参数 说明 xs sm >=768px md >=992px lg >=1200px xl >=1920px 更多：ElementUI 组件 3.7 Axios 封装使用 返回目录 安装 Axios：cnpm i axios -D 封装 api 到 src/api/api.js 中 api.js /** * 封装逻辑 * 1. 引入 axios。 * 2. 设置请求配置 request。如：请求超时，响应头等 * 3. 设置请求中的遮罩（未实现） * 4. 设置请求成功后的数据过滤（未实现） * 5. 设置并暴露接口，传 data、method、url 到请求配置 request 上。 */ // 设置 axios import axios from 'axios'; // 请求配置 const request = axios.create({ // 本地开发 dev 的时候，不需要开启这个 // baseURL: 'http://172.26.167.5:8080', timeout: 5000, headers: { timestamp: \"20181026094424\", deviceid: \"10102\", signature: \"F9CB03DD3ED50EDA5DB214C42D4DC0D6\", } }) /** * 获取用户名 * userId */ export const getUserName = data => request({ method: 'get', url: '/api/getUserName', params: data }) 在 Pages 中调用： UserInfo.vue // 引用接口 import { getUserName } from \"@/api/api\" export default { methods: { _getUserName() { // 获取用户名 getUserName({ userId: this.userId, }).then( (res) => { console.log(\"\\n【API - 获取用户名】：\"); }) } } } 设置 webpack 跨域 index.js： config/index.js dev: { proxyTable: { '/stat': { // restful 接口规律 target: 'http://172.**.**.**:8080/', // 接口的域名 changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 } }, }, 更多参考：Axios 中文说明 3.8 动态引用组件 返回目录 修改路由文件： 项目/src/router/index.js import Vue from 'vue' import Router from 'vue-router' const Login = () => import('@/pages/Home/Login') const Index = () => import('@/pages/Home/Index') const ListOnePageOne = () => import('@/pages/ListOne/PageOne') Vue.use(Router) export default new Router({ routes: [ { path: '/', name: 'Login', component: Login }, { path: '/Index', component: Index, children: [ { path:'/', component: ListOnePageOne, meta: [\"第一组第一页\"], } ] } ] }) 3.9 图片的引用及打包 返回目录 在 VueCli 中，图片可以存放在两个位置： 静态目录，不会被打包：项目/static/img 动态目录，将会被打包：项目/src/assets/img 详细来说： static 的目录中的图片，不会被 Webpack 相关机制理会，你引入的时候，是怎样的，它就是怎样的。 assets 中的图片，它会被 Webpack 处理，在配置了图片相关打包 loader 的情况下，它会在 项目/build/webpack.base.conf.js 中依据相关的 loader 限制，在一定大小下转换为 Base64。 项目/build/webpack.base.conf.js { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') } }, 从代码中可以看出可以看出，它对于小于 10K(10000/1024) 的图片，会打包成 base64，从而减少了我们在浏览器加载时的性能损耗。 那么，在 VueCli 中应该如何引用图片呢？ export default { data() { return { icon1: require('../../assets/img/emoticon_cool.png'), // 引用 assets 下的图片 icon2: '/static/img/emoticon_cute.png' // 引用 static 下的图片 } } } 说完 static 和 assets 的区别，以及对图片的引用，如果小伙伴们想验证下，那么可以看看 Webpack 在打包的时候对图片的处理： 项目/config/index/js 'use strict' const path = require('path') module.exports = { dev: { assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: {}, //... 省略剩下的代码 }, build: { index: path.resolve(__dirname, '../dist/index.html'), assetsRoot: path.resolve(__dirname, '../dist'), assetsSubDirectory: 'static', assetsPublicPath: '/', // ...省略剩下的代码 } } 从代码中可以看出，对于 static 的资源，VueCli 在开发模式 dev 以及打包模式 build 中都进行了配置，它不会被 webpack 进行打包，属于 “静态资源”。 但是，问题来了： VueCli 打包的时候，生成的是图片的绝对路径，部署的时候无法解析到图片，需要配置成相对路径，需要怎么改呢？ 位置 1： 项目/build/webpack.prod.conf.js output: { publicPath: './', path: config.build.assetsRoot, filename: utils.assetsPath('js/[name].[chunkhash].js'), chunkFilename: utils.assetsPath('js/[id].[chunkhash].js') }, 在 output 这块，新增代码 publicPath: './'。 位置 2： 项目/build/utils.js if (options.extract) { return ExtractTextPlugin.extract({ use: loaders, publicPath: '../../', fallback: 'vue-style-loader' }) } else { return ['vue-style-loader'].concat(loaders) } 在 vue-style-loader 这里，新增 publicPath: '../../ 这行代码。 这样，打包出来的图片路径，就是相对路径了。 3.10 rem 适配 返回目录 如果项目属于手机端，那么需要进行 rem 适配，即将固定宽度的 px 转换为 rem，为了方便计算，下面有一份 100px = 1rem 的 JS 适配代码，只需要将代码放到 项目/src/utils/rem.js 中，并在 项目/src/main.js 中引用即可。 项目/src/main.js // 引用 rem 适配 import './utils/rem' 项目/src/utils/rem.js /* * 移动端 rem 适配，px:rem = 100:1 * 该适配兼容 UC 竖屏转横屏出现的 BUG * 自定义设计稿的宽度：designWidth * 最大宽度：maxWidth * 这段 js 的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为 750，最大宽度为 750，则为(750,750) */ ! function (e, t) { function n() { var n = l.getBoundingClientRect().width; t = t || 540, n > t && (n = t); var i = 100 * n / e; r.innerHTML = \"html{font-size:\" + i + \"px;}\" } var i, d = document, o = window, l = d.documentElement, r = document.createElement(\"style\"); if (l.firstElementChild) l.firstElementChild.appendChild(r); else { var a = d.createElement(\"div\"); a.appendChild(r), d.write(a.innerHTML), a = null } n(), o.addEventListener(\"resize\", function () { clearTimeout(i), i = setTimeout(n, 300) }, !1), o.addEventListener(\"pageshow\", function (e) { e.persisted && (clearTimeout(i), i = setTimeout(n, 300)) }, !1), \"complete\" === d.readyState ? d.body.style.fontSize = \"16px\" : d.addEventListener( \"DOMContentLoaded\", function (e) { d.body.style.fontSize = \"16px\" }, !1) }(750, 750); jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/Axios.html":{"url":"JavaScript-library/Vue/Axios.html","title":"✘ Axios","keywords":"","body":"Axios Create by jsliang on 2018-11-8 13:41:10Recently revised in 2018-12-25 21:47:43  饮水思源：Axios 中文文档  Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 一 目录 目录 一 目录 二 正文  2.1 get  2.1 post 二 正文 返回目录  axios 实战经验 2.1 get 返回目录  方法：axios.get(url, options)  话不多说，先上代码： Vue学习 new Vue({ el: document.getElementById('app'), template: ` 发送请求 数据为： {{ getData }} `, data() { return { getData: '' } }, methods: { sendAjax() { // 直接使用 axios // get 为请求方式 axios.get('https://www.easy-mock.com/mock/5be3885e033152564881d354/getInfo') // then 为 promise 获取数据 .then((res) => { this.getData = res.data; }) // catch 为 promise 捕获异常 .catch(); } } })  如上，我们使用 axios 非常简单，只需要引用它的 cdn，然后通过： axios.get() .then() .catch()  就可以直接调用 axios 获取数据。 2.2 post 返回目录  post 请求讲解 三 杂记 3.1 跨域代理  http-proxy-middleware | 代理了解推荐文章 设置 index.js： dev: { proxyTable: { '/stat': { target: 'http://172.**.**.**:8080/', // 接口的域名 changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 } }, }, 设置 main.js 全局拦截器： // 设置 axios import axios from 'axios'; // 添加请求拦截器 axios.interceptors.request.use( (config) => { config.headers.common['timestamp'] = \"******\"; config.headers.common['deviceid'] = \"******\"; config.headers.common['signature'] = \"******\"; // 在发送请求之前做些什么 return config; }, (error) => { // 在请求错误时做些什么 return Promise.reject(error); }) 调用 PartOne.vue： axios({ url: \"stat/getApersonnelDistribution\", method: \"get\", params: { rank: 4 }, }).then( (res) => { console.log(res); }) 3.2 单个页面多 API 调用 全代码为： create() { this._getApi(); }, methods: { _getApi() { axios(xxx).then( res=> { console.log(res); this._drawxxx(res); }) }, _drawxxx(res) { } } 理解：  首先，在 create() 中调用方法体。 然后，在 methods() 中编写方法体，方法体调用 axios。 最后，在方法体中通过 axios 获取到数据之后，将数据传入到方法中进行处理。 缘故：这样分布处理，有利于代码逻辑优化，当某步出现错误的时候，方便调试。同时使用 _ 开头命名方法，防止与其他 api 冲突。 3.3 Axios 封装 封装 api 到 src/api/api.js 中 api.js /** * 封装逻辑 * 1. 引入 axios。 * 2. 设置请求配置 request。如：请求超时，响应头等 * 3. 设置请求中的遮罩（未实现） * 4. 设置请求成功后的数据过滤（未实现） * 5. 设置并暴露接口，传 data、method、url 到请求配置 request 上。 */ // 设置 axios import axios from 'axios'; // 请求配置 const request = axios.create({ // 本地开发 dev 的时候，不需要开启这个 // baseURL: 'http://172.****.****.5:8080', timeout: 5000, headers: { timestamp: \"20181026094424\", deviceid: \"10102\", signature: \"F9CB03DD3ED50EDA5DB214C42D4DC0D6\", } }) /** * 获取用户名 * userId */ export const getUserName = data => request({ method: 'get', url: '/api/getUserName', params: data }) 在 Pages 中调用： UserInfo.vue // 引用接口 import { getUserName } from \"@/api/api\" export default { methods: { _getUserName() { // 获取用户名 getUserName({ userId: this.userId, }).then( (res) => { console.log(\"\\n【API - 获取用户名】：\"); }) } } } jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/VueCli2.html":{"url":"JavaScript-library/Vue/VueCli2.html","title":"✘ VueCli2","keywords":"","body":"VueCli Create by jsliang on 2018-11-8 21:12:34Recently revised in 2018-12-26 08:17:06  VueCli 的学习  关于 Vue 系列学习。 学习 VueBase.md 学习 VueRouter.md 学习 Axios.md 学习 VueCli.md 学习 VueDeploymentOptimization.md 学习 VuePrepare.md jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/VueCli3.html":{"url":"JavaScript-library/Vue/VueCli3.html","title":"✘ VueCli3","keywords":"","body":"VueCli3 Create by jsliang on 2018-12-29 22:14:56Recently revised in 2018-12-29 22:15:00  VueCli3 的学习 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/VueRouter.html":{"url":"JavaScript-library/Vue/VueRouter.html","title":"✘ Vue Router","keywords":"","body":"Vue Router Create by jsliang on 2018-11-8 13:39:39Recently revised in 2019-1-23 08:26:17  饮水思源：Vue Router 官方文档  Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有： 嵌套的路由/视图表 模块化的、基于组件的路由配置 路由参数、查询、通配符 基于 Vue.js 过渡系统的视图过渡效果 细粒度的导航控制 带有自动激活的 CSS class 的链接 HTML5 历史模式或 hash 模式，在 IE9 中自动降级 自定义的滚动条行为 一 目录 目录 一 目录 二 正文  2.1 初识 Vue Router  2.2 路由初定义  2.3 router-view 与 router-link  2.4 路由 name 的使用  2.5 路由传参  2.6 嵌套路由  2.7 路由守卫 2.1 初识 Vue Router 返回目录  在介绍路由的时候，我们先理清下传统开发方式的路由和 SPA 页面的路由： 传统开发方式中，url 改变后，立刻发起请求，响应整个页面，渲染整个页面。 SPA 锚点值改变后，不会发起立即发起请求。发起 ajax 请求，SPA 应用会局部改变页面数据。 2.2 路由初定义 返回目录  话不多说，先上代码： index.html Vue学习 // 2. 使用插件 Vue.use(VueRouter); // 3. 定义路由对象 var Login = { template: ` 登录页面 ` } // 4. 创建路由挂载对象 var router = new VueRouter({ // 5. 配置路由对象 routes: [ { path: '/login', component: Login } ] }); // 6. 指定路由改变局部的位置 var App = { template: ` ` } // 7. 将路由对象关联到 Vue 实例中 new Vue({ el: document.getElementById('app'), // 注意这里比平时多了个 router，标明我们要开启路由模式 router: router, components: { app: App }, template: `` })  在上面代码中，我们先编写第 1 步，引用 vue-router 这个插件。 然后，我们通过第 2 步 Vue.use(VueRouter) 来使用这个插件。 接着，我们通过第 3 步来定义路由对象，即我们的子组件页面。 再来，我们通过第 4 步创建路由挂载对象后，在第 5 步配置路由对象。 紧接着，我们通过第 6 步的 来挂载我们的路由子组件。 最后，我们通过第 7 步的操作，在 new Vue 中使用 router，从而做到 SPA 页面路由的使用。  那么，他们是怎么显示的呢？ 我们在展示的页面后面敲上 /login，页面就会加载 Login 子组件。例如 jsliang 的就是 http://127.0.0.1:8080/#/login。 此刻页面显示为： 2.3 router-view 与 router-link 返回目录  话不多说，先看代码： index.html Vue学习 // 2. 使用插件 Vue.use(VueRouter); // 3. 定义路由对象 var Login = { template: ` 登录页面 ` } var Register = { template: ` 注册页面 ` } // 4. 创建路由挂载对象 var router = new VueRouter({ // 5. 配置路由对象 routes: [ { path: '/login', component: Login }, { path: '/register', component: Register } ] }); // 6. 指定路由改变局部的位置 var App = { template: ` 登录 注册 ` } // 7. 将路由对象关联到 Vue 实例中 new Vue({ el: document.getElementById('app'), // 注意这里比平时多了个 router，标明我们要开启路由模式 router: router, components: { app: App }, template: `` })  在上一章节理解了路由的使用之后，现在我们要做的很简单，就是在第 3 步中定义 Register 组件，并在第 5 步中挂载该组件，最后通过第 6 步的 ，从而达到 中展示对应路由组件的目的。  下面我们查看下该代码是否能正确运行： 2.4 路由 name 的使用 返回目录  在章节 3.13.1 和章节 3.13.2 中，我们都是通过 来切换路由的。 假如某天需求改了，产品经理或者项目经理说页面上不能用 localhost:8080/#/login，那样子太 low（真的 low 吗？不见得，但是它们要求就是这样，能咋办啊~ o(╥﹏╥)o），而是用 localhost:8080/#/mylogin，所以我们需要修改页面两次（ 和 path）…… 又到了哪天，它丢你个文档说，我们路由定好了，照着文档写。然后你一看，我天，页面上显示的路径都和你做的不一样……所以有没有更好的方法解决这个问题呢？ 有的，那就是给 routes 起 name 值： index.html Vue学习 // 2. 使用插件 Vue.use(VueRouter); // 3. 定义路由对象 var Login = { template: ` 登录页面 ` } var Register = { template: ` 注册页面 ` } // 4. 创建路由挂载对象 var router = new VueRouter({ // 5. 配置路由对象 routes: [ { name: 'login', path: '/myLogin', component: Login }, { name: 'register', path: '/myRegister', component: Register } ] }); // 6. 指定路由改变局部的位置 var App = { template: ` 登录 注册 ` } // 7. 将路由对象关联到 Vue 实例中 new Vue({ el: document.getElementById('app'), // 注意这里比平时多了个 router，标明我们要开启路由模式 router: router, components: { app: App }, template: `` })  首先，在代码方面，我们通过沿用章节 3.13.2 中的代码来演示 name 的使用。 然后，在第 5 步中，我们分别给两个路由对象起了名字。 最后，我们在第 6 步中，通过 :to 来动态绑定了路由值为 name: '***，从而达到了我们的目的。  这样，当我们上头想修改网址路径的时候，我们只需要到第 5 步的代码中修改即可。 2.5 路由传参 返回目录  在平时开发中，我们经常给我们的 url 传参，那么在 Vue 开发中，Vue 是如何在路径中带参数，并且在对应路由中获取到参数的呢？ 先上代码，先睹为快： index.html Vue学习 // 2. 使用插件 Vue.use(VueRouter); // 3. 定义路由对象 var Login = { template: ` 登录页面 `, // 输出路径 created: function() { console.log(this.$route); console.log(this.$route.query); } } var Register = { template: ` 注册页面 `, // 输出路径 created: function() { console.log(this.$route); console.log(this.$route.params); } } // 4. 创建路由挂载对象 var router = new VueRouter({ // 5. 配置路由对象 routes: [ { name: 'login', path: '/myLogin', component: Login }, { name: 'register', path: '/myRegister/:name', component: Register } ] }); // 6. 指定路由改变局部的位置 var App = { template: ` 登录 注册 ` } // 7. 将路由对象关联到 Vue 实例中 new Vue({ el: document.getElementById('app'), // 注意这里比平时多了个 router，标明我们要开启路由模式 router: router, components: { app: App }, template: `` })  下面我们先查看其结果：  在这里，我们有两种传参方式： query 传参：  首先，在第 6 步的 :to 中，我们通过 登录，设置传参的值为 id=1。 接着，在第 3 步的 Login 组件中定义 created，打印出它的对象及其参数： {name: \"login\", meta: {…}, path: \"/myLogin\", hash: \"\", query: {…}, …} {id: 1}  最后，在页面中路径显示为显示为：http://127.0.0.1:8080/#/myLogin?id=1 params 传参：  首先，在第 6 步的 :to 中，我们通过 注册，设置传参的值为 name=jsliang。 接着，在第 5 步中，给它的 path 预留个 name 的插槽：path: '/myRegister/:name' 然后，在第 3 步的 Login 组件中定义 created，打印出它的对象及其参数： {name: \"register\", meta: {…}, path: \"/myRegister/jsliang\", hash: \"\", query: {…}, …} {name: \"jsliang\"}  最后，在页面中路径显示为：http://127.0.0.1:8080/#/myRegister/jsliang  当然，小伙伴可能会考虑到传多个参数： query 传多个参数代码片段：http://127.0.0.1:8080/#/myLogin?id=1&name=jsliang 登录 params 传多个参数代码片段：http://127.0.0.1:8080/#/myRegister/2/梁峻荣 path: '/myRegister/:id/:name' 注册 2.6 嵌套路由 返回目录  在章节 3.10 传递 DOM - slot 中，我们提到了 slot 及具名 slot 的区分。然后，在 Vue 日常开发中，如果我们的路由只能一个 放整版页面，这是满足不了我们需求的。 所以，你考虑到的，大佬们也考虑到了：嵌套路由！通过不同锚点值，填入不同的组件。 index.html Vue学习 // 2. 使用插件 Vue.use(VueRouter); // 3. 定义路由对象 var Login = { // 8. 插槽。路由对象下中还有 template: ` 登录页面 我是屌丝 我是土豪 ` } // 9. 二级路由子组件 var poorManLogin = { template: ` 屌丝登录页面 ` } var richManLogin = { template: ` 土豪登录页面 ` } var Register = { template: ` 注册页面 ` } // 4. 创建路由挂载对象 var router = new VueRouter({ // 5. 配置路由对象 routes: [ { name: 'login', path: '/myLogin', component: Login, // 10. 定义路由下的子路由 children: [ { name: 'poorManLogin', path: 'loginWayOne', component: poorManLogin }, { name: 'richManLogin', path: 'loginWayTwo', component: richManLogin } ] }, { name: 'register', path: '/myRegister', component: Register } ] }); // 6. 指定路由改变局部的位置 var App = { template: ` 登录 注册 ` } // 7. 将路由对象关联到 Vue 实例中 new Vue({ el: document.getElementById('app'), // 注意这里比平时多了个 router，标明我们要开启路由模式 router: router, components: { app: App }, template: `` })  先看看代码的实现效果：  首先，我们使用章节 3.13.3 路由 name 的使用 的代码，在其基础上开发，没有搞懂该章节代码的小伙伴可以先看该章节代码讲解。 然后，我们在第 8 步中，给路由对象再嵌套子路由： // 8. 插槽。路由对象下中还有 template: ` 登录页面 我是屌丝 我是土豪 `  接着，我们在第 9 步中定义这两个路由子组件。 最后，我们在第 10 步中，通过 children 数组，将这两个子组件配置到路由对象上，我们就可以在 的组件中，再定义一层 ，并使用它，从而做到嵌套路由的开发。  看到这里，小伙伴们是不是也想到了，可以用嵌套路由来满足用单页应用来开发多页应用的目的~ 3.7 路由守卫 返回目录  话不多说，先上代码： index.html Vue学习 // 2. 使用插件 Vue.use(VueRouter); // 3. 定义路由对象 var Login = { // 简单的登录页面 template: ` 登录页面 用户名： 登录 `, data() { return { userName: '' } }, methods: { // 点击登录按钮，将输入框的内容记录为 userName，并存到 localStorage login: function(e) { localStorage.setItem(\"userName\", this.userName); console.log(\"存储了用户名：\" + this.userName); } } } var User = { template: ` 用户页面 ` } // 4. 创建路由挂载对象 var router = new VueRouter(); // 5. 动态配置路由对象，设置路由规则 router.addRoutes([ { path: '/', redirect: { name: 'login' } }, { name: 'login', path: '/login', component: Login }, { name: 'user', path: '/user', component: User, // 权限控制，给用户界面定义全局路由守卫 meta: { isChecked: true } } ]) // 6. 定义路由守卫 router.beforeEach(function(to, from, next) { // 如果是前往登录页或者首页，则直接前往 if(to.name === \"login\" || to.path === '/') { // 执行下一步，不定义就会卡住 next(); } else { // 如果是前往用户页，则需要进行判断 localStorage 是否有值 if(!localStorage.getItem(\"userName\")) { alert('请登录~'); next({ name: 'login' }) } else { // 执行下一步，不定义就会卡住 next(); } } }) // 7. 指定路由改变局部的位置 var App = { template: ` 登录 我的 ` } // 8. 将路由对象关联到 Vue 实例中 new Vue({ el: document.getElementById('app'), // 注意这里比平时多了个 router，标明我们要开启路由模式 router: router, components: { app: App }, template: `` })  看下代码成果：  首先，我们做下知识点讲解： 路由元数据 meta meta 是对于路由规则是否需要验证权限的配置。 在路由对象中和 name 属性同级的代码上添加 { meta: { isChecked: true }} 即可做标记。 路由钩子 路由钩子发生在权限控制的函数执行时期。在每次路由匹配后，渲染组件到 router-view 之前触发。 router.beforeEach(function(to, from, next){ }) next() 有三种状态：1.next() 为放行，即路由可以正常跳转；2.next(false) 为取消用户导航的行为，即不放行；3.next({name:'***'}) 为重定向到某个页面。  然后，在 index.html 中，我们在第 3 步中，做了个简单登录页面，将用户输入的信息 userName，存储到了 localStorage。 接着，在第 5 步中，我们对 user 路由，做了 meta 判断，进行权限控制。 最后，我们在第 6 步中，定义了路由守卫，先判断是哪个页面登录，如果是登录页或者首页，则直接前往；如果是用户页，则进行 localStorage 判断，如果用户输入了并保存了 userName，则跳往用户页，否则不给跳转。  如此，我们做到了路由守卫。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/Vuex.html":{"url":"JavaScript-library/Vue/Vuex.html","title":"✘ Vuex","keywords":"","body":"Vuex Create by jsliang on 2018-12-29 18:58:58Recently revised in 2018-12-29 18:59:02  Vuex 的学习 安装 Vuex：cnpm i vuex -S src/main.js // 1. 引入 Vuex import Vuex from 'vuex'; // 2. 安装插件 Vue.use(Vuex); // 3. 创建 store let store = new Vuex.Store({ // 4. 配置 store 中的数据/存/取 state: { number: 30 }, // 取数据 getters: { getNum(state) { return state.num; } }, // 操作数据 mutations: { addNum(state, payload) { // 调用者传递增加的数量 state.num += payload.num; } }, // 行为，在行为中，可以存在异步操作，但是最终还是通知 mutations actions: { addNumByServerRate(store, payload) { setTimeout(function() { let rate = 1; state.commit('addNum', {num: payload.num * rate}); }, 1000) } } }) new Vue({ el: '#app', // 5. 将 store 对象关联到 Vue 实例 store, compontents: { App }, template: '' }) App.vue export default { methods: { change() { // 也可以改值，但不是官方推荐，会被寄刀片的 // this.$store.state.xxx // 一般写代码都不直接提交，除非明知是同步操作，没有后台请求 this.$store.commit('addNum', {num:5}); // 完美的套路 this.$store.dispatch('addNumByServerRate', { num: 10 }); } }, computed: { appShowNum() { return this.$store.getters.getNum; } } } 提取出来，提高解耦性 新建 src/modules/numModule.js modules/numModule.js // 上面内容 main.js import numModule from '@/modules/numModule'; jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/VueSSR.html":{"url":"JavaScript-library/Vue/VueSSR.html","title":"✘ Vue SSR 服务端渲染","keywords":"","body":"Vue SSR 服务端渲染 Create by jsliang on 2018-12-29 20:04:33Recently revised in 2018-12-29 20:04:37 Vue.js 服务器端渲染指南 用 Vue 构建多页面应用 vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 为什么会有 SPA localhost:8080/#/xxx 不会因为用户的字段输入而刷新 可以通过 location.hash 控制路由 history 模式 去除了 # 的方式，每次都向服务器请求 index.html，再由客户端分析当前 url，做不同的变化 实现原理 在页面中通过 location.pathname 获取当前请求 url 让服务器不论什么请求都返回以上这个 index.html SPA 是什么 Vue-Router 中是否可以不使用 # 来开发 -> history 模式，默认是 hash 模式 在 history 模式中，可以使用 scroll 导航后滚动（history 模式实现其实基于服务器每次返回 index.html，而客户端根据 location.pathname 来做渲染） SEO 是什么 - 搜索引擎优化 SPA 下 SEO 必然比较差 使用预渲染，固定的页面，作为服务器响应的结果回来 - history 模式 Vue SPA 实现 SEO 优化 vue项目做seo（prerender-spa-plugin预渲染） 下载 npm i prerender-spa-plugin -D 配置 webpack.prod.js 文件 webpack.prod.js const PrerenderSpaPlugin = require('prerender-spa-plugin'); plugins: [ new PrerenderSpaPlugin({ staticDir: path.join(__dirname, '..', 'dist'), // Required - Routes to render. routes: [ '/', '/user' ] // 根据这两个路由规则找到组件渲染 HTML 文件 }) ] 配置路由变更对象，传递构造属性 mode: history 构建项目代码：npm run build 进入 dist 目录，启动生成的代码 node index.js 效果 骨架屏 Skeleton Screen - 骨架屏。骨架屏就是在页面数据尚未加载前先给用户展示出页面的大致结构，直到请求数据返回后再渲染页面，补充进需要显示的数据内容。常用于文章列表、动态列表页。 相当于 loading 图标而言，用户可以预览未来要看的结构，同时避免白屏的尴尬，还能操作。因此用户体验较好。 Vue 页面骨架屏注入实践 LAVAS - 基于 Vue.js 的 PWA 解决方案 结合 Service Worker 做了用户体验优化，实现了离线浏览。 npm i lavas -g lavas init 选择包含 app_shell，也包含了骨架屏的功能 骨架屏的实现原理，就是在 Vue 真正渲染之前，先加载了默认的一套代码 预加载样式 先加载预加载样式的 js 文件 然后加载 Vue 文件，渲染页面 所以，在我们请求加载数据，完成渲染之前，我们可以先使用骨架屏，然后等数据渲染完成之后，我们将骨架屏关掉。 自己配置骨架屏：Vue 页面骨架屏注入步骤详解 什么是 PWA PWA （渐进式 Web Application） 慢慢收服你。 离线浏览 Web 应用，生成桌面应用，顶部通知（页面都可以不存在），预缓存（在页面没启动之前，请求资源保存到浏览器。从而在访问的时候，大幅提升速度），骨架屏，App shell（利用缓存机制保存 css + html + js 等等），分享，全屏图标。 这些东西，是产品经理设计的，因为这项 PWA 技术，经 Chrome 推出，但是一直没有火起来（手机端 55 以上支持这些所有技术）、IOS Safari 考虑支持。（支持率比较差） 英文 caniuse，中文 lavas 官网 history 源码 index.html HelloWorld 显示区域 去看 user 页面 去看 goods 页面 function goHistory(url) { let text = ''; // 判断用户点击的是哪个按钮 switch(url) { case '/user': test = '用户页面'; alert('/user'); break; case '/goods': text = '商品页面'; alert('/goods'); break; } history.pushState( {}, '', url); // 改变页面效果 document.getElementById(\"app\").innerText = text; } // 当页面加载的时候 window.onload = function() { let text2 = ''; // 获取当前 path 路径 var path = location.pathname; switch(path) { case '/user': test = '用户页面'; alert('/user'); break; case '/goods': text = '商品页面'; alert('/goods'); break; } // 改变页面效果 document.getElementById(\"app\").innerText = text2; } index.js const http = require('http'); const fs = require('fs'); http.createServer( (req, res) => { fs.readFile('./index.html', (err, data) => { res.end(data); }) }).listen(8888); 启动 node index.js，这样，我们就可以监听到我们的页面了。 多页应用 核心思想：就是两个 Vue 项目，一次 Webpack 打包，关联用 url 联系 Webpack 操作 多个入口： {main1: './usermain.js', main2:'./goodsmain.js'} 多个 html 插件 注意事项： // 文件名称 filename: filename + '.html', // 页面模板需要加对应的 js 脚本，如果不加这行，则每个页面都会引入所有的 js 脚本 chunks: ['mainfest', 'vendor', filename], inject: true 使用 CachesAPI 获取指定缓存的内容 caches.open('key').then(function(cachedRequests) { ... }) jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/VueUploadFile.html":{"url":"JavaScript-library/Vue/VueUploadFile.html","title":"✔ Vue 上传文件","keywords":"","body":"Vue 上传文件 Create by jsliang on 2019-3-21 16:57:58Recently revised in 2019-3-21 16:58:02 步骤 1. 设置 Node 跨域代理 修改 项目/config/index.js 下的 dev 设置： 原 build/index.js 配置： dev: { // Paths assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: {}, } 修改后 build/index.js 配置： dev: { // Paths assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: { '/services': { // 碰到 /services 类型的接口，使用 node 代理 target: 'http://172.**.**.49:8080', // 需要将开发模式的 localhost:8080 代理到哪个接口 changeOrigin: true, // 如果接口跨域，需要设置这个参数为 true } }, }, 这时，我们在 npm run dev 下，就可以将 localhost:8080 调用 http://172.**.**.49:8080 的接口由 Node 代理转发，从而实现接口的跨域请求。 步骤 2. 实现原生上传图片 步骤 1 为前置条件 如何实现 上传图片： Album.vue // 如果使用方法 1 // import { uploadFile } from '../../api/api' // 如果使用方法 2 import axios from 'axios' export default { methods: { // 普通上传图片 uploads(e) { // 方法 1 - 可行 // const file = e.target.files[0]; // console.log(file); // const fd = new FormData(); // fd.append('userBlicence', file); // uploadFile(fd).then( res => { // console.log(res); // }).catch( error => { // console.log(error); // }) // 方法 2 - 可行 const file = e.target.files[0]; console.log(file); const fd = new FormData(); fd.append('userBlicence', file); axios({ method: 'post', timeout: 5000, headers: { 'Content-Type':'multipart/form-data', timestamp: \"2019032009000\", deviceid: \"10001\", signature: \"2743cfbda4601a359400929393b7657a\", }, url: '/services/Auser-uploadImg.action', data: fd, }).then( res => { console.log(res); }).catch( error => { console.log(error); }) }, } } 如果我们不用封装接口，那么我们直接使用方法 2 即可。 但是，一般情况下，我们会抽取接口到 api.js，进行接口的统一管理： api.js // 设置 axios import axios from 'axios'; // 请求配置 const request = axios.create({ // 开发模式下不需要开启，打包模式下去掉该注释 // baseURL: 'http://172.**.**.49:8080', timeout: 5000, headers: { timestamp: \"2019032009000\", deviceid: \"10001\", signature: \"2743cfbda4601a359400929393b7657a\", } }) /** * 上传图片 * userBlicence - 图片 */ export const uploadFile = data => request({ method: 'post', headers: { 'Content-Type':'multipart/form-data', }, url: '/services/Auser-uploadImg.action', data: data, }) 这样，当我们使用方法 1 的时候，我们直接调用接口即可。 步骤 3. 实现 ElementUI 上传图片 步骤 1 为前置条件 相对于原生上传图片来说，ElementUI 上传图片更为便捷： 点击上传 export default { data() { return { headers: { timestamp: \"2019032009000\", deviceid: \"10001\", signature: \"2743cfbda4601a359400929393b7657a\", } } }, methods: { // ElementUI 上传图片成功 uploadSuccess(res, file) { console.log(res); console.log(file); }, } } 如此，就可以实现图片上传的功能。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/VueDeploymentOptimization.html":{"url":"JavaScript-library/Vue/VueDeploymentOptimization.html","title":"✔ Vue 部署优化","keywords":"","body":"Vue 部署优化 Create by jsliang on 2018-12-7 14:53:566Recently revised in 2019-3-6 10:57:46  在进行 Vue 项目部署时，发现它访问速度贼慢，于是做了下优化，下面是优化建议： 一 进行路由懒加载  路由懒加载 - VueRouter 官网  大致意思就是，将 import PartOne from '@/components/PartOne'  换成 const PartOne = () => import('@/components/PartOne');  这样，就可以访问快点了。 index.js import Vue from 'vue' import Router from 'vue-router' Vue.use(Router) // 路由懒加载 const PartOne = () => import('@/components/PartOne'); export default new Router({ routes: [ { path: '/', components: { PartOne: PartOne, } }, { path: '/PartOne', name: 'PartOne', component: PartOne }, ] }) 二 开启 Gzip Nginx 配置 Gzip PS：Nginx 需要在 conf/nginx.conf 文件中的 http 中设置。 #user nobody; # 跟CPU有关，不用修改 worker_processes 1; events { # nginx最大负载量 worker_connections 1024; } http { # mime type映射 include mime.types; default_type application/octet-stream; # 启动高效传输文件的模式 sendfile on; # 长连接timeout keepalive_timeout 65; # 开启 gzip gzip on; gzip_types text/plain application/x-javascript application/javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; # http结构下可以有多个server。请求进来后，确定哪一个server由server_name决定 server { # 监听端口 listen 80 default_server; # 识别的域名 server_name localhost default_server; # 一个关键配置，与URL参数乱码问题有关 #charset utf-8; root html; location / { index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } include ../vhost/*.conf; } Vue 开启 Gzip  首先，安装 compression-webpack-plugin： npm i compression-webpack-plugin -D  然后，修改配置代码： config/index.js // ... 代码省略 productionGzip: true, productionGzipExtensions: ['js', 'css'],  最后，打包的文件中会有 .gz 后缀的文件，表示开启成功了。 三 屏蔽 sourceMap  修改配置代码： config/index.js // ... 代码省略 productionSourceMap: false,  这个 productionSourceMap 有什么作用呢？其实就是项目打包后，我们的代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确知道是哪里的代码出错了，而开启了 productionSourceMap，就会自动生成一些 map 文件，准确地告诉我们哪一行那一列出错。 关闭了 productionSourceMap 后，一方面可以减少上线代码包的大小，另一方面提高系统的安全性。 四 开启 uglifyjs-webpack-plugin 的 cache build/webpack.prod.conf.js new UglifyJsPlugin({ cache: true, uglifyOptions: { compress: { warnings: false } }, sourceMap: config.build.productionSourceMap, parallel: true }), 开启后打包第二次的时间是第一次的一半。 五 优化图片  平时我们切图、下载图的 png、jpg 图片，都异常的大，所以我们需要对图片进行压缩： TinyPNG | 图片压缩  上面的网站就能很不错地压缩图片，从而减少图片的体积。 六 参考文献： vuejs项目性能优化总结 | 简书 - Evtion jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/VueSourceCode.html":{"url":"JavaScript-library/Vue/VueSourceCode.html","title":"✘ Vue 源码剖析","keywords":"","body":"Vue 源码剖析 Create by jsliang on 2018-12-29 23:21:20Recently revised in 2018-12-31 19:29:31 什么是 Flow Flow 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查，所以了解 Flow 有助于我们阅读源码。 为什么使用 Flow JavaScript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用是很容易就写出非常隐蔽的隐患代码，在编译期甚至看上去都不会报错，但在运行阶段就可能出现各种奇怪的 bug。 项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。Vue.js 在做 2.0 重构的时候，在 ES2015 的基础上，除了 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。之所以选择 Flow，主要是因为 Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力。 Flow 工作方式 类型推断：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型。 类型注释：事先注释好我们期待的类型，Flow 会基于这些注释来判断。 Flow 在 Vue.js 源码中的应用 有时候我们想引用第三方库，或者自定义一些类型，但 Flow 并不认识，因此检查的时候会报错。为了解决这类问题，Flow 提出了一个 libdef 的概念，可以用来识别这些第三方库或者是自定义类型，而 Vue.js 也利用了这一特性。 在 Vue.js 的主目录下有 .flowconfig 文件， 它是 Flow 的配置文件，感兴趣的同学可以看官方文档。这其中的 [libs] 部分用来描述包含指定库定义的目录，默认是名为 flow-typed 的目录。 这里 [libs] 配置的是 flow，表示指定的库定义都在 flow 文件夹内。我们打开这个目录，会发现文件如下： flow ├── compiler.js # 编译相关 ├── component.js # 组件数据结构 ├── global-api.js # Global API 结构 ├── modules.js # 第三方库定义 ├── options.js # 选项相关 ├── ssr.js # 服务端渲染相关 ├── vnode.js # 虚拟 node 相关 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/VueDemoOne.html":{"url":"JavaScript-library/Vue/VueDemoOne.html","title":"✔ Vue Demo - 功成千骨","keywords":"","body":"Vue Demo - 功成千骨 Create by jsliang on 2019-1-2 08:46:46Recently revised in 2019-1-12 20:00:02 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习折腾的动力！GitHub 地址 抛开 Vue-Cli，使用最简单原始的方式开发一个 TodoList 并不断完善，完成正在进行、完成列表、回收站这三个功能模块，并实现下面这些功能： 新增任务 改变状态 修改任务 删除任务 成品展示： 代码地址：功成千骨 - 代码地址 项目地址：功成千骨 - 线上地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 项目解析 四 骨架 - HTML 五 功能 - JS  5.1 页面数据化  5.2 数据简化  5.3 添加数据  5.4 改变状态  5.5 修改内容  5.6 数据回收  5.7 彻底删除 六 皮肤 - CSS  6.1 重置样式  6.2 偷天换日 七 总结 二 前言 返回目录 经过系列的折腾，并且参照不同大佬的“新人作”，将五花八门的 TodoList 各种写法综合起来，从 0 到 1 不依赖 Vue-Cli 打造一个属于自己的 TodoList，后期将加以 Node 的框架 Koa 连接 MySQL 提供接口，从而实现面向大众的 TodoList！ 欲练此功，必先自宫，额(⊙o⊙)…不对，必先学习 Vue 系列之 Vue 基础。 三 项目解析 返回目录 在我们平时的工作中，我们应该在拿到 PSD 设计稿或者原型设计的时候，我们应该对我们的功能进行划分，对 HTML、CSS、JS 进行划分，以便于后期的维护制作，下面我们先看一下我们的 UI： 额(⊙o⊙)… 好吧-_-|| 惨不忍睹，我们还是按照这形式，将 HTML 搭建出来，并用 JS 实现功能先吧，后期再填充 CSS 了。 下面是目录结构： 四 骨架 - HTML 返回目录 现在，我们先完成 index.html 架构。 然后 index.css 和 index.js 这两个文件，可以是空的，因为我们先架好骨架，再进行 JS 的事件以及 CSS 的渲染。 index.html 功成千骨 .content-list { display: flex; } 功成千骨 进击 千军万马取敌首 （待完成） 敌军 1 × 敌军 2 >× 敌军 3 × 敌羞吾去脱他衣 （已完成） 亡军 1 × 亡军 2 × 亡军 3 × 溃不成军鸟兽散 （回收站） 返回 逃军 1 × 返回 逃军 2 × 返回 逃军 3 × 不折腾的前端 和咸鱼有什么区别 @2019 jsliang 文档库 此时页面内容如下所示： 五 功能 - JS 返回目录 搭建好网页的骨架，我们先让它跑起来吧。 你可以上面的 HTML 步骤想象成造了一个骷髅人，然后现在你要施法，要让骷髅人跑起来了。 奔跑吧，骷髅人~ 5.1 页面数据化 返回目录 现在，我们进行页面的数据化，我们需要考虑有哪几块是需要变成数据的：输入的内容、todo 项、完成项、未完成项。 那么，我们先进行简单抽取： index.html 代码片段 进击 千军万马取敌首 （待完成） x 敌羞吾去脱他衣 （已完成） x 溃不成军鸟兽散 （回收站） 返回 x 在这里，我们将页面数据化了，现在看下我们的 index.js 内容： index.js var app = new Vue({ el: \"#app\", data: { id: 1, todo: \"\", todoInfos: [ { id: 7, isChecked: false, todoTitle: \"敌军 1\", }, { id: 8, isChecked: false, todoTitle: \"敌军 2\", }, { id: 9, isChecked: false, todoTitle: \"敌军 3\", }, ], finishInfos: [ { id: 1, isChecked: true, todoTitle: \"亡军 1\", }, { id: 2, isChecked: true, todoTitle: \"亡军 2\", }, { id: 3, isChecked: true, todoTitle: \"亡军 3\", }, ], recycleInfos: [ { id: 4, isChecked: false, todoTitle: \"逃军 1\", }, { id: 5, isChecked: false, todoTitle: \"逃军 2\", }, { id: 6, isChecked: false, todoTitle: \"逃军 3\", }, ] } }) 这样，我们就通过 v-for 完成了数据的渲染，同时页面和之前的一样： 5.2 数据简化 返回目录 在这里，我们稍微暂停下，观察 todoInfos、finishInfos、recycleInfos 这三个数组，发现它们都是差不多的结构。那么，我们干脆将它合并？ index.js var app = new Vue({ el: \"#app\", data: { id: 1, todo: \"\", todoInfos: [ { id: 7, // id 唯一且自增 isChecked: false, // 未完成和放弃为 false，完成为 true isEdit: false, // 是否在编辑 todoTitle: \"敌军 1\", state: 0, // 0 - 未完成，1 - 完成，2 - 放弃完成 }, { id: 8, // id 唯一且自增 isChecked: false, // 未完成和放弃为 false，完成为 true isEdit: false, // 是否在编辑 todoTitle: \"敌军 2\", // todo 标题 state: 1, // 0 - 未完成，1 - 完成，2 - 放弃完成 }, { id: 9, // id 唯一且自增 isChecked: false, // 未完成和放弃为 false，完成为 true isEdit: false, // 是否在编辑 todoTitle: \"敌军 3\", // todo 标题 state: 2, // 0 - 未完成，1 - 完成，2 - 放弃完成 }, ] } }) 这样一来，我们就可以修改 HTML，让它通过 state 来区分这三块的数据： index.html 代码片段 进击 千军万马取敌首 （待完成） x 敌羞吾去脱他衣 （已完成） x 溃不成军鸟兽散 （回收站） 返回 x 此时，我们的页面还是如修改之前一般，但是已经实现了数据化。 下面我们开始写增删改数据的功能方法。 5.3 添加数据 返回目录 首先，我们往 HTML 中添加点击事件，当然，如果每次都要点击按钮，就太麻烦了，干脆我们再加个键盘回车事件： index.html 代码片段 进击 然后，我们往 JS 中添加点击方法： index.js var app = new Vue({ el: \"#app\", data: { id: 1, todo: \"\", todoInfos: [ // 已不需要，注释掉 // { // id: 7, // id 唯一且自增 // isChecked: false, // 未完成和放弃为 false，完成为 true // isEdit: false, // 是否在编辑 // todoTitle: \"敌军 1\", // state: 0, // 0 - 未完成，1 - 完成，2 - 放弃完成 // }, ] }, methods: { addTodoItem() { // 每次点击，往数组中添加一组数据 this.todoInfos.push({ id: this.id, // id 唯一且自增 isChecked: false, // 未完成和放弃为 false，完成为 true isEdit: false, // 是否在编辑 todoTitle: this.todo, // todo 标题 state: 0, // 0 - 未完成，1 - 完成，2 - 放弃完成 }) // id 自增 this.id++; // 清空输入框 this.todo = \"\"; }, } }) 最后，我们查看下新增功能是否实现： 5.4 改变状态 返回目录 下面我们进行 isChecked 与 state 的改变，从而让数据在这三种状态中变化： 栏目 状态 未完成 isChecked: false、state: 0 已完成 isChecked: true、state: 1 回收站 state: 2 在本章节，我们实现 未完成 -> 已完成 的转变，这里只需要修改下 HTML 代码即可： index.html 代码片段 千军万马取敌首 （待完成） x 敌羞吾去脱他衣 （已完成） x 我们可以查看下结果： OK，成功完成 待完成 -> 已完成 的转变。 5.5 修改内容 返回目录 现在，我们实现点击 todoTitle，变成修改模式，修改完后点击其他地方，或者按下回车按钮，从而实现数据的修改： index.html 代码片段 千军万马取敌首 （待完成） x 敌羞吾去脱他衣 （已完成） x 溃不成军鸟兽散 （回收站） 返回 x 在这里，我们仅需要在点击 span 标签的时候，改变下 isEdit 的状态，即进入编辑模式，同时，在 input 标签失去焦点或者在输入完成后点击回车按钮，就可以实现数据的修改。 最后，我们查看下实现情况： 5.6 数据回收 返回目录 同理，如果我们要将数据扔进回收站中去，那就需要将 state 改为 2 即可。 如果数据是从回收站返回待完成，我们只需要将 state 改为 0 即可。 index.html 代码片段 千军万马取敌首 （待完成） x 敌羞吾去脱他衣 （已完成） x 实现结果： 5.7 彻底删除 返回目录 首先，我们给 HTML 添加点击事件，将参数传递给方法体中 index.html 代码片段 溃不成军鸟兽散 （回收站） 返回 x 然后，我们通过编写 deleteInfo 来删除 todoInfos 中的数据： index.js 代码片段 methods: { addTodoItem() { // 每次点击，往数组中添加一组数据 this.todoInfos.push({ id: this.id, // id 唯一且自增 isChecked: false, // 未完成和放弃为 false，完成为 true isEdit: false, // 是否在编辑 todoTitle: this.todo, // todo 标题 state: 0, // 0 - 未完成，1 - 完成，2 - 放弃完成 }) // id 自增 this.id++; // 清空输入框 this.todo = \"\"; }, /** * 这里使用了三种写法 * 1. map + splice * 2. splice + findIndex * 3. filter */ // // 1. map + splice 写法 // deleteInfo(recycleItem) { // this.todoInfos.map((item, index) => { // if(item.id == recycleItem.id) { // this.todoInfos.splice(index, 1); // } // }) // }, // // 2. splice + findIndex 写法 // deleteInfo(recycleItem) { // this.todoInfos.splice( this.todoInfos.findIndex( v => v.id === recycleItem.id), 1); // }, // 3. filter 写法 deleteInfo(recycleItem) { this.todoInfos = this.todoInfos.filter( (x) => { return x.id != recycleItem.id; }) } } 兴致突来，想起 茴字的四种写法，于是，这里也奉上删除数据的三种写法，这里就不估算性能损耗了，哪种喜欢就用哪种吧。 此时完成功能如下所示： 到此，我们完成了所有的功能实现~ 六 皮肤 - CSS 返回目录 那么，我们回来我们的大难题，就是给这个页面增加皮肤，让这个页面漂亮点。 6.1 重置样式 返回目录 enm......因为不同浏览器对于一些 DOM 元素的渲染不同，所以我们先重置下浏览器样式吧： reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /** 图片自适应 - image responsize **/ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: 16px } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: 16px } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: 16px } /* Internet Explorer */ 6.2 偷天换日 返回目录 然后，我们就面临一个问题，要怎么美化呢？ 脑阔疼，我们还是去网上盗个皮肤下来吧： 很好，然后我们对着修改下 CSS： index.css /* 共用 */ html, body { height: 100%; } body { background: url(\"../img/background.jpg\") no-repeat center; background-size: 100% 100%; } /* 多项选项框 */ input[type=\"checkbox\"] { width: 25px; height: 25px; background-color: #fff; -webkit-appearance: none; border: 1px solid deepskyblue; border-radius: 2px; outline: none; } input[type=\"checkbox\"]:hover { cursor: pointer; } input[type=\"checkbox\"]:checked { background: url(\"../img/icon-checked.png\") no-repeat center; background-size: 100%; } /* 共用标题样式 */ .todo-title { margin-top: 10px; word-break: normal; width: 75%; display: block; white-space: pre-wrap; word-wrap: break-word ; overflow: hidden ; } /* 图标样式 */ .icon-recycle { width: 25px; height: 25px; background: url(\"../img/icon-recycle.png\") no-repeat center; background-size: 100%; } .icon-delete { width: 25px; height: 25px; background: url(\"../img/icon-delete.png\") no-repeat center; background-size: 100%; } .content-list-recycle-back { display: block; width: 20px; height: 20px; background: url(\"../img/icon-back.png\") no-repeat center; background-size: 100%; } /* 页面主体 */ .main-container { width: 1200px; height: 100%; margin: 0 auto; position: relative; } /* 头部标题 */ .header { width: 100%; height: 150px; background: url(\"../img/title.png\") no-repeat center; } /* 内容区 */ .content { text-align: center; } /* 内容区 - 输入区 */ .content-input-todo { height: 40px; } .content-input-todo input { height: 40px; padding-left: 20px; padding-right: 20px; border: none; border-radius: 20px; } .content-input-todo button { width: 100px; padding: 5px; border-radius: 20px; background: #36AF9E; color: #fff; outline: none; } /* 内容区 - 列表区 */ .content-list { display: flex; margin-top: 30px; } .content-list div { width: 380px; margin-right: 20px; border: 1px solid #ccc; padding: 30px; border: 15px solid transparent; border-image: url(\"../img/border.png\") 60 60 stretch; } .content-list div ul { text-align: left; } .content-list div ul li { width: 100%; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #ccc; } .content-list div ul li:hover { cursor: pointer; } .content-list div ul li input[type=\"checkbox\"] { margin-right: 10px; } .content-list div ul li input[type=\"text\"] { outline: none; border: none; background: rgba(255, 255, 255, 0); color: #000; border-bottom: 1px solid #ccc; } /* 底部区 */ .footer { position: absolute; bottom: 0; width: 100%; text-align: center; } .footer a { color: deepskyblue; } .footer a:hover { color: deepskyblue; } 大功告成，看下我们的成品： 七 总结 返回目录 到此，我们就写完了这个简单的小 Demo 咯~ 下面将代码地址和项目地址贴出来，需要 参考 的小伙伴自行下载或者观看。 代码地址：功成千骨 - 代码地址 项目地址：功成千骨 - 线上地址 当然，还没完！ 我们还可以折腾更多： 使用 ElementUI 或者 Bootstrap 进行多端适配 使用 localStorage 来进行本地版开发 使用 Node 来进行数据多端使用 使用 可视化配置，将 DOM 元素的 CSS 抽取成数据，让用户可以配置自己的 Todolist 使用 HTML5 的 manifest 来开发 离线存储 …… 那么，后面有机会折腾，咱再相会 Todolist ，打造升级版本的啦~ 后记 如果小伙伴需要存放 jsliang.top 这样的纯静态页面或者 company.jsliang.top 这样的具有 Node 后端支持的页面，推荐购买云服务器来存放。 如果小伙伴们不知道该怎么选择云服务器，可以查看 详细介绍 或者加 jsliang QQ：1741020489 咨询。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/VueDemoTwo.html":{"url":"JavaScript-library/Vue/VueDemoTwo.html","title":"✘ Vue Demo Two - 新闻 SPA","keywords":"","body":"Vue Demo Two - 新闻 SPA Create by jsliang on 2019-1-23 12:56:37Recently revised in 2019-2-11 11:31:58 Mint-UI 9 宫格布局： 在 src/components/home 中使用 Home.vue 1 2 3 4 5 6 .grid ul { margin: 0; padding: 0; } .grid li { list-style: none; float: left; width: 33.3%; backgorund-color: yellowgreen; text-align: center; height: 30px; } 组件封装 在 components 文件夹下新建 common 在 common 下新建 MyUl.vue MyUl.vue export default { name: 'my-ul', data() { return { } } } ul { margin: 0; padding: 0; } MyLi.vue export default { name: 'my-li', data() { return { } } } li { list-style: none; float: left; width: 33.3%; backgorund-color: yellowgreen; text-align: center; height: 30px; } main.js 中引用自己的组件 main.js // 引入自己的 ul 和 li 组件 import MyUl from '@/components/Common/MyUl' import MyLi from '@/components/Common/MyLi' // 注册全局组件 Vue.component(MyUl.name, MyUl); Vue.component(MyLi.name, MyLi); 在页面中使用 Home.vue {{grid.title}} data() { return { grids: [ { className: \"cms-news\", title: \"新闻资讯\", url: \"baidu.com\" }, { className: \"cms-photo\", title: \"图文分享\", url: \"jsliang.top\" }, ] } } 重定向路由： router/index.js routes: [ { path: '/', redirect: { name: 'home' }, } ] 通过 导向页面： Home.vue 首页 data() { return { grids: [ {className: \"cms-news\", title: \"新闻\", router:{name: 'new.list'}} ] } } router/index.js import NewsList from \"@/components/News/NewsList\" routers: [ { name: \"news.list\", path: \"/news/list\", component: NewsList } ] News/NewsList.vue ……省略 关于 :key=\"**\"，如果数据有对应的 id，则用它的 id。 时间过滤器：Moments.js 安装 Monents.js：npm install moment --save main.js // 定义 moment 全局日期过滤器 import Moment from 'moment'; // {{ 'xxx' | converTime('YYYY-MM-DD') }} // {{ 'xxx' | converTime('YYYY年MM月DD日') }} Vue.filter(\"converTime\", function(data, formatStr) { return Moment(data).format(formatStr); }); NewsList.vue {{ news.add_time | converTime('YYYY-MM-DD') }} 可以获取绝对时间或者相对时间 Vue.filter(\"relativeTime\", function(previousTime) { return Moment(previousTime).fromNow(); }) 封装头部 components/common/NavBar.vue 返回 {{title}} export default { name: 'nav-bar', props: ['title'], methods: { goBack() { this.$router.go(-1); } } } src/main.js // 引入自己的 ul 和 li 组件 import NabBar from '@/components/Common/NabBar' // 注册全局组件 Vue.component(NabBar.name, NabBar); NewsList.vue 点击切换不同页面，MintUI 组件下边导航 App.vue @click = \"changeHash\" methods: { changeHash() { // 在 Vue 完成渲染任务以后的行为 this.$nextTick(function() { console.log(this.selected); this.$router.push({ name: this.selected }) }) } } 点击跳转到文章详情 NewsList.vue index.js import NewsDetail from '@/components/News/NewsDetail'; export default new Router({ routes: [ // 新闻详情 { name: 'news.detail', path: '/news/detail', component: NewsDetail } ] }) NewsDetail …… 图文分享 Home.vue { className: \"cms-photo\", title: \"图文分享\", router: { name: \"photo.list\", params: { categoryId: 0 } } } router/index.js { name: \"photo.list\", path: \"/photo/list/:category\", component: PhotoList } lazy load 使用 MintUi 自带的 v-lazy 指令 安装 v-lazy 包 路由守卫  路由守卫 PhotoList.vue export default { beforeRouteUpdate(to, from, next) { // ... console.log(to); next(); } } 接口返回信息 { Status: 1, //数据状态 Code: 200, //反码状态 Message: 'Successful', //描述信息 ClientTime: 1473765898, //客户端请求时间 ServerTime: 1473765935, //服务端响应时间 token: '38ce6474a370c3fe84ddf92403bec204cfcbe07b', //唯一token也可做加密key data:{ //json数据，格式层级关系根据对应需求虽易定 key1: value1, key2: value2, key3: { [ name: '小明', sex: 1, ],[ name: '小华', sex: 1, ],[ name: '小刚', sex: 1, ]} } } 关于分类跳转 在 created() 中调用函数，查看 id，跳转到不同分类 在用户修改 url 时，beforeRouteUpdate() 中调用函数，查看 id，跳转到不同分类 在点击按钮上触发事件。 新闻详情 通过 v-html 来渲染富文本 NewsDetail.vue 由于 v-html 是 this.nextTick() 中执行的，所以要注意下渲染机制。 图片预览 图片预览插件 - vue-preview main.js // 图片预览插件 import VuePreview from 'vue-preview' // default install Vue.use(VuePreview); // 上面代码会内部运行下面代码 Vue.component('vue-preview', componentObj); 封装评论组件 新建 src/components/Common/Comment.vue Comment.vue // 内容 export default { name: \"comment\" } main.js import Comment from '@/components/Common/Comment'; Vue.component(Comment.name, Comment); PhotoDetail.vue let id = this.$route.query.id; 关于使用组件 artId - 详情 id pageIndex - 页数 Comment.vue export default { name: \"comment\", props: ['cid'], // 评论需要的 id created() { // 使用该组件的时候，是否有页码，如果有，就到那个页面，如果没有，就是第一页。 let id = this.$route.query.page || '1'; } } 关于评论方式 路人 用户 加载中功能 src/main.js // 配置请求拦截器，显示 loading 图标 Axios.interceptors.request.use(function(config) { MintUI.Indicator.open({ text: \"加载中...\", spinnerType: \"fading-circle\" }) return config; }); // 配置响应拦截器，关闭 loading 图标 Axios.intercepotrs.response.use(function(response) { MintUI.Indicator.close(); return response; }) MintUI 下拉刷新与上拉加载 参考地址 // loadmore 的禁止函数调用的属性来控制 this.isAllLoaded = true; // 通知元素重新定位 this.$refs.loadmore.onBottomLoaded(); 过渡效果 Vue 过渡动画 父子组件通讯 新建 src/EventBus.js EventBus.js import Vue from 'vue'; // bus 公交车，基于事件的同一个载体对象 let EventBus = new Vue(); // $on(事件名, function() {}) -> $emit('事件名', 数据) export default EventBus; src/App.vue import EventBus from './EventBus.js'; export default { created() { EventBus.$on('addShopcart', (data) => { console.log(data); console.log(this); }) } } src/components/Goods/GoodsDetail.vue insertBall() { // 通知 App 组件增加小球数量 EventBus.$emit('addShopcart', this.pickNum); } 路由守卫判断来回的路由 路由守卫 beforeRouteEnter (to, from, next) { next(vm => { // 通过 `vm` 访问组件实例 }) } 商品的增删改查 src/GoodsTools.js let obj = {}; // 获取所有商品数据 obj.getGoodsList = function() { return JSON.parse(window.localStorage.getItem('goodsList') || '{}'); } // 保存商品 obj.saveGoods = function(goodsList) { // 本地存储 window.localStorage.setItem('goodsList', JSON.stringify(goodsList)); } // 新增一个商品 obj.add = function(goods) { // 判断当前 goodsList 中是否包含该商品，有则追加，无则赋值 let goodsList = this.getGoodsList(); if(goodsList[goods.id]) { // 有该 key 做追加 goodsList[goods.id] += goods.num; } else { goodsList[goods.id] = goods.num; } // 保存数据 this.saveGoods(goodsList); } // 获取购物车数量总数 obj.getTotalCount = function() { let goodsList = this.getGoodsList(); let values = Object.value(goodsList); let sum = 0; values.forEach(val => sum += val); return sum; } export default obj; App.vue import GoodsTools from './GoodsTools.js'; export default { created() { // 初始化小球的数量 this.num = GoodsTools.getTotalCount(); } } GoodsDetail.vue import GoodsTools from '@/GoodsTools'; afterEnter() { // 添加到本地存储 GoodsTools.add({ id: this.goodsInfo.id, num: this.pickNum }) } 离开页面 beforeRouteLeave(to, from, next) { // 导航离开该组件的对应路由时调用 // 可以访问组件实例 this if(confirm('亲，真的要离开吗？')) { } else { // 取消导航行为 next(false); } } 中获取其他组件的高度 App.vue Content.vue export default { props: ['apprefs'], mounted() { console.log(this.apprefs.appHeader.$el.offsetHeight); console.log(this.apprefs.appFooter.$el.offsetHeight); } } 滚动行为 VueRouter 滚动行为 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Vue/VueDemoThree.html":{"url":"JavaScript-library/Vue/VueDemoThree.html","title":"✘ Vue Demo Three - 千人千魔","keywords":"","body":"Vue Demo Three - 千人千魔 Create by jsliang on 2019-1-23 12:56:37Recently revised in 2019-2-11 11:31:58 该 Demo，可分为四大部分： 部分一：吐槽系统 功能 用户可吐槽工作、生活、学习 用户可查看吐槽详情 用户可点赞吐槽 用户可评论吐槽 用户可回复吐槽评论 用户可举报吐槽 用户举报数超 50，管理员将审核，吐槽将可能因违规被删除 数据库设计 字段 类型 说明 id int 主键，自动递增 time datetime 时间 部分二：商城系统 用户可以上传商品 用户可以查看商品详情 用户可以添加商品到购物车并购买 用户可以评论商品 用户可以点赞商品 用户的商品评论违法被举报删除 商品分为人气商品和新商品 用户可以搜索商品 商品违法被举报删除 用户可以实施商品攻略战，以超过商品原价 10 倍的积分买断商品拥有权 商品不能是正规商品 部分三：积分系统 用户签到能领取积分 用户评论被点赞能获得积分 用户上传商品能获得积分 用户上传的商品获得点赞可以领取积分 用户文章、商品被举报删除可以获得成就 用户商品被买断可以获得积分 积分可用户商品购买以及商品拥有权购买 积分可用于系统成就达成 部分四：用户信息 用户信息来源于微信/QQ 用户可有个人座右铭 用户拥有文章发表权以及商品发表权 部分五：土豪系统 积分累计到一定程度开启土豪系统 土豪可以看到普通用户看不到的页面 土豪可以 8 折垄断商品 土豪可以花费积分购买排名 土豪可以打赏其他用户 土豪被举报将扣除全部积分 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/React/":{"url":"JavaScript-library/React/","title":"React","keywords":"","body":"React create by jsliang on 2018-9-5 08:59:31Recently revised in 2019-04-23 14:32:31 一 React 介绍 React 是 Facebook 于 2013 年推出的函数式编程，是目前前端框架中使用人数最多的前端框架，其拥有健全的文档与完善的社区。 React 16.0 及以上版本，又被成为 React Fiber。 二 React 与 Vue 比较 Vue 提供了非常丰富的 API，但是因为过于丰富，灵活度相对于 React 没有那么灵活。 开发复杂度比较高的项目时，可以选择 React。而面向用户端复杂度没那么高的项目，可以使用 Vue。 具体选用何种框架，还是取决于个人/团队对于该框架的驾驭程度 三 目录 文章 知识点 《React Demo One - TodoList》) React 《React Demo Two - TodoList 升级》 React、Redux、Redux-Thunk、Redux-Saga、React-Redux 《React Demo Three - 简书》 React、Redux、React-Redux、Redux-Thunk 四 学习顺序 ReactBase ReactDemoOne-TodoList ReactRedux ReactDemoTwo-TodoListUpgrade ReactDemoThree-JianShu jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-23 14:32:48 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/React/ReactBase.html":{"url":"JavaScript-library/React/ReactBase.html","title":"✘ React 基础","keywords":"","body":"React 基础 create by jsliang on 2019-3-26 09:25:41Recently revised in 2019-04-23 16:14:43 记录 React 基础知识，并尝试构建个人知识体系。 React 版本：16.4 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 JSX  3.1 什么是 JSX  3.2 JSX（一）  3.3 JSX（二）  3.3 JSX（三） 四 元素渲染 五 组件 & Props 六 state & 生命周期  6.1 Mounting  6.2 Updation  6.3 Unmounting  6.4 汇总 二 前言 返回目录 万丈高楼平地起，地基还得自己起。 从 0 开始，丰富自己的 React 技术栈。 最好的学习还是自己看官方文档，别人的笔记终究是别人学习的总结。 三 JSX 返回目录 3.1 什么是 JSX 返回目录 const element = Hello, world!; 在 React 中，我们管这样的内容，叫 JSX。 3.2 JSX（一） 返回目录 JSX 类似于 HTML 标签，但是它确切来说是 React 内部生成的，它也可以包含表达式，例如： function formatName(user) { return user.firstName + ' ' + user.lastName; } const user = { firstName: 'Harper', lastName: 'Perez' }; const element = ( Hello, {formatName(user)}! ); ReactDOM.render( element, document.getElementById('root') ); 3.3 JSX（二） 返回目录 不仅如此，还可以将 JSX 作为返回值： function getGreeting(user) { if (user) { return Hello, {formatName(user)}!; } return Hello, Stranger.; } 3.4 JSX（三） 返回目录 Babel 转译器会把 JSX 转换成一个名为 React.createElement() 的方法调用。 const element = ( Hello, world! ); // 等价于上面代码 const element = React.createElement( 'h1', {className: 'greeting'}, 'Hello, world!' ); 四 元素渲染 返回目录 元素是构成 React 应用的最小单位。 元素用来描述你在屏幕上看到的内容： const element = Hello, world; 与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。 我们可以拿 create-react-app 中的简化代码来看看： index.html Todolist 你需要允许在 APP 中运行 JavaScript index.js import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; ReactDOM.render(, document.getElementById('root')); App.js import React, { Component } from 'react'; class App extends Component { render() { return ( Hello React! ); } } export default App; 在这三个文件中我们可以很简单地看出猫腻： 我们在 index.html 中有个根节点： 我们通过 index.js 往 index.html 挂载元素：ReactDOM.render(, document.getElementById('root')); 我们在 App.js 中表示元素的具体内容为：Hello React! 如此，小伙伴们对元素应该有个清晰了解了。 五 组件 & Props 返回目录 元素是 React 中的最小单位，当元素堆积过多的时候就形成页面，而我们可以将页面划分成不同的部门，从而实现复用，于是就有了组件。 组件可以将 UI 切分成一些独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。 组件从概念上看就像是函数，它可以接收任意的输入值（称之为 props），并返回一个需要在页面上展示的 React 元素。 下面我们来看个例子： function Welcome(props) { return Hello, {props.name}; } const element = ; ReactDOM.render( element, document.getElementById('root') ); 在这个例子中，我们做了 4 件事： 我们对 元素调用了 ReactDOM.render() 方法。 React 将 {name: 'Sara'} 作为 props 传入并调用 Welcome 组件。 Welcome 组件将 Hello, Sara 元素作为结果返回。 React DOM 将 DOM 更新为 Hello, Sara。 六 state & 生命周期 返回目录 本文生命周期为 React 16.4，目前 React 16.8 版本已有新生命周期 上图为 React 16.4 版本的生命钩子。 何为生命周期：生命周期函数指在某一个时刻会自动调用执行的函数。 6.1 Mounting 返回目录 componentWillMount()：在组件即将被挂载到页面的时刻自动执行。 render()：渲染 JSX。 componentDidMount()：在组件被挂载到页面之后，自动被执行。 6.2 Updation 返回目录 shouldComponentUpdate()：在组件被更新之前，它会自动被执行。如果该生命周期存在于子组件，然后该子组件不需要根据父组件更新而更新，我们只需要 return false 即可①。 componentWillUpdate()：在组件被更新之前，它会自动被执行，但是它在 shouldComponentUpdate() 之后被执行。如果 shouldComponentUpdate() 返回 true，这个函数会被执行；如果返回 false，该函数不会被执行。 render()：渲染 JSX。 componentDidUpdate()：组件更新完成之后，它会被执行。 ①： shouldComponentUpdate(nextProps, nextState) { if(nextProps.content !== this.props.content) { return true; } else { return false; } } componentWillReceiveProps()：当一个组件从父组件中接收了参数。只要父组件的 render() 函数被重新执行了，子组件的这个生命周期函数就会被执行。 6.3 Unmounting 返回目录 componentWillUnmount()：当这个组件即将被从页面中剔除的时候，会被执行。 6.4 汇总 返回目录 n 调试工具 React Development Tools 介绍 React Development Tools 下载地址 n 子组件接受数据校验及默认设置 // 引用类型校验 import PropTypes from 'prop-types' class TodoItem extends React { // ...省略 } // 使用类型校验 TodoItem.protoTypes = { test: PropTypes.string.isRequired, content: PropTypes.arrayOf(PropTypes.number, PropTypes.string), deleteItem: PropTypes.func, index: PropTypes.number } // 使用字段默认值 TodoItem.defaultProps = { test: 'Hello World!' } export default TodoItem; n poops、state 以及 render 函数的关系 当组件的 state 或者 props 发生改变的时候，render 函数就会重新执行。 当父组件的 render 函数被运行时，它的子组件的 render 都将被重新运行一次。 n React 的 DOM 操作 首先，尝试模仿下 React 的数据更新： state 数据 JSX 模板 数据 + 模板结合，生成真实的 DOM，来显示 state 发生改变 数据 + 模板结合，生成真实的 DOM，替换原始的 DOM 然后，我们分析下缺陷： 第一次生成了一个完整的 DOM 片段 第二次生成了一个完整的 DOM 片段 第二次的 DOM 替换第一次的 DOM，非常耗性能 接着，我们尝试优化下思路： state 数据 JSX 模板 数据 + 模板结合，生成真实的 DOM，来显示 state 发生改变 数据 + 模板结合，生成真实的 DOM，并不直接替换原始的 DOM 新的 DOM（Document Fragment）与原始的 DOM 作对比，找差异 找出 input 框发生了什么变化 只用新的 DOM 中的 input 元素，替换掉老的 DOM 中的 input 元素 再来，我们再次分析下缺陷： 性能的提升并不明显 然后，我们进一步优化提升： state 数据 JSX 模板 数据 + 模板生成虚拟 DOM（虚拟 DOM 就是一个 JS 对象，用来描述真实 DOM）（损耗了性能） ['div', {id: 'abc'}, [ 'span', {}, 'Hello World!' ]] 用虚拟 DOM 的解构生成真实的 DOM，来显示 Hello World! state 发生变化 数据 + 模板生成新的虚拟 DOM（极大提升了性能） ['div', {id: 'abc'}, [ 'span', {}, 'Hello jsliang!' ]] 比较原始虚拟 DOM 和新的虚拟 DOM 的区别，找到区别是 span 中内容（极大提升了性能） 直接操作 DOM，改变 span 中的内容 最后，我们分析下现在优点： 性能提升了 它使得跨端应用得以实现。React Native（网页上生成 DOM 标签，手机上生成原生应用代码） 在 JSX 中，JSX -> createElemnt -> 虚拟 DOM（JS 对象） -> 真实的 DOM：return item可以被下面语句替换：return React.createElement('div', {}, React.createElement('span', {}, 'item')) n 虚拟 DOM 中的 diff 算法 比较原生虚拟 DOM 和新的虚拟 DOM 的区别，使用 Diff（different）算法 如上图，在 React 中，对于 setState，它采用异步操作，统一对 state 中的数据进行更改。 首先，比对第一层的 DOM 节点，如果它相同，则往下继续对比；如果它不同，则停止对比，更新第一层及以下的 DOM 节点。 然后，比对第二次的 DOM 节点…… 最后，形成一种比对算法。 关于 React 中的 key 值： 如果我们没有在 for 遍历中，给节点赋值上相应的 key 值，那么，React 的查找就像上图左侧一样，毫无目的，很难进行比较。 当我们使用了相应的 key 值时，我们就可以快速找到不同的地方，进行对比，从而方便进行渲染。 现在可以解释，为啥不要使用 index 作为 for 循环的 key 值。 第一次我们添加了：a - 0、b - 1、 c - 2 当我们删除了 a 之后：b - 0、c - 1 这时候，我们对应的 key 值就变了，我们就需要重新渲染整个 DOM 节点了。 ref： ref 帮助我们在 React 中直接获取 DOM 元素 TodoList.js {this.input = input}} onChange={this.handleInputChange.bind(this)} /> handleInputChange() { const value = this.input.value; } // 之前 // handleInputChange(e) { // const value = e.target.value; // } 工作中不推荐 ref 形式，因为它操作 DOM 了。 n setState 异步 在 this.setState() 中，我们知道它是异步执行的。 那么，当我们需要在它进行数据更新之后操作，我们要怎么做呢？使用 Promise？不需要！因为 React 提供了 setState 后的操作： this.setState( (prevState) => { inputValue: '', }), () => { console.log('设置完状态后执行'); }); n 调用接口 - axios 安装：npm i axios -S 引用：import axios from 'axios' 使用：axios.get('地址').then( (res) => {}).catch( (error) => {})) mock：使用 Charles 模拟接口。 n React 中的动画 使用 CSS3 编写动画 使用插件 react-transition-grup 地址：react-transition-group 安装：npm i react-transition-group --save jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:19:42 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/React/ReactPrepare.html":{"url":"JavaScript-library/React/ReactPrepare.html","title":"✘ React 开发准备","keywords":"","body":"React 开发准备 Create by jsliang on 2019-04-25 16:20:59Recently revised in 2019-04-26 11:57:21 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 二 前言 返回目录 在使用 Create React App 搭建脚手架的时候，有些步骤是重复的，有时候甚至还会忘记这些配置的使用方法，故在此记录一些常用步骤（插件安装等），方便自己回顾。 三 初始化目录 返回目录 下载 Node.js 安装 Create React App： npm i create-react-app -g 开启新项目： create-react-app todolist cd todolist npm start 打包项目：npm build 项目目录： - todolist + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - mainfest.json —— 提供 meta 信息给项目，并与 serviceWorker.js 相呼应，进行离线 APP 定义 - src ——————————————————— 项目主要目录 - App.css —— 主组件样式 - App.js —— 主组件入口 - App.test.js —— 自动化测试文件 - index.css —— 全局 css 文件 - index.js —— 所有代码的入口 - logo.svg —— 页面的动态图 - serviceWorker.js —— PWA。帮助开发手机 APP 应用，具有缓存作用 - .gitignore ———————————— 配置文件。git 上传的时候忽略哪些文件 - package-lock.json ————— 锁定安装包的版本号，保证其他人在 npm i 的时候使用一致的 node 包 - package.json —————————— node 包文件，介绍项目以及说明一些依赖包等 - README.md ————————————— 项目介绍文件 当然，一般我们都需要进行项目定制化，有些功能不需要的（例如 Service Worker），有些文件不需要的（例如 logo.svg），有些文件需要修改的（例如 index.html），就需要进行简化下： - demo + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 + mock —— 本地 Mock 文件夹 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - src ——————————————————— 重要的目录 + api —— 封装 API 接口文件 - assets —— 静态资源文件夹 + img —— 图片资源文件夹 + components —— 共用组件 + pages —— 路由页面 + store —— 全局配置 store - style —— 全局配置样式 - index.css —— 全局样式 - reset.css —— 重置浏览器样式 - common.css —— 项目复用样式 - icon.css —— 图标样式 - App.js —— 主组件入口 - index.js —— 所有代码的入口 - .gitignore ———————————— 配置文件。Git 上传的时候忽略哪些文件 - package.json —————————— Node 包文件。介绍项目以及说明一些依赖包等 - README.md ————————————— 项目介绍文件 Reset CSS reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 16px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 16px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /* * 图片自适应 - image responsize * 1. 清空浏览器对图片的设置 * 2. 图片 的情况下，图片会撑高 div，这么设置可以清除该影响 */ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .32rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .32rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .32rem } /* Internet Explorer */ Npm Install 安装 Redux：npm i redux -S 安装 React-Redux：npm i react-redux -S 安装 Redux-Saga：npm i redux-saga -S 安装 React-Router：npm i react-router-dom -S 安装 Ant Design：npm i antd -S 安装 Axios：npm i axios -S 总：cnpm i redux react-redux redux-saga react-router-dom antd axios -S React Router DOM 案例 import React, { Fragment } from 'react'; import { BrowserRouter, Route } from 'react-router-dom'; import Header from './components/Header'; import TimeLine from './pages/TimeLine'; function App() { return ( ); } export default App; jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:21:35 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/React/ReactList.html":{"url":"JavaScript-library/React/ReactList.html","title":"✘ React 知识点清单","keywords":"","body":"React 知识点清单 create by jsliang on 2019-04-23 14:10:18Recently revised in 2019-04-26 11:49:38 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 清单 四 Create React App 五 DvaJS 六 Service Workers 七 Debugger for Chrome 八 Source Maps 分析包大小 九 Sass 安装及使用 十 React Loadable - 代码打包分割 十一 React Router - 路由 十二 Axios - 调用后端接口 十三 Fetch - 调用后端接口 十四 Mock - 利用 Create React App 特性 二 前言 返回目录 求你别更新了，我学不过来了！ 别笑，这是事实。 现在前端界的玩意真的太多了，有些东西你听都没听过，然后很多招聘信息中居然 明目张胆 的贴着应聘者须具备 XX 技能，看得你目瞪口呆。 所以，这篇文章仅仅罗列知识点及其简单使用，更深一步的时候还是看我其他的实战文章或者自行百度搜索。 由于是罗列，有时候你会发现它毫无逻辑，甚至可读性极差。毕竟 —— 仅仅是罗列。 三 清单 返回目录 【Create React App】：构建一个 React 的脚手架工具 通过本文快速了解 Create React App 中文文档 【DvaJS】：类似 Create React App 的，方便 React 快速搭建项目的脚手架工具 通过本文快速了解 DvaJS 官网 【Service Worker】：具有离线缓存作用，能让浏览器在网速差或者网络不通的情况下，还能访问网站的静态资源。 通过本文快速了解 Service Workers API - MDN 制作渐进式 Web 应用程序(PWA) 【Debugger for Chrome】：Visio Studio Code 软件的开发插件，可以用来调试 Vue、React 等脚手架代码，非常方便。 通过本文快速了解 使用 VSCode 调试 React 应用 【source-map-explorer】：用来分析 Bundle 包的大小，从而进一步优化项目。 通过本文快速了解 React App 中如何分析Bundle Size？ 【node-sass】：通过 Sass 这个 CSS 预编译处理器，更好地编写 CSS。 通过本文快速了解 添加 Sass 样式表 【React Loadable】：配合 React Router，在 Create React App 中进行组件分割，减少每个 JS 文件的大小。 通过本文快速了解 Code-Splitting - GitHub react-loadable Code Splitting in Create React App 【React Router】：由于 Create React App 并没有规定路由解决方案，在此推荐 React Router。 通过本文快速了解 React Router 【Axios】：Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 Node.js 中。可以用来调用后端接口。 通过本文快速了解 Axios 中文说明 【Fetch】：Fetch API 类似于 Axios，它提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的部分，例如请求和响应。 通过本文快速了解 使用 Fetch - MDN React 快速上手 - 09 数据请求 fetch - SegmentFault 【Mock】：有时候后端接口还没好，我们不能干愣着，可以借助 Create React App 中的 Node 服务，直接调用本地模拟数据。 通过本文快速了解 四 Create React App 返回目录 通过运行一个命令来建立现代 Web 应用程序，来帮助你快速开发 React 项目。 步骤： 下载 Node.js 安装 Create React App： npm i create-react-app -g 开启新项目： create-react-app todolist cd todolist npm start 打包项目：npm build 项目目录： - todolist + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - mainfest.json —— 提供 meta 信息给项目，并与 serviceWorker.js 相呼应，进行离线 APP 定义 - src ——————————————————— 项目主要目录 - App.css —— 主组件样式 - App.js —— 主组件入口 - App.test.js —— 自动化测试文件 - index.css —— 全局 css 文件 - index.js —— 所有代码的入口 - logo.svg —— 页面的动态图 - serviceWorker.js —— PWA。帮助开发手机 APP 应用，具有缓存作用 - .gitignore ——————————— 配置文件。git 上传的时候忽略哪些文件 - package-lock.json ———— 锁定安装包的版本号，保证其他人在 npm i 的时候使用一致的 node 包 - package.json ————————— node 包文件，介绍项目以及说明一些依赖包等 - README.md ———————————— 项目介绍文件 参考链接：Create React App 中文文档 五 DvaJS 返回目录 什么是 DvaJS？ dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。 说白了，它是类似于 create-react-app 的，帮你配置脚手架的工具，可以让你快速搭建项目。 参考链接：DvaJS 官网 六 Service Workers 返回目录 在使用 Create React App 创建新项目时，会默认装上未开启的 Service Workers。 什么是 Service Workers？ Service Workers 本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步 API。 为什么加入 Service Workers？ 在 Create React App 中，由于离线优先的 Progressive Web Apps（渐进式 Web 应用程序）比传统网页更快，更可靠，并提供了很好的移动体验，所以它将 Service Workers 添加了进来。 如何开启 Service Workers？ 修改 src/index.js 目录中的 serviceWorker.unregister(); 为 serviceWorker.register() 即可开启离线缓存功能。 进一步定制需要自行百度/Chrome。 参考链接： Service Workers API - MDN 制作渐进式 Web 应用程序(PWA) - Create Web App 中文文档 七 Debugger for Chrome 返回目录 可以通过 Visio Studio Code 的插件 Debugger for Chrome 调试 Create React App： 安装 -> Debugger for Chrome 调试 -> 添加配置： launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Chrome\", \"type\": \"chrome\", \"request\": \"launch\", \"url\": \"http://localhost:3000\", \"webRoot\": \"${workspaceRoot}/src\", \"sourceMapPathOverrides\": { \"webpack:///src/*\": \"${webRoot}/*\" } } ] } 保存 -> 开始调试 通过上述步骤即可开始调试 如有问题可以参考下面资料 参考资料：使用 VSCode 调试 React 应用 - 知乎 八 Source Maps 分析包大小 返回目录 使用 source maps 分析 JavaScript 包。 这有助于你了解代码膨胀的来源，从而配合其他插件来减少每个包的大小，优化项目。 安装：npm i source-map-explorer -S 修改 package.json： package.json \"scripts\": { \"analyze\": \"source-map-explorer build/static/js/main.*\", \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test\", } 打包：npm run build 分析：npm run analyze 参考资料：React App 中如何分析Bundle Size？ - 简书 九 Sass 安装及使用 返回目录 Sass 是一种 CSS 的预编译处理器，简单来说就是方便你有组织有预谋地编写 CSS，更多 Sass 技巧可以去参考文献查找。 安装 node-sass：npm i node-sass -S 引入：@import 'styles/_colors.scss'; // 假设 styles 目录 在 src/ 目录下 参考文献： Sass 中文文档 添加 Sass 样式表 - Create React App 中文文档 十 React Loadable - 代码打包分割 返回目录 在 Create React App 中，我们可以使用 React Loadable 来进行代码的分割。 使用方式： import Loadable from 'react-loadable'; const LoadableOtherComponent = Loadable({ loader: () => import('./OtherComponent'), loading: () => Loading..., }); const MyComponent = () => ( ); 参考文献： Code-Splitting - GitHub react-loadable - GitHub Code Splitting in Create React App - Server Less Stack Overflow 十一 React Router - 路由 返回目录 由于 Create React App 并没有规定路由解决方案，然后市面上比较收欢迎的路由解决方案是 React Router，所以可以尝试使用： 安装：npm i react-router-dom -S 使用： React Router 官方文档 React Router DOM 中文文档（一） - 简书 React Router DOM 中文文档（二） - 简书 十二 Axios - 调用后端接口 返回目录 Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 Node.js 中。 功能： 从浏览器中创建 XMLHttpRequests 从 Node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 安装：npm install axios -S 使用：axios.get('/user').then((res) => {}).catch((err) => {}) Axios 中文说明 当然 React 调用接口不可能一家独霸，你还可以了解：AJAX API三驾马车: Axios vs . jQuery和Fetch - 掘金 十三 Fetch - 调用后端接口 返回目录 Fetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的部分，例如请求和响应。它还提供了一个全局 fetch() 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。 由于 Fetch 是浏览器内置，所以可以直接调用： fetch('http://example.com/movies.json') .then(function(response) { return response.json(); }) .then(function(myJson) { console.log(myJson); }); 由于 Fetch 具有极大兼容性，所以可以在 Create React App 中使用插件：cross-fetch，它能解决掉一大部分的兼容：npm i cross-fetch -S。 参考文献： 使用 Fetch - MDN React 快速上手 - 09 数据请求 fetch - SegmentFault 十四 Mock - 利用 Create React App 特性 返回目录 在我们的 Create React App 中，其实是可以使用它自带的 Node 进行接口模拟的，下面我们来看目标目录： - todolist + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 - api —— 新增的 Mock 文件夹 - user.json —— Mock 的 JSON 数据 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - src ——————————————————— 项目主要目录 - App.js —— 主组件入口 - index.css —— 全局 css 文件 - index.js —— 所有代码的入口 - .gitignore ——————————— 配置文件。git 上传的时候忽略哪些文件 - package.json ————————— node 包文件，介绍项目以及说明一些依赖包等 然后，我们在 src 目录中某个文件的 ComponentDidMount 等位置，调用 Fetch 或者 Axios，即可获取到数据： user.json { \"status\": \"0\", \"data\": [ { \"name\": \"jsliang\", \"age\": 24 }, { \"name\": \"梁峻荣\", \"age\": 24 } ] } Test.js import React, { Component } from 'react'; class Test extends Component { render() { return( Hello React ) } componentDidMount() { fetch( '/api/test.json' ) .then(res => res.json()) .then(data => { console.log(data) }) .catch(e => { console.log('错误:', e) }) } } export default Test; 最后，我们就可以在浏览器的控制台查看到 Mock 接口数据： data: [{name: \"jsliang\", age: 24}, {name: \"梁峻荣\", age: 24}] status: \"0\" Else 阅读推荐 返回目录 知乎专栏 - 魔都三帅和江浙沪包邮技术大联盟 关于 export 和 import - Stack Overflow 从redux-thunk到redux-saga实践 - SegmentFault jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-26 11:59:34 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/React/ReactList-CreateReactApp.html":{"url":"JavaScript-library/React/ReactList-CreateReactApp.html","title":"✔ React List - Create React App","keywords":"","body":"React List - Create React App create by jsliang on 2019-04-24 11:36:57Recently revised in 2019-04-25 10:44:54 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 安装及初始目录 四 默认支持特性 五 配合 VS Code 调试 六 分析包大小 七 模块引入 CSS 八 Sass 安装及使用 九 添加图片、背景、SVG 十 public 文件夹  10.1 引用静态资源  10.2 Mock 数据 十一 代码打包分割 十二 引用 TypeScript 十三 React Router - 路由 十四 自定义环境变量 十五 测试 十六 开发环境代理 十七 使用 Ajax 请求获取数据 十八 Title 和 Meta 十九 总结 二 前言 返回目录 Create React App 是一个官方支持的创建 React 单页应用程序的方法。它提供了一个零配置的现代构建设置。 本文 绝大多数、99% 内容来自 Create React App 的文档，1% 来自个人的整理。 如果对此话有所误解，请跳至文：十九 总结 可加 QQ 群：798961601，跟随 jsliang 一起折腾 参考文献： Create React App - 英文文档 Create React App - 中文文档 Create React App - GitHub 三 安装及初始目录 返回目录 下载 Node.js 安装 Create React App： npm i create-react-app -g 开启新项目： create-react-app todolist cd todolist npm start 打包项目：npm build 项目目录： - todolist + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - mainfest.json —— 提供 meta 信息给项目，并与 serviceWorker.js 相呼应，进行离线 APP 定义 - src ——————————————————— 项目主要目录 - App.css —— 主组件样式 - App.js —— 主组件入口 - App.test.js —— 自动化测试文件 - index.css —— 全局 css 文件 - index.js —— 所有代码的入口 - logo.svg —— 页面的动态图 - serviceWorker.js —— PWA。帮助开发手机 APP 应用，具有缓存作用 - .gitignore ——————————— 配置文件。git 上传的时候忽略哪些文件 - package-lock.json ———— 锁定安装包的版本号，保证其他人在 npm i 的时候使用一致的 node 包 - package.json ————————— node 包文件，介绍项目以及说明一些依赖包等 - README.md ———————————— 项目介绍文件 参考文献：入门 - Create React App 中文文档 四 默认支持特性 返回目录 支持所有现代浏览器（IE 9、10、11 除外，如果需要，请自行配置） 支持指数运算符 (ES2016) 支持 async / await (ES2017) 支持 Object Rest(剩余) / Spread(展开) 属性 (ES2018) 支持动态 import() (stage 3 proposal) 支持 Class 字段和静态属性 (part of stage 3 proposal) 支持 JSX, Flow 和 TypeScript 支持 PostCSS，无需手动添加 CSS 前缀，Create React App 会自动补全 参考文献：支持的浏览器和特性 - Create React App 中文文档 五 配合 VS Code 调试 返回目录 可以通过 Visio Studio Code 的插件 Debugger for Chrome 调试 Create React App： 安装 -> Debugger for Chrome 调试 -> 添加配置： launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Chrome\", \"type\": \"chrome\", \"request\": \"launch\", \"url\": \"http://localhost:3000\", \"webRoot\": \"${workspaceRoot}/src\", \"sourceMapPathOverrides\": { \"webpack:///src/*\": \"${webRoot}/*\" } } ] } 保存 -> 开始调试 通过上述步骤即可开始调试 如有问题可以参考下面资料 参考资料：使用 VSCode 调试 React 应用 - 知乎 六 分析包大小 返回目录 使用 source maps 分析 JavaScript 包。 这有助于你了解代码膨胀的来源，从而配合其他插件来减少每个包的大小，优化项目。 安装：npm i source-map-explorer -S 修改 package.json： package.json \"scripts\": { \"analyze\": \"source-map-explorer build/static/js/main.*\", \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test\", } 分析：npm run build 分析：npm run analyze 参考资料：React App 中如何分析Bundle Size？ - 简书 七 模块引入 CSS 返回目录 在 Create React App 中，如果你的 react-scripts 版本是 2.0 或者更高，你可以通过模块形式引入样式： Button.js import React, { Component } from 'react'; import styles from './Button.module.css'; // 将 css modules 文件导入为 styles import './another-stylesheet.css'; // 导入常规 CSS 文件 class Button extends Component { render() { // 作为 js 对象引用 return Error Button; } } 这样子不会导致样式的冲突，就好比你 import JS 进来一样。 参考资料：添加 CSS Modules 样式表 - Create React App 中文文档 八 Sass 安装及使用 返回目录 安装 node-sass：npm i node-sass -S 引入：@import 'styles/_colors.scss'; // 假设 styles 目录 在 src/ 目录下 参考文献：添加 Sass 样式表 - Create React App 中文文档 九 添加图片、背景、SVG 返回目录 添加图片：通过 import 引入即可。 import React from 'react'; import logo from './logo.png'; // 告诉 Webpack 这个 JS 文件使用了这个图片 console.log(logo); // /logo.84287d09.png function Header() { // 导入结果是图片的 URL return ; } export default Header; 引用背景：通过 url 引用即可。 .logo { background-image: url(./logo.png); } 引用 SVG： import React from 'react'; import logo from './logo.svg'; import './App.css'; function App() { return ( ); } export default App; 或者： import { ReactComponent as Logo } from './logo.svg'; const App = () => ( {/* ReactComponent 导入名称是特殊的 */} {/* Logo 是一个实际的 React 组件 */} ); 参考文献：添加图片，字体和文件 - Create React App 中文文档 十 public 文件夹 返回目录 在 Create React App 创建的项目中，有个 public 文件夹，该文件夹下通常有： favicon.ico - 网页小标签 index.html - 项目首页 mainfest.json - 提供 meta 信息给项目，并与 serviceWorker.js 相呼应，进行离线 APP 定义 当然，它不仅可以拥有这些文件，还可以新增内容。 10.1 引用静态资源 返回目录 index.html 可以引用静态资源。 在 index.html 中引用的静态资源不会被 Webpack 打包，而是被复制到打包目录中，使用方法： 只需要加上 %PUBLIC_URL%/ 表示引用 public 下的资源即可。 在 JavaScript 中： render() { return ; } 这样也会引用 public 中的资源，从而让图片 不会被 Webpack 打包。当然，需要牺牲的代价有： public 文件夹中的所有文件都不会进行后处理或压缩。 在编译时不会调用丢失的文件，并且会导致用户出现 404 错误。 结果文件名不包含内容哈希值，因此你需要添加查询参数或在每次更改时重命名它们（以便清除浏览器缓存）。 10.2 Mock 数据 返回目录 此外，由于它内含 Node.js，所以还可以利用这点进行数据模拟（Mock），做法是： 在 public 文件夹中新建 api 目录，然后创建文件 headerList.json，引用 axios 后，通过： axios.get('/api/headerList.json').then() 即可调用该文件进行 Mock。 api 下可以存放多个 json 文件 参考文献：使用 public 文件夹 - Create React App 中文文档 十一 代码打包分割 返回目录 在 Create React App 中，我们可以使用 React Loadable 来进行代码的分割。 使用方式： import Loadable from 'react-loadable'; const LoadableOtherComponent = Loadable({ loader: () => import('./OtherComponent'), loading: () => Loading..., }); const MyComponent = () => ( ); 参考文献： Code-Splitting - GitHub react-loadable - GitHub Code Splitting in Create React App 十二 引用 TypeScript 返回目录 使用 TypeScript 启动新的 Create React App项目：npx create-react-app my-app --typescript 往 Create React App 现有项目中添加 TypeScript：npm i typescript @types/node @types/react @types/react-dom @types/jest -S。（记得修改所有 JS 文件为 TS 文件，例如 src/index.js -> src/index.tsx） 参考文献：添加 TypeScript - Create React App 中文文档 十三 React Router - 路由 返回目录 由于 Create React App 并没有规定路由解决方案，然后市面上比较收欢迎的路由解决方案是 React Router，所以可以尝试使用： 安装：npm i react-router-dom -S 使用：React Router 十四 自定义环境变量 返回目录 定义环境变量：process.env.REACT_APP_SECRET_CODE 获取特殊内置环境变量：process.env.NODE_ENV。值为：test、development、production。对应三种环境。 render() { return ( You are running this application in {process.env.NODE_ENV} mode. ); } 在开发环境，该页面渲染为： You are running this application in development mode. 十五 测试 返回目录 Create React App 使用 Jest 作为其测试运行器。 但是很不幸的是，工作中并没有用上，估计以后的工作也可能不会用上，所以咱们只需要知道有这回事，等有机会再进行尝试。 参考文献： 运行测试 - Create React App 中文文档 调试测试 - Create React App 中文文档 十六 开发环境代理 返回目录 在开发项目的过程中，最担心的莫过于浏览器告诉你跨域了：后端端口在 4000，或者主机在另一个 IP 地址…… 所以，我们需要在开发环境中配置代理。 嗯，你问为什么生产（部署）环境我们不做代理？因为那属于后端的活了，或许你是个 全栈 工程师，你可以自行解决下。 往 package.json 中添加字段： package.json \"proxy\": \"http://localhost:4000\", 这样当你调用接口：fetch('/api/todos') 时，它会请求代理到 http://localhost:4000/api/todos。 当然，有可能 proxy 不够灵活，小伙伴们可以尝试通过直接访问 Express，并连接项目的代理中间件，详情看参考文献。 参考文献： 在开发环境中代理 API 请求 - Create React App 中文文档 手动配置代理 - Create React App 中文文档 十七 使用 Ajax 请求获取数据 返回目录 在 Create React App 中，可以通过下面两种方法获取 Ajax 数据： fetch() API axios 库 当然，没有限制死必须使用这两种。 这两种调用 Ajax 请求获取数据的方式便捷在它返回 Promise 供链式调用数据。 参考文献：使用AJAX请求获取数据- Create React App 中文文档 十八 Title 和 Meta 返回目录 动态更新 Title：document.title API 根据 React 组件更改 Title：React Helmet 等第三方库 动态更新 Meta： 然后读取 index.html 并将 __OG_TITLE__ 和 __OG_DESCRIPTION__ 替换掉即可。 参考文献：Title(网页标题) 和 Meta 标签 - Create React App 中文文档 十九 总结 返回目录 关于照抄 Create React App： 有必要吗？有必要，也没有必要。 有必要是因为 好记性不如烂笔头，自己敲一遍可以加深点点记忆，而且中文文档的翻译比较哆嗦，所以总结起来看着方便。 没必要是因为大部分都在 Create React App 的中文文档/英文文档中都有提示，所以一些小伙伴可能在下面 ** 了。 whatever, just record. 关于前端学习： 昨天微信群一位小伙伴询问有没有购买慕课网的 TS 重构 Axios 视频 昨天票圈一位小伙伴推荐 Koa 源码剖析视频 只能说，各自有各自的安排。 但是，千万千万不要随大流，能用到工作的知识才是 有用知识。 如果这些知识对你目前的工作，或者甚至以后的工作毫无帮助，请忽视它，无论它在前端圈子有多热闹。 关于 jsliang： 将 React 及其周边技术的官方文档过一遍 进行自己构思的项目实战 跟随公司项目进行大量操练 进一步剖析 React 源码 学习算法和数据结构 再说…… jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-26 12:01:56 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/React/ReactList-ReactRedux.html":{"url":"JavaScript-library/React/ReactList-ReactRedux.html","title":"✔ React List - React Redux","keywords":"","body":"React List - React Redux Create by jsliang on 2019-3-26 08:51:55Recently revised in 2019-04-24 10:00:40 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 二 前言 返回目录 在 React 中，如果兄弟组件需要通讯，例如左侧中的深色圆圈发送到底部圆圈，需要兜很多弯子。 而 Redux 的出现，是为了弥补这种麻烦的通讯方式，建立起一个中央机制，方便各组件之间的通讯。 Redux = Reducer + Flux 如上图，即为 Redux 工作机制。 蓝色：借书人 黄色：借书动作 橙色：图书管理员 紫色：系统 它的流程可以理解为：借书人走到前台（借书动作）跟图书管理员申请借书，图书管理员帮它查找书籍资料，然后拿到电脑返回信息，告诉他去哪借就行了。 换回正常话，即：当组件（React Components）需要调用数据的时候，它就向创造器（Action Creators）发起请求，创造器通知管理者（Store），管理者就去查找相关资料（Reducers），拿到返回的信息后，再告诉组件。 Redux 知识点补充 store 是唯一的 只有 store 能够改变自己的内容 Redux 核心 API createStore：创建 store store.dispatch：派发 action store.getState：获取 store 所有数据内容 store.subscribe：监控 store 改变，store 改变了该方法就会被执行 UI 组件和容器组件 UI 组件 —— 傻瓜组件，做页面的渲染 容器组件 —— 聪明组件，做页面的逻辑 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-26 12:05:18 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/React/ReactList-ReactRouter.html":{"url":"JavaScript-library/React/ReactList-ReactRouter.html","title":"✔ React List - React Router","keywords":"","body":"React List - React Router Create by jsliang on 2019-04-26 13:13:18Recently revised in 2019-04-29 15:25:01 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 初试 四 简介 五 BrowserRouter  5.1 BrowserRouter 语法  5.2 BrowserRouter - basename  5.3 BrowserRouter - getUserConfirmation  5.4 BrowserRouter - forceRefresh  5.5 BrowserRouter - keyLength 六 HashRouter  6.1 HashRouter - basename  6.2 HashRouter - getUserConfirmation  6.3 HashRouter - hashType 七 Link  7.1 Link - to  7.2 Link - replace  7.3 Link - other 八 NavLink  8.1 NavLink - activeClassName  8.2 NavLink - activeStyle  8.3 NavLink - exact  8.4 NavLink - isActive 九 MemoryRouter  9.1 MemoryRouter - initialEntries  9.2 MemoryRouter - initialIndex  9.3 MemoryRouter - getUserConfirmation  9.4 MemoryRouter - keyLength 十 Redirect  10.1 Redirect - from  10.2 Redirect - to  10.3 Redirect - push  10.4 Redirect - exact 十一 Route  11.1 Route - component  11.2 Route - render  11.3 Route - children  11.4 Route - path  11.5 Route - exact  11.6 Route - location  11.7 Route - sensitive 十二 Switch 十三 篇外一：history 十四 篇外二：Code Splitting 十五 篇外三：Scroll To Top  15.1 跳转页面后滚动到顶部  15.2 页面滚动到顶部 十六 篇外四：Redux 十七 总结 二 前言 返回目录 前端路由，是指改变 URL 路径的形式，从而切换到不同的页面，例如： localhost:3000/home localhost:3000/user 通过切换不同的 URL，显示不同的页面，从而有了 路由 的概念。 这篇文章我们讲解在 React 中如何通过 React Router 这个插件，灵活使用路由。 jsliang 瞎吹的，最好自己百度 前端路由 是啥。 参考资料： React Router 官方文档 React Router 中文文档 React Router 中文文档（旧） React Router DOM 中文文档（一） - 简书 React Router DOM 中文文档（二） - 简书 篇外话题： 网上有很多 React Router 文章了，例如： React Router 中文文档（一） React Router DOM 中文文档（一） 为何 jsliang 要多次一举？ 你记录你的，我记录我的，互相不妨碍。 看这些跟看官网没啥两样，所以我需要亲自动手过一遍官网。 记录我看官网的内容，顺带记录我应用上去的实例，方便我下次回顾。 三 初试 返回目录 当前版本：\"react-router-dom\": \"^5.0.0\" 首先，在 Create React App 中，我们引用 React Router： npm i react-router-dom -S 然后，在 src 目录下新建 pages 用来存放页面，并修改 App.js： 案例：App.js import React, { Fragment } from 'react'; import { BrowserRouter, Route, Switch, Redirect } from 'react-router-dom'; import ScrollToTop from './components/ScrollToTop'; import Header from './components/Header'; import TimeLine from './pages/TimeLine'; import NotFound from './pages/404'; function App() { return ( ); } export default App; 最后，通过在 App.js 中如此定义，即可定义对应的组件，并渲染对应页面和进行跳转。 四 简介 返回目录 下面我们拿一些常用的进行介绍： import { BrowserRouter, HashRouter, Redirect, Route, NavLink, Link, MemoryRouter, Switch, withRouter } from \"react-router-dom\"; ：\b路由组件包裹层。 和 的包裹层。 ：路由组件包裹层。相对于 来说，更适合静态文件的服务器。 ：路由重定向。渲染 将使导航到一个新的地址。 ：路由。定义一个路由页面，用来匹配对应的组件（Component）和路由路径。 ：活跃链接。当 URL 中的路径等于该路由定义的路径时，该标签可以呈现它定义的 activeClassName。 ：链接。用来跳转到 对应的路由（Component） 中。 ：暂未使用。 能在内存中保存 URL 的历史记录。很适合在测试环境和非浏览器环境中使用，例如 React Native。 ：路由分组。渲染与该地址匹配的第一个子节点 或者 。可以利用 做分组。 ：路由组合。通过 高阶组件访问 history 对象的属性和最近的 的 match。或者利用它来结合 Redux。 五 BrowserRouter 返回目录 会为你创建一个专门的 history 对象，用来记录你的路由，从而能够返回上一页或者跳转到指定的路由页面。 区别于 ，有响应请求的服务器时使用 ，使用的是静态文件的服务器，则用 。 简单案例： 5.1 BrowserRouter 语法 返回目录 import { BrowserRouter } from 'react-router-dom' 5.2 BrowserRouter - basename 返回目录 规则：basename: string 为里面的子目录提供基础路径名，例如： {/* 渲染为 */} 5.3 BrowserRouter - getUserConfirmation 返回目录 规则：getUserConfirmation: function 用于确认导航的功能。 // 默认使用 window.confirm。 const getConfirmation = (message, callback) => { const allowTransition = window.confirm(message) callback(allowTransition) } 5.4 BrowserRouter - forceRefresh 返回目录 规则：forceRefresh: bool 如果为 true，则路由器将在页面导航中使用整页刷新 const supportsHistory = 'pushState' in window.history 5.5 BrowserRouter - keyLength 返回目录 规则：keyLength: number 设置它里面路由的 location.key 的长度。默认为 6。 key 的作用：点击同一个链接时，每次该路由下的 location.key都会改变，可以通过 key 的变化来刷新页面。 六 HashRouter 返回目录 使用 URL 的 hash 部分（即 window.location.hash ）的 使 UI 与 URL 保持同步。 重要提示：Hash 历史记录不支持 location.key 或 location.state。 import { HashRouter } from 'react-router-dom' 6.1 HashRouter - basename 返回目录 规则：basename: string 所有位置的基本 URL，格式正确的基本名应该有一个前导斜线，但结尾不能有斜线。 {/* 渲染为 */} 6.2 HashRouter - getUserConfirmation 返回目录 规则：getUserConfirmation: func 用于确认导航的功能。默认使用 window.confirm。 // this is the default behavior const getConfirmation = (message, callback) => { const allowTransition = window.confirm(message) callback(allowTransition) } 6.3 HashRouter - hashType 返回目录 规则：hashType: string 用于 window.location.hash 的编码类型。可用的值是： slash - 创建 #/ 和的 #/sunshine/lollipops noslash - 创建 # 和的 #sunshine/lollipops hashbang - 创建 ajax crawlable，如 #!/ 和 #!/sunshine/lollipops 默认为 slash。 七 Link 返回目录 在应用程序周围提供声明式的,可访问的导航。 7.1 Link - to 返回目录 规则 1：to: string 链接位置的字符串表示，通过连接位置的路径名，搜索和 hash 属性创建。 字符串形式跳转 规则 2：to: object 一个可以具有以下任何属性的对象： pathname: 表示要链接到的路径的字符串。 search: 表示查询参数的字符串形式。 hash: 放入网址的 hash，例如 #a-hash。 state: 状态持续到 location。 对象形式跳转 7.2 Link - replace 返回目录 规则：replace: bool 如果为 true，则单击链接将替换历史堆栈中的当前入口，而不是添加新入口。 替换当前 hash 路径 7.3 Link - other 返回目录 还可以传递想要放在 上的属性，例如标题，ID、className 等。 测试 1 返回目录 八 NavLink 返回目录 一个特殊版本的 Link，当它与当前 URL 匹配时，为其渲染元素添加样式属性。 高亮显示首页：首页 8.1 NavLink - activeClassName 返回目录 规则：activeClassName: string 要给出的元素的类处于活动状态时。默认的给定类是 active。它将与 className 属性一起使用。 FAQs 8.2 NavLink - activeStyle 返回目录 规则：activeStyle: object 当元素处于 active 时应用于元素的样式。 FAQs 8.3 NavLink - exact 返回目录 规则：exact: bool 如果为 true，则仅在位置完全匹配时才应用 active 的类/样式。 Profile 8.4 NavLink - isActive 返回目录 规则：isActive: function 一个为了确定链接是否处于活动状态而添加额外逻辑的函数，如果你想做的不仅仅是验证链接的路径名与当前 URL 的 pathname 是否匹配，那么应该使用它 // 如果链接不仅仅匹配 events/123，而是所有奇数链接都匹配 const oddEvent = (match, location) => { if (!match) { return false } const eventID = parseInt(match.params.eventID) return !isNaN(eventID) && eventID % 2 === 1 } Event 123 九 MemoryRouter 返回目录 能在内存中保存 URL 的历史记录(并不会对地址栏进行读写)。很适合在测试环境和非浏览器环境中使用，例如 React Native。 9.1 MemoryRouter - initialEntries 返回目录 规则：initialEntries: array history 栈中的一个 location 数组。这些可能是具有 { pathname, search, hash, state } 或简单的 URL 字符串的完整地址对象。 9.2 MemoryRouter - initialIndex 返回目录 规则：initialIndex: number 在 initialEntries 数组中的初始化地址索引。 9.3 MemoryRouter - getUserConfirmation 返回目录 规则：getUserConfirmation: function 用于确认导航的函数。在使用 时，直接使用 ，你必须使用这个选项。 9.4 MemoryRouter - keyLength 返回目录 规则：keyLength: number location.key的长度。默认为 6。 十 Redirect 返回目录 渲染 将使导航到一个新的地址。这个新的地址会覆盖 history 栈中的当前地址，类似服务器端（HTTP 3xx）的重定向。 我们可以设置某个路由重定向到另一个路由，例如下面即对 / 完全匹配重定向到 /timeline 页面。 10.1 Redirect - from 返回目录 规则：from: string 重定向 from 的路径名。可以是任何 path-to-regexp 能够识别的有效的 URL 路径。 所有匹配的 URL 参数都提供给 to 中的模式。 必须包含在 to 中使用的所有参数。 to 未使用的其他参数将被忽略。 10.2 Redirect - to 返回目录 规则：to: string 重定向到的 URL，可以是任何 path-to-regexp 能够理解有效 URL 路径。 在 to 中使用的 URL 参数必须由 from 覆盖。 规则：to: object 重定向到的 location，pathname 可以是任何 path-to-regexp 能够理解的有效的 URL 路径。 10.3 Redirect - push 返回目录 规则：push: bool 当 true 时，重定向会将新地址推入 history 中，而不是替换当前地址。 10.4 Redirect - exact 返回目录 规则：exact: bool 完全匹配 from。 十一 Route 返回目录 只要应用程序位置与 Route 的路径匹配，组件就会被渲染。 11.1 Route - component 返回目录 只有当位置匹配时才会渲染的 React 组件。 const User = ({ match }) => { return Hello {match.params.username}! } 11.2 Route - render 返回目录 规则：render: function 这允许方便的内联渲染和包裹，而不是上面那种不想要的重新安装的解释 可以传递一个在位置匹配时调用的函数，而不是使用属性为您创建新的 React element component，该 render 属性接收所有相同的 route props 的 component 渲染属性。 // 行内编写 Home}/> // 包裹分开写 const FadingRoute = ({ component: Component, ...rest }) => ( ( )}/> ) 11.3 Route - children 返回目录 规则：children: function 有时你需要渲染路径是否匹配位置。在这些情况下，您可以使用函数 children 属性，它的工作原理与渲染完全一样，不同之处在于它是否存在匹配。 children 渲染道具接收所有相同的 route props 作为 component 和 render 方法，如果 Route 与 URL 不匹配，match 则为 null ，这允许你动态调整你的 UI 界面，基于路线是否匹配，如果路线匹配我们则添加一个 active 类。 const ListItemLink = ({ to, ...rest }) => ( ( )}/> ) 11.4 Route - path 返回目录 规则：path: string 任何 path-to-regexp 可以解析的有效的 URL 路径 11.5 Route - exact 返回目录 规则：exact: bool 如果为 true，则只有在路径完全匹配 location.pathname 时才匹配。 path location.pathname exact matches? /one /one/two true no /one /one/two false yes jsliang 个人经验： 加了 exact 属性后，会完全匹配路径；如果没有加，则二级路径也会匹配当前路径（例如 /timeline/book）。 我们可以动态设置 extra 的值，从而判断是否需要加载某个组件。 const Home = () => Home; const App = () => { const someVariable = true; return ( {/* these are good */} } /> {/* do not do this */} } /> ); }; 11.6 Route - location 返回目录 规则：location: object 一个 元素尝试其匹配 path 到当前的历史位置（通常是当前浏览器 URL）。但是，也可以通过location 一个不同 pathname 的匹配。 11.7 Route - sensitive 返回目录 规则：sensitive: bool 如果路径区分大小写，则为 true，则匹配。 path location.pathname sensitive matches? /one /one true yes /One /one true no /One /one false yes 十二 Switch 返回目录 渲染与该地址匹配的第一个子节点 或者 。 可以利用 做分组，即当有匹配时，匹配对应 path 对应的组件；如果没有匹配，则匹配 NotFound 页面。 十三 篇外一：history 返回目录 history 是一个包，在你安装 React Router 的时候，会作为它依赖包安装到项目中，所以你可以直接使用 history 中的属性和方法： length - (number 类型) history 堆栈的条目数 action - (string 类型) 当前的操作(push, replace, pop) location - (object 类型) 当前的位置。location 会具有以下属性： pathname - (string 类型) URL 路径 search - (string 类型) URL 中的查询字符串 hash - (string 类型) URL 的哈希片段 state - (object 类型) 提供给例如使用 push(path, state) 操作将 location 放入堆栈时的特定 location 状态。只在浏览器和内存历史中可用 push(path, [state]) - (function 类型) 在 history 堆栈添加一个新条目 replace(path, [state]) - (function 类型) 替换在 history 堆栈中的当前条目 go(n) - (function 类型) 将 history 堆栈中的指针调整 n goBack() - (function 类型) 等同于 go(-1) goForward() - (function 类型) 等同于 go(1) block(prompt) - (function 类型) 阻止跳转 十四 篇外二：Code Splitting 返回目录 随着应用的增长，代码包会随着生长。 到最后你会发现，你打包后的 js 文件大地太多离谱。 所以，我们需要通过代码分割，依据不同的路由，加载不同的 js 文件。 安装 React Loadable：npm i react-loadable -S 结合 React Router 和 React Loadable 进行 Code Spliting： import { BrowserRouter as Router, Route, Switch } from 'react-router-dom'; import Loadable from 'react-loadable'; const Loading = () => Loading...; const Home = Loadable({ loader: () => import('./routes/Home'), loading: Loading, }); const About = Loadable({ loader: () => import('./routes/About'), loading: Loading, }); const App = () => ( ); 打包项目： npm run build 十五 篇外三：Scroll To Top 返回目录 15.1 跳转页面后滚动到顶部 返回目录 首先，在全局 components 文件中定义 ScrollToTop 文件夹，其中 index.js 内容为： src/components/ScrollToTop/index.js import { Component } from 'react'; import { withRouter } from 'react-router-dom'; class ScrollToTop extends Component { componentDidUpdate(prevProps) { if (this.props.location !== prevProps.location) { window.scrollTo(0, 0) } } render() { return this.props.children } } export default withRouter(ScrollToTop); 然后，在 App.js 或者其他页面中使用 ScrollToTop 功能： src/App.js import React, { Fragment } from 'react'; import { BrowserRouter, Route, Switch, Redirect } from 'react-router-dom'; import ScrollToTop from './components/ScrollToTop'; import Header from './components/Header'; import TimeLine from './pages/TimeLine'; import NotFound from './pages/404'; function App() { return ( ); } export default App; 最后，我们切换路由的时候，页面就会滚动到顶部。 15.2 页面滚动到顶部 返回目录 暂未实现 十六 篇外四：Redux 返回目录 在项目中，我们更希望 React Router 和 React Redux 合并起来，这时候可以： // before export default connect(mapStateToProps)(Something) // after import { withRouter } from 'react-router-dom' export default withRouter(connect(mapStateToProps)(Something)) 参考文献：Redux Integration 十七 总结 返回目录 如果你纯粹过文档（官方文档，jsliang 的文档），你会觉得毫无趣味、了无生趣、乏味、沉闷…… 所以，jsliang 的学法是：开启了一个项目，边翻阅文档，边应用到项目中，并进行 Mark 标记，以便下次使用。 如此，该文档虽然完结了，但是仍未完结！完结的是我过完了官方文档，未完结的是 React Router 在我项目中可能有其他应用，需要我一一添加进来。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:07:50 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/React/ReactDemoOne-TodoList.html":{"url":"JavaScript-library/React/ReactDemoOne-TodoList.html","title":"✔ React Demo One - TodoList","keywords":"","body":"React Demo One - TodoList Create by jsliang on 2019-3-18 08:37:10Recently revised in 2019-05-20 17:50:01 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文  3.1 新建 React 项目  3.2 项目目录解析  3.3 精简项目结构  3.4 初探组件  3.5 JSX  3.6 事件及双向数据绑定  3.7 优化-抽取 CSS  3.8 优化-抽取 JS 四 总结 五 参考文献 二 前言 返回目录 关于 React，jsliang 从 2018-9-5 就开始折腾了，中途因为工作调动，没能继续折腾下去。最近因为新公司工作需求，从头开始继续折腾 React，希望我的文章能对没学过 React 或者初入 React 的小伙伴有所帮助。 本文参考来自慕课网： 《React 16.4 开发简书项目从零基础入门到实战》 其中掺杂个人对编程的理解，如有错误，望多多指正。 前置知识： ES5/ES6 Webpack npm 文章结构： 基础内容 -> 环境搭建 -> 基础语法 -> 原理进阶 -> 动画 Redux -> Redux 进阶 实战项目 -> 环境搭建 -> Header -> 首页 -> 详情页 登录校验 -> 上线 涉及知识点： create-react-app 组件化思维 JSX 开发调试工具 虚拟 DOM 生命周期 React-transition-group Redux Antd UI、容器组件 无状态组件 redux-thunk redux-saga styled-components immutable.js redux-immutable axios 其中，本文为第一个 Demo 案例：通过编写一个简单的 TodoList 小 Demo，熟悉 React 的开发流程。 三 正文 返回目录 Now，开始搞事情。 3.1 新建 React 项目 返回目录 下载 Node.js 安装 React 脚手架： npm i create-react-app -g 开启新项目： create-react-app todolist cd todolist npm start 打开 localhost:3000 查看页面 3.2 项目目录解析 返回目录 - todolist + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - mainfest.json —— 提供 meta 信息给项目，并与 serviceWorker.js 相呼应，进行离线 APP 定义 - src ——————————————————— 项目主要目录 - App.css —— 主组件样式 - App.js —— 主组件入口 - App.test.js —— 自动化测试文件 - index.css —— 全局 css 文件 - index.js —— 所有代码的入口 - logo.svg —— 页面的动态图 - serviceWorker.js —— PWA。帮助开发手机 APP 应用，具有缓存作用 - .gitignore ———————————— 配置文件。git 上传的时候忽略哪些文件 - package-lock.json ————— 锁定安装包的版本号，保证其他人在 npm i 的时候使用一致的 node 包 - package.json —————————— node 包文件，介绍项目以及说明一些依赖包等 - README.md ————————————— 项目介绍文件 3.3 精简项目结构 返回目录 为了方便开发，下面对 creat-react-app 的初始目录进行精简： - todolist + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - src ——————————————————— 重要的目录 - App.js —— 主组件入口 - index.js —— 所有代码的入口 - .gitignore ———————————— 配置文件。git 上传的时候忽略哪些文件 - package.json —————————— node 包文件，介绍项目以及说明一些依赖包等 - README.md ————————————— 项目介绍文件 favicon.ico、.gitignore、README.md 是我们无需理会的，但是其他文件，我们需要精简下它们的代码： index.html Todolist 你需要允许在 APP 中运行 JavaScript App.js import React, { Component } from 'react'; class App extends Component { render() { return ( Hello React! ); } } export default App; index.js import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; ReactDOM.render(, document.getElementById('root')); package.json { \"name\": \"todolist\", \"version\": \"0.1.0\", \"private\": true, \"dependencies\": { \"react\": \"^16.8.4\", \"react-dom\": \"^16.8.4\", \"react-scripts\": \"2.1.8\" }, \"scripts\": { \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test\", \"eject\": \"react-scripts eject\" }, \"eslintConfig\": { \"extends\": \"react-app\" }, \"browserslist\": [ \">0.2%\", \"not dead\", \"not ie 3.4 初探组件 返回目录 类似于上图，在进行页面开发的时候，我们很容易地使用庖丁解牛的技巧，将页面进行划分，然后一部分一部分地将页面搭建出来。 给个比较官方的说法，就叫页面组件化：将页面切成几个部分，从而有利于页面的拼装以及代码的维护。 在 create-react-app 的默认配置中，App.js 就是一个组件，一起来看： App.js // 1. 引用 React 及其组件 import React, { Component } from 'react'; // 2. 定义一个叫 App 的组件继承于 Component class App extends Component { render() { return ( Hello React! ); } } // 3. 根据 React 实例，在 App 内部编写完毕后，导出这个 App 组件 export default App; 在上面，我们引用、定义并导出了这个 App 的组件，然后我们就要使用它： index.js // 1. 引入 React、ReactDOM import React from 'react'; import ReactDOM from 'react-dom'; // 2. 将 App.js 导入进来 import App from './App'; // 3. 通过 ReactDOM 将 App.js 以虚拟 DOM 的形式渲染/挂载到 root 根节点，该节点在 index.html 中 ReactDOM.render(, document.getElementById('root')); index.js 告诉我们，它会通过 ReactDom，将 App.js 这个组件挂载到 root 这个节点上，那么，这个 root 在哪里呢？我们查看下 index.html： index.html Todolist 你需要允许在 APP 中运行 JavaScript OK，很容易地我们就捋清楚思路了：我们在 index.html 中定义了个 root 根节点，然后我们通过 index.js，将 App.js 以组件形式渲染到了 index.html 中，从而实现了节点的挂载。 思维发散：我们知道 index.js 和 App.js 的最终结合是挂载到 id=\"root\" 节点上的，如果我们再开一个 index2.js 和 App2.js，挂载到 id=\"root2\" 节点上，行不行呢？亦或者我们开一个 id=\"root3\" 的节点，我们在其中操作 jQuery，是不是也可行？ 3.5 JSX 返回目录 在 create-react-app 的文件中，不管是 index.js 中的： ReactDOM.render(, document.getElementById('root')); 还是 App.js 中的： class App extends React.Component { render() { return ( Hello React! ); } } 等这些有关 DOM 的渲染，都需要用到 JSX，因此需要引入 React： import React from 'react'; JSX 的定义： 那么，什么是 JSX 呢？ React 的核心机制之一就是可以在内存中创建虚拟的 DOM 元素。React 利用虚拟 DOM 来减少对实际 DOM 的操作从而提升性能。 JSX 就是 JavaScript 和 XML 结合的一种格式。 React 发明了 JSX，利用 HTML 语法来创建虚拟 DOM。当遇到 ，JSX 就当 HTML 解析，遇到 { 就当 JavaScript 解析。 JSX 的使用： 在 JSX 语法中，如果我们需要使用自己创建的组件，我们直接使用它的定义名即可，例如： index.js // 1. 引入 React、ReactDOM import React from 'react'; import ReactDOM from 'react-dom'; // 2. 将 App.js 导入进来 import App from './App'; // 3. 通过 ReactDOM 将 App.js 以虚拟 DOM 的形式渲染/挂载到 root 根节点，该节点在 index.html 中 ReactDOM.render(, document.getElementById('root')); 其中第三点即是自定义组件渲染到根节点。 提示：在 React 中，如果需要使用自定义组件，那么该组件不能小写开头 app，而是使用 App 这样的大写开头形式。 3.6 事件及双向数据绑定 返回目录 这是我们精简后的目录结构： 我们修改下目录结构，开始编写 TodoList： 首先，我们修改 App.js 为 TodoList.js： App.js TodoList.js import React, { Component } from 'react'; class TodoList extends Component { render() { return ( Hello React! ); } } export default TodoList; 然后，我们修改 index.js 中挂载到 index.html 的组件为 TodoList： index.js import React from 'react'; import ReactDOM from 'react-dom'; import TodoList from './TodoList'; // 3. 通过 ReactDOM 将 App.js 以虚拟 DOM 的形式渲染/挂载到 root 根节点，该节点在 index.html 中 ReactDOM.render(, document.getElementById('root')); 修改完毕，小伙伴们可以重启下 3000 端口，查看下我们的 React 是否能正常启动。 在此步骤中，我们仅仅修改 App.js 为 TodoList.js，使 index.js 挂载到 root 的是 TodoList.js，除此之外没进行其他操作。 最后，如果没有问题，那么我们进一步编写 TodoList，获取到 input 输入框的值，并渲染到列表中： TodoList.js // Fragment 是一种占位符形式，类似于 Vue 的 Template import React, { Component, Fragment } from 'react'; class TodoList extends Component { constructor(props) { super(props); this.state = { inputValue: '', list: [] } } render() { return ( {/* 单项数据绑定 */} 提交 吃饭 X 睡觉 X 打豆豆 X ) } handleInputChange(e) { console.log(e.target.value); this.setState({ inputValue: e.target.value }) } } export default TodoList; 我们先查看演示： OK，这样我们在每输入一个字符的时候，我们就能立刻获取到对应的数据，这时候实现了单向数据流：输入框 -> JS 内存。 其中有 3 点需要讲解下： Fragment 是 React 提供的一种占位符，它像 、 等标签一样，但是它在实际渲染的时候是不会出现的。因为 React 的 JSX 首层必须要有标签，然后如果使用 等会占用一个层级，所以，类似于 Vue 的 Template，React 使用了 Fragment 这种空标签。 constructor 表示父类的构造方法，在 ES6 中，构造方法 constructor 相当于其构造函数，用来新建父类的 this 对象，而 super(props) 则是用来修正 this 指向的。简而言之，我们可以在这里定义数据，并在整个 js 文件中使用。 onChange 这种写法，是 React 指定的写法，例如 onClick 等，在原生 JS 中，使用的是 onclick，而在 React 中，为了区别，需要进行半驼峰编写事件名字。同时，绑定的 handleInputChange，可以直接在 render 下面进行编写。 参考文献：《react 中 constructor() 和 super() 到底是个啥？》 这样，我们就对 React 的数据及事件有了初步理解，下面我们加下按钮点击新增列表事件以及点击 X 删除列表事件。 TodoList.js // Fragment 是一种占位符形式，类似于 Vue 的 Template import React, { Component, Fragment } from 'react'; class TodoList extends Component { // 构造函数 constructor(props) { super(props); // 定义数据 this.state = { inputValue: '', list: [] } } // 渲染页面 render() { let closeStyle = { fontSize: '1.2em', color: 'deepskyblue', marginLeft: '10px' } return ( {/* 单项数据绑定 */} {/* 在 React 中，绑定时间的，一般为半驼峰形式 */} 提交 { this.state.list.map( (item, index) => { return {index}. {item} X }) } ) } // 方法体 - 输入内容 handleInputChange(e) { this.setState({ inputValue: e.target.value }) } // 方法体 - 点击提交 handleBtnClick() { this.setState({ list: [...this.state.list, this.state.inputValue], inputValue: '' }) } // 方法体 - 删除项目 handleItemDelete(index) { const list = [...this.state.list]; list.splice(index, 1); this.setState({ list: list }) } } export default TodoList; 在这一部分，我们需要了解 3 个知识点： 在 render 中 closeStyle 这个变量，我们用来定义 CSS 属性，然后我们通过 style={closeStyle}，直接写了个行内样式（下面我们会抽离出来） 关于 JSX 遍历输出的形式： { this.state.list.map( (item, index) => { return {index}. {item} X }) } 我们通过 {} 里面循环输出 DOM 节点。如果你学过 jQuery，那么可以将它当为拼接字符串；如果你学过 Vue，那么可以将它当成 v-for 变了种写法。 在这里我们不用理会为什么这么写，我们先接受这种写法先。 关于改变 constructor 中的数据，我们使用： this.setState({ list: list }) 这种形式。其实，这也是有记忆技巧的，要知道我们在定义数据的时候，使用了： // 定义数据 this.state = { inputValue: '', list: [] } 即： this.state，那么我们需要修改数据，那就是 this.setState 了。 至此，我们的简易 TodoList 就实现了，下面我们进一步优化，将 CSS 和 JS 进一步抽取。 3.7 优化-抽取 CSS 返回目录 在上面中，我们提到 closeStyle 是一种行内的写法，作为一枚 完美编程者，我们肯定不能容忍，下面我们开始抽离： TodoList.js import React, { Component, Fragment } from 'react'; import './style.css' // ... 省略中间代码 { this.state.list.map( (item, index) => { return {index}. {item} X }) } 在这里，我们需要知道：我们可以通过 import 的形式，直接将 CSS 文件直接导入，然后，我们命名 class 的时候，因为 React 怕 JS 的 class 与 HTML 的 class 冲突，所以我们需要使用 className。 最后我们再编写下 CSS 文件： .icon-close { font-size: 1.2em; color: deepskyblue; margin-left: 10px; } 如此，我们就实现了 CSS 的抽取。 3.8 优化-抽取 JS 返回目录 在第 4 章关于组件的介绍中，我们讲到：一些复杂的 JS 是可以抽取出来，并以组件的形式，嵌入到需要放置的位置的。 那么，我们在 JSX 越写越多的情况下，是不是可以将列表渲染那部分抽取出来，从而精简下 JSX 呢？ 答案是可以的，下面我们看下实现： TodoList.js // Fragment 是一种占位符形式，类似于 Vue 的 Template import React, { Component, Fragment } from 'react'; // 引入组件 import TodoItem from './TodoItem'; // 引用样式 import './style.css'; class TodoList extends Component { // 构造函数 constructor(props) { super(props); // 定义数据 this.state = { inputValue: '', list: [] } this.handleInputChange = this.handleInputChange.bind(this); this.handleBtnClick = this.handleBtnClick.bind(this); this.handleItemDelete = this.handleItemDelete.bind(this); } // 渲染页面 render() { return ( 输入内容： {/* 单项数据绑定 */} {/* 在 React 中，绑定时间的，一般为半驼峰形式 */} 提交 {/* 精简 JSX，将部分抽取出来 */} { this.getTodoItem() } ) } // 获取单独项 getTodoItem() { return this.state.list.map( (item, index) => { return ( ) }) } // 方法体 - 输入内容 handleInputChange(e) { const value = e.target.value; this.setState( () => ({ inputValue: value })) } // 方法体 - 点击提交 handleBtnClick() { const list = this.state.list, inputValue = this.state.inputValue; this.setState( () => ({ list: [...list, inputValue], inputValue: '' })) } // 方法体 - 删除项目 handleItemDelete(index) { // immutable - state 不允许做任何改变 const list = [...this.state.list]; list.splice(index, 1); this.setState( () => ({ list: list })) } } export default TodoList; 我们关注下 TodoList.js 的改变： 我们在 constructor 中，将方法进行了提前定义： this.handleInputChange = this.handleInputChange.bind(this); 这样，我们在下面就不用写 .bind(this) 形式了。 我们修改了下 this.setState() 的形式： 原写法： this.setState({ list: list }) 现写法： this.setState( () => ({ list: list })) 因为 React 16 版本进行了更新，使用这种写法比之前的好，至于好在哪，咱先不关心，以后就用这种写法了。 我们引用了组件： import TodoItem from './TodoItem'; 并且将组件放到方法体：this.getTodoItem() 中，而 this.getTodoItem() 的定义是： // 获取单独项 getTodoItem() { return this.state.list.map( (item, index) => { return ( ) }) } 在这里我们可以看到，我们通过自定义值的形式，将数据 key、item、index 传递给了子组件 TodoItem。同时，通过 handleItemDelete，将自己的方法传递给了子组件，这样子组件就可以调用父组件的方法了： TodoItem.js import React, { Component } from 'react' class TodoItem extends Component { constructor(props) { super(props); // 这种写法可以节省性能 this.handleClick = this.handleClick.bind(this); } render() { const { item } = this.props; return ( {item} X ) } handleClick() { const { handleItemDelete, index } = this.props; handleItemDelete(index); } } export default TodoItem; 这样，我们就完成了组件的抽取，并学会了 父组件传递值给子组件 子组件调用父组件的方法 由此，我们在接下来就可以编写更丰富健全的项目了。 本文代码地址：React 系列源码地址 四 总结 返回目录 在我们学习任意一门语言中，大多就是上手 “Hello World！” 编程~ 然后做小案例的时候，我们都喜欢来个 TodoList，因为它能讲清楚一些有关基础的知识点。 现在，我们回顾下，我们开发 React 的 TodoList 有啥收获： create-react-app 的安装及开发。 组件化的思想及在 create-react-app 中关于组件化的应用。 React 关于数据 data 以及方法 methods 的定义及使用，以及如何进行数据双向绑定。 将大的组件拆分成小组件，并实现父子组件通讯（父组件传递参数给子组件，子组件调用父组件的方法） 至此，jsliang 就精通 jQuery、Vue、React 编写 TodoList 了，哈哈！ 五 参考文献 返回目录 《React.Component 与 React.PureComponent（React之性能优化）》 《visual studio code + react 开发环境搭建》 《react 中 constructor() 和 super() 到底是个啥？》 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:50:01 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/React/ReactDemoTwo-TodoListUpgrade.html":{"url":"JavaScript-library/React/ReactDemoTwo-TodoListUpgrade.html","title":"✔ React Demo Two - TodoList 升级","keywords":"","body":"React Demo Two - TodoList 升级 create by jsliang on 2019-3-26 09:26:53Recently revised in 2019-4-7 03:04:02 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 初始化项目 四 使用 Ant Design 五 使用 Redux 六 Redux 探索  6.1 Redux 插件  6.2 Redux 知识点讲解 七 Redux 探索  7.1 Input 输入数据  7.2 Button 提交数据  7.3 删除 TodoItem 列表项 八 优化：抽取 ActionType 九 优化：抽取整个 action 十 优化：UI 组件和容器组件 十一 优化：无状态组件 十二 结尾：调用 Axios，Redux-Base 完成 十三 进阶：Redux 中间件 十四 进阶：Redux-Thunk 中间件进行 ajax 请求管理 十五 进阶：Redux-Saga 中间件进行 Ajax 请求管理 十六 进阶：React-Redux 十七 总结 二 前言 返回目录 声明：该系列文章主要参考慕课网的 React 实战视频，并结合个人理解进行编写： 《React 16.4 开发简书项目从零基础入门到实战》 本次 Demo 基于 ReactDemoOne 进行了 Redux 的升级，同时会讲解到中间件 Redux-Thunk 以及 Redux-Saga，最终会使用 React-Redux 进行项目重构。 所以，没有看第一篇的小伙伴可以查看： React Demo One - TodoList 如果小伙伴想对照这源码一起看文章，可以前往下面地址下载： React 系列源码地址 注意，本文代码在 TodoListUpgrade 目录，并且它四个文件夹，分别对应： Redux-Base —— 记录 Redux 基础内容 Redux-Thunk —— 在 Redux-Base 基础上进行 redux-thunk 的中间件配置 Redux-Saga —— 在 Redux-Base 基础上进行 redux-saga 的中间件配置 React-Redux —— 对 TodoList 进行 react-redux 重新改造 Redux-Base 项目最终目录如下，小伙伴可以先创建空文件放着，后续将使用到： 三 初始化项目 返回目录 获取 React 系列 中 Simpify 目录中的代码，将其 Copy 到 Redux-Base 中，并将 App 修改为 TodoList，进行 TodoList 小改造。 下面我们开始修改： src/index.js 代码详情 ```js import React from 'react'; import ReactDOM from 'react-dom'; import TodoList from './TodoList'; ReactDOM.render(, document.getElementById('root')); ``` src/App.js TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; class TodoList extends Component { render() { return ( Hello TodoList! ); } } export default TodoList; ``` src/index.css 代码详情 ```css /* 尚未进行编写 */ ``` 此时我们在终端运行 npm run start，显示结果为： 四 使用 Ant Design 返回目录 Ant Design 官网：https://ant.design/index-cn 下面开始在 TodoList 项目中使用 Ant Design： 安装：npm i antd -S 使用： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; // 引入 React 及其 Component import './index.css'; // 引入 index.css import { Input, Button, List } from 'antd'; // 1. 引入 antd 的列表 import 'antd/dist/antd.css'; // 2. 引入 antd 的样式 // 3. 定义数据 const data = [ '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ]; class TodoList extends Component { render() { return ( TodoList {/* 4. 使用 Input、Button 组件 */} 提交 {/* 5. 使用 List 组件 */} ({index + 1} - {item})} /> ); } } export default TodoList; ``` src/index.css 代码详情 ```css .todo { width: 1000px; margin: 20px auto 0; padding: 30px; border: 1px solid #ccc; border-radius: 10px; } .todo-title { text-align: center; } .todo-action .todo-input { width: 200px; } .todo-action .todo-submit { margin-left: 10px; } .todo-list { margin-top: 30px; } ``` 在这里，我们引用 Ant Design 的步骤大致为： 引入 antd 的 Input、Button、List 组件 引入 antd 的样式 定义数据 使用 Input、Button 组件 使用 List 组件 此时页面显示为： 五 使用 Redux 返回目录 我觉得有必要在讲解 Redux 之前，我们先使用 Redux 体验一下： 安装 Redux：npm i redux -S 下面我们按照 Redux 的使用方法先试试： 在 src 目录下创建 store 目录用来存储 Redux 数据，该目录下有 reducer.js 以及 index.js 两个文件 首先，我们编写 reducer.js 文件，该文件的作用是定义并处理数据： src/store/reducer.js 代码详情 ```js // 1. 我们定义一个数据 defaultState const defaultState = { inputValue: '', todoList: [ '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ] } // 2. 我们将数据 defaultState 最终以 state 形式导出去 export default (state = defaultState, action) => { return state; } ``` 然后，我们编写 index.js 文件，该文件的作用是通过 createStore 方法创建数据仓库并导出去给 TodoList.js 使用。 src/store/index.js 代码详情 ```js import { createStore } from 'redux'; // 3. 我们引用 redux 这个库中的 createStore import reducer from './reducer'; // 4. 我们引用 reducer.js 中导出的数据 // 5. 我们通过 redux 提供的方法 reducer 来构建一个数据存储仓库 const store = createStore(reducer); // 6. 我们将 store 导出去 export default store; ``` 最后，我们在 TodoList.js 中引用 store/index.js 并到列表中进行使用，以及打印出来 store 传递给我们的数据： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; // 引入 React 及其 Component import './index.css'; // 引入 index.css import { Input, Button, List } from 'antd'; // 引入 antd 的组件 import 'antd/dist/antd.css'; // 引入 antd 的样式 import store from './store'; // 7. 引入 store，你可以理解为 store 提供数据。./store 是 ./store/index.js 的缩写 class TodoList extends Component { // 8. 在 constructor 中通过 store.getState() 方法来获取数据，并赋值为 state constructor(props) { super(props); // 9. 我们尝试在 Console 中打印 store.getState() console.log(store.getState()); this.state = store.getState(); } render() { return ( TodoList {/* 使用 Input、Button 组件 */} 提交 {/* 使用 List 组件 */} {/* 10. 将原先的 data 换成 state 中的 todoList */} ({index + 1} - {item})} /> ); } } export default TodoList; ``` 这时候，我们查看 Chrome 控制台和页面，发现它的确起作用了： 这样我们就完成了 Redux 中数据的【查询】，那么我们如何【修改】 Redux 中的数据，以及 Redux 是什么呢？我们一一道来。 六 Redux 探索 返回目录 Redux 官网：链接 Redux 中文小册：链接 如果小伙伴觉得自己看小册或者官网理解比较通透，请自行查阅，下面观点仅供参考。 6.1 Redux 插件 返回目录 安装：科学上网找到对应的 Chrome 插件，或者百度下载一个，或者通过 npm install --save-dev redux-devtools 安装它的开发者工具。 使用： 关闭浏览器，并重新打开，再打开控制台（F12），进入 Redux 栏，提示你尚未安装代码 前往 index.js 安装代码。 查看 state 中发现存有数据，此时 Redux 插件安装完毕。 src/store/index.js 代码详情 ```js import { createStore } from 'redux'; import reducer from './reducer'; // 如果安装了 Redux 工具，则在这里可以直接使用该工具 const store = createStore( reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__() ); export default store; ``` 6.2 Redux 知识点讲解 返回目录 由于 React 关于自身的定义：“用于构建用户界面的 JavaScript 库”。 所以，当我们在 React 中，如果兄弟组件需要通讯，例如上图中左侧的深色圆圈发送数据到顶部（第一排）的圆圈，我们就需要兜很多弯子，导致数据通讯非常麻烦。 而 Redux 的出现，是为了弥补这种麻烦的通讯方式：建立起一个中央机制，方便各组件之间的通讯。从而就有了上图中右侧的调度方式。 那么，Redux 是怎么个运行/工作机制呢？我们通过下面图片进行分析： 在上面图中，我们假设： 蓝色（React Component）：借书人 黄色（Action Creators）：借书动作 橙色（Store）：图书管理员 紫色（Reducers）：系统 它的流程可以理解为：首先借书人走到前台（借书动作）跟图书管理员申请借书，图书管理员帮它在系统中查找书籍资料，然后拿到电脑返回信息，最后告诉他去哪借/怎么使用。 换回正常话，即：当组件（React Components）需要调用数据的时候，它就向创造器（Action Creators）发起请求，创造器通知管理者（Store），管理者就去查找相关资料（Reducers），拿到返回的信息后，再告诉组件。 而在这过程中，我们会使用到 Redux 的一些常用/核心 API： createStore：创建 store store.dispatch：派发 action store.getState：获取 store 所有数据内容 store.subscribe：监控 store 改变，store 改变了该方法就会被执行 下面我们通过 Input 输入数据、Button 提交数据以及删除 TodoItem 列表项进一步讲解上面知识点。 七 Redux 数据修改 返回目录 现在开始通过 Input 输入数据、Button 提交数据以及删除 TodoItem 列表项讲解 Redux 数据修改。 7.1 Input 输入数据 返回目录 src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; // 引入 React 及其 Component import './index.css'; // 引入 index.css import { Input, Button, List } from 'antd'; // 引入 antd 的组件 import 'antd/dist/antd.css'; // 引入 antd 的样式 import store from './store'; // 引入 store，你可以理解为 store 提供数据。./store 是 ./store/index.js 的缩写 class TodoList extends Component { // 在 constructor 中通过 store.getState() 方法来获取数据，并赋值为 state constructor(props) { super(props); // 我们尝试在 Console 中打印 store.getState() // console.log(store.getState()); this.state = store.getState(); // 2. 定义 handleInputChange this.handleInputChange = this.handleInputChange.bind(this); // 7. 绑定方法 handleStoreChange 来处理 Redux 返回回来的数据 this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); } render() { return ( TodoList {/* 使用 Input、Button 组件 */} {/* 1. Input 绑定 handleInputChange 事件 */} 提交 {/* 使用 List 组件 */} {/* 将原先的 data 换成 state 中的 todoList */} ({index + 1} - {item})} /> ); } // 3. 编写 handleInputChange handleInputChange(e) { // 4. 通过 action，将数据传递给 store const action = { type: 'change_input_value', value: e.target.value } store.dispatch(action); } // 8. 在 handleStoreChange 中处理数据 handleStoreChange() { this.setState(store.getState()); } } export default TodoList; ``` src/store/reducer.js 代码详情 ```js // 定义一个数据 defaultState const defaultState = { inputValue: '', todoList: [ // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ] } // 将数据 defaultState 最终以 state 形式导出去 export default (state = defaultState, action) => { // 5. 打印 state 和 action console.log(state); console.log(action); // 6. 在 reducer.js 中获取数据，并 return 回去处理结果 if(action.type === 'change_input_value') { const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState } return state; } ``` 此时，我们打开控制台，一边在 Input 输入框输入内容，一边查看 Console 输出，会发现： 现在我们来分析下（或者小伙伴看着代码的备注理解下），我们修改代码的时候做了什么： 在 Input 组件中，我们为其 onChange 时绑定 handleInputChange 事件。 定义 handleInputChange 方法。 编写 handleInputChange 方法。 我们在 handleInputChange 中编写 action，通过 dispatch 将 action 从 TodoList.js 传递给 Redux 中的 reducer.js。 在 reducer.js 中打印 state 和 action。 Redux 在 reducer.js 中接收到 state 和 action，然后我们将新的 newState 返回回去（先返回到 src/store/index.js，再返回到 src/TodoList.js），期望 TodoList.js 能接受到反馈。 在 TodoList 的 constructor 中通过 store.subscribe 绑定处理 Redux 传回来的数据的处理方法 handleStoreChange。 在 handleStoreChange 中，我们直接 setState Redux 返回的 state，即 store.getState()。 这时候，我们再查看章节 6.2 的 Redux 知识点讲解，就会发现知识点通畅了。 前往：6.2 Redux 知识点讲解 参考：计数器 代码详情 ```js import { createStore } from 'redux'; /** * 这是一个 reducer，形式为 (state, action) => state 的纯函数。 * 描述了 action 如何把 state 转变成下一个 state。 * * state 的形式取决于你，可以是基本类型、数组、对象、 * 甚至是 Immutable.js 生成的数据结构。惟一的要点是 * 当 state 变化时需要返回全新的对象，而不是修改传入的参数。 * * 下面例子使用 `switch` 语句和字符串来做判断，但你可以写帮助类(helper) * 根据不同的约定（如方法映射）来判断，只要适用你的项目即可。 */ function counter(state = 0, action) { switch (action.type) { case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; } } // 创建 Redux store 来存放应用的状态。 // API 是 { subscribe, dispatch, getState }。 let store = createStore(counter); // 可以手动订阅更新，也可以事件绑定到视图层。 store.subscribe(() => console.log(store.getState()) ); // 改变内部 state 惟一方法是 dispatch 一个 action。 // action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行 store.dispatch({ type: 'INCREMENT' }); // 1 store.dispatch({ type: 'INCREMENT' }); // 2 store.dispatch({ type: 'DECREMENT' }); // 1 ``` 7.2 Button 提交数据 返回目录 下面，我们为 Input 提供回车事件，以及使用 Button 的提交事件，小伙伴们可以参照 Input 的输入事件，先自行编写，写完再查看这个章节收获会更大。 src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; // 引入 React 及其 Component import './index.css'; // 引入 index.css import { Input, Button, List } from 'antd'; // 引入 antd 的组件 import 'antd/dist/antd.css'; // 引入 antd 的样式 import store from './store'; // 引入 store，你可以理解为 store 提供数据。./store 是 ./store/index.js 的缩写 class TodoList extends Component { // 在 constructor 中通过 store.getState() 方法来获取数据，并赋值为 state constructor(props) { super(props); // 我们尝试在 Console 中打印 store.getState() // console.log(store.getState()); this.state = store.getState(); // 处理 handleInputChange 方法 this.handleInputChange = this.handleInputChange.bind(this); // 绑定方法 handleStoreChange 来处理 Redux 返回回来的数据 this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); // 2. 处理 handleAddItem 方法 this.handleAddItem = this.handleAddItem.bind(this); // 7. 处理 handleInputKeyUp 方法 this.handleInputKeyUp = this.handleInputKeyUp.bind(this); } render() { return ( TodoList {/* 使用 Input、Button 组件 */} {/* Input 绑定 handleInputChange 事件 */} {/* 6. Input 绑定回车事件：handleInputKeyUp */} {/* 1. 为 Button 定义点击执行 handleAddItem 方法 */} 提交 {/* 使用 List 组件 */} {/* 将原先的 data 换成 state 中的 todoList */} ({index + 1} - {item})} /> ); } // 编写 handleInputChange 方法 handleInputChange(e) { // 通过 dispatch(action)，将数据传递给 store const action = { type: 'change_input_value', value: e.target.value } store.dispatch(action); } // 在 handleStoreChange 中处理数据 handleStoreChange() { this.setState(store.getState()); } // 3. 编写 handleAddItem 方法 handleAddItem() { // 4. 通过 dispatch(action)，将数据传递给 store const action = { type: 'add_todo_item' } store.dispatch(action); } // 8. 为 Input 的 keyUp 方法 handleInputKeyUp 绑定 handleAddItem handleInputKeyUp(e) { if(e.keyCode === 13) { this.handleAddItem(); } } } export default TodoList; ``` src/store/reducer.js 代码详情 ```js // 定义一个数据 defaultState const defaultState = { inputValue: '', todoList: [ // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ] } // 将数据 defaultState 最终以 state 形式导出去 export default (state = defaultState, action) => { // 打印 state 和 action // console.log(state); // console.log(action); // 在 reducer.js 中获取数据，并 return 回去处理结果 if(action.type === 'change_input_value') { const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; } // 5. 在 reducer.js 中获取数据，并 return 回去处理结果 if(action.type === 'add_todo_item') { const newState = JSON.parse(JSON.stringify(state)); newState.todoList.push(newState.inputValue); newState.inputValue = ''; return newState; } return state; } ``` 这时候，我们的 Button 提交事件都处理完毕了，此时页面的功能实现： OK，我们再来梳理一遍流程： 为 Button 定义点击执行 handleAddItem 方法 处理 handleAddItem 方法 编写 handleAddItem 方法 通过 dispatch(action)，将数据传递给 store 在 reducer.js 中获取数据，并 return 回去处理结果 Input 绑定回车事件：handleInputKeyUp 处理 handleInputKeyUp 方法 为 Input 的 keyUp 方法 handleInputKeyUp 绑定 handleAddItem 值得注意的是，我们在 Input 的时候，就做过 handleStoreChange 的处理，所以我们就没有再写 store.subscribe() 来监控数据的改变，所以小伙伴们要注意整体流程。 7.3 删除 TodoItem 列表项 返回目录 那么接下来，我们再给列表项点击添加删除事件。 src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; // 引入 React 及其 Component import './index.css'; // 引入 index.css import { Input, Button, List } from 'antd'; // 引入 antd 的组件 import 'antd/dist/antd.css'; // 引入 antd 的样式 import store from './store'; // 引入 store，你可以理解为 store 提供数据。./store 是 ./store/index.js 的缩写 class TodoList extends Component { // 在 constructor 中通过 store.getState() 方法来获取数据，并赋值为 state constructor(props) { super(props); // 我们尝试在 Console 中打印 store.getState() // console.log(store.getState()); this.state = store.getState(); // 处理 handleInputChange 方法 this.handleInputChange = this.handleInputChange.bind(this); // 绑定方法 handleStoreChange 来处理 Redux 返回回来的数据 this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); // 处理 handleAddItem 方法 this.handleAddItem = this.handleAddItem.bind(this); // 处理 handleInputKeyUp 方法 this.handleInputKeyUp = this.handleInputKeyUp.bind(this); } render() { return ( TodoList {/* 使用 Input、Button 组件 */} {/* Input 绑定 handleInputChange 事件 */} {/* Input 绑定回车事件：handleInputKeyUp */} {/* 为 Button 定义点击执行 handleAddItem 方法 */} 提交 {/* 使用 List 组件 */} {/* 将原先的 data 换成 state 中的 todoList */} {/* 1. 列表点击事件绑定 handleDeleteItem 方法 */} ( {index + 1} - {item} )} /> ); } // 编写 handleInputChange 方法 handleInputChange(e) { // 通过 dispatch(action)，将数据传递给 store const action = { type: 'change_input_value', value: e.target.value } store.dispatch(action); } // 在 handleStoreChange 中处理数据 handleStoreChange() { this.setState(store.getState()); } // 编写 handleAddItem 方法 handleAddItem() { // 通过 dispatch(action)，将数据传递给 store const action = { type: 'add_todo_item' } store.dispatch(action); } // 为 Input 的 keyUp 方法 handleInputKeyUp 绑定 handleAddItem handleInputKeyUp(e) { if(e.keyCode === 13) { this.handleAddItem(); } } // 2. 编写 handleDeleteItem 方法 handleDeleteItem(index) { console.log(index); // 3. 通过 dispatch(action)，将数据传递给 store const action = { type: 'delete_todo_item', index } store.dispatch(action); } } export default TodoList; ``` src/store/reducer.js 代码详情 ```js // 定义一个数据 defaultState const defaultState = { inputValue: '', todoList: [ // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ] } // 将数据 defaultState 最终以 state 形式导出去 export default (state = defaultState, action) => { // 打印 state 和 action // console.log(state); // console.log(action); // 在 reducer.js 中获取数据，并 return 回去处理结果 if(action.type === 'change_input_value') { const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; } // 在 reducer.js 中获取数据，并 return 回去处理结果 if(action.type === 'add_todo_item') { const newState = JSON.parse(JSON.stringify(state)); newState.todoList.push(newState.inputValue); newState.inputValue = ''; return newState; } // 4. 在 reducer.js 中获取数据，并 return 回去处理结果 if(action.type === 'delete_todo_item') { const newState = JSON.parse(JSON.stringify(state)); newState.todoList.splice(action.index, 1); return newState; } return state; } ``` 现在我们先进行功能演示： 再来查看下我们的编程思路： 列表点击事件绑定 handleDeleteItem 方法。此时，由于需要绑定 this，并且传递值 index，即两个值，所以我们直接在代码中：this.handleDeleteItem.bind(this, index) 编写 handleDeleteItem 方法 通过 dispatch(action)，将数据传递给 store 在 reducer.js 中获取数据，并 return 回去处理结果 这样，我们就完成了列表项的删除。 至此，我们就熟悉了 Reudx 的数据获取以及修改方法。 八 优化：抽取 action 中的 type 返回目录 在上面章节中，我们已经完成了 TodoList 的建设，可以说我们已经搞定了。 但是，你懂的，本篇文章名为：【React Demo Two - TodoList 升级】 就是说，我们不仅要升级到 Redux，还要进一步地升级，为大型项目的开发做铺垫。 所以，本章节开始进行优化处理。 在上面代码中，我们有没有发现我们 action 的 type 是写到 TodoList.js 中的，多了后不好处理？ change_input_value add_todo_item delete_todo_item 所以我们需要进行下 type 的处理，我们在 store 目录下新增一个 actionTypes.js： src/store/actionTypes.js 代码详情 ```js // 1. 定义 actionTypes export const CHANGE_INPUT_VALUE = 'change_input_value'; export const ADD_TODO_ITEM = 'add_todo_item'; export const DELETE_TODO_ITEM = 'delete_todo_item'; ``` 然后在 TodoList.js 和 reducer.js 中使用： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; // 引入 React 及其 Component import './index.css'; // 引入 index.css import { Input, Button, List } from 'antd'; // 引入 antd 的组件 import 'antd/dist/antd.css'; // 引入 antd 的样式 import store from './store'; // 引入 store，你可以理解为 store 提供数据。./store 是 ./store/index.js 的缩写 import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM } from './actionTypes'; // 2. 引用 actionTypes class TodoList extends Component { // 在 constructor 中通过 store.getState() 方法来获取数据，并赋值为 state constructor(props) { super(props); // 我们尝试在 Console 中打印 store.getState() // console.log(store.getState()); this.state = store.getState(); // 处理 handleInputChange 方法 this.handleInputChange = this.handleInputChange.bind(this); // 绑定方法 handleStoreChange 来处理 Redux 返回回来的数据 this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); // 处理 handleAddItem 方法 this.handleAddItem = this.handleAddItem.bind(this); // 处理 handleInputKeyUp 方法 this.handleInputKeyUp = this.handleInputKeyUp.bind(this); } render() { return ( TodoList {/* 使用 Input、Button 组件 */} {/* Input 绑定 handleInputChange 事件 */} {/* Input 绑定回车事件：handleInputKeyUp */} {/* 为 Button 定义点击执行 handleAddItem 方法 */} 提交 {/* 使用 List 组件 */} {/* 将原先的 data 换成 state 中的 todoList */} {/* 列表点击事件绑定 handleDeleteItem 方法 */} ( {index + 1} - {item} )} /> ); } // 编写 handleInputChange 方法 handleInputChange(e) { // 通过 dispatch(action)，将数据传递给 store // 3. 使用 actionTypes const action = { type: CHANGE_INPUT_VALUE, value: e.target.value } store.dispatch(action); } // 在 handleStoreChange 中处理数据 handleStoreChange() { this.setState(store.getState()); } // 编写 handleAddItem 方法 handleAddItem() { // 通过 dispatch(action)，将数据传递给 store // 3. 使用 actionTypes const action = { type: ADD_TODO_ITEM } store.dispatch(action); } // 为 Input 的 keyUp 方法 handleInputKeyUp 绑定 handleAddItem handleInputKeyUp(e) { if(e.keyCode === 13) { this.handleAddItem(); } } // 编写 handleDeleteItem 方法 handleDeleteItem(index) { console.log(index); // 通过 dispatch(action)，将数据传递给 store // 3. 使用 actionTypes const action = { type: DELETE_TODO_ITEM, index } store.dispatch(action); } } export default TodoList; ``` src/store/reducer.js 代码详情 ```js import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM } from './actionTypes'; // 2. 引用 actionTypes // 定义一个数据 defaultState const defaultState = { inputValue: '', todoList: [ // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', // '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ] } // 将数据 defaultState 最终以 state 形式导出去 export default (state = defaultState, action) => { // 打印 state 和 action // console.log(state); // console.log(action); // 在 reducer.js 中获取数据，并 return 回去处理结果 // 3. 使用 actionTypes if(action.type === CHANGE_INPUT_VALUE) { const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; } // 在 reducer.js 中获取数据，并 return 回去处理结果 // 3. 使用 actionTypes if(action.type === ADD_TODO_ITEM) { const newState = JSON.parse(JSON.stringify(state)); newState.todoList.push(newState.inputValue); newState.inputValue = ''; return newState; } // 在 reducer.js 中获取数据，并 return 回去处理结果 // 3. 使用 actionTypes if(action.type === DELETE_TODO_ITEM) { const newState = JSON.parse(JSON.stringify(state)); newState.todoList.splice(action.index, 1); return newState; } return state; } ``` 另外，抽取 actionTypes.js 的意义在于，固定 action.type 值，从而不会因为在两处不同地方使用，导致报错。 九 优化：抽取整个 action 返回目录 随着代码量的增多，我们发现注释逐渐增长，所以在这里，我们先去掉所有注释，请小伙伴们自行熟悉上面章节的代码流程。 清除完毕后，我们可以发现：虽然 actionType 抽取出来了，但是当页面足够复杂的时候，我们的 action 管理起来还是非常复杂，所以我们尝试将整个 action 抽取出来。 我们在 store 目录中新建一个 actionCreators.js： src/store/actionCreators.js 代码详情 ```js // 1. 引入 actionTypes import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM } from './actionTypes' // 2. 导出相应 action export const getInputChangeAction = (value) => ({ type: CHANGE_INPUT_VALUE, value }) export const getAddItemAction = () => ({ type: ADD_TODO_ITEM }) export const getItemDeleteAction = (index) => ({ type: DELETE_TODO_ITEM, index }) ``` 机智的小伙伴，看到这里，应该就明白我们的意图了，所以，我们再修改下 TodoList.js 即可： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import { Input, Button, List } from 'antd'; import 'antd/dist/antd.css'; import store from './store'; import { getChangeInputValue, getAddTodoItem, getDeleteTodoItem } from './store/actionCreators'; // 3. 引入 actionCreators class TodoList extends Component { constructor(props) { super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); this.handleAddItem = this.handleAddItem.bind(this); this.handleInputKeyUp = this.handleInputKeyUp.bind(this); } render() { return ( TodoList 提交 ( {index + 1} - {item} )} /> ); } handleInputChange(e) { // 4. 使用 actionCreators 中的 getChangeInputValue const action = getChangeInputValue(e.target.value); store.dispatch(action); } handleStoreChange() { this.setState(store.getState()); } handleAddItem() { // 4. 使用 actionCreators 中的 getAddTodoItem const action = getAddTodoItem(); store.dispatch(action); } handleInputKeyUp(e) { if(e.keyCode === 13) { this.handleAddItem(); } } handleDeleteItem(index) { // 4. 使用 actionCreators 中的 getAddTodoItem const action = getDeleteTodoItem(index); store.dispatch(action); } } export default TodoList; ``` 这样，我们就把整个 action 抽取出来了，在大型项目中，对我们的工作会非常方便。 十 优化：UI 组件和容器组件 返回目录 现在，先抛出两个定义： UI 组件 —— 傻瓜组件，做页面的渲染 容器组件 —— 聪明组件，做页面的逻辑 我们先不多解释，进行代码拆分，再来讲解为什么会有这两个定义。 在这里，我们进行组件的拆分： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import 'antd/dist/antd.css'; import store from './store'; import { getChangeInputValue, getAddTodoItem, getDeleteTodoItem } from './store/actionCreators'; // 1. 将 Input 等 antd 的组件引入迁移到 TodoListUI，并引入 TodoListUI import TodoListUI from './TodoListUI'; class TodoList extends Component { constructor(props) { super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleAddItem = this.handleAddItem.bind(this); this.handleInputKeyUp = this.handleInputKeyUp.bind(this); this.handleDeleteItem = this.handleDeleteItem.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); } render() { return ( // 2. 编写 TodoListUI，传递参数到 TodoListUI 中 ); } handleInputChange(e) { // 解决 Antd 中的 bug e.persist(); const action = getChangeInputValue(e.target.value); store.dispatch(action); } handleStoreChange() { this.setState(store.getState()); } handleAddItem() { const action = getAddTodoItem(); store.dispatch(action); } handleInputKeyUp(e) { // 解决 Antd 中的 bug e.persist(); if(e.keyCode === 13) { this.handleAddItem(); } } handleDeleteItem(index) { // 解决 Antd 中的 bug index.persist(); const action = getDeleteTodoItem(index); store.dispatch(action); } } export default TodoList; ``` 在这里，我们将 render 中的内容抽取到子组件，该子组件在 src 目录下，叫 TodoListUI，我们将 TodoList.js 当成容器组件中，只需要将数据传递给 TodoListUI 就行了，然后我们编写 UI 组件内容： src/TodoListUI.js 代码详情 ```js // 3. 引入 Input 等组件 import React, { Component } from 'react'; import { Input, Button, List } from 'antd'; class TodoListUI extends Component { render() { return ( // 4. 接收 TodoList.js 中传递的数据 TodoList 提交 {/* 5. 在处理 handleDeleteItem 的时候需要注意，index 的值需要再进行处理 */} ( {this.props.handleDeleteItem(index)}}> {index + 1} - {item} )} /> ); } } export default TodoListUI; ``` 这样，我们就完成了 UI 组件和容器组件的拆分。 我们所做的内容有： 将 Input 等 antd 的组件引入迁移到 TodoListUI，并引入 TodoListUI 编写 TodoListUI，传递参数到 TodoListUI 中 引入 Input 等组件 接收 TodoList.js 中传递的数据 在处理 handleDeleteItem 的时候需要注意，index 的值需要再进行处理 这样，我们就完成了页面的抽取，当我们页面过多的时候，我们就将内容独立到 UI 组件中。而容器组件，则可以包含无数个 UI 组件。所以： 容器组件是聪明组件，它对整体进行了一个把控；而 UI 组件是傻瓜组件，只需要执行容器组件传递过来的事件并渲染页面即可。 十一 优化：无状态组件 返回目录 当一个组件中，只有 render() 函数，而不做其他事情的时候，我们就把它叫做无状态组件。 在 TodoList 这个项目中，我们的 TodoListUI 就只做了 render() 工作，所以可以将 TodoListUI 作为一个无状态组件： src/TodoListUI 代码详情 ```js // 1. 我们不需要 react 中的 Component 了 import React from 'react'; import { Input, Button, List } from 'antd'; // class TodoListUI extends Component { // 2. 进行无状态组件定义，然后父组件传递过来的数据，通过 props 获取 const TodoListUI = (props) => { // 3. 我们不需要进行 render 了，直接 return 就可以了 return ( // 4. 接收 TodoList.js 中传递的数据 TodoList {/* 5. 我们修改 this.props 为 props */} 提交 ( {props.handleDeleteItem(index)}}> {index + 1} - {item} )} /> ); } export default TodoListUI; ``` 在这里，大致做了 5 项工作： 我们不需要 react 中的 Component 了，所以我们去掉了 Component 进行无状态组件定义，然后父组件传递过来的数据，通过 props 获取 我们不需要进行 render 了，直接 return 就可以了 接收 TodoList.js 中传递的数据 我们修改 this.props 为 props 十二 结尾：调用 Axios，Redux-Base 完成 返回目录 终于来到最终环节，我们需要获取后端提供的接口，来进一步开发。 引入 Axios：cnpm i axios -S 在 componentDidMount 中获取接口数据，并走流程，最终渲染到页面上： TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import 'antd/dist/antd.css'; import store from './store'; // 7. 从 actionCreators 中引入 initListAction import { getChangeInputValue, getAddTodoItem, getDeleteTodoItem, initListAction } from './store/actionCreators'; import TodoListUI from './TodoListUI'; import axios from 'axios'; // 1. 引入 axios class TodoList extends Component { constructor(props) { super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleAddItem = this.handleAddItem.bind(this); this.handleInputKeyUp = this.handleInputKeyUp.bind(this); this.handleDeleteItem = this.handleDeleteItem.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); } render() { return ( ); } // 2. 在 componentDidMount() 中进行 axios 接口调用 componentDidMount() { axios.get('https://www.easy-mock.com/mock/5ca803587e5a246db3d100cb/todolist').then( (res) => { console.log(res.data.todolist); // 3. 将接口数据 dispatch 到 action 中，所以需要先前往 actionCreators.js 中创建 action // 8. 创建 action 并 dispatch 到 reducer.js 中 const action = initListAction(res.data.todolist); store.dispatch(action); }) } handleInputChange(e) { // 解决 Antd 中的 bug e.persist(); const action = getChangeInputValue(e.target.value); store.dispatch(action); } handleStoreChange() { this.setState(store.getState()); } handleAddItem() { const action = getAddTodoItem(); store.dispatch(action); } handleInputKeyUp(e) { // 解决 Antd 中的 bug e.persist(); if(e.keyCode === 13) { this.handleAddItem(); } } handleDeleteItem(index) { // 解决 Antd 中的 bug index.persist(); const action = getDeleteTodoItem(index); store.dispatch(action); } } export default TodoList; ``` actionCreators.js 代码详情 ```js // 5. 从 actionTypes 引入 INIT_LIST_ACTION import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM, INIT_LIST_ACTION } from './actionTypes'; export const getChangeInputValue = (value) => ({ type: CHANGE_INPUT_VALUE, value }) export const getAddTodoItem = () => ({ type: ADD_TODO_ITEM }) export const getDeleteTodoItem = (index) => ({ type: DELETE_TODO_ITEM, index }) // 4. 编写导出的 initListAction，所以需要先在 actionTypes 中引入 INIT_LIST_ACTION export const initListAction = (data) => ({ type: INIT_LIST_ACTION, data }) ``` actionTypes.js 代码详情 ```js export const CHANGE_INPUT_VALUE = 'change_input_value'; export const ADD_TODO_ITEM = 'add_todo_item'; export const DELETE_TODO_ITEM = 'delete_todo_item'; // 6. 导出 INIT_LIST_ACTION export const INIT_LIST_ACTION = 'init_list_action'; ``` reducer.js 代码详情 ```js // 9. 从 actionTypes 引用 INIT_LIST_ACTION import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM, INIT_LIST_ACTION } from './actionTypes'; const defaultState = { inputValue: '', todoList: [] } export default (state = defaultState, action) => { if(action.type === CHANGE_INPUT_VALUE) { const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; } if(action.type === ADD_TODO_ITEM) { const newState = JSON.parse(JSON.stringify(state)); newState.todoList.push(newState.inputValue); newState.inputValue = ''; return newState; } if(action.type === DELETE_TODO_ITEM) { const newState = JSON.parse(JSON.stringify(state)); newState.todoList.splice(action.index, 1); return newState; } // 10. 接受 TodoList 传递过来的数据，并进行处理与返回 if(action.type === INIT_LIST_ACTION) { const newState = JSON.parse(JSON.stringify(state)); newState.todoList = action.data; return newState; } return state; } ``` 这样，我们就完成了 axios 的调用，并渲染到页面上，整理出来，思路为： TodoList.js —— 引入 axios TodoList.js —— 在 componentDidMount() 中进行 axios 接口调用 TodoList.js —— 将接口数据 dispatch 到 action 中，所以需要先前往 actionCreators.js 中创建 action actionCreators.js —— 编写导出的 initListAction，所以需要先在 actionTypes 中引入 INIT_LIST_ACTION actionCreators.js —— 从 actionTypes 引入 INIT_LIST_ACTION actionTypes.js —— 导出 INIT_LIST_ACTION 到 actionCreators TodoList.js —— 从 actionCreators 中引入 initListAction TodoList.js —— 创建 action 并 dispatch 到 reducer.js 中 reducer.js —— 从 actionTypes 引用 INIT_LIST_ACTION reducer.js —— 接受 TodoList 传递过来的数据，并进行处理与返回 如此，我们就完成了接口的调用，此时页面显示如下： 到此，我们就完成了 Redux-Base。 但是，这只是简单的 Redux 的使用，我们可以感受到，仅仅使用 Redux 对于项目来说还是复杂的，所以我们需要 Redux 的中间件 Redux-Thunk 以及 Redux-Saga。并在最后尝试使用下 React-Redux。 十三 进阶：Redux 中间件 返回目录 什么是中间件？ 中间件即是安排在谁与谁之间的插件。 什么是 Redux 中间件？ 看图： 在上面图中我们可以看出，我们通过 Dispatch 将 Action 派发到 Store 的时候，我们在 Dispatch 中引用了中间件做处理。它对 Dispatch 做了封装升级，从而使得我们不仅可以在 Dispatch 使用对象，而且可以使用方法函数。 这样，当我们传递给 Dispatch 一个对象的时候，跟我们正常使用 redux 没区别。但是，当我们传递给 Dispatch 一个函数的时候，如果我们使用了 Redux-Thunk 或者 Redux-Saga 的时候，它们就会对此进行处理，从而让我们也可以调用函数。 因此，简单来说，Redux 的中间件，就是对 Dispatch 的封装升级。 十四 进阶：Redux-Thunk 中间件进行 ajax 请求管理 返回目录 在第十二章节中，我们在 TodoList 中进行了 Ajax 请求，这是可以的。 但是，随着 Ajax 请求越来越多，如果我们都在页面中编写，那么就会让页面显得臃肿。 这时候，就需要 Redux-Thunk 了。Redux-Thunk 可以把异步请求及复杂业务逻辑抽取到其他地方处理。 我们拷贝一份 Redux-Base 代码到 Redux-Thunk 目录中，并执行： 注意：不需要拷贝 node_modules 文件夹 安装依赖：npm i 运行项目：npm run start 然后，我们开始引用 Redux-Thunk： Redux Thunk：Github 地址 安装：npm i redux-thunk -S 教程小例子： test.js 代码详情 ```js import { createStore, applyMiddleware } from 'redux'; import thunk from 'redux-thunk'; import rootReducer from './reducers/index'; const store = createStore( rootReducer, applyMiddleware(thunk) ) ``` 很好看上去非常 easy 有木有，那么我们在项目中尝试一下。 src/store/index.js 代码详情 ```js // 2. 从 redux 中引入 applyMiddleware，applyMiddleware 的作用是应用 redux 中间件 // 3. 引入 compose 函数，因为我们用到了两个中间件：redux-thunk 以及 redux-devtools-extension，需要 compose 辅助 import { createStore, applyMiddleware, compose } from 'redux'; import reducer from './reducer'; // 1. 从 redux-thunk 中引入 thunk import thunk from 'redux-thunk'; // 3. 使用 redux-devtools-extension 中间件 const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose; // 4. 使用 applyMiddleware 对此进行扩展 const enhancer = composeEnhancers( applyMiddleware(thunk), ); // 5. 在 createStore 进行 enhancer 调用 const store = createStore( reducer, enhancer ); export default store; ``` 在这里，我们做了几件事： 从 redux-thunk 中引入 thunk 从 redux 中引入 applyMiddleware，applyMiddleware 的作用是应用多个 redux 中间件 引入 compose 函数，因为我们用到了两个中间件：redux-thunk 以及 redux-devtools-extension，需要 compose 辅助 使用 redux-devtools-extension 中间件 使用 applyMiddleware 对此进行扩展，即 redux-thunk 中间件加上 redux-devtools-extension 中间件 在 createStore 进行 enhancer 调用 这样，我们就同时在一个项目中使用了 redux-thunk 中间件加上 redux-devtools-extension 中间件，从而做到了 redux-thunk 的引用。 接下来，我们就要使用 redux-thunk 了 src/store/actionCreators.js 代码详情 ```js import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM, INIT_LIST_ACTION } from './actionTypes'; // 1. 把 axios 从 TodoList.js 中剪切到 actionCreators.js 中 import axios from 'axios'; export const getChangeInputValue = (value) => ({ type: CHANGE_INPUT_VALUE, value }) export const getAddTodoItem = () => ({ type: ADD_TODO_ITEM }) export const getDeleteTodoItem = (index) => ({ type: DELETE_TODO_ITEM, index }) export const initListAction = (data) => ({ type: INIT_LIST_ACTION, data }) // 2. 把 TodoList 文件中 componentDidMount() 的 axios.get() 挪到 actionCreators.js 中 // 3. 在没使用 redux-thunk 之前，我们仅可以在 actionCreators.js 中使用对象，现在我们也可以使用函数了。 export const getTodoList = () => { // 7. 当我们使用 getTodoList 的时候，我们也能传递 store 的 dispatch，从而在下面代码中使用 return (dispatch) => { axios.get('https://www.easy-mock.com/mock/5ca803587e5a246db3d100cb/todolist').then( (res) => { // 8. 直接使用 actionCreators.js 中的 initListAction方法，并 dispatch 该 action const action = initListAction(res.data.todolist); dispatch(action); }) } } ``` src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import 'antd/dist/antd.css'; import store from './store'; // 4. 在 TodoList.js 中引用 actionCreators.js 中的 getTodoList import { getChangeInputValue, getAddTodoItem, getDeleteTodoItem, getTodoList } from './store/actionCreators'; import TodoListUI from './TodoListUI'; class TodoList extends Component { constructor(props) { super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleAddItem = this.handleAddItem.bind(this); this.handleInputKeyUp = this.handleInputKeyUp.bind(this); this.handleDeleteItem = this.handleDeleteItem.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); } render() { return ( ); } componentDidMount() { // 5. 在 componentDidMount 中调用 getTodoList。如果我们没使用 redux-thunk，我们只能使用对象，但是现在我们可以使用函数了。 const action = getTodoList(); // 6. 当我们 dispatch 了 action 的时候，我们就调用了步骤 1 的 getTodoList()，从而获取了数据 store.dispatch(action); } handleInputChange(e) { const action = getChangeInputValue(e.target.value); store.dispatch(action); } handleStoreChange() { this.setState(store.getState()); } handleAddItem() { const action = getAddTodoItem(); store.dispatch(action); } handleInputKeyUp(e) { if(e.keyCode === 13) { this.handleAddItem(); } } handleDeleteItem(index) { const action = getDeleteTodoItem(index); store.dispatch(action); } } export default TodoList; ``` 看到这里，我们或许已经懵逼，所以先瞅瞅思路： 把 axios 从 TodoList.js 中剪切到 actionCreators.js 中 把 TodoList 文件中 componentDidMount() 的 axios.get() 挪到 actionCreators.js 中 在没使用 redux-thunk 之前，我们仅可以在 actionCreators.js 中使用对象，现在我们也可以使用函数了。 在 TodoList.js 中引用 actionCreators.js 中的 getTodoList()，并去除没再引用的 initListAction 在 componentDidMount() 中调用 getTodoList()。如果我们没使用 redux-thunk，我们只能使用对象，但是现在我们可以使用函数了。 当我们 dispatch 了 action 的时候，我们就调用了步骤 1 的 getTodoList()，从而获取了数据 当我们使用 getTodoList() 的时候，我们也能传递 store 的 dispatch，从而在下面代码中使用 直接使用 actionCreators.js 中的 initListAction 方法，并 dispatch 该 action 如此，我们就通过 redux-thunk，将 axios 的接口调用抽取到了 actionCreators.js 中了。 为什么我们原本在 TodoList.js 中用的好好的，到了这里要走那么多步骤把它抽取出来？ 其实我们需要知道的是，当页面足够复杂，项目足够大，代码越来越多的时候，如果我们的接口调用都在容器组件中，我们就不方便对接口进行管理，最后如果我们需要改动某个接口，我们就要在页面中慢慢查找。 通过 redux-thunk 的调用，我们就把接口代码从容器组件中抽取出来，从而做到：接口代码逻辑是接口代码逻辑，业务代码逻辑是业务代码逻辑。 而且，通过 redux-thunk 的抽取，可以方便我们的自动化测试。当然，自动化测试长啥样子，我们还不清楚，但是我们可以安慰自己的是：这样子始终是有道理的。 总结：至此，我们就完成了 Redux-Thunk 的引用及其使用，小伙伴们可以多进行尝试，进一步熟悉 Redux-Thunk。 十五 进阶：Redux-Saga 中间件进行 Ajax 请求管理 返回目录 有了 Redux-Thunk 的经验，我们也可以了解下 Redux-Saga 了。 首先我们还是从 Redux-Base 中拷贝一份文件到 Redux-Saga 目录中。 注意：不需要拷贝 node_modules 文件夹 安装依赖：npm i 运行项目：npm run start 然后，我们开始引用 Redux-Saga： Redux Saga：Github 地址 安装：npm i redux-saga -S 教程小例子： test.js 代码详情 ```js import { createStore, applyMiddleware } from 'redux' import createSagaMiddleware from 'redux-saga' import reducer from './reducers' import mySaga from './sagas' // create the saga middleware const sagaMiddleware = createSagaMiddleware() // mount it on the Store const store = createStore( reducer, applyMiddleware(sagaMiddleware) ) // then run the saga sagaMiddleware.run(mySaga) // render the application ``` 噗呲，可以看出，Redux-Saga 的引用方式跟 Redux-Thunk 一样简单。但是，请抱着接受一定复杂性的形式继续学习。 下面我们操作 store 目录下的 index.js 文件，进行 Redux-Saga 的引用： src/store/index.js 代码详情 ```js // 1. 引入 applyMiddleware 和 compose 进行多个中间件的处理 import { createStore, applyMiddleware, compose } from 'redux'; import reducer from './reducer'; // 2. 引入 redux-saga 的 createSagaMiddleware import createSagaMiddleware from 'redux-saga'; // 6. 创建并引用 store 下的 sagas.js 文件 import todoSaga from './sagas'; // 3. 调用 createSagaMiddleware 方法 const sagaMiddleware = createSagaMiddleware(); // 4. 定义 composeEnhancers const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose; // 5. 调用 composeEnhancers 进行多中间件处理 const enhancer = composeEnhancers( applyMiddleware(sagaMiddleware), ); const store = createStore( reducer, enhancer ); // 7. 使用 todoSaga sagaMiddleware.run(todoSaga); export default store; ``` src/store/sagas.js 代码详情 ```js // 8. 使用 generator 函数定义 todoSaga function* todoSaga() { } // 9. 将 generator 函数导出去 export default todoSaga; ``` 如此，我们就完成了 Redux-Saga 的引用，大致做了如下步骤： 引入 applyMiddleware 和 compose 进行多个中间件的处理 引入 redux-saga 的 createSagaMiddleware 调用 createSagaMiddleware 方法 定义 composeEnhancers 调用 composeEnhancers 进行多中间件处理 创建并引用 store 下的 sagas.js 文件的 todoSaga 通过 sagaMiddleware 使用 todoSaga 使用 generator 函数定义 sagas.js 文件 将 generator 函数导出去 同时我们观察下页面，也不存在报错，说明我们引用对了。 下面我们将 componentDidMount() 方法中的 axios.get() 这些异步接口提取到 src/store/sagas.js 中进行处理： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import 'antd/dist/antd.css'; import store from './store'; // 1. 删除 initListAction 以及下面的 axios，并引入 actionCreators.js 中的 getInitList import { getChangeInputValue, getAddTodoItem, getDeleteTodoItem, getInitList } from './store/actionCreators'; import TodoListUI from './TodoListUI'; class TodoList extends Component { constructor(props) { super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleAddItem = this.handleAddItem.bind(this); this.handleInputKeyUp = this.handleInputKeyUp.bind(this); this.handleDeleteItem = this.handleDeleteItem.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); } render() { return ( ); } componentDidMount() { // 5. 调用 getInitList，并使用 dispatch 将 action 派发出去。这时候不仅 reducer.js 可以接收到这个 action，我们的 sagas.js 也可以接收到这个 action。 const action = getInitList(); store.dispatch(action); } handleInputChange(e) { const action = getChangeInputValue(e.target.value); store.dispatch(action); } handleStoreChange() { this.setState(store.getState()); } handleAddItem() { const action = getAddTodoItem(); store.dispatch(action); } handleInputKeyUp(e) { if(e.keyCode === 13) { this.handleAddItem(); } } handleDeleteItem(index) { const action = getDeleteTodoItem(index); store.dispatch(action); } } export default TodoList; ``` src/store/actionCreators.js 代码详情 ```js // 2. 导入 actionTypes.js 中的 GET_INIT_LIST import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM, INIT_LIST_ACTION, GET_INIT_LIST } from './actionTypes'; export const getChangeInputValue = (value) => ({ type: CHANGE_INPUT_VALUE, value }) export const getAddTodoItem = () => ({ type: ADD_TODO_ITEM }) export const getDeleteTodoItem = (index) => ({ type: DELETE_TODO_ITEM, index }) export const initListAction = (data) => ({ type: INIT_LIST_ACTION, data }) // 3. 使用 GET_INIT_LIST export const getInitList = () => ({ type: GET_INIT_LIST }); ``` src/store/actionTypes.js 代码详情 ```js export const CHANGE_INPUT_VALUE = 'change_input_value'; export const ADD_TODO_ITEM = 'add_todo_item'; export const DELETE_TODO_ITEM = 'delete_todo_item'; export const INIT_LIST_ACTION = 'init_list_action'; // 4. 定义 GET_INIT_LIST 并导出给 actionTypes.js 使用 export const GET_INIT_LIST = 'get_init_list'; ``` src/store/sagas.js 代码详情 ```js // 6. 引用 redux-saga/effets 中的 takeEvery // 13. 由于我们在 sagas.js 中没有引用到 store，所以不能使用 store.dispatch()，但是 redux-saga 给我们提供了 put 方法来代替 store.dispatch() 方法 import { takeEvery, put } from 'redux-saga/effects'; // 7. 引入 GET_INIT_LIST 类型 import { GET_INIT_LIST } from './actionTypes'; // 11. 将 TodoList.js 的 axios 引入迁移到 sagas.js 中 import axios from 'axios'; // 12. 引入 actionCreator.js 中的 initListAction import { initListAction } from './actionCreators' // 8. 使用 generator 函数 function* todoSaga() { // 9. 这行代码表示，只要我们接收到 GET_INIT_LIST 的类型，我们就执行 getInitList 方法 yield takeEvery(GET_INIT_LIST, getInitList); } // 10. 定义 getInitList 方法 function* getInitList() { try { // 14. 在 sagas.js 中处理异步函数 const res = yield axios.get('https://www.easy-mock.com/mock/5ca803587e5a246db3d100cb/todolis'); const action = initListAction(res.data.todolist); // 15. 等 action 处理完之后，在执行 put 方法 yield put(action); } catch (error) { console.log(\"接口请求失败，请检查 todolist 接口。\"); } } export default todoSaga; ``` 这样，我们就把调用接口的异步请求函数，抽取到了 sagas.js 文件中，期间我们做了： TodoList.js —— 删除 initListAction 以及下面的 axios，并引入 actionCreators.js 中的 getInitList actionCreators.js —— 导入 actionTypes.js 中的 GET_INIT_LIST actionTypes.js —— 使用 GET_INIT_LIST actionTypes.js —— 定义 GET_INIT_LIST 并导出给 actionTypes.js 使用 TodoList.js —— 调用 getInitList，并使用 dispatch 将 action 派发出去。这时候不仅 reducer.js 可以接收到这个 action，我们的 sagas.js 也可以接收到这个 action。 引用 redux-saga/effets 中的 takeEvery 引入 GET_INIT_LIST 类型 使用 generator 函数 通过 takeEvery，表示只要我们接收到 GET_INIT_LIST 的类型，我们就执行 getInitList 方法 定义 getInitList 方法 将 TodoList.js 的 axios 引入迁移到 sagas.js 中 引入 actionCreator.js 中的 initListAction 由于我们在 sagas.js 中没有引用到 store，所以不能使用 store.dispatch()，但是 redux-saga 给我们提供了 put 方法来代替 store.dispatch() 方法，所以我们引用 put 方法。 在 sagas.js 中处理异步函数 等 action 处理完之后，在执行 put 方法：yield put(action) 如此，我们就成功将 TodoList 中异步请求接口抽取到了 sagas.js 中，从而对接口进行统一管理。 在 src/store/sagas.js 中，我们还通过 try...catch... 方法，对接口进行处理，当接口不存在或者请求异常的时候，我们将知道该接口出错了。 总结：至此，我们就完成了 Redux-Saga 的引用及其使用，小伙伴们可以多进行尝试，进一步熟悉 Redux-Saga。 参考文献：generator - 廖雪峰 十六 进阶：React-Redux 返回目录 在之前的章节中，我们使用了 React，也使用了 Redux，以及接触了 Redux 的中间件：Redux-Thunk 和 Redux-Saga。 那么，本章节讲解下 React-Redux。 什么是 React-Redux。 它是一个第三方模块，更方便我们在 React 中使用 Redux。 在这里，由于 React-Base 目录是 React 与 Redux 分开的，所以我们复制一份 Simplify 目录的基础代码到 React-Redux 目录中，并进行 TodoList 改造，从而开始我们的 React-Redux 之旅。 将 Simplify 改造成 TodoList 的方法可参考 第三章 初始化项目、第四章 使用 Ant Design 以及 第五章 使用 Redux。 下面 jsliang 贴出自己的初始化后的代码： src/index.js 代码详情 ```js import React from 'react'; import ReactDOM from 'react-dom'; import TodoList from './TodoList'; ReactDOM.render(, document.getElementById('root')); ``` src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import { Input, Button, List } from 'antd'; import 'antd/dist/antd.css'; import store from './store'; class TodoList extends Component { constructor(props) { super(props); this.state = store.getState(); } render() { return ( TodoList 提交 ({index + 1} - {item})} /> ); } } export default TodoList; ``` src/index.css 代码详情 ```css .todo { width: 1000px; margin: 20px auto 0; padding: 30px; border: 1px solid #ccc; border-radius: 10px; } .todo-title { text-align: center; } .todo-action .todo-input { width: 200px; } .todo-action .todo-submit { margin-left: 10px; } .todo-list { margin-top: 30px; } ``` src/store/index.js 代码详情 ```js import { createStore } from 'redux'; import reducer from './reducer'; const store = createStore(reducer); export default store; ``` src/store/reducer.js 代码详情 ```js const defaultState = { inputValue: '', list: [ '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ] } export default (state = defaultState, action) => { return state; } ``` 此时页面展示为第四章最后的页面样子： React Redux：GitHub 地址 安装 react-redux：npm i react-redux -S 是时候展现真正的技术了！ 我们在 src/index.js 中引用 react-redux： src/index.js 代码详情 ```js import React from 'react'; import ReactDOM from 'react-dom'; import TodoList from './TodoList'; // 1. 引入 react-redux 的 Provider import { Provider } from 'react-redux'; // 3. 引入 store import store from './store'; // 2. 使用 Provider 重新定义 App const App = ( // 4. Provider 连接了 store，那么 Provider 里面的组件，都可以获取和使用 store 中的内容 ) // 5. 直接渲染 App ReactDOM.render(App, document.getElementById('root')); ``` 接着可以在 src/TodoList.js 中使用： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import { Input, Button, List } from 'antd'; import 'antd/dist/antd.css'; // 6. 在 TodoList 中，我们就不需要使用 import store from store 以及定义 constructor 获取 store 了，而是通过 react-redux 的 connect 来获取 import { connect } from 'react-redux'; class TodoList extends Component { render() { return ( TodoList {/* 10. 使用 inputValue */} 提交 {/* 12. 使用 list */} ({index + 1} - {item})} /> ); } } // 8. 定义 mapStateToProps 方法，把 store 里面的数据，映射成组件里面的 props，其中参数 state 就是 store 里面的数据 const mapStateToProps = (state) => { return { // 9. 定义 inputValue inputValue: state.inputValue, // 11. 定义 list list: state.list } } // 7. 导出 connect 方法，让 TodoList 和 store 做连接，需要对应两个规则，即：mapStateToProps 和 export default connect(mapStateToProps, null)(TodoList); ``` 现在，我们发现代码仍能正常运行，我们分析下我们做了什么步骤： 引入 react-redux 的 Provider 使用 Provider 重新定义 App 引入 store Provider 连接了 store，那么 Provider 里面的组件，都可以获取和使用 store 中的内容 直接渲染 App 在 TodoList.js 中，我们就不需要使用 import store from store 以及定义 constructor 获取 store 了，而是通过 react-redux 的 connect 来获取 导出 connect 方法，让 TodoList.js 和 store 做连接，需要对应两个规则，即：mapStateToProps 和 ** 定义 mapStateToProps 方法，把 store 里面的数据，映射成组件里面的 props，其中参数 state 就是 store 里面的数据 定义 inputValue 使用 inputValue 定义 list 使用 list 如此，我们就完成了 store 通过 react-redux 在 TodoList.js 中的引用。 下面我们再试试修改 store 的值： src/TodoList.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import { Input, Button, List } from 'antd'; import 'antd/dist/antd.css'; import { connect } from 'react-redux'; class TodoList extends Component { render() { return ( TodoList {/* 3. 给 Input 绑定 onChange 事件 handleInputChange，此时我们通过 this.props 来绑定方法 */} 提交 ({index + 1} - {item})} /> ); } } const mapStateToProps = (state) => { return { inputValue: state.inputValue, list: state.list } } // 2. 定义 mapDispatchToProps 方法，该方法即是 TodoList.js 将 store.dispatch 方法映射到 props 上，所以我们就可以通过 this.props 来定义方法 // 4. 这里我们传递了 dispatch，所以就可以使用 store.dispatch 方法 const mapDispatchToProps = (dispatch) => { return { // 5. 定义 handleInputChange 方法 handleInputChange(e) { const action = { type: 'change_input_value', value: e.target.value } // 6. 将 action 派发到 reducer.js dispatch(action); } } } // 1. 使用 mapDispatchToProps 方法 export default connect(mapStateToProps, mapDispatchToProps)(TodoList); ``` 在修改 src/reducer.js： src/reducer.js 代码详情 ```js const defaultState = { inputValue: '', list: [ '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第一条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第二条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第三条 TodoList', '这是非常非常非常长的让人觉得不可思议的但是它语句通顺的第四条 TodoList', ] } export default (state = defaultState, action) => { // 7. 判断传递过来的 action.type 是哪个，进行深拷贝，获取 action.value 的值，并返回 newState if(action.type === 'change_input_value') { const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; } return state; } ``` 这时候，我们做了 7 个步骤： 在 TodoList.js 中使用了 mapDispatchToProps 方法 定义 mapDispatchToProps 方法，该方法即是 TodoList.js 将 store.dispatch 方法映射到 props 上，所以我们就可以通过 this.props 来定义方法 给 Input 绑定 onChange 事件 handleInputChange，此时我们通过 this.props 来绑定方法 在 mapDispatchToProps 中我们传递了 dispatch，所以就可以使用 store.dispatch 方法 定义 handleInputChange 方法 将 action 派发到 reducer.js 判断传递过来的 action.type 是哪个，进行深拷贝，获取 action.value 的值，并返回 newState 至此，我们就简单过了一遍 React-Redux 的使用，下面我们的 Button 按钮点击提交，以及点击 Item 项进行 TodoList 的 list 项删除功能，我们就不一一讲解了，感兴趣的小伙伴可以自行实现下，并通过下载 jsliang 的代码进行参照： React 系列文章代码地址 十七 总结 返回目录 现在，我们完成了所有的知识点、代码及其讲解，是时候可以放松聊聊了：这篇文章中我们学会了啥： Ant Design 的使用 Redux 的引入及使用 UI 组件、容器组件、无状态组件以及为了一些大型项目进行的代码抽取封装 Axios 在 React 中的使用 为了方便管理 Axios 接口代码，我们使用了 Redux 的中间件 Redux-Thunk 和 Redux-Thunk 使用 React-Redux 再过了遍 Redux 的使用，并学习 React-Redux 的使用 至此，我们就成功完结这篇文章，进入到 React 下个环节的升级进阶了。 如果小伙伴们感觉 jsliang 写得不错，记得给个 【赞】 或者给 jsliang 的文档库点个 【star】，你们的 【赞】 或者 【star】 是我满满的动力，哈哈，React 系列下篇再见！ jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-24 11:41:52 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/React/ReactDemoThree-JianShu.html":{"url":"JavaScript-library/React/ReactDemoThree-JianShu.html","title":"✔ React Demo Three - 简书","keywords":"","body":"React Demo Three - 简书 Create by jsliang on 2019-4-7 19:37:41Recently revised in 2019-04-23 09:40:45 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 本文章最终成果： 本来这只是篇纯粹的仿简书首页和文章详情页的文章，但是中间出了点情况（第十九章有提到），所以最终出来的是简书和掘金的混合体~ 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 初始化项目目录 四 创建 React 头部组件 五 编写简书头部导航 六 设置输入框动画 七 优化代码 八 使用 redux-devtools-extension 插件 九 优化：抽取 reducer.js 十 优化：抽取 action 十一 优化：immutable.js 十二 优化：redux-immutable 十三 功能实现：热门搜索 十四 代码优化 十五 解决历史遗留问题 十六 功能实现：换一换 十七 功能优化  17.1 换一换图标旋转  17.2 避免聚焦重复请求 十八 React 路由  18.1 路由（一）  18.2 路由（二） 十九 页面实现：二级导航栏 二十 页面实现：首页  20.1 多层级组件引用 store  20.2 完善整个首页 二十一 总结 二 前言 返回目录 岁月如梭，光阴荏苒。 既然决定了做某事，那就坚持下去。 相信，坚持必定有收获，不管它体现在哪个方面。 React 的学习，迈开 TodoList，进一步前行。 三 初始化项目目录 返回目录 首先，引入 Simplify 目录的内容到 JianShu 文件夹。或者前往文章 《React Demo One - TodoList》 手动进行项目简化。 我们的最终目录如下所示： 小伙伴们可以自行新建空文件，在后续不会因为不知道该文件放到哪，从而导致思路错乱。 然后，我们通过： 安装依赖：npm i 运行项目：npm run start 跑起项目来，运行结果如下所示： 接着，我们在 src 目录下引入 reset.css，去除各种浏览器的差异性影响。 src/reset.css 代码详情 ```js /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /* * 图片自适应 - image responsize * 1. 清空浏览器对图片的设置 * 2. 图片 的情况下，图片会撑高 div，这么设置可以清除该影响 */ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: 1em } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: 1em } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: 1em } /* Internet Explorer */ ``` 顺带创建一个空的全局样式 index.css 文件。 并在 index.js 中引入 reset.css 和 index.css。 src/index.js 代码详情 ```js import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; import './reset.css'; import './index.css'; ReactDOM.render(, document.getElementById('root')); ``` 四 创建 React 头部组件 返回目录 首先，在 src 目录下，新建 common 目录，并在 common 目录下，新建 header 目录，其中的 index.js 内容如下： src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; class Header extends Component { render() { return ( Header ) } } export default Header; ``` 然后，我们在 App.js 中引入 header.js： src/App.js 代码详情 ```js import React, { Component } from 'react'; import Header from './common/header'; class App extends Component { render() { return ( ); } } export default App; ``` 最后，页面显示为： 由此，我们完成了 Header 组件的创建。 五 编写简书头部导航 返回目录 首先，我们编写 src/common/header 下的 index.js： src/common/heder/index.js 代码详情 ```js import React, { Component } from 'react'; import './index.css'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { constructor(props) { super(props); this.state = { inputFocus: true } this.searchFocusOrBlur = this.searchFocusOrBlur.bind(this); } render() { return ( 首页 下载App Aa 登录 注册 写文章 ) } searchFocusOrBlur(e) { const inputFocus = this.state.inputFocus; this.setState( () => ({ inputFocus: !inputFocus })) } } export default Header; ``` 然后，我们添加 CSS 样式： src/common/heder/index.css 代码详情 ```css header { width: 100%; height: 58px; display: flex; align-items: center; border-bottom: 1px solid #ccc; font-size: 17px; } .headef_left-img { width: 100px; height: 56px; } .header_center { width: 1000px; margin: 0 auto; display: flex; justify-content: space-between; } .nav-item { margin-right: 30px; display: flex; align-items: center; } .header_center-left { display: flex; } .header_center-left-home { color: #ea6f5a; } .header_center-left-search { position: relative; } .header_center-left-search input { width: 240px; padding: 0 40px 0 20px; height: 38px; font-size: 14px; border: 1px solid #eee; border-radius: 40px; background: #eee; } .header_center-left-search .input-active { width: 280px; } .header_center-left-search i { position: absolute; top: 8px; right: 10px; } .header_center-left-search .icon-active { padding: 3px; top: 4px; border-radius: 15px; border: 1px solid #ea6f5a; } .header_center-left-search .icon-active:hover { cursor: pointer; } .header_center-right { display: flex; color: #969696; } .header_right-register, .header_right-write { width: 80px; text-align: center; height: 38px; line-height: 38px; border: 1px solid rgba(236,97,73,.7); border-radius: 20px; font-size: 15px; color: #ea6f5a; background-color: transparent; } .header_right-write { margin-left: 10px; padding-left: 10px; margin-right: 0px; color: #fff; background-color: #ea6f5a; } ``` 接着，由于图标这些，我们可以抽取到公用样式表中，所以我们在 src 目录下添加 common.css： src/common.css 代码详情 ```css .icon { display: inline-block; width: 20px; height: 21px; margin-right: 5px; } .icon-home { background: url('./resources/img/icon-home.png') no-repeat center; background-size: 100%; } .icon-write { background: url('./resources/img/icon-write.png') no-repeat center; background-size: 100%; } .icon-download { background: url('./resources/img/icon-download.png') no-repeat center; background-size: 100%; } .icon-search { background: url('./resources/img/icon-search.png') no-repeat center; background-size: 100%; } ``` 当然，我们需要位置存放图片，所以需要在 src 目录下，新建 recourses 目录，recourses 目录下存放 img 文件夹，该文件夹存放这些图标文件。 最后，我们在 src 下的 index.js 中引用 common.css src/index.js 代码详情 ```js import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; import './reset.css'; import './index.css'; import './common.css'; ReactDOM.render(, document.getElementById('root')); ``` 至此，我们页面展示为： 六 设置输入框动画 返回目录 参考地址：react-transition-group 安装动画库：npm i react-transition-group -S 修改代码： src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; // 1. 引入动画库 import { CSSTransition } from 'react-transition-group'; import './index.css'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { constructor(props) { super(props); this.state = { inputBlur: true } this.searchFocusOrBlur = this.searchFocusOrBlur.bind(this); } render() { return ( 首页 下载App {/* 2. 通过 CSSTransition 包裹 input */} Aa 登录 注册 写文章 ) } searchFocusOrBlur(e) { const inputBlur = this.state.inputBlur; this.setState( () => ({ inputBlur: !inputBlur })) } } export default Header; ``` src/common/header/index.css 代码详情 ```css header { width: 100%; height: 58px; display: flex; align-items: center; border-bottom: 1px solid #ccc; font-size: 17px; } .headef_left-img { width: 100px; height: 56px; } .header_center { width: 1000px; margin: 0 auto; display: flex; justify-content: space-between; } .nav-item { margin-right: 30px; display: flex; align-items: center; } .header_center-left { display: flex; } .header_center-left-home { color: #ea6f5a; } .header_center-left-search { position: relative; } /* 3. 编写对应的 CSS 样式 */ .slide-enter { transition: all .2s ease-out; } .slide-enter-active { width: 280px; } .slide-exit { transition: all .2s ease-out; } .silde-exit-active { width: 240px; } /* 3. 结束 */ .header_center-left-search input { width: 240px; padding: 0 40px 0 20px; height: 38px; font-size: 14px; border: 1px solid #eee; border-radius: 40px; background: #eee; } .header_center-left-search .input-active { width: 280px; } .header_center-left-search i { position: absolute; top: 8px; right: 10px; } .header_center-left-search .icon-active { padding: 3px; top: 4px; border-radius: 15px; border: 1px solid #ea6f5a; } .header_center-left-search .icon-active:hover { cursor: pointer; } .header_center-right { display: flex; color: #969696; } .header_right-register, .header_right-write { width: 80px; text-align: center; height: 38px; line-height: 38px; border: 1px solid rgba(236,97,73,.7); border-radius: 20px; font-size: 15px; color: #ea6f5a; background-color: transparent; } .header_right-write { margin-left: 10px; padding-left: 10px; margin-right: 0px; color: #fff; background-color: #ea6f5a; } ``` 这样，经过四个操作步骤： 安装动画库：npm i react-transition-group -S 引入动画库 通过 CSSTransition 包裹 input 编写对应的 CSS 样式 我们就成功实现了 CSS 动画插件的引入及使用，此时页面显示为： 七 优化代码 返回目录 安装 Redux：npm i redux -S 安装 React-Redux：npm i react-redux -S 开始在代码中加入 Redux 和 React-Redux 首先，创建 store 文件夹，并在里面创建 index.js 和 reducer.js： src/store/index.js 代码详情 ```js import { createStore } from 'redux'; import reducer from './reducer'; const store = createStore(reducer); export default store; ``` src/store/reducer.js 代码详情 ```js const defaultState = { inputBlur: true }; export default (state = defaultState, action) => { return state; } ``` 接着，在 App.js 中引用 react-redux 以及 store/index.js： src/App.js 代码详情 ```js import React, { Component } from 'react'; import { Provider } from 'react-redux'; import Header from './common/header'; import store from './store'; class App extends Component { render() { return ( ); } } export default App; ``` 然后，修改 src 下 common 中 header 里面 index.js 中的内容： src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { render() { return ( 首页 下载App Aa 登录 注册 写文章 ) } } const mapStateToProps = (state) => { return { inputBlur: state.inputBlur } } const mapDispathToProps = (dispatch) => { return { searchFocusOrBlur() { const action = { type: 'search_focus_or_blur' } dispatch(action); } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 再来，我们再修改下 reducer.js，获取并处理 src/index.js 中 dispatch 过来的值： src/store/reducer.js 代码详情 ```js const defaultState = { inputBlur: true }; export default (state = defaultState, action) => { if(action.type === 'search_focus_or_blur') { const newState = JSON.parse(JSON.stringify(state)); newState.inputBlur = !newState.inputBlur return newState; } return state; } ``` 此时，我们完成了修改的步骤。同时，这时候因为 src 下 common 中 header 里面的 index.js 中只有 render 方法体，它构成了无状态组件，所以我们将其转换成无状态组件： src/common/header/index.js 代码详情 ```js import React from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import homeImage from '../../resources/img/header-home.png'; const Header = (props) => { return ( 首页 下载App Aa 登录 注册 写文章 ) } const mapStateToProps = (state) => { return { inputBlur: state.inputBlur } } const mapDispathToProps = (dispatch) => { return { searchFocusOrBlur() { const action = { type: 'search_focus_or_blur' } dispatch(action); } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 最后，我们完成了 Redux、React-Redux 的引用及使用，以及对 header/index.js 的无状态组件的升级。 由于我们只是将必要的数据存储到 state 中，所以样式和功能无变化，故不贴出效果图。 八 使用 redux-devtools-extension 插件 返回目录 修改 src/store/index.js 如下： src/store/index.js 代码详情 ```js import { createStore, compose } from 'redux'; import reducer from './reducer'; const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose; const store = createStore(reducer, composeEnhancers()) export default store; ``` 这时候，我们就成功开启之前安装过的 redux-devtools-extension 插件。 使用一下： 九 优化：抽取 reducer.js 返回目录 在项目开发中，我们会发现 reducer.js 随着项目的开发越来越庞大，最后到不可维护的地步。 该视频的慕课讲师也提到：当你的一个 js 文件代码量超过 300 行，说明它的设计从一开始来说就是不合理的。 所以，我们要想着进一步优化它。 首先，我们在 header 目录下，新建 store，并新建 reducer.js，将 src/store 的 reducer.js 中的内容剪切到 header/store/reducer.js 中： src/common/header/store/reducer.js 代码详情 ```js // 1. 将 reducer.js 转移到 header/store/reducer.js 中 const defaultState = { inputBlur: true }; export default (state = defaultState, action) => { if(action.type === 'search_focus_or_blur') { const newState = JSON.parse(JSON.stringify(state)); newState.inputBlur = !newState.inputBlur return newState; } return state; } ``` 然后，我们修改 src/store/reducer.js 的内容为： src/store/reducer.js 代码详情 ```js // 2. 通过 combineReducers 整合多个 reducer.js 文件 import { combineReducers } from 'redux'; import headerReducer from '../common/header/store/reducer'; const reducer = combineReducers({ header: headerReducer }) export default reducer; ``` 最后，我们修改 src/common/header/index.js 内容： src/common/header/index.js 代码详情 ```js // 代码省略 。。。 const mapStateToProps = (state) => { return { // 3. 因为引用的层级变了，所以需要修改 state.inputBlur 为 state.header.inputBlue inputBlur: state.header.inputBlur } } // 代码省略 。。。 ``` 在这里，我们需要知道的是：之前我们只有一层目录，所以修改的是 state.inputBlur。 但是，因为通过 combineReducers 将 reducer.js 进行了整合，所以需要修改为 state.header.inputBlur 至此，我们就完成了 reducer.js 的优化。 十 优化：抽取 action 返回目录 首先，在 header 的 store 中新建 actionCreators.js 文件： src/common/header/store/actionCreators.js 代码详情 ```js // 1. 定义 actionCreators export const searchFocusOrBlur = () => ({ type: 'search_focus_or_blur' }) ``` 然后，我们在 header 中的 index.js 文件引入 actionCreators.js，并在 mapDispathToProps 方法体中将其 dispatch 出去： src/common/header/index.js 代码详情 ```js import React from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; // 2. 以 actionCreators 的形式将所有 action 引入进来 import * as actionCreators from './store/actionCreators'; import homeImage from '../../resources/img/header-home.png'; const Header = (props) => { return ( 首页 下载App Aa 登录 注册 写文章 ) } const mapStateToProps = (state) => { return { inputBlur: state.header.inputBlur } } const mapDispathToProps = (dispatch) => { return { searchFocusOrBlur() { // 3. 使用 actionCreators dispatch(actionCreators.searchFocusOrBlur()); } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 接着，因为我们在 actionCreators.js 中使用的 type 是字符串，所以我们同样在 store 中创建 actionTypes.js，将其变成常量： src/common/header/store/actionTypes.js 代码详情 ```js export const SEARCH_FOCUS_OR_BLUR = 'search_focus_or_blur'; ``` 再然后，我们在 actionCreators.js 中引入 actionTypes.js： src/common/header/store/actionCreators.js 代码详情 ```js // 4. 引入常量 import { SEARCH_FOCUS_OR_BLUR } from './actionTypes'; // 1. 定义 actionCreators // 5. 将 action 中的字符串修改为常量 export const searchFocusOrBlur = () => ({ type: SEARCH_FOCUS_OR_BLUR }) ``` 再接着，我们修改下 header 目录中 store 下的 reducer.js，因为我们的字符串变成了常量，所以这里也需要做相应变更： src/common/header/store/reducer.js 代码详情 ```js // 6. 引入常量 import * as actionTypes from './actionTypes' const defaultState = { inputBlur: true }; export default (state = defaultState, action) => { // 7. 使用常量 if(action.type === actionTypes.SEARCH_FOCUS_OR_BLUR) { const newState = JSON.parse(JSON.stringify(state)); newState.inputBlur = !newState.inputBlur return newState; } return state; } ``` 然后，我们现在 header/store 目录下有：actionCreators.js、actionTypes.js、reducer.js 三个文件，如果我们每次引入都要一个一个找，那是相当麻烦的，所以我们在 header/store 目录下再新建一个 index.js，通过 index.js 来管理这三个文件，这样我们其他页面需要引入它们的时候，我们只需要引入 store 下的 index.js 即可。 src/common/header/store/index.js 代码详情 ```js // 8. 统一管理 store 目录中的文件 import * as actionCreators from './actionCreators'; import * as actionTypes from './actionTypes'; import reducer from './reducer'; export { actionCreators, actionTypes, reducer }; ``` 此时，值得注意的是，这时候我们需要处理下 header/index.js 文件： 代码详情 ```js import React from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; // 2. 以 actionCreators 的形式将所有 action 引入进来 // import * as actionCreators from './store/actionCreators'; // 9. 引入 store/index 文件即可 import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; // 代码省略 ``` 最后，再处理下 src/store/reducer.js，因为它引用了 common/header/store 中的 reducer.js： 代码详情 ```js import { combineReducers } from 'redux'; // 10. 修改下引用方式 import { reducer as headerReducer } from '../common/header/store'; const reducer = combineReducers({ header: headerReducer }) export default reducer; ``` 至此，我们就完成了本次的优化抽取。 十一 优化；immutable.js 返回目录 在我们工作的过程中，如果一不小心，就会修改了 reducer.js 中的数据（平时开发的时候，我们会通过 JSON.parse(JSON.stringify()) 来进行深拷贝，获取一份额外的来进行修改）。 所以，这时候，我们就需要使用 immutable.js，它是由 Facebook 团队开发的，用来帮助我们生产 immutable 对象，从而限制 state 不可被改变。 安装 immutable.js：npm i immutable -S。 案例 immutable.js： const { Map } = require('immutable'); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = map1.set('b', 50); map1.get('b') + \" vs. \" + map2.get('b'); // 2 vs. 50 看起来很简单，我们直接在简书 Demo 中使用： src/common/header/store/reducer.js 代码详情 ```js import * as actionTypes from './actionTypes' // 1. 通过 immutable 引入 fromJS import { fromJS } from 'immutable'; // 2. 对 defaultState 使用 fromJS const defaultState = fromJS({ inputBlur: true }); export default (state = defaultState, action) => { if(action.type === actionTypes.SEARCH_FOCUS_OR_BLUR) { // const newState = JSON.parse(JSON.stringify(state)); // newState.inputBlur = !newState.inputBlur // return newState; // 4. 通过 immutable 的方法来 set state 的值 // immutable 对象的 set 方法，会结合之前 immutable 对象的值和设置的值，返回一个全新的对象 return state.set('inputBlur', !state.get('inputBlur')); } return state; } ``` src/common/header/index.js 代码详情 ```js import React from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; const Header = (props) => { return ( 首页 下载App Aa 登录 注册 写文章 ) } const mapStateToProps = (state) => { return { // 3. 通过 immutable 提供的 get() 方法来获取 inputBlur 属性 inputBlur: state.header.get('inputBlur') } } const mapDispathToProps = (dispatch) => { return { searchFocusOrBlur() { dispatch(actionCreators.searchFocusOrBlur()); } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 我们大致做了四个步骤，从而完成了 immutable.js 的引用及使用： 通过 import immutable 引入 fromJS 对 defaultState 使用 fromJS 这时候我们就不能直接修改 matStateToProps 中的值了，而是 通过 immutable 提供的 get() 方法来获取 inputBlur 属性 通过 immutable 的方法来 set state 的值。immutable 对象的 set 方法，会结合之前 immutable 对象的值和设置的值，返回一个全新的对象 这样，我们就成功保护了 state 的值。 十二 优化：redux-immutable 返回目录 当然，在上面，我们保护了 header 中的 state，我们在代码中： inputBlur: state.header.get('inputBlur') 这个 header 也是 state 的值，所以我们也需要对它进行保护，所以我们就需要 redux-immutable 安装 redux-immutable：npm i redux-immutable -S 使用 redux-immutable： src/store/reducer.js 代码详情 ```js // import { combineReducers } from 'redux'; // 1. 通过 redux-immutable 引入 combineReducers 而非原先的 redux import { combineReducers } from 'redux-immutable'; import { reducer as headerReducer } from '../common/header/store'; const reducer = combineReducers({ header: headerReducer }) export default reducer; ``` src/common/header/index.js 代码详情 ```js // 代码省略。。。 const mapStateToProps = (state) => { return { // 2. 通过同样的 get 方法来获取 header inputBlur: state.get('header').get('inputBlur') } } // 代码省略。。。 ``` 这样，通过简单的三个步骤，我们就保护了主 state 的值： 安装 redux-immutable：npm i redux-immutable -S 通过 redux-immutable 引入 combineReducers 而非原先的 redux 通过同样的 get 方法来获取 header 十三 功能实现：热门搜索 返回目录 本章节完成三个功能： 写热门搜索显示隐藏 安装 redux-thunk 使用 React 中 Node 提供的作假数据的功能，在 public/api 下写个文件 headerList.json，并做假数据，使用方式为 axios.get('/api/headerList.json').then() 首先，我们完成热门搜索的显示隐藏： src/common.css 代码详情 ```css .icon { display: inline-block; width: 20px; height: 21px; margin-right: 5px; } .icon-home { background: url('./resources/img/icon-home.png') no-repeat center; background-size: 100%; } .icon-write { background: url('./resources/img/icon-write.png') no-repeat center; background-size: 100%; } .icon-download { background: url('./resources/img/icon-download.png') no-repeat center; background-size: 100%; } .icon-search { background: url('./resources/img/icon-search.png') no-repeat center; background-size: 100%; } .display-hide { display: none; } .display-show { display: block; } ``` src/common/header/index.css 代码详情 ```css header { width: 100%; height: 58px; display: flex; align-items: center; border-bottom: 1px solid #ccc; font-size: 17px; } /* 头部左边 */ .header_left-img { width: 100px; height: 56px; } /* 头部中间 */ .header_center { width: 1000px; margin: 0 auto; display: flex; justify-content: space-between; } .nav-item { margin-right: 30px; display: flex; align-items: center; } /* 头部中间左部 */ .header_center-left { display: flex; } /* 头部中间左部 - 首页 */ .header_center-left-home { color: #ea6f5a; } /* 头部中间左部 - 搜索框 */ .header_center-left-search { position: relative; } .slide-enter { transition: all .2s ease-out; } .slide-enter-active { width: 280px; } .slide-exit { transition: all .2s ease-out; } .silde-exit-active { width: 240px; } .header_center-left-search input { width: 240px; padding: 0 45px 0 20px; height: 38px; font-size: 14px; border: 1px solid #eee; border-radius: 40px; background: #eee; } .header_center-left-search .input-active { width: 280px; } .header_center-left-search .icon-search { position: absolute; top: 8px; right: 10px; } .header_center-left-search .icon-active { padding: 3px; top: 4px; border-radius: 15px; border: 1px solid #ea6f5a; } /* 头部中间左部 - 热搜 */ .header_center-left-search .icon-active:hover { cursor: pointer; } .header_center-left-hot-search:before { content: \"\"; left: 27px; width: 10px; height: 10px; transform: rotate(45deg); top: -5px; z-index: -1; position: absolute; background-color: #fff; box-shadow: 0 0 8px rgba(0,0,0,.2); } .header_center-left-hot-search { position: absolute; width: 250px; left: 0; top: 125%; padding: 15px; font-size: 14px; background: #fff; border-radius: 4px; box-shadow: 0 0 8px rgba(0, 0, 0, 0.2); } .header_center-left-hot-search-title { display: flex; justify-content: space-between; color: #969696; } .header_center-left-hot-search-change { display: flex; justify-content: space-between; align-items: center; } .icon-change { display: inline-block; width: 20px; height: 14px; background: url('../../resources/img/icon-change.png') no-repeat center; background-size: 100%; } .icon-change:hover { cursor: pointer; } .header_center-left-hot-search-content span { display: inline-block; margin-top: 10px; margin-right: 10px; padding: 2px 6px; font-size: 12px; color: #787878; border: 1px solid #ddd; border-radius: 3px; } .header_center-left-hot-search-content span:hover { cursor: pointer; } /* 头部中间右部 */ .header_center-right { display: flex; color: #969696; } /* 头部右边 */ .header_right-register, .header_right-write { width: 80px; text-align: center; height: 38px; line-height: 38px; border: 1px solid rgba(236,97,73,.7); border-radius: 20px; font-size: 15px; color: #ea6f5a; background-color: transparent; } .header_right-write { margin-left: 10px; padding-left: 10px; margin-right: 0px; color: #fff; background-color: #ea6f5a; } ``` src/common/header/index.js 代码详情 ```js import React from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; const Header = (props) => { return ( 首页 下载App {/* 添加热搜模块 */} 热门搜索 换一批 考研 慢死人 悦心 一致 是的 jsliang Aa 登录 注册 写文章 ) } const mapStateToProps = (state) => { return { inputBlur: state.get('header').get('inputBlur') } } const mapDispathToProps = (dispatch) => { return { searchFocusOrBlur() { dispatch(actionCreators.searchFocusOrBlur()); } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 由此，我们完成了热门搜索的显示隐藏： PS：由于页面逐渐增大，所以我们 header 中使用无状态组件已经满足不了我们要求了，我们需要将无状态组件改成正常的组件： src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { render() { return ( 首页 下载App 热门搜索 换一批 考研 慢死人 悦心 一致 是的 jsliang Aa 登录 注册 写文章 ) } } const mapStateToProps = (state) => { return { inputBlur: state.get('header').get('inputBlur') } } const mapDispathToProps = (dispatch) => { return { searchFocusOrBlur() { dispatch(actionCreators.searchFocusOrBlur()); } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 然后，由于我们的数据是从接口模拟过来的，而在上一篇文章说过，如果要对接口代码进行管理，最好使用 Redux-Thunk 和 Redux-Saga，这里我们使用 Redux-Thunk： 安装 redux-thunk：cnpm i redux-thunk -S 安装 axios：cnpm i axios -S 在这里，我们要知道 create-react-app 的配置是包含 Node.js 的，所以我们可以依靠 Node.js 进行开发时候的 Mock 数据。 下面开始开发： src/store/index.js 代码详情 ```js // 2. 引入 redux 的 applyMiddleware，进行多中间件的使用 import { createStore, compose, applyMiddleware } from 'redux'; // 1. 引入 redux-thunk import thunk from 'redux-thunk'; import reducer from './reducer'; const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose; // 3. 通过 applyMiddleware 同时使用 redux-thunk 和 redux-dev-tools const store = createStore(reducer, composeEnhancers( applyMiddleware(thunk) )); export default store; ``` 引入 redux-thunk 引入 redux 的 applyMiddleware，进行多中间件的使用 通过 applyMiddleware 同时使用 redux-thunk 和 redux-dev-tools 这样，我们就可以正常使用 redux-thunk 了。 src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { render() { return ( 首页 下载App 热门搜索 换一批 {/* 15. 遍历输出该数据 */} { this.props.list.map((item) => { return {item} }) } Aa 登录 注册 写文章 ) } } const mapStateToProps = (state) => { return { inputBlur: state.get('header').get('inputBlur'), // 14. 获取 reducer.js 中的 list 数据 list: state.get('header').get('list') } } const mapDispathToProps = (dispatch) => { return { searchFocusOrBlur() { // 4. 派发 action 到 actionCreators.js 中的 getList() 方法 dispatch(actionCreators.getList()); dispatch(actionCreators.searchFocusOrBlur()); } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` src/common/header/store/actionCreators.js 代码详情 ```js import * as actionTypes from './actionTypes' // 7. 引入 axios import axios from 'axios'; // 11. 引入 immutable 的类型转换 import { fromJS } from 'immutable'; export const searchFocusOrBlur = () => ({ type: actionTypes.SEARCH_FOCUS_OR_BLUR }) // 10. 定义 action，接受参数 data，同时因为我们使用了 Immutable，所以需要将获取的数据转换为 immutable 类型 const changeList = (data) => ({ type: actionTypes.GET_LIST, data: fromJS(data) }) // 5. 编写 getList 的 action，由于需要 actionTypes 中定义，所以前往 actionTypes.js 中新增 export const getList = () => { return (dispatch) => { // 8. 调用 create-react-app 中提供的 Node 服务器，从而 mock 数据 axios.get('/api/headerList.json').then( (res) => { if(res.data.code === 0) { const data = res.data.list; // 由于数据太多，我们限制数据量为 15 先 data.length = 15; // 12. 派发 changeList 类型 dispatch(changeList(data)); } }).catch( (error) => { console.log(error); }); } } ``` src/common/header/store/actionTypes.js 代码详情 ```js export const SEARCH_FOCUS_OR_BLUR = 'header/search_focus_or_blur'; // 6. 新增 actionType export const GET_LIST = 'header/get_list'; ``` src/common/header/store/reducer.js 代码详情 ```js import * as actionTypes from './actionTypes' import { fromJS } from 'immutable'; const defaultState = fromJS({ inputBlur: true, // 9. 给 header 下的 reducer.js 提供存储数据的地方 list: [] }); export default (state = defaultState, action) => { if(action.type === actionTypes.SEARCH_FOCUS_OR_BLUR) { return state.set('inputBlur', !state.get('inputBlur')); } // 13. 判断 actionTypes 是否为 GET_LIST，如果是则执行该 action if(action.type === actionTypes.GET_LIST) { return state.set('list', action.data); } return state; } ``` public/api/headerList.json 代码详情 ```js { \"code\": 0, \"list\": [\"区块链\",\"小程序\",\"vue\",\"毕业\",\"PHP\",\"故事\",\"flutter\",\"理财\",\"美食\",\"投稿\",\"手帐\",\"书法\",\"PPT\",\"穿搭\",\"打碗碗花\",\"简书\",\"姥姥的澎湖湾\",\"设计\",\"创业\",\"交友\",\"籽盐\",\"教育\",\"思维导图\",\"疯哥哥\",\"梅西\",\"时间管理\",\"golang\",\"连载\",\"自律\",\"职场\",\"考研\",\"慢世人\",\"悦欣\",\"一纸vr\",\"spring\",\"eos\",\"足球\",\"程序员\",\"林露含\",\"彩铅\",\"金融\",\"木风杂谈\",\"日更\",\"成长\",\"外婆是方言\",\"docker\"] } ``` 通过下面步骤： 派发 action 到 actionCreators.js 中的 getList() 方法 编写 getList 的 action，由于需要 actionTypes 中定义，所以前往 actionTypes.js 中新增 新增 actionType 引入 axios 调用 create-react-app 中提供的 Node 服务器，从而 mock 数据 给 header 下的 reducer.js 提供存储数据的地方 定义 action，接受参数 data，同时因为我们使用了 Immutable，所以需要将获取的数据转换为 immutable 类型 引入 Immutable 的类型转换 派发 changeList 类型 判断 actionTypes 是否为 GET_LIST，如果是则执行该 action 获取 reducer.js 中的 list 数据 遍历输出该数据 这样，我们就成功地获取了 mock 提供的数据： 十四 代码优化 返回目录 reducer.js 中使用 switch...case... 替换掉 if... 语句。 src/common/header/store/reducer.js 代码详情 ```js import * as actionTypes from './actionTypes' import { fromJS } from 'immutable'; const defaultState = fromJS({ inputBlur: true, list: [] }); export default (state = defaultState, action) => { switch(action.type) { case actionTypes.SEARCH_FOCUS_OR_BLUR: return state.set('inputBlur', !state.get('inputBlur')); case actionTypes.GET_LIST: return state.set('list', action.data); default: return state; } } ``` 十五 解决历史遗留问题 返回目录 在这里，我们解决下历史遗留问题：在我们失焦于输入框的时候，我们的【热门搜索】模块就会消失，从而看不到我们点击【换一换】按钮的效果，所以我们需要修改下代码，在我们鼠标在【热门模块】中时，这个模块不会消失，当我们鼠标失焦且鼠标不在热门模块中时，热门模块才消失。 src/common/header/store/reducer.js 代码详情 ```js import * as actionTypes from './actionTypes' import { fromJS } from 'immutable'; const defaultState = fromJS({ inputFocus: false, // 1. 设置鼠标移动到热门模块为 false mouseInHot: false, list: [], }); export default (state = defaultState, action) => { switch(action.type) { case actionTypes.SEARCH_FOCUS: return state.set('inputFocus', true); case actionTypes.SEARCH_BLUR: return state.set('inputFocus', false); case actionTypes.GET_LIST: return state.set('list', action.data); // 6. 在 reducer.js 中判断这两个 action 执行设置 mouseInHot case actionTypes.ON_MOUSE_ENTER_HOT: return state.set('mouseInHot', true); case actionTypes.ON_MOUSE_LEAVE_HOT: return state.set('mouseInHot', false); default: return state; } } ``` src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { render() { return ( 首页 下载App {/* 8. 在判断中加多一个 this.props.mouseInHot，这样只要有一个为 true，它就不会消失 */} 热门搜索 换一批 { this.props.list.map((item) => { return {item} }) } Aa 登录 注册 写文章 ) } } const mapStateToProps = (state) => { return { inputFocus: state.get('header').get('inputFocus'), list: state.get('header').get('list'), // 7. 在 index.js 中获取 mouseInHot: state.get('header').get('mouseInHot'), } } const mapDispathToProps = (dispatch) => { return { searchFocus() { dispatch(actionCreators.getList()); dispatch(actionCreators.searchFocus()); }, searchBlur() { dispatch(actionCreators.searchBlur()); }, // 3. 定义 onMouseEnterHot 和 onMouseLeaveHot 方法 onMouseEnterHot() { dispatch(actionCreators.onMouseEnterHot()); }, onMouseLeaveHot() { dispatch(actionCreators.onMouseLeaveHot()); }, } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` src/common/header/store/actionCreators.js 代码详情 ```js import * as actionTypes from './actionTypes' import axios from 'axios'; import { fromJS } from 'immutable'; export const searchFocus = () => ({ type: actionTypes.SEARCH_FOCUS }) export const searchBlur = () => ({ type: actionTypes.SEARCH_BLUR }) // 4. 在 actionCreators.js 中定义这两个方法：onMouseEnterHot 和 onMouseLeaveHot export const onMouseEnterHot = () => ({ type: actionTypes.ON_MOUSE_ENTER_HOT, }) export const onMouseLeaveHot = () => ({ type: actionTypes.ON_MOUSE_LEAVE_HOT, }) export const getList = () => { return (dispatch) => { axios.get('/api/headerList.json').then( (res) => { if(res.data.code === 0) { const data = res.data.list; // 由于数据太多，我们限制数据量为 15 先 data.length = 15; dispatch(changeList(data)); } }).catch( (error) => { console.log(error); }); } } const changeList = (data) => ({ type: actionTypes.GET_LIST, data: fromJS(data) }) ``` src/common/header/store/actionTypes.js 代码详情 ```js export const SEARCH_FOCUS = 'header/search_focus'; export const SEARCH_BLUR = 'header/search_blur'; export const GET_LIST = 'header/get_list'; // 5. 在 actionTypes.js 中新增 action 类型 export const ON_MOUSE_ENTER_HOT = 'header/on_mouse_enter_hot'; export const ON_MOUSE_LEAVE_HOT = 'header/on_mouse_leave_hot'; ``` 我们先看实现： 然后我们看看实现逻辑： 在 reducer.js 中设置鼠标移动到热门模块为 false 在 index.js 中设置移入为 onMouseEnterHot，移出为 onMouseLeaveHot 在 index.js 中 mapDispathToProps 定义 onMouseEnterHot 和 onMouseLeaveHot 方法 在 actionCreators.js 中定义这两个方法：onMouseEnterHot 和 onMouseLeaveHot 在 actionTypes.js 中新增 action 类型 在 reducer.js 中判断这两个 action 执行设置 mouseInHot 在 index.js 中 mapStateToProps 获取 mouseInHot 在 index.js 中的判断中加多一个 this.props.mouseInHot，这样只要有一个为 true，它就不会消失 注意：由于之前设置的 this.props.inputFoucsOrBlur 会造成聚焦和失焦都会调用一次接口，而且逻辑比较复杂，容易出错，所以这里我们进行了修改，将其分为聚焦和失焦两部分。 十六 功能实现：换一换 返回目录 下面我们开始做换一换功能： src/common/header/store/reducer.js 代码详情 ```js import * as actionTypes from './actionTypes' import { fromJS } from 'immutable'; const defaultState = fromJS({ inputFocus: false, mouseInHot: false, list: [], // 1. 在 reducer.js 中设置页数和总页数 page: 1, totalPage: 1, }); export default (state = defaultState, action) => { switch(action.type) { case actionTypes.SEARCH_FOCUS: return state.set('inputFocus', true); case actionTypes.SEARCH_BLUR: return state.set('inputFocus', false); case actionTypes.GET_LIST: // 4. 我们通过 merge 方法同时设置多个 state 值 return state.merge({ list: action.data, totalPage: action.totalPage }); case actionTypes.ON_MOUSE_ENTER_HOT: return state.set('mouseInHot', true); case actionTypes.ON_MOUSE_LEAVE_HOT: return state.set('mouseInHot', false); // 11. 判断 action 类型，并进行设置 case actionTypes.CHANGE_PAGE: return state.set('page', action.page + 1); default: return state; } } ``` src/common/header/store/actionCreators.js 代码详情 ```js import * as actionTypes from './actionTypes' import axios from 'axios'; import { fromJS } from 'immutable'; export const searchFocus = () => ({ type: actionTypes.SEARCH_FOCUS }) export const searchBlur = () => ({ type: actionTypes.SEARCH_BLUR }) export const onMouseEnterHot = () => ({ type: actionTypes.ON_MOUSE_ENTER_HOT, }) export const onMouseLeaveHot = () => ({ type: actionTypes.ON_MOUSE_LEAVE_HOT, }) export const getList = () => { return (dispatch) => { axios.get('/api/headerList.json').then( (res) => { if(res.data.code === 0) { const data = res.data.list; // 2. 由于数据太多，我们之前限制数据量为 15，这里我们去掉该行代码 // data.length = 15; dispatch(changeList(data)); } }).catch( (error) => { console.log(error); }); } } const changeList = (data) => ({ type: actionTypes.GET_LIST, data: fromJS(data), // 3. 我们在这里计算总页数 totalPage: Math.ceil(data.length / 10) }) // 9. 定义 changePage 方法 export const changePage = (page) => ({ type: actionTypes.CHANGE_PAGE, page: page, }) ``` src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { render() { return ( 首页 下载App 热门搜索 {/* 7. 进行换页功能实现，传递参数 page 和 totalPage */} this.props.changePage(this.props.page, this.props.totalPage)}> 换一批 { // 6. 在 index.js 中进行计算： // 一开始显示 0-9 共 10 条，换页的时候显示 10-19 ……以此类推 this.props.list.map((item, index) => { if(index >= (this.props.page - 1) * 10 && index {item} } else { return ''; } }) } Aa 登录 注册 写文章 ) } } const mapStateToProps = (state) => { return { inputFocus: state.get('header').get('inputFocus'), list: state.get('header').get('list'), mouseInHot: state.get('header').get('mouseInHot'), // 5. 在 index.js 中 mapStateToProps 获取数据 page: state.get('header').get('page'), totalPage: state.get('header').get('totalPage'), } } const mapDispathToProps = (dispatch) => { return { searchFocus() { dispatch(actionCreators.getList()); dispatch(actionCreators.searchFocus()); }, searchBlur() { dispatch(actionCreators.searchBlur()); }, onMouseEnterHot() { dispatch(actionCreators.onMouseEnterHot()); }, onMouseLeaveHot() { dispatch(actionCreators.onMouseLeaveHot()); }, // 8. 调用 changePage 方法 changePage(page, totalPage) { if(page === totalPage) { page = 1; dispatch(actionCreators.changePage(page)); } else { dispatch(actionCreators.changePage(page)); } } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` src/common/header/store/actionTypes.js 代码详情 ```js export const SEARCH_FOCUS = 'header/search_focus'; export const SEARCH_BLUR = 'header/search_blur'; export const GET_LIST = 'header/get_list'; export const ON_MOUSE_ENTER_HOT = 'header/on_mouse_enter_hot'; export const ON_MOUSE_LEAVE_HOT = 'header/on_mouse_leave_hot'; // 10. 定义 action export const CHANGE_PAGE = 'header/change_page'; ``` 此时我们代码思路是： 在 reducer.js 中设置页数 page 和总页数 totalPage 在 actionCreators.js 中，之前由于数据太多，我们之前限制数据量为 15，这里我们去掉该行代码 在 actionCreators.js 这里计算总页数 在 reducer.js 中通过 merge 方法同时设置多个 state 值 在 index.js 中 mapStateToProps 获取数据 在 index.js 中进行计算：一开始显示 0-9 共 10 条，换页的时候显示 10-19 ……以此类推 在 index.js 中进行换页功能实现，传递参数 page 和 totalPage 在 index.js 调用 changePage 方法，进行是否重置为第一页判断，并 dispatch 方法 在 actionCreators.js 中定义 changePage 方法 在 actionTypes.js 中定义 action 在 reducer.js 中判断 action 类型，并进行设置 如此，我们就实现了换一换功能： 十七 功能优化 返回目录 17.1 换一换图标旋转 返回目录 src/common/header/index.css 代码详情 ```css header { width: 100%; height: 58px; display: flex; align-items: center; border-bottom: 1px solid #ccc; font-size: 17px; } /* 头部左边 */ .header_left-img { width: 100px; height: 56px; } /* 头部中间 */ .header_center { width: 1000px; margin: 0 auto; display: flex; justify-content: space-between; } .nav-item { margin-right: 30px; display: flex; align-items: center; } /* 头部中间左部 */ .header_center-left { display: flex; } /* 头部中间左部 - 首页 */ .header_center-left-home { color: #ea6f5a; } /* 头部中间左部 - 搜索框 */ .header_center-left-search { position: relative; } .slide-enter { transition: all .2s ease-out; } .slide-enter-active { width: 280px; } .slide-exit { transition: all .2s ease-out; } .silde-exit-active { width: 240px; } .header_center-left-search input { width: 240px; padding: 0 45px 0 20px; height: 38px; font-size: 14px; border: 1px solid #eee; border-radius: 40px; background: #eee; } .header_center-left-search .input-active { width: 280px; } .header_center-left-search .icon-search { position: absolute; top: 8px; right: 10px; } .header_center-left-search .icon-active { padding: 3px; top: 4px; border-radius: 15px; border: 1px solid #ea6f5a; } /* 头部中间左部 - 热搜 */ .header_center-left-search .icon-active:hover { cursor: pointer; } .header_center-left-hot-search:before { content: \"\"; left: 27px; width: 10px; height: 10px; transform: rotate(45deg); top: -5px; z-index: -1; position: absolute; background-color: #fff; box-shadow: 0 0 8px rgba(0,0,0,.2); } .header_center-left-hot-search { position: absolute; width: 250px; left: 0; top: 125%; padding: 15px; font-size: 14px; background: #fff; border-radius: 4px; box-shadow: 0 0 8px rgba(0, 0, 0, 0.2); } .header_center-left-hot-search-title { display: flex; justify-content: space-between; color: #969696; } .header_center-left-hot-search-change { display: flex; justify-content: space-between; align-items: center; } .icon-change { display: inline-block; width: 20px; height: 14px; background: url('../../resources/img/icon-change.png') no-repeat center; background-size: 100%; /* 1. 在 index.css 中添加动画 */ transition: all .2s ease-in; transform-origin: center center; } .icon-change:hover { cursor: pointer; } .span-change:hover { cursor: pointer; } .header_center-left-hot-search-content span { display: inline-block; margin-top: 10px; margin-right: 10px; padding: 2px 6px; font-size: 12px; color: #787878; border: 1px solid #ddd; border-radius: 3px; } .header_center-left-hot-search-content span:hover { cursor: pointer; } /* 头部中间右部 */ .header_center-right { display: flex; color: #969696; } /* 头部右边 */ .header_right-register, .header_right-write { width: 80px; text-align: center; height: 38px; line-height: 38px; border: 1px solid rgba(236,97,73,.7); border-radius: 20px; font-size: 15px; color: #ea6f5a; background-color: transparent; } .header_right-write { margin-left: 10px; padding-left: 10px; margin-right: 0px; color: #fff; background-color: #ea6f5a; } ``` src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { render() { return ( 首页 下载App 热门搜索 {/* 2. 在 index.js 中给 i 标签添加 ref，并通过 changePage 方法传递过去 */} this.props.changePage(this.props.page, this.props.totalPage, this.spinIcon)}> {this.spinIcon = icon}}> 换一批 { this.props.list.map((item, index) => { if(index >= (this.props.page - 1) * 10 && index {item} } else { return ''; } }) } Aa 登录 注册 写文章 ) } } const mapStateToProps = (state) => { return { inputFocus: state.get('header').get('inputFocus'), list: state.get('header').get('list'), mouseInHot: state.get('header').get('mouseInHot'), page: state.get('header').get('page'), totalPage: state.get('header').get('totalPage'), } } const mapDispathToProps = (dispatch) => { return { searchFocus() { dispatch(actionCreators.getList()); dispatch(actionCreators.searchFocus()); }, searchBlur() { dispatch(actionCreators.searchBlur()); }, onMouseEnterHot() { dispatch(actionCreators.onMouseEnterHot()); }, onMouseLeaveHot() { dispatch(actionCreators.onMouseLeaveHot()); }, changePage(page, totalPage, spinIcon) { // 3. 在 index.js 中设置它原生 DOM 的 CSS 属性 if(spinIcon.style.transform === 'rotate(360deg)') { spinIcon.style.transform = 'rotate(0deg)'; } else { spinIcon.style.transform = 'rotate(360deg)'; } if(page === totalPage) { page = 1; dispatch(actionCreators.changePage(page)); } else { dispatch(actionCreators.changePage(page)); } } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 这里我们通过三个步骤实现了图标旋转： 在 index.css 中添加动画 在 index.js 中给 i 标签添加 ref，并通过 changePage 方法传递过去 在 index.js 中设置它原生 DOM 的 CSS 属性 实现效果如下： 17.2 避免聚焦重复请求 返回目录 在代码中，我们每次聚焦，都会请求数据，所以我们需要根据 list 的值来判断是否请求数据： src/common/header/index.js 代码详情 ```js import React, { Component } from 'react'; import { connect } from 'react-redux'; import { CSSTransition } from 'react-transition-group'; import './index.css'; import { actionCreators } from './store'; import homeImage from '../../resources/img/header-home.png'; class Header extends Component { render() { return ( 首页 下载App this.props.searchFocus(this.props.list)} onBlur={this.props.searchBlur} /> 热门搜索 this.props.changePage(this.props.page, this.props.totalPage, this.spinIcon)}> {this.spinIcon = icon}}> 换一批 { this.props.list.map((item, index) => { if(index >= (this.props.page - 1) * 10 && index {item} } else { return ''; } }) } Aa 登录 注册 写文章 ) } } const mapStateToProps = (state) => { return { inputFocus: state.get('header').get('inputFocus'), list: state.get('header').get('list'), mouseInHot: state.get('header').get('mouseInHot'), page: state.get('header').get('page'), totalPage: state.get('header').get('totalPage'), } } const mapDispathToProps = (dispatch) => { return { searchFocus(list) { // 2. 判断 list 的 size 是不是等于 0，是的话才请求数据（第一次），不是的话则不请求 if(list.size === 0) { dispatch(actionCreators.getList()); } dispatch(actionCreators.searchFocus()); }, searchBlur() { dispatch(actionCreators.searchBlur()); }, onMouseEnterHot() { dispatch(actionCreators.onMouseEnterHot()); }, onMouseLeaveHot() { dispatch(actionCreators.onMouseLeaveHot()); }, changePage(page, totalPage, spinIcon) { if(spinIcon.style.transform === 'rotate(360deg)') { spinIcon.style.transform = 'rotate(0deg)'; } else { spinIcon.style.transform = 'rotate(360deg)'; } if(page === totalPage) { page = 1; dispatch(actionCreators.changePage(page)); } else { dispatch(actionCreators.changePage(page)); } } } } export default connect(mapStateToProps, mapDispathToProps)(Header); ``` 在这里，我们做了两个步骤： 给 searchFocus 传递 list 在 searchFocus 中判断 list 的 size 是不是等于 0，是的话才请求数据（第一次），不是的话则不请求 这样，我们就成功避免聚焦重复请求。 十八 React 路由 返回目录 18.1 路由（一） 返回目录 什么是路由？ 前端路由就是根据 URL 的不同，显示不同的内容。 安装 React 的路由：npm i react-router-dom -S 安装完毕之后，我们只需要修改下 src/App.js，就可以体验到路由： src/App.js 代码详情 ```js import React, { Component } from 'react'; import { Provider } from 'react-redux'; import Header from './common/header'; import store from './store'; // 1. 引入 React 路由的 BrowserRouter 和 Route import { BrowserRouter, Route } from 'react-router-dom'; class App extends Component { render() { return ( {/* 2. 在页面中使用 React 路由 */} HOME}> DETAIL}> ); } } export default App; ``` 在这里我们仅需要做两个步骤： 引入 React 路由的 BrowserRouter 和 Route 在页面中使用 React 路由 这样，我们就实现了路由： 18.2 路由（二） 返回目录 在 src 下新建 pages 文件夹，然后在该文件夹下新建文件夹和文件： src/pages/detail/index.js src/pages/home/index.js 它们的内容如下： src/pages/detail/index.js 代码详情 ```js import React, { Component } from 'react' class Detail extends Component { render() { return ( Detail ) } } export default Detail; ``` src/pages/home/index.js 代码详情 ```js import React, { Component } from 'react' class Home extends Component { render() { return ( Home ) } } export default Home; ``` 在有 header 的经验下，我们应该知道，我们希望在 URL 输入路径 localhost:3000 的时候，访问 home 组件；在输入 localhost:3000/detail 的时候，访问 detail 组件。 到这步，我们仅需要修改下 src/App.js，就可以实现目标： src/App.js 代码详情 ```js import React, { Component } from 'react'; import { Provider } from 'react-redux'; import Header from './common/header'; import store from './store'; import { BrowserRouter, Route } from 'react-router-dom'; // 1. 引入 Home、Detail 组件 import Home from './pages/home'; import Detail from './pages/detail'; class App extends Component { render() { return ( {/* 2. 在页面中引用组件 */} ); } } export default App; ``` 现在，我们切换下路由，就可以看到不用的页面，这些页面我们也可以通过编辑对应的 index.js 来修改了。 十九 页面实现：二级导航栏 返回目录 由于前面有过编程经验了，所以在这里我们就不多说废话，直接进行实现。 「简书」因违反《网络安全法》《互联网信息服务管理办法》《互联网新闻信息服务管理规定》等相关法律法规，严重危害互联网信息传播秩序，根据网信主管部门要求，从 2019 年 4 月 13 日 0 时至 4 月 19 日 0 时，暂停更新 PC 端上的内容，并对所有平台上的内容进行全面彻底的整改。 没法，本来想根据简书的首页继续编写的，但是恰巧碰到简书出问题了，只好拿掘金的首页和详情页来实现了。 我们将掘金首页划分为 3 个模块：顶部 TopNav、左侧 LeftList、右侧 RightRecommend。所以我们在 home 下面新建个 components 目录，用来存放这三个组件。同时，在开发 common/header 的时候，我们也知道，还需要一个 store 文件夹，用来存放 reducer.js 等： - pages - detail - index.js - home - components - LeftList.js - RightRecommend.js - TopNav.js - store - actionCreators.js - actionTypes.js - index.js - reducer.js - index.css - index.js src/index.css 代码详情 ```css body { background: #f4f5f5; } ``` src/App.js 代码详情 ```js import React, { Component } from 'react'; import { Provider } from 'react-redux'; import Header from './common/header'; import store from './store'; import { BrowserRouter, Route } from 'react-router-dom'; import Home from './pages/home'; import Detail from './pages/detail'; class App extends Component { render() { return ( ); } } export default App; ``` src/common/header/index.css 代码详情 ```css header { position: fixed; top: 0; left: 0; width: 100%; height: 58px; display: flex; align-items: center; border-bottom: 1px solid #f1f1f1; font-size: 17px; background: #fff; } /* 头部左边 */ .header_left-img { width: 100px; height: 56px; } /* 头部中间 */ .header_center { width: 1000px; margin: 0 auto; display: flex; justify-content: space-between; } .nav-item { margin-right: 30px; display: flex; align-items: center; } /* 头部中间左部 */ .header_center-left { display: flex; } /* 头部中间左部 - 首页 */ .header_center-left-home { color: #ea6f5a; } /* 头部中间左部 - 搜索框 */ .header_center-left-search { position: relative; } .slide-enter { transition: all .2s ease-out; } .slide-enter-active { width: 280px; } .slide-exit { transition: all .2s ease-out; } .silde-exit-active { width: 240px; } .header_center-left-search { z-index: 999; } .header_center-left-search input { width: 240px; padding: 0 45px 0 20px; height: 38px; font-size: 14px; border: 1px solid #eee; border-radius: 40px; background: #eee; } .header_center-left-search .input-active { width: 280px; } .header_center-left-search .icon-search { position: absolute; top: 8px; right: 10px; } .header_center-left-search .icon-active { padding: 3px; top: 4px; border-radius: 15px; border: 1px solid #ea6f5a; } /* 头部中间左部 - 热搜 */ .header_center-left-search .icon-active:hover { cursor: pointer; } .header_center-left-hot-search:before { content: \"\"; left: 27px; width: 10px; height: 10px; transform: rotate(45deg); top: -5px; z-index: -1; position: absolute; background-color: #fff; box-shadow: 0 0 8px rgba(0,0,0,.2); } .header_center-left-hot-search { position: absolute; width: 250px; left: 0; top: 125%; padding: 15px; font-size: 14px; background: #fff; border-radius: 4px; box-shadow: 0 0 8px rgba(0, 0, 0, 0.2); } .header_center-left-hot-search-title { display: flex; justify-content: space-between; color: #969696; } .header_center-left-hot-search-change { display: flex; justify-content: space-between; align-items: center; } .icon-change { display: inline-block; width: 20px; height: 14px; background: url('../../resources/img/icon-change.png') no-repeat center; background-size: 100%; transition: all .2s ease-in; transform-origin: center center; } .icon-change:hover { cursor: pointer; } .span-change:hover { cursor: pointer; } .header_center-left-hot-search-content span { display: inline-block; margin-top: 10px; margin-right: 10px; padding: 2px 6px; font-size: 12px; color: #787878; border: 1px solid #ddd; border-radius: 3px; } .header_center-left-hot-search-content span:hover { cursor: pointer; } /* 头部中间右部 */ .header_center-right { display: flex; color: #969696; } /* 头部右边 */ .header_right-register, .header_right-write { width: 80px; text-align: center; height: 38px; line-height: 38px; border: 1px solid rgba(236,97,73,.7); border-radius: 20px; font-size: 15px; color: #ea6f5a; background-color: transparent; } .header_right-write { margin-left: 10px; padding-left: 10px; margin-right: 0px; color: #fff; background-color: #ea6f5a; } ``` src/pages/home/index.js 代码详情 ```js import React, { Component } from 'react'; import LeftList from './components/LeftList'; import RightRecommend from './components/RightRecommend'; import TopNav from './components/TopNav'; import './index.css'; class Home extends Component { render() { return ( ) } } export default Home; ``` src/pages/home/index.css 代码详情 ```css /* 主体 */ .container { width: 960px; margin: 0 auto; } .main-container { display: flex; } /* 顶部 */ .top-nav { position: fixed; left: 0; top: 59px; width: 100%; height: 46px; line-height: 46px; z-index: 100; box-shadow: 0 1px 2px 0 rgba(0,0,0,.05); font-size: 14px; background: #fff; } .top-nav-list { display: flex; width: 960px; margin: auto; position: relative; } .top-nav-list-item a { height: 100%; align-items: center; display: flex; flex-shrink: 0; color: #71777c; padding-right: 12px; } .active a { color: #007fff; } .top-nav-list-right { position: absolute; top: 0; right: 0; } /* 主内容 */ .main-container { margin-top: 120px; } /* 左侧 */ .left-list { width: 650px; height: 1000px; background: #fff; } /* 右侧 */ .right-recommend { width: 295px; height: 1000px; margin-left: 15px; background: #fff; } ``` src/pages/home/components/TopNav.js 代码详情 ```js import React, { Component } from 'react'; import { Link } from 'react-router-dom'; class TopNav extends Component { render() { return ( 推荐 关注 后端 前端 Android IOS 人工智能 开发工具 代码人生 阅读 标签管理 ) } } export default TopNav; ``` src/pages/home/components/LeftList.js 代码详情 ```js import React, { Component } from 'react' class LeftList extends Component { render() { return ( 左侧 ) } } export default LeftList; ``` src/pages/home/components/RightRecommend.js 代码详情 ```js import React, { Component } from 'react' class RightRecommend extends Component { render() { return ( 右侧 ) } } export default RightRecommend; ``` 此时，页面显示为： 二十 页面实现：首页 返回目录 20.1 多层级组件引用 store 返回目录 在我们规划中，App 是主组件，下面有 header | home | detail，然后 home 下面有 LeftList | RightRecommend，那么 App/home/leftList 如何引用 store 呢？ src/pages/home/components/LeftList.js 代码详情 ```js import React, { Component } from 'react'; import { Link } from 'react-router-dom'; // 1. 在 LeftList 中引入 react-redux 的 connect import { connect } from 'react-redux'; import { actionCreators } from '../store'; class LeftList extends Component { render() { return ( 热门 | 最新 | 评论 本周最热 · 本月最热 · 历史最热 {/* 5. 循环输出 props 里面的数据 */} { this.props.list.map((item) => { return ( 热· 专栏· { item.get('user').get('username') } · 一天前· { item.get('tags').map((tagsItem, index) => { if (index === 0) { return tagsItem.get('title'); } else { return null; } }) } {item.get('title')} {item.get('likeCount')} {item.get('commentsCount')} ) }) } ) } componentDidMount() { this.props.getLeftList(); } } // 3. 在 LeftList 中定义 mapStateToProps const mapStateToProps = (state) => { return { list: state.get('home').get('leftNav') } }; // 4. 在 LeftList 中定义 mapDispathToProps const mapDispathToProps = (dispatch) => { return { getLeftList() { dispatch(actionCreators.getLeftList()); } } }; // 2. 在 LeftList 中使用 connect export default connect(mapStateToProps, mapDispathToProps)(LeftList); ``` 20.2 完善整个首页 返回目录 当然，如果仅仅是运行上面的代码，你会发现它是报错的。 是的，因为它只是全部代码的一部分，所以需要你去完善它。当然，你也可以直接获取全部代码： React 系列文章代码地址 不管如何，你实现的最终成果如下所示： 二十一 总结 返回目录 写到这里，我们已经完成了一个首页的开发。 在这个开发中，我们学习到了非常多。 当然，后面 jsliang 自己也是偷懒了，慕课原视频中还有： 加载更多功能实现 跳转到顶部功能实现 详情页开发 登录页开发 登录鉴权功能实现 单页面异步加载组件（react-loadable） …… 这里不一一列举了，因为 jsliang 感觉它们重复性很大，我们只需要在下一个项目中去实践，相信能获得更清晰的印象。（当然，前提是你跟 jsliang 一样有动力深入学习） 那么，到这里我们就宣布结束啦，我们下篇文章见！ jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-23 14:34:33 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/React/ReactDemoFour-JueJin.html":{"url":"JavaScript-library/React/ReactDemoFour-JueJin.html","title":"✔ React Demo Four - 掘金","keywords":"","body":"React Demo Four - 掘金 Create by jsliang on 2019-5-15 08:25:08Recently revised in 2019-05-15 15:57:20 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文 二 前言 返回目录 首先，经过前面的一系列折腾，发觉自己的时间远远没有想象中的那么充足，又因为这三周的工作，搞得自己 “精疲力竭”、“无法动弹”，越发感到暴躁与疲惫（可能有天气的小小影响）。 同时，经过前面的贴代码，以及文章反馈远没有自己想象中的高，jsliang 觉得自己可能做了无用功，于是在 React 系列 4 仿掘金 的更新上感觉动力不足——也许你会觉得这句话非常扯淡，jsliang 的动力怎么会跟文章反馈挂钩了…… 再来就是，看到身边的同事/小伙伴都在刷 LeetCode、看 React 源码、学 Java、搞 Egg……越发觉得自己落了下乘，所以在暴躁的同时也在犹豫彷徨，我究竟想成就一个怎样的未来：jsliang 的未来在哪？ 这么说来，思来想去，目前自己可以走三条路： 深造：一路走到黑，完善 React 系列栈，并配合 Node、MySQL 打造自己的网站，毕竟深度学习才能让自己在某个领域成为 “砖家”，可以想象的是，深入学习 React 的大佬是可以自己搭建公司的 React 脚手架，自己开发插件，自己优化项目等。 广度：扩宽自己思维，学算法，探索 LeetCode 等网站。有句话叫做：一流的数学，二流的算法。数学咱就算了，没这头脑，但是搞搞算法应该可以吧，并且算法这玩意真的挺有用的，有时候工作总觉得某方面没处理好，没准就是算法的影响。 转行：这也许是最没有出息的想法。众所周知编程是一行吃青春饭的地儿，年轻的时候进了这个行业是能拿到高回报的。可是，毕竟是青春饭碗，过了这个年纪往往就意味着有淘汰风险，毕竟身体比不了年轻人，精力、思考等也比不上。所以，就算 jsliang 在本命年也深深感到这个危机。但是，转行要转哪去？除了编程我还有啥能力，不可得知。 因此，这本身就是个值得深思的问题。而且，我们还有生活，我们的努力就是为了更好的生活，如果你的努力带来的是 996-ICU，一年甚至几年的努力工作、努力学习换不来住一次医院，换不来房子的首付，想想这是很可怕的事情。 最后，说到这里小伙伴们心里应该有谱了，至于 jsliang 的想法或者你对自己的未来有想法了想找个人来个中肯的建议，你可以联系 jsliang： QQ：1741020489 微信： 三 正文 返回目录 实现效果： 源码下载：React 系列文章代码地址 使用技术： \"dependencies\": { \"axios\": \"^0.18.0\", \"react\": \"^16.8.6\", \"react-dom\": \"^16.8.6\", \"react-loadable\": \"^5.5.0\", \"react-redux\": \"^7.0.2\", \"react-router-dom\": \"^5.0.0\", \"react-scripts\": \"3.0.0\", \"redux\": \"^4.0.1\", \"redux-saga\": \"^1.0.2\" }, 其中数据处理方面没有使用，即：react-loadable、react-redux、redux、redux-saga 这四个没有使用到，下篇文章可能尝试完善做好。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 16:51:36 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/React/ReactDemoFive-AroundYuanGang.html":{"url":"JavaScript-library/React/ReactDemoFive-AroundYuanGang.html","title":"✘ React Demo Five - 员岗周边","keywords":"","body":"React Demo Five - 员岗周边 Create by jsliang on 2019-5-16 22:09:22Recently revised in 2019-05-17 16:46:45 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 二 前言 返回目录 突然想起一个词，叫：食在广州。 而我，广漂，衣食住行都围绕广州番禺区的【员岗地铁站】。 所以，兴致而来，开发一个多端登录的 App，记录附近的点点滴滴。 React 系列文章地址 Node 系列文章地址 由于文章有这两个前置，如果不熟悉 React 或者 Node 开发的一套，请先去学习对应的前置。 三 开发思路与进度 返回目录 [ ] 功能结构划分 [ ] 衣 [ ] 食 [ ] 住 [ ] 行 3.2 食 对一些饭点的介绍 点击地图的饭点，可以查看到对应饭点的菜单（建议堂食、不建议堂食） 可以获取饭点的外卖电话、点餐 App（美团，大众，饿了么……） 可以评价饭点的饭菜 店家可以更新自己的菜单（收费） jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 19:39:43 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Angular/":{"url":"JavaScript-library/Angular/","title":"Angular","keywords":"","body":"Angular create by jsliang on 2018-9-5 11:33:18Recently revised in 2019-2-11 09:55:35 前言 AngularJS 诞生于 2009 年，由 Misko Hevery 等人创建，后为 Google 所收购。是一款优秀的前端 JS 框架，已经被用于 Google 的多款产品当中。 AngularJS 有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。 由于 AngularJS 有着诸多不便，AngularJS 在 2.0 版本进行了重写，于是有了现在的 Angular。 目录 章节名 导航 Demo1 股票管理网站 Demo2 企业开发平台 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Angular/AngularDemoOne-taskmgr.html":{"url":"JavaScript-library/Angular/AngularDemoOne-taskmgr.html","title":"✘ Angular Demo One - 打造企业级协作平台","keywords":"","body":"Angular Demo One - 打造企业级协作平台 create by jsliang on 2018-9-5 11:56:07Recently revised in 2019-2-11 10:05:39 目录 章节名 导航 第一章 环境搭建 第二章 项目工程结构介绍 UI 第三章 UI整体布局 More... 已断更！缺乏对应基础，补基础去了！ 第一章 环境搭建 1. 安装 Angular： npm i @angular/cli -g _ _ ____ _ ___ / \\ _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | '_ \\ / _` | | | | |/ _` | '__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/ Angular CLI: 6.1.5 Node: 8.11.2 OS: win32 x64 Angular: ... Package Version ------------------------------------------------------ @angular-devkit/architect 0.7.5 @angular-devkit/core 0.7.5 @angular-devkit/schematics 0.7.5 @schematics/angular 0.7.5 @schematics/update 0.7.5 rxjs 6.3.2 typescript 2.9.2 2. 安装 VS Code 插件： Debugger for Chrome、Angular 6 Snippets 3. 安装开发插件： 安装 Chrome 关于 Angular 的开发插件：点击前往 4. 常用命令： npm i -S —— 软件开发依赖 npm i -D —— 软件生产依赖 ng new —— 新建 Angular项目 ng build -prod —— 生产环境编译 ng server —— 启动开发服务器 5. Mock Rest API： json-server: 用户快速搭建 REST API 的利器。 安装：npm i json-server -g，版本为 0.14.0 。 启动：json-server /json 文件位于的目录/*.json。 支持 GET， POST， PUT， PATCH， DELETE 等 REST 命令。 6. 测试 REST API： 几种常用的 API 测试工具： 使用 Postman 测试常用的 API：地址 使用 VS Code 的 REST Client 插件 此刻， jsliang 的 node 等版本为：node : 8.11.2npm : 6.3.0cnpm : 6.0.0 第二章 项目工程结构介绍 2.1 文件组织约定 目录结构按相对独立的功能划分 src/app 下第一层子目录中除了模块，还有领域对象、动画和工具文件夹 资源存放在 src/assets 目录下 2.2 命名约定 模块和组件的类文件都使用 index.ts 的命名约定 2.3 新建项目 ng new taskmgr -si --style=scss —— 新建 angular 项目 // 注： -si === --skip-install cnpm i —— 安装依赖 ng g m core —— 创建核心模块 ng g m shared —— 创建分享模块 2.4 添加代码 taskmgr/src/app/core/core.module.ts // 原代码 import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [ CommonModule ], declarations: [] }) export class CoreModule { } // 更新后代码 import { NgModule, SkipSelf } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [ CommonModule ], declarations: [] }) export class CoreModule { constructor(parent: CoreModule) { if(parent) { throw new Error(\"模块已经存在，不能再次加载！\"); } } } taskmgr/src/app/shared/shared.module.ts // 原代码 import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [ CommonModule ], declarations: [] }) export class SharedModule { } // 更新后代码 import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [ CommonModule ], exports: [ CommonModule ], declarations: [] }) export class SharedModule { } taskmgr/src/app/app.module.ts // 原代码 import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } // 更新后代码 import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { CoreModule } from './core/core.module'; import { AppComponent } from './app.component'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, CoreModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } 第三章 UI整体布局 3.1 修改代码 ng g c core/header --spec=false ng g c core/footer --spec=false ng g c core/sidebar --spec=false taskmgr/src/app/app.component.html // 源代码 Welcome to {{ title }}! Here are some links to help you start: Tour of Heroes CLI Documentation Angular blog // 修改后 taskmgr/src/app/core/core.module.ts // 源代码 // 修改后 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/Angular/AngularDemoTwo-stock-management-platform.html":{"url":"JavaScript-library/Angular/AngularDemoTwo-stock-management-platform.html","title":"✘ Angular Demo Two - Angular 股票管理平台","keywords":"","body":"Angular Demo Two - Angular 股票管理平台 create by jsliang on 2018年9月5日17:28:51Recently revised in 2018年9月6日16:47:36 前言 AngularJS 诞生于 2009 年，由 Misko Hevery 等人创建，后为 Google 所收购。是一款优秀的前端 JS 框架，已经被用于 Google 的多款产品当中。 AngularJS 有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。 由于 AngularJS 有着诸多不便，AngularJS 在 2.0 版本进行了重写，于是有了现在的 Angular。 目录 章节名 导航 第一章 介绍 第二章 开始 Angular 开发 第三章 路由和导航 第四章 依赖注入 第五章 绑定、响应式编程和管道 第六章 组件间通讯 第七章 表单处理 第八章 与服务器通讯 第九章 构建和部署 第一章 - 介绍 Angular 是一个开发平台。它能帮你更轻松的构建 Web 应用。Angular 集声明式模板、依赖注入、端到端工具和一些最佳实践于一身，为你解决开发方面的各种挑战。Angular 为开发者提升构建 Web、手机或桌面应用的能力。 1.1 Angular 的优点 跨平台 渐进式应用：充分利用现代 Web 平台的各种能力，提供 App 式体验。高性能、离线使用、免安装。 原生：借助来自Ionic、NativeScript和React Native中的技术与思想，构建原生移动应用。 桌面：借助你已经在Web开发中学过的能力，结合访问原生操作系统API的能力，创造能在桌面环境下安装的应用，横跨Mac、Windows和Linux平台。 速度与性能 代码生成：Angular会把你的模板转换成代码，针对现代JavaScript虚拟机进行高度优化，轻松获得框架提供的高生产率，同时又能保留所有手写代码的优点。 统一平台：在服务端渲染应用的首屏，像只有HTML和CSS的页面那样几乎瞬间展现，支持 Node.js®、.NET、PHP，以及其它服务器，为通过SEO来优化站点铺平了道路。 代码拆分：借助新的组件路由器，Angular可以实现快速加载。自动代码拆分机制可以让用户仅仅加载那些用于渲染所请求页面的代码。 生产率 模板：通过简单而强大的模板语法，快速创建UI视图。 Angular CLI：命令行工具：快速进入构建环节、添加组件和测试，然后立即部署。 各种 IDE：在常用IDE和编辑器中获得智能代码补全、实时错误反馈及其它反馈等特性。 完整开发故事 测试：使用Karma进行单元测试，让你在每次存盘时都能立即知道是否弄坏了什么。Protractor则让你的场景测试运行得又快又稳定。 动画：通过Angular中直观简便的API创建高性能复杂编排和动画时间线 —— 只要非常少的代码。 可访问性：通过支持ARIA的组件、开发者指南和内置的一体化测试基础设施，创建具有完备可访问性的应用。 1.2 AngularJS 架构与 Angular 架构 AngularJS 的架构： 为何 AngularJS 被抛弃 饱受诟病的性能问题。通过检查进行数据更新，当数据不断增加时，检查的效率就不断降低。页面加载速度也会变慢。 落后于当前web发展理念(如组件式的开发) 对手机端的支持不是太友好。由于angularJS是09年诞生的，因此并没有考虑到手机端的适配，首先是性能问题，手机平台的硬件资远远比不上电脑平台。 于是，就有了 Angular 的开发： 组件( Component )：是 Angular 应用的基本构建块，可以把一个组件理解为一段带有业务逻辑和数据的HTML 服务：用来封装可重用的业务逻辑 指令：允许你向 HTML 元素添加自定义行为 模块：将应用中不同部分组织成一个 Angular 框架可以理解的单页。 第二章 - 开始 Angular 开发 2.1 安装 Angular 安装 Angular-cli ：npm i @angular/cli -g 新建 Angular 项目：ng new project 安装 Node 依赖：npm i 运行 Angular 项目：npm run start 2.2 Angular-CLI 目录介绍 + e2e —— 自动化配置文件及用例 demo，自动测试使用 + node_modules —— 安装依赖包 + src —— 项目文件目录 + app —— 应用组件和模块 - app.component.css —— 根组件样式 - app.component.html —— 根组件页面 - app.component.spec.ts —— 测试用例的例子 - app.component.ts —— 根组件 - app.module.ts —— 根模块 + assets —— 静态文件目录，图片、第三方库等 - .gitkeep —— assets 目录用于存放图片等静态资源文件，构建时会拷贝到发布包里。新创建时一般为空，由于 git 会忽略空文件夹，放置 .gitkeep 这个空文件可以保证目录得到管理 + environments —— 开发模式和生产模式的配置文件，可以将接口的路径写在这里 - environment.prod.ts —— 生产环境 - environment.ts —— 开发环境 - browserslist —— 该项目的浏览器兼容情况 - favicon.ico —— 项目页面迷你小图标 - index.html —— 启动页 - karma.conf.js —— karma 是单元测试的执行器，karma.conf.js 是 karma 的配置文件 - main.ts —— 入口文件 - polyfills.ts —— 兼容性，可以根据需要开放兼容 IE10 和 ES6、 ES7 的语法 - style.css —— 全局样式 - test.ts —— 测试用例 - tsconfig.app.json —— typescript 配置文件 - tsconfig.spec.json —— typescript 配置文件 - tslint.json —— tslint 语法校验配置文件 - .editorconfig —— editorconfig 配置文件，规范开发用的 - .gitignore —— git 忽略文件，配置 .gitignore 可以忽略诸如 node_modules 此类的包 - angular.json —— angular 配置文件 - package.json —— 项目依赖配置文件，npm 根据该文件安装依赖包 - README.md —— 初始化新手教程，其实就是官方的 readMe - tsconfig.json —— typescript 配置文件 - tslint.json —— tslint 语法校验配置文件 2.3 Angular 运行流程 在我们启动 npm run start 的过程中，Angular 做了什么事呢？这边我们讲解下： 首先，Angular-CLI 根据 npm run start，打开 package.json 这个文件： package.json { \"name\": \"stock-management-platform\", \"version\": \"0.0.0\", \"scripts\": { \"ng\": \"ng\", \"start\": \"ng serve\", \"build\": \"ng build\", \"test\": \"ng test\", \"lint\": \"ng lint\", \"e2e\": \"ng e2e\" }, \"private\": true, \"dependencies\": { \"@angular/animations\": \"^6.1.0\", \"@angular/common\": \"^6.1.0\", \"@angular/compiler\": \"^6.1.0\", \"@angular/core\": \"^6.1.0\", \"@angular/forms\": \"^6.1.0\", \"@angular/http\": \"^6.1.0\", \"@angular/platform-browser\": \"^6.1.0\", \"@angular/platform-browser-dynamic\": \"^6.1.0\", \"@angular/router\": \"^6.1.0\", \"core-js\": \"^2.5.4\", \"rxjs\": \"^6.0.0\", \"zone.js\": \"~0.8.26\" }, \"devDependencies\": { \"@angular-devkit/build-angular\": \"~0.7.0\", \"@angular/cli\": \"~6.1.5\", \"@angular/compiler-cli\": \"^6.1.0\", \"@angular/language-service\": \"^6.1.0\", \"@types/jasmine\": \"~2.8.6\", \"@types/jasminewd2\": \"~2.0.3\", \"@types/node\": \"~8.9.4\", \"codelyzer\": \"~4.2.1\", \"jasmine-core\": \"~2.99.1\", \"jasmine-spec-reporter\": \"~4.2.1\", \"karma\": \"~1.7.1\", \"karma-chrome-launcher\": \"~2.2.0\", \"karma-coverage-istanbul-reporter\": \"~2.0.0\", \"karma-jasmine\": \"~1.1.1\", \"karma-jasmine-html-reporter\": \"^0.2.2\", \"protractor\": \"~5.4.0\", \"ts-node\": \"~5.0.1\", \"tslint\": \"~5.9.1\", \"typescript\": \"~2.7.2\" } } 然后发现这文件告诉 Angular-CLI，执行 ng serve，即 npm run start === ng serve。然后，它定义了主入口为 main.js，那么，我们以此寻找，发现有个 main.ts，可以想到是 TypeScript 编译成 JavaScript，所以我们首先打开 main.ts 进行查看。 在 main.ts 中： main.ts // 关闭 Angular 的开发模式 import { enableProdMode } from '@angular/core'; // 使用哪个模块来启动应用 import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; // 导入主模块 import { AppModule } from './app/app.module'; // 导入环境配置 import { environment } from './environments/environment'; // 如果是生产环境，就调用下面方法 if (environment.production) { enableProdMode(); } // 设置启动模块为 AppModule platformBrowserDynamic().bootstrapModule(AppModule) .catch(err => console.log(err)); 我们可以看到，它设置了启动模块为 APPModule ，所以，我们通过路径 src/app/app.module 找到 app.module.ts 这个文件。 我们打开 app.module.ts ： // 这是 Angular 的模块文件 import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; @NgModule({ // 声明模块、指令以及管道 declarations: [ // 模块组件： AppComponent AppComponent ], // 导入的模块 imports: [ // 浏览器模块 BrowserModule ], // 模块中提供的服务 providers: [], // 声明模块主组件 bootstrap: [AppComponent] }) export class AppModule { } 在这里，我们可以看到它的主组件为 AppComponent ，所以我们找到 AppComponent 的路径为 src/app/app.component.ts ，因此我们打开该文件。 我们打开 app.component.ts ： // 从 angular 核心中引用 Component 这个装饰器 import { Component } from '@angular/core'; // 定义装饰器 @Component({ selector: 'app-root', // 挂载 dom 节点 templateUrl: './app.component.html', // 模板 html 文件 styleUrls: ['./app.component.css'] // 模板 css 样式文件 }) // 控制器 export class AppComponent { title = '股票管理平台'; // AppComponent 控制器有个 title 值 } OK，从装饰器中我们可以看到，我们这个组件，挂载到 index.html 的 app-root 这个节点中，而且其模板文件由 app.component.html 与 app.component.css 这两个文件形成。 由此，我们知道，通过编写 app.component.html 和 app.component.css ，我们形成了一个 app 的组件(可以看成为一块 HTML 片段，而 index.html 是一个页面)，挂载到 index.html 中。这样，我们就能够编写SPA模式的页面了。 模拟的 index.html 股票管理平台 --> 欢迎来到{{ title }}! 2.4 Angular 组件 第三章 - 开发准备 3.1 安装依赖 安装引用 jquery 和 bootstrap： 股票管理平台 安装 TS 类型描述文件： npm i @types/jquery @types/bootstrap -D (由于 TypeScript 中不支持 $ ，所以我们需要先安装类型描述文件，让 TypeScript 认识 jQuery 和 Bootstrap ，以免它报错) 3.2 新建组件 新建导航栏组件： ng g component navbar 新建尾部组件： ng g component footer 查询表单组件： ng g component search 新建轮播图组件： ng g component carousel 新建产品信息组件： ng g component product 新建星级评价组件： ng g component stars 查看是否有生成新的组件： 此时，发现 app.module.ts 变为： // 这是 Angular 的模块文件 import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; import { NavbarComponent } from './navbar/navbar.component'; import { FooterComponent } from './footer/footer.component'; import { SearchComponent } from './search/search.component'; import { CarouselComponent } from './carousel/carousel.component'; import { ProductComponent } from './product/product.component'; import { StarsComponent } from './stars/stars.component'; @NgModule({ // 声明模块、指令以及管道 declarations: [ //, NavbarComponent, FooterComponent, SearchComponent, CarouselComponent, ProductComponent, StarsComponent, AppComponent ], // 导入的模块 imports: [ // 浏览器模块 BrowserModule ], // 模块中提供的服务 providers: [], // 声明模块主组件 bootstrap: [AppComponent] }) export class AppModule { } 3.3 开始开发 app.component.html navbar.component.html 管理平台 在线竞拍 关于我们 联系我们 网站地图 navbar.component.css .navbar { margin-bottom: 30px; } footer.component.html jsliang Angular 入门实战 @2018 search.component.html 商品名称 商品价格 商品类别 搜索 carousel.component.html #holder_165b232526b text { fill: #555; font-weight: normal; font-family: Helvetica, monospace; font-size: 40pt } First slide #holder_165b2325267 text { fill: #444; font-weight: normal; font-family: Helvetica, monospace; font-size: 40pt } Second slide #holder_165b232526d text { fill: #333; font-weight: normal; font-family: Helvetica, monospace; font-size: 40pt } Third slide Previous Next product.component.ts import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-product', templateUrl: './product.component.html', styleUrls: ['./product.component.css'] }) export class ProductComponent implements OnInit { private products: Array; constructor() { } ngOnInit() { this.products = [ new Product(1, \"第一个商品\", 1.99, 1.5, \"这是第一个商品，这是 jsliang 学习 Angular入门实战时创建的\", [\"硬件设备\"]), new Product(1, \"第二个商品\", 2.99, 2.5, \"这是第二个商品，这是 jsliang 学习 Angular入门实战时创建的\", [\"图书\", \"后端\"]), new Product(1, \"第三个商品\", 3.99, 3.5, \"这是第三个商品，这是 jsliang 学习 Angular入门实战时创建的\", [\"硬件设备\"]), new Product(1, \"第四个商品\", 4.99, 4.5, \"这是第四个商品，这是 jsliang 学习 Angular入门实战时创建的\", [\"电子产品\", \"硬件设备\"]), new Product(1, \"第五个商品\", 5.99, 5.5, \"这是第五个商品，这是 jsliang 学习 Angular入门实战时创建的\", [\"电子产品\"]), new Product(1, \"第六个商品\", 6.99, 1.5, \"这是第六个商品，这是 jsliang 学习 Angular入门实战时创建的\", [\"图书\", \"前端\"]) ] } } export class Product { constructor( public id: number, public title: string, public price: number, public rating: number, public desc: string, public categories: Array ) { } } product.component.html #holder_165b232526d text { fill: #333; font-weight: normal; font-family: Helvetica, monospace; font-size: 40pt } Third slide {{ product.price }}元 {{ product.title }} {{ product.desc }} 第四章 - 路由 4.1 Route 名称 简介 使用 Routes 路由配置，保存着哪个 URL 对应展示哪个组件，以及在哪个 RouterOutlet 中展示组件 import {HomeComponent} from \"./home/home.component\"; const routes: Routes = [{ path: 'home', component: HomeComponent }] RouterOutlet 在 HTML 中标记路由内容呈现位置的占位符指令 Router 负责在运行时执行路由的对象，可以通过调用其 navigate() 和 navigateByUrl() 方法来导航到一个指定的路由。 -> constructor(private router: Router) {} -> toProductDetails() {this.router.navigate(['/product'])} RouterLink 在 HTML 中声明路由导航用的指令 > ActivatedRoute 当前激活的路由对象，保存着当前路由的信息，如路由地址，路由参数等。 * 4.2 解析图 4.3 传递数据 在路由时传递数据的方法有： 在查询参数中传递数据 /product?id=1&name=2 => ActivatedRoute.queryParams[id] 在路由路径中传递参数 {path:/product/:id} => /product/1 => ActivatedRoute.params[id] 在路由配置中传递参数 {path:/product, component:ProductComponent, data:[{isProd:true}]} => ActivatedRoute.data[0][isProd] 4.4 路由+传递数据 商品详情 商品详情 4.5 路由重定向 在用户访问一个特定的地址时，将其重定向到另一个特定的地址 www.aaa.com => www.aaa.com/home www.aaa.com/x => www.aaa.com/y {path:'', redirectTo:'/home', pathMatch:'full'} 4.6 子路由 { path: 'home', component: HomeComponent, children: [ { path: '/xxx', component: XxxComponent } { path: '/yyy', component: YyyComponent } ] } 4.7 辅助路由 { path: 'xxx', component: XxxComponent, outlet: \"aux\" } { path: 'yyy', component: YyyComponent, outlet: \"aux\" } Xxx Yyy 4.8 辅助路由实现 辅助路由案例整体思路 在 app 组件的模板上再定义一个插座来显示聊天面板 单独开发一个聊天室插件，只显示在新定义的插座上。 通过路路由参数控制新电脑是否显示聊天面板。 第五章 - 绑定、响应式编程和管道 5.1 本节内容 数据绑定 响应式编程 管道 第六章 - 组件间通讯 6.1 本节内容 输入输出属性 中间人模式 组件生命周期 第七章 - 表单处理 7.1 本节内容 模板式表单 响应式表单 表单校验 第八章 - 表单处理 8.1 本节内容 创建 web 服务器 使用 Http 协议与服务器通讯 使用 WebSocket 协议与服务器通讯 构建和部署 9.1 本节内容 构建和部署 多环境支撑 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/ECharts/":{"url":"JavaScript-library/ECharts/","title":"ECharts","keywords":"","body":"ECharts Create by jsliang on 2018-11-28 10:53:08Recently revised in 2019-2-11 11:09:57  Echarts + Vue 折腾。 一 前言  ECharts 官网  ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。 二 简介 2.1 丰富的可视化类型  ECharts 提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。  除了已经内置的包含了丰富功能的图表，ECharts 还提供了自定义系列，只需要传入一个renderItem函数，就可以从数据映射到任何你想要的图形，更棒的是这些都还能和已有的交互组件结合使用而不需要操心其它事情。  你可以在下载界面下载包含所有图表的构建文件，如果只是需要其中一两个图表，又嫌包含所有图表的构建文件太大，也可以在在线构建中选择需要的图表类型后自定义构建。 2.2 多种数据格式无需转换直接使用  ECharts 内置的 dataset 属性（4.0+）支持直接传入包括二维表，key-value 等多种格式的数据源，通过简单的设置 encode 属性就可以完成从数据到图形的映射，这种方式更符合可视化的直觉，省去了大部分场景下数据转换的步骤，而且多个组件能够共享一份数据而不用克隆。  为了配合大数据量的展现，ECharts 还支持输入 TypedArray 格式的数据，TypedArray 在大数据量的存储中可以占用更少的内存，对 GC 友好等特性也可以大幅度提升可视化应用的性能。 2.3 千万数据的前端展现  通过增量渲染技术（4.0+），配合各种细致的优化，ECharts 能够展现千万级的数据量，并且在这个数据量级依然能够进行流畅的缩放平移等交互。  几千万的地理坐标数据就算使用二进制存储也要占上百 MB 的空间。因此 ECharts 同时提供了对流加载（4.0+）的支持，你可以使用 WebSocket 或者对数据分块后加载，加载多少渲染多少！不需要漫长地等待所有数据加载完再进行绘制。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/ECharts/CurriculumVitae.html":{"url":"JavaScript-library/ECharts/CurriculumVitae.html","title":"✔ ECharts 打造在线个人简历","keywords":"","body":"ECharts 打造在线个人简历 Create by jsliang on 2018-12-5 11:48:56Recently revised in 2019-2-11 11:08:28 Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址 互联网冬天？裁员？跳槽？ 最近频繁听身边朋友说公司裁员、员工跳槽的事情，然后帮几个还没毕业的小师弟修改了几份简历，结果嘛，enmmm...... 咱使用 Vue + ECharts + ElementUI 来打造份在线个人简历，并将它部署到免费的服务器上去吧！ 最终成品线上地址：点击查看 涉及技术： Vue Vue-Router ECharts ElementUI HTML/HTML5 CSS/CSS3 JavaScript/ES6 一 目录  不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 整体搭建  3.1 基础配置  3.2 安装 ECharts  3.3 安装 ElementUI  3.4 总体配置 四 分步实现  4.1 part1 - 基本信息  4.2 part2 - 好友分布  4.3 part3 - 技能特长  4.4 part4 - 文章成就  4.5 part5 - 工作经验  4.6 part6 - 编程技能  4.7 part7 - 求职意向 五 总结 二 前言 返回目录  在使用 Vue + ECharts 编写公司报表项目的时候，突如其来有个 idea，想到好像可以写个在线简历。 于是，就去做了。 文章中的见解仅代表个人观点，不代表 “最优想法”，请文明评论、科学参考。 如有更好建议，可加 jsliang 的文档库 QQ 群讨论：798961601。 谢谢~ 三 整体搭建 返回目录  工欲善其事，必先利其器。 在我们进行愉快折腾之前，我们需要将代码的环境搭建好，才能如鱼得水，更好地开发。 3.1 基础配置 返回目录  首先，我们在指定目录下，通过控制台（终端）新建一个 Vue-Cli 项目： vue init webpack  然后，我们使用 npm i 安装 Vue-Cli 的依赖，生成 node_modules 文件夹。 最后，我们引入 CSS reset，并清理下红框内文件，之后项目变为如下所示：  此刻我们的一些文件发生了变动： HelloWorld.vue export default { name: 'HelloWorld', data () { return { } } } App.vue export default { name: 'App' } main.js import Vue from 'vue' import App from './App' import router from './router' Vue.config.productionTip = false // 引入样式重置 import '../static/css/reset.css' new Vue({ el: '#app', router, components: { App }, template: '' }) reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /** 图片自适应 - image responsize **/ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .26rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .26rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .26rem } /* Internet Explorer */  当然，怕小伙伴们嫌麻烦，不想敲代码。 所以 jsliang 直接上传了基础代码，需要的小伙伴直接下载即可：  ECharts 打造在线个人简历分支 - 基础配置 3.2 安装 ECharts 返回目录  既然说了用 ECharts 来写，那么，我们肯定要搞下 ECharts 的安装啦~  首先，我们在项目中安装 ECharts 依赖： npm i echarts -S  然后，你可以选择按需引用还是全局引用（个人建议使用按需引用）： 全局引用  ECharts 初始化应在钩子函数 mounted() 中，这个钩子函数是在 el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。 项目/src/main.js import Vue from 'vue' import App from './App' import router from './router' // 引入echarts import echarts from 'echarts' Vue.prototype.$echarts = echarts Vue.config.productionTip = false new Vue({ el: '#app', router, components: { App }, template: '' }) 项目/src/components/HelloWorld.vue export default { name: 'hello', data () { return { msg: 'Welcome to Your Vue.js App' } }, mounted(){ this.drawLine(); }, methods: { drawLine(){ // 基于准备好的dom，初始化echarts实例 let myChart = this.$echarts.init(document.getElementById('myChart')) // 绘制图表 myChart.setOption({ title: { text: '在Vue中使用echarts' }, tooltip: {}, xAxis: { data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); } } } 按需引用  如果我们使用全局引用。将 ECharts 图表打包，会导致体积过大，所以项目中最好按需引入。 在这里我们使用 requrie 引用而不是 import，是因为 import 必须写全路径，比较麻烦。 项目/src/components/HelloWorld.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); // 引入柱状图组件 require(\"echarts/lib/chart/bar\"); // 引入提示框和title组件 require(\"echarts/lib/component/tooltip\"); require(\"echarts/lib/component/title\"); export default { name: 'hello', data() { return { msg: 'Welcome to Your Vue.js App' } }, mounted() { this.drawLine(); }, methods: { drawLine() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById('myChart')) // 绘制图表 myChart.setOption({ title: { text: 'ECharts 入门示例' }, tooltip: {}, xAxis: { data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); } } };  最后，我们只需要 npm run dev 启动项目，打开 localhost:8080 即可：  当然，仅仅带进门，可能小伙伴们还可能会感觉懵逼：下一步我要怎么做？ 所以，jsliang 顺带讲讲 ECharts 如何上手： 照着上面案例敲一遍 过一遍它的上手文档：5 分钟上手 ECharts 查看它的各种实例，并从自己要做的简单的图做起 在步骤 3 中，碰到不懂的属性值，记得随时查看文档：文档 - 配置项手册  如此，小伙伴们就可以更好上手 ECharts 啦~ 3.3 安装 ElementUI 返回目录  考虑到 UI 是我，开发还是我。 那么，尽情使用 UI 框架吧！这里偷懒用 ElementUI 咯。 然后，为了使项目尽可能小巧，jsliang 打算按需引入 ElementUI： 安装 ElementUI：npm i element-ui -S 安装 babel-plugin-component：npm i babel-plugin-component -D 修改 .babelrc： .babelrc { \"presets\": [ [\"env\", { \"modules\": false, \"targets\": { \"browsers\": [\"> 1%\", \"last 2 versions\", \"not ie 按需引入 Row 与 Col： main.js import Vue from 'vue' import App from './App' import router from './router' Vue.config.productionTip = false // 引入样式重置 import '../static/css/reset.css' // 引入及使用 ElementUI import {Row, Col} from 'element-ui'; Vue.use(Row).use(Col); new Vue({ el: '#app', router, components: { App }, template: '' })  这样，就可以在项目中使用这两个组件了： 项目/src/components/HelloWorld.vue 代码片段 111 222 333 3.4 总体配置 返回目录  该需要的东东，都差不多准备好了。 那么，我们的简历，长啥样呢？ 由于手里木有成品 “参考” 和 “借鉴”，所以去网上看看别人的 ECharts 都长啥样吧：  如图，jsliang 觉得这图的布局不错，所以下载下来了它的 png 版本和 psd 版本。 然后，怕小伙伴们难以想象要怎么操作，我用 PS 修改下它的 psd 吧：  很好，这个在线个人简历要怎么做就一目了然了。  下面我们开始切图仔工作：  首先，创建 7 个 components，并删除 HelloWorld.vue：  jsliang 太懒，名字就懒得想了，从左到右，从上到下，依次命名 7 个框的名字为 PartOne 到 PartSeven 吧。 PartOne.vue 代码示例 第一部分 export default { } 说到这里，有的小伙伴可能觉得复制粘贴或者手写 Vue-Cli 代码特别烦，所以这里推荐使用 VS Code 的插件：Vue VSCode Snippets。通过在页面上敲：vbase，就可以快速生成 Vue-Cli 的基础代码了。  然后，我们在 index.js 中定义这些文件，并在 App.vue 引用它们： 项目/src/router/index.js import Vue from 'vue' import Router from 'vue-router' Vue.use(Router) const PartOne = () => import('@/components/PartOne'); const PartTwo = () => import('@/components/PartTwo'); const PartThree = () => import('@/components/PartThree'); const PartFour = () => import('@/components/PartFour'); const PartFive = () => import('@/components/PartFive'); const PartSix = () => import('@/components/PartSix'); const PartSeven = () => import('@/components/PartSeven'); export default new Router({ routes: [ { path: '/', components: { PartOne: PartOne, PartTwo: PartTwo, PartThree: PartThree, PartFour: PartFour, PartFive: PartFive, PartSix: PartSix, PartSeven: PartSeven } }, { path: '/PartOne', name: 'PartOne', component: PartOne }, { path: '/PartTwo', name: 'PartTwo', component: PartTwo }, { path: '/PartThree', name: 'PartThree', component: PartThree }, { path: '/PartFour', name: 'PartFour', component: PartFour }, { path: '/PartFive', name: 'PartFive', component: PartFive }, { path: '/PartSix', name: 'PartSix', component: PartSix }, { path: '/PartSeven', name: 'PartSeven', component: PartSeven }, ] }) 项目/src/App.vue export default { name: 'App' }  此时，通过 npm run dev，我们可以在 localhost:8080/#/ 中可以看到我们已成功进行了布局：  最后，我们通过 CSS 的渲染，成功实现我们的总体布局： 此刻的项目结构图： App.vue export default { name: \"App\", data() { return { bannerXSSM: require(\"./assets/img/banner_640.png\"), bannerMD: require(\"./assets/img/banner_1000.png\"), bannerLGXL: require(\"./assets/img/banner.png\"), }; } }; body { background: #011128; color: #fff; } .app { width: 100%; } .part { padding: 20px; } .banner img { width: 100%; height: 80px; } p { text-align: center; } main.js import Vue from 'vue' import App from './App' import router from './router' Vue.config.productionTip = false // 引入样式重置 import '../static/css/reset.css' // 引入 ElementUI 响应式断点 import 'element-ui/lib/theme-chalk/display.css'; // 引入及使用 ElementUI import {Row, Col} from 'element-ui'; Vue.use(Row).use(Col); new Vue({ el: '#app', router, components: { App }, template: '' }) PartOne.vue ( PartTwo 及其他 6 个文件雷同) 第一部分 export default { name: \"partOne\" }; .part-one { width: 100%; height: 500px; border: 15px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; }  这样，我们就成功完成了高尚的切图仔工作，可以继续下一步咯：  为了防止小伙伴们晕乎，保险起见 jsliang 将总体配置的代码提交到了分支，需要的小伙伴直接下载即可：  ECharts 打造在线个人简历分支 - 完整配置 四 分步实现 返回目录  提问：简历一般有什么内容？ 回答： 基本信息：姓名、工作年限、学历、格言、年龄、联系电话、电子邮箱、GitHub、掘金…… 求职意向：职位、城市、薪资、准备入职时间…… 工作经验：…… 个人技能：熟悉 HTML5、CSS3、JavaScript…… 教育背景/荣誉证书（这两样没有很出彩的地方的话，jsliang 建议就忽略不写了）  所以，我们就着这几方面来编写我们的简历吧~ 4.1 part1 - 基本信息 返回目录  话不多说，先上代码： PartOne.vue 姓&emsp;&emsp;名：梁峻荣 学&emsp;&emsp;历：本科 工作年限：1 年 年&emsp;&emsp;龄：23 联系电话：18818881888 电子邮箱：1741020489@qq.com 博&emsp;&emsp;客：jsliang.top 掘&emsp;&emsp;金：jsliang GitHub：LiangJunrong export default { name: \"partOne\", data() { return { headImage: require('../assets/img/head_image.png') } } }; a { color: deepskyblue; } a:hover { color: rgb(118, 190, 248); } p { line-height: 30px; } .part-one { width: 100%; height: 500px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; padding-left: 10px; } .part-one-image { width: 150px; height: 150px; }  实现效果：  如上，这只是个简单的信息填充，就不多说了。 4.2 part2 - 好友分布 返回目录  话不多说，先上代码： PartTwo.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); // 引用中国地图 require(\"echarts/map/js/china.js\"); export default { name: \"partTwo\", data() { return {}; }, mounted() { this.drawECharts(); }, methods: { drawECharts() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById(\"part-two\")); // 排行前五城市 let myFirendCity = [ { name: \"广州\", value: [\"113.23\", \"23.16\", \"9\"] }, { name: \"深圳\", value: [\"114.07\", \"22.62\", \"12\"] }, { name: \"上海\", value: [\"121.48\", \"31.22\", \"10\"] }, { name: \"西安\", value: [\"108.95\", \"34.27\", \"4\"] }, { name: \"北京\", value: [\"116.46\", \"39.92\", \"12\"] }, ]; // 好友分布省份 let myFriendProvince = [ { name: \"山东\", value: 1 }, { name: \"四川\", value: 1 }, { name: \"广东\", value: 21 }, { name: \"广西\", value: 1 }, { name: \"北京\", value: 12 }, { name: \"甘肃\", value: 1 }, { name: \"上海\", value: 10 }, { name: \"陕西\", value: 4 }, { name: \"湖北\", value: 1 }, { name: \"湖南\", value: 1 }, { name: \"山西\", value: 1 }, { name: \"辽宁\", value: 2 }, { name: \"江苏\", value: 1 }, { name: \"河北\", value: 3 }, { name: \"海南\", value: 1 }, { name: \"河南\", value: 1 } ]; myChart.setOption({ // 标题 title: { text: \"前端好友分布\", textStyle: { color: \"#fff\" }, subtext: \"微信统计\", subtextStyle: { color: \"#fff\" }, x: \"center\" }, // 移动显示 tooltip: { trigger: \"item\", // 鼠标移动过去显示 formatter: function(params) { if (params.value[2] == undefined) { if(!params.name) { return \"该地区暂无好友\"; } else { return params.name + \" : \" + params.value; } } else { return params.name + \" : \" + params.value[2]; } } }, // 左边注记 visualMap: { text: [\"\", \"好友数\"], min: 0, max: 30, // 是否能通过手柄显示 calculable: true, inRange: { color: [\"#e4e004\", \"#ff5506\", \"#ff0000\"] }, textStyle: { color: \"#fff\" } }, // geo geo: { map: \"china\" }, // 数据 series: [ // 排行前五城市 { name: \"排行前五\", type: \"effectScatter\", coordinateSystem: \"geo\", symbolSize: function(val) { return val[2] * 2; }, showEffectOn: \"render\", rippleEffect: { brushType: \"stroke\" }, hoverAnimation: true, label: { normal: { formatter: \"{b}\", position: \"right\", show: true, color: \"#fff\" } }, itemStyle: { normal: { color: \"#ddb926\", shadowBlur: 10, shadowColor: \"#333\" } }, // 类似于 z-index zlevel: 1, data: myFirendCity, }, // 好友分布省份 { name: \"好友数\", type: \"map\", mapType: \"china\", // 是否允许缩放 roam: false, label: { // 显示省份标签 normal: { formatter: myFirendCity, show: false, textStyle: { color: \"#fff\" } }, // 对应的鼠标悬浮效果 emphasis: { show: false } }, itemStyle: { normal: { borderWidth: 0.5, // 区域边框宽度 borderColor: \"#fff\", // 区域边框颜色 areaColor: \"deepskyblue\" // 区域颜色 }, // 对应的鼠标悬浮效果 emphasis: { borderWidth: 1, borderColor: \"#fff\", areaColor: \"#00aeff\" } }, // 数据 data: myFriendProvince } ] }); } } }; .part-two { width: 100%; height: 500px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; }  实现效果：  首先，我们引用了 ECharts 及它的中国地图： let echarts = require(\"echarts/lib/echarts\"); require(\"echarts/map/js/china.js\");  然后，我们初始化 DOM 和数据： let myChart = echarts.init(document.getElementById(\"part-two\")); let myFriendData = [ { name: \"山东\", value: 1 }, { name: \"四川\", value: 1 }, { name: \"广东\", value: 21 }, { name: \"广西\", value: 1 }, { name: \"北京\", value: 12 }, { name: \"甘肃\", value: 1 }, { name: \"上海\", value: 5 }, { name: \"陕西\", value: 4 }, { name: \"湖北\", value: 1 }, { name: \"湖南\", value: 1 }, { name: \"山西\", value: 1 }, { name: \"辽宁\", value: 2 }, { name: \"江苏\", value: 1 }, { name: \"河北\", value: 3 }, { name: \"海南\", value: 1 }, { name: \"河南\", value: 1 } ];  最后，我们通过 setOption 实现了地图的描绘，上面配置仅是个人配置方法，详细的方法请参考：ECharts 配置。 4.3 part3 - 技能特长 返回目录  说到简历，还记得之前看过一份，印象特深，因为人家就是用 Word 中用图表展示的。所以，咱也试试： PartThree.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); export default { name: \"partThree\", data() { return {}; }, mounted() { this.drawECharts(); }, methods: { drawECharts() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById(\"part-three\")); myChart.setOption({ // 标题 title: { // 标题文本 text: \"技能分布图\", // 标题样式 textStyle: { color: \"#fff\" }, // 标题位置 x: \"center\" }, // 移动显示 tooltip: { trigger: \"item\", // 显示文字样式 formatter: \"{a} {b} : {d}%\" }, // 注记 legend: { x: \"center\", y: \"bottom\", textStyle: { color: \"#fff\" }, data: [ \"HTML5\", \"CSS3\", \"JavaScript\", \"jQuery\", \"Vue\", \"Node\", \"微信小程序\", \"其他\" ] }, // 注记显示手柄 calculable: true, // 图形系列 series: [ { name: \"技能分布\", type: \"pie\", radius: [30, 110], roseType: \"area\", data: [ { value: 15, name: \"HTML5\" }, { value: 15, name: \"CSS3\" }, { value: 20, name: \"JavaScript\" }, { value: 20, name: \"jQuery\" }, { value: 20, name: \"Vue\" }, { value: 15, name: \"Node\" }, { value: 25, name: \"微信小程序\" }, { value: 15, name: \"其他\" } ] } ], // 颜色调整 color: ['#00bfff', '#00ffdd', '#207ffc', '#00aeff', \"#00eeff\", \"#006eff\", \"#0099ff\", \"#0066ff\"] }); } } }; .part-three { width: 100%; height: 500px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; }  如上，我们就设置好了： 4.4 part4 - 文章成就 返回目录  有时候就是想偷懒，也想不起自己还有啥好吹水的了，于是贴个自己的前端文档库的成就吧： PartFour.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); export default { name: \"partFour\", data() { return {}; }, mounted() { this.drawECharts(); }, methods: { drawECharts() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById(\"part-four\")); myChart.setOption({ // 标题 title: { // 标题文本 text: \"文章成就统计\", // 标题文本样式 textStyle: { color: \"#fff\" }, // 标题位置 x: \"center\" }, // 图形布局 grid: { // 距离底部高度 bottom: \"20\" }, // 横轴 xAxis: { show: false, type: \"category\", data: [\"Github 提交：\\n1141\", \"Github Star数：\\n269\", \"掘金点赞量：\\n1508\", \"掘金关注者：\\n234\"], axisLine: { lineStyle: { color: \"#fff\" } }, axisLabel: { // 横轴信息全部显示 interval: 0 } }, // 纵轴 yAxis: { type: \"value\", axisLine: { lineStyle: { color: \"#fff\" } }, axisLabel: { // 横轴信息全部显示 interval: 0 } }, // 图形系列 series: [ { // 图类型 type: \"bar\", // 数据 data: [1141, 269, 1508, 234], // 文本 label: { show: true, position: \"top\", color: \"#fff\", formatter: \"{b}\" }, // 柱条样式 itemStyle: { color: \"deepskyblue\" }, zlevel: 1 } ] }); } } }; .part-four { width: 100%; height: 310px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } 4.5 part5 - 前端研发 返回目录  简历一大重点，就是工作经验啦： PartFive.vue 工作经验 广州**科技股份有限公司 | 2018/05 - 至今 工作内容：日常操作 jQuery 编写活动页、微信小程序、Vue + ECharts 报表制作…… 项目成就： &emsp;1. 企业宝小程序。使用原生代码进行微信小程序的开发，代码已完成，尚在审核，尚未上线。 &emsp;2. ECharts 报表汇总。使用 Vue + ECharts 进行报表设计，正在开发。 &emsp;3. jQuery 活动页及 H5 活动页。 export default { name: \"partFive\", data() { return { partFive: \"part-five\", curWidth: 0 }; }, beforeMount() { this.curWidth = document.documentElement.clientWidth || document.body.clientWidth; if(this.curWidth a { color: deepskyblue; } a:hover { color: rgb(118, 190, 248); } .part-five { width: 100%; height: 310px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .part-five-responsive { width: 100%; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .text-center { text-align: center; } .text-small { font-size: 0.9em; color: rgb(253, 239, 239); }  结果显示为： 4.6 part6 - 编程技能 返回目录  除了工作经验，我们还需要 show 一下我们的编程技能都有什么： PartSix.vue 编程技能 前端：HTML/HTML5、CSS/CSS3、JS/ES6、jQuery、Vue、微信小程序…… 后端：Node、PHP 其他：MongoDB、MySQL、Sqlserver export default { name: \"partSix\", data() { return { partSix: \"part-six\", curWidth: 0 }; }, beforeMount() { this.curWidth = document.documentElement.clientWidth || document.body.clientWidth; if(this.curWidth .part-six { width: 100%; height: 310px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .part-six-responsive { width: 100%; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .text-center { text-align: center; } .font-small { font-size: .9em; } .font-bold { font-weight: bold; color: deepskyblue; }  成果如下图所示： 4.7 part7 - 求职意向 返回目录  最后，当然要表明我们的求职意向，好让 HR 小姐姐知道我们想要什么啦~ PartSeven.vue 求职意向 期望职位：前端工程师 工作技能：Vue 目标城市：广州、深圳、杭州、上海 期望薪资：10K - 15K 入职时间：随时入职 export default { name: \"partSeven\", data() { return { partSeven: \"part-seven\", curWidth: 0 }; }, beforeMount() { this.curWidth = document.documentElement.clientWidth || document.body.clientWidth; if(this.curWidth .part-seven { width: 100%; height: 310px; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .part-sevev-responsive { width: 100%; border: 40px solid transparent; border-image: url(\"~@/./assets/img/border_image.png\") 30 30 stretch; background: #18202d; } .text-center { text-align: center; } .text-small { font-size: .9em; } .font-bold { text-align: center; color: deepskyblue; }  结果如下图所示：  至此，所有代码编写完毕，偷懒的小伙伴可以去下面地址下载所有代码： ECharts 打造在线个人简历 五 总结 返回目录  最后再看下我们的最终成品：  OK，到这里，也是时候将这份成品放到我们的线上啦：  使用 GitHub Pages 和 VuePress 搭建网站  我们只需要搭建个 GitHub Pages 的账号，就可以部署这份在线简历咯~ 当然 jsliang 有自己的服务器哈，就没使用 GitHub Pages 了，感兴趣的小伙伴可以跟着上面的文章折腾去~ 所以，这篇文章就结束啦！ 番外：  哈哈，jsliang 已经 预 感 到 了：  你的好友喷子小哥上线啦！ “哇，这样用 ECharts 的吗？还能不能更 low 点？！” “哇，Vue 这样写的吗？你懂不懂 Vue？” “哇，……”  enm......所以我不管怎么说，都说不过这些大佬的，所以有的评论就不回复啦，哈哈~  最后，在此祝小伙伴们找到更好的工作~ 小伙伴们如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址 撰文不易，如果文章对小伙伴有帮助，希望小伙伴们给勤劳敲代码、辛苦撰文的 jsliang 进行微信/支付宝打赏，你们的每一次打赏都是最好的鼓励，谢谢~ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/ECharts/CurriculumVitaeImprove.html":{"url":"JavaScript-library/ECharts/CurriculumVitaeImprove.html","title":"✔ ECharts 打造在线个人简历 【升级版】","keywords":"","body":"ECharts 打造在线个人简历 【升级版】 Create by jsliang on 2018-12-11 10:21:27Recently revised in 2019-2-11 11:07:47  在发表文章 ECharts 打造在线个人简历 （GitHub版 / 掘金版） 后，迎来了各位大佬的吐槽： 根本没有一点技术含量，体现不出较高的前端水准。 可以用 Canvas 做动态背景么？应该会更炫酷。 百度的 AntV 也不错，值得一试。 边框能不能更炫酷点，用 CSS3 的动画来实现。 GitHub 的 start 数和掘金的点赞数能不能用爬虫爬出来啊，这样会不会更牛逼点。  综上，我决定结合这些建议，将它化为可行性，再升级打造过！ …… …… …… 才怪咧！jsliang 稳食艰难，抽不出功夫啊~  目前正在折腾这两篇文章： Node 基础：从 0 到 1 打造 Node 扎实基础，实现 Web 服务的部署以及仿 Express 深入了解 Node 以及使用原生 Node 编写个简单的企业网站。 JavaScript 之 构造函数与原型对象：进一步深入了解，加深 JavaScript 的学习及使用。  同时，愁着下面两点： 写文章耗时。基本是：写文章时间 = 学习敲代码的时间 * 1.5。因为我不仅要自己懂，还要化繁为简，讲得小伙伴们也懂，我也印象深刻点。 明年想跳槽换 10K+ 的工作。但是时间不够，技术没法沉淀，现在在朝着自己 8 月份布的局，努力学习提升中，毕竟资本提不上去没资格跟 HR 要更好的薪资。  所以，除非有 特殊安排，要不在线简历这块是没那么快更新的咯，哈哈~  最后的最后，引用我之前那句话：  不折腾的前端，和咸鱼有什么区别  相信按奈不住的小伙伴，可以根据 jsliang 的文章，结合上面更改的建议，自己动手搞个更炫酷的简历的，加油~ 更多精彩，尽在 jsliang 的文档库 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/ECharts/EChartsVue.html":{"url":"JavaScript-library/ECharts/EChartsVue.html","title":"✔ ECharts + Vue 折腾记","keywords":"","body":"ECharts + Vue 折腾记 Create by jsliang on 2018-11-28 11:01:39Recently revised in 2019-2-11 11:09:30  Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址  技术官网就是躺坑的地儿！ 翻遍百度文，一把辛酸泪~ 整合网上的 Vue + ElementUI，Vue + ECharts，ECharts + 百度地图 API……的文章，带你走非一般的道路。 一 目录  不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文  3.1 Vue  3.2 Echarts  3.3 ElementUI  3.4 百度地图 四 精细入微  4.1 百度地图调整  4.2 样式问题集 二 前言 返回目录  现在是大数据和云计算的时代，所以数据可视化逐渐变成一种趋势。 而 ECharts 对于制作的图表可以满足小伙伴们的创造力，它具备华丽的外衣，且实用。 在这里，jsliang 将通过 ECharts + Vue 进行折腾。 如果小伙伴们对 Vue 还不太熟，这里可能没法带你飞喔~前置条件：Vue、Npm、Webpack  参考文献： ECharts Demo | ECharts 官网 ElementUI | ElementUI 官网 在 vue-cli 项目中使用 echarts | 博客园 - 搞前端的李蚊子 Vue：在 Vue 中使用 echarts | 简书 - Mr_Treasure 在 VUE 项目中使用 ECharts 画 K 线图和面积图 | CSDN - zgh0711 在 vue 中添加 Echarts 图表使用详解 | PHP 中文网 - 小云云 v-charts | 饿了么 vue-echarts | npm 在 vue 中，应该直接使用 echarts 还是 vue-echarts | Vue 论坛 - JasonBai007 在 vue 项目中引入高德地图及其 UI 组件 | CSDN - shuaizi96 vue 引入高德地图 echarts 百度地图引用报错 A parser-blocking, cross site (i.e. different eTLD+1) script | CSDN - 雨中畅游 vue 引入公共css文件 | CSDN - Smartsunsing 调用百度地图api 去掉地图左下角LOGO或文字 | CSDN - 陈小黏 Echarts数据可视化系列文章 | CSDN - 数据架构师 几种css炫酷背景欣赏 | CSDN - 小圣贤君 三 正文 返回目录  Now, let's go~ 如果你觉得自己的 npm 下载速度过慢，请使用 cnpm： 安装：npm install -g cnpm --registry=https://registry.npm.taobao.org 使用：cnpm i 插件 -g 3.1 Vue 返回目录  Vue 参考文档： 介绍 Vue.js | Vue 官网 介绍 Vue Router | Vue Router 官网  步骤： 安装 vue-cli：npm i vue-cli -g 初始化 Vue 项目：vue init webpack 开启开发模式：npm run dev 打开浏览器，查看网页： http://localhost:8080 3.2 Echarts 返回目录  首先，我们在项目中安装 ECharts 依赖： npm i echarts -S  然后，你可以选择按需引用还是全局引用： 全局引用  ECharts 初始化应在钩子函数 mounted() 中，这个钩子函数是在 el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。 项目/src/main.js import Vue from 'vue' import App from './App' import router from './router' // 引入echarts import echarts from 'echarts' Vue.prototype.$echarts = echarts Vue.config.productionTip = false new Vue({ el: '#app', router, components: { App }, template: '' }) 项目/src/components/HelloWorld.vue export default { name: 'hello', data () { return { msg: 'Welcome to Your Vue.js App' } }, mounted(){ this.drawLine(); }, methods: { drawLine(){ // 基于准备好的dom，初始化echarts实例 let myChart = this.$echarts.init(document.getElementById('myChart')) // 绘制图表 myChart.setOption({ title: { text: '在Vue中使用echarts' }, tooltip: {}, xAxis: { data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); } } } 按需引用  如果我们使用全局引用。将 ECharts 图表打包，会导致体积过大，所以项目中最好按需引入。 在这里我们使用 requrie 引用而不是 import，因为 import 必须写全路径，比较麻烦。 项目/src/components/HelloWorld.vue // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); // 引入柱状图组件 require(\"echarts/lib/chart/bar\"); // 引入提示框和title组件 require(\"echarts/lib/component/tooltip\"); require(\"echarts/lib/component/title\"); export default { name: 'hello', data() { return { msg: 'Welcome to Your Vue.js App' } }, mounted() { this.drawLine(); }, methods: { drawLine() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById('myChart')) // 绘制图表 myChart.setOption({ title: { text: 'ECharts 入门示例' }, tooltip: {}, xAxis: { data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }); } } };  最后，我们只需要 npm run dev 启动项目，打开 localhost:8080 即可。 3.3 ElementUI 返回目录  考虑到项目没有 UI 设计稿。那么，就需要引用一款 Vue 的 UI 框架了，偷懒用 ElementUI 吧。 然后，为了使项目尽可能小巧，jsliang 打算按需引入 ElementUI： 安装 ElementUI：npm i element-ui -S 安装 babel-plugin-component：npm i babel-plugin-component -D 修改 .babelrc： .babelrc { \"presets\": [ [\"env\", { \"modules\": false, \"targets\": { \"browsers\": [\"> 1%\", \"last 2 versions\", \"not ie 按需引入 Row 与 Col： main.js import Vue from 'vue' import App from './App' import router from './router' Vue.config.productionTip = false import {Row, Col} from 'element-ui'; Vue.use(Row).use(Col); new Vue({ el: '#app', router, components: { App }, template: '' })  这样，就可以在项目中使用这两个组件了。 3.4 百度地图 返回目录  引用百度地图很简单，但是结合 Vue + ECharts 来使用百度地图，很难。现在我们过一遍如何使用： 引用百度地图： 项目/index.html ECharts 图表 注意：srcipt 引用的链接，需要你去百度地图 API 那里获得，因为 ak 对应的是个人的 API 地址，这里不可能泄露给你的。百度地图 API 在组件中使用它： 模板表格 // 注意在 index.html 引入全局的百度地图 JS // script src=\"\"http://api.map.baidu.com/getscript?v=3.0&ak=Xjmh9v5jGa******6ZVf0PU2ueSedr5F\" // 引入基本模板 let echarts = require(\"echarts/lib/echarts\"); // 引入百度扩展 require(\"echarts/extension/bmap/bmap\"); export default { name: \"temp\", data() { return {}; }, mounted() { this.drawTempMap(); }, methods: { drawTempMap() { // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById(\"temp-chart\")); // 创建地图实例 var map = new BMap.Map(\"temp-chart\"); // 绘制图表 myChart.setOption({ // 加载 bmap 组件 bmap: { // 百度地图中心经纬度 center: [116.46, 39.92], // 百度地图缩放 zoom: 4, // 是否开启拖拽缩放，可以只设置 'scale' 或者 'move' roam: true, // 百度地图的自定义样式，见 http://developer.baidu.com/map/jsdevelop-11.htm mapStyle: {} }, series: [ { type: \"scatter\", // 使用百度地图坐标系 coordinateSystem: \"bmap\", // 数据格式跟在 geo 坐标系上一样，每一项都是 [经度，纬度，数值大小，其它维度...] data: [ [116.46, 39.92, 1] ] } ] }); } } }; .temp-chart { width: 300px; height: 300px; }  这样，我们就可以在我们的 ECharts 畅通无阻地使用百度地图了。 四 精细入微 返回目录  有时候，一些小细节总会困惑你。 在这里，jsliang 将贴出自己解决的小细节。 结合 Ctrl + F 搜索关键字喔~ 4.1 百度地图调整 返回目录 问：为什么开发的时候控制台报 warning？ api?v=3.0&ak=Xjmh9v5jGa*****6ZVf0PU2ueSedr5F:1 A parser-blocking, cross site (i.e. different eTLD+1) script, http://api.map.baidu.com/getscript?  答： 这时候你的引用地址应该是：  你只需要将 api 改成 getscript 即可解决它的 warning 警告： 问：如何去除百度地图左下角的信息（logo 和 文字）？  答：  你只需要在全局样式里写上下面这段话就可以屏蔽它： App.vue .BMap_cpyCtrl, .BMap_noprint, .anchorBL { display: none !important; } 4.2 样式问题集 返回目录 问：为什么 Chrome 上的 body 会有 8px 的 margin 值？或者 img 不贴边之类的。 答：  这是浏览器自带的样式喔，去掉方式：  首先，在项目的 static 目录上，新建 css 文件夹，然后新建 reset.css，内容如下所示： 项目/static/css/reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /** 图片自适应 - image responsize **/ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .26rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .26rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .26rem } /* Internet Explorer */  然后，在项目目录的 src 目录下的 main.js 文件中添加下面的语句，就可以引用 css 样式，清空浏览器的内置了： 项目/src/main.js import '../static/css/reset.css' /**引入样式重置 */  Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/design-pattern/":{"url":"JavaScript-library/design-pattern/","title":"设计模式","keywords":"","body":"设计模式手册 - 0 - 目录和简介 create by jsliang on 2018-8-21 11:30:00Recently revised in 2019-2-11 11:12:507 项目实例 点我前往 目录 章节名 导航 第一章 部署开发环境 第二章 面向对象与设计模式初探 第三章 工厂模式 第四章 单例模式 第五章 适配器模式 第六章 装饰器模式 第七章 代理模式 第八章 外观模式 第九章 观察者模式 第十章 迭代器模式 第十一章 状态模式 第十二章 其他模式 第十三章 综合应用 其他模式中包含：原型模式、桥接模式、组合模式、享元模式、策略模式、模板方法模式、职责连模式、命令模式、备忘录模式、中介者模式、访问者模式、解释器模式这12种不常用模式 关于面试 面试中能说出第二章至第十一章的模式，一般来说设计模式方面是满分了，当然不排除是高级工程师，但是高级工程师是不会看我这篇文章的，所以 jsliang 就不担心被打脸了 关于工作日常使用 如果是常用的设计模式，最好就是结合自己的理解，列个列表，在工作中大胆尝试使用，而不是学习完就丢一边。如果是非常用的设计模式，那就应该视业务场景选择性使用。 使用场景 如果是业务性很强的，压根没时间写点好的JavaScript。一般来说，直接用面向对象写法，怎么方便怎么来。所以就有了“活动说明直接整张图丢上去，文字都也不弄出来”“能上图的就上图，写个文字都是罪” 然后，如果是长久使用的，要考虑维护的，还是用面向对象思路封装好来，随时调用。 知识普及： Webpack babel-core：把es6中的新语法（箭头函数、rest参数等）解析成ast这种形式，然后配合各个插件分析语法进行相应的处理。 babel-loader：一种loader解析器，配合Webpack解析ES6编写的js文件。 babel-preset-*：babel-reset-2015包含了es6对应的新语法，如果配置了babel-reset-latest，则包含了es2015、es2016、es2017的插件（之后可能包括es2018等）。注：在安装过程中jsliang发现，官方已不建议使用babel-preset-*系列了，而是推荐使用下面介绍的babel-preset-env包。 babel-polyfill：实现浏览器对不支持API的兼容（兼容旧环境、填补）。 babel-preset-env：如果不做任何配置，该loader等同于bable-preset-latest，如果你需要根据不同浏览器或者node版本进行配置，推荐使用babel-preset-env进行配置使用 详情介绍 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/design-pattern/design-pattern-chapter01.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter01.html","title":"✘ 设计模式手册 - 1 - 部署开发环境","keywords":"","body":"设计模式手册 - 1 - 部署开发环境 create by jsliang on 2018年8月22日11:19:00Recently revised in 2019-05-20 17:31:21 第一章 部署开发环境  为什么要部署个开发环境呢？我就不能直接将es6转成es5直接使用吗？回答是：可以啊！链接拿去，里面告诉你怎么配置babel，将es6转es5。如果你觉得还要配置babel，也是挺麻烦的，链接拿去，里面已经设置好了，直接在线将es8、es7、es6转es5，去吧少年~ 但是，怎么说呢，工欲善其事，必先利其器。一切的编程就是为了偷懒，所以jsliang配置个Webpack的es6环境，就是想： 偷懒。每次写完代码按Ctrl+C，就可以在另一个显示屏（jsliang两个显示屏的）直接看到编译结果了，而不是用命令行将ES6转为ES5. 还是偷懒。有时候写个小项目，用原生搞的话，ES5有时候写起来不爽啊，能耍耍ES6就好了，到时候还要搞事情，转ES5、手机查看啥的，还不如直接配置好，到时候直接用啦。 还是还是偷懒。要知道有些个玩意，叫vue-cli、react-cli、angular-cli，而且目前jsliang所知的，就是vue-cli是单页面SPA配置，到时候你要去搞多页面，还是需要学Webpack，所以事先学学，到时候就不用焦头烂额，又学react又搞Webpack啦~对了，顺带打个广告，Webpack的多页面配置jsliang已经配置好了，Webpack学习链接拿去、多页面配置链接拿去。  好嘞，jsliang强行解释一通，不管你接不接受，反正我是接受了，部署开发环境走起~ 1.1 打包JavaScript  本节实现目的：部署个能打包JavaScript的环境： 执行命令行：npm init -y，初始化package.json文件。 执行命令行：cnpm i webpack webpack-cli -D，安装webpack及其命令行工具webpack-cli。 在根目录下新建src文件夹，并在里面新建index.js文件，该文件打印了个100。 index.js console.log(100); 在根目录下新建webpack.dev.config.js文件。 webpack.dev.config.js module.exports = { entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname, filename: './dist/src/index.js' }, } 在webpack.dev.config.js中，我们做了两件事： 告知webpack我们的入口文件（需要被解析的ES6文件）在根目录的src下的index.js； 告知webpack我们的出口文件（被解析后的ES5文件）需要打包到的位置是相对于当前目录的dist/src下的index.js。 修改package.json文件。 package.json { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack --config ./webpack.dev.config.js --mode development\" }, \"keywords\": [ \"javascript\", \"design\", \"pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", } } 在这里，我们修改了\"scripts\"部分，告知npm在npm run dev的时候，记得使用webpack命令，用开发模式来解析配置文件webpack.dev.config.js。 执行命令行：npm run dev，可以查看到在根目录中生成了个dist文件夹，该文件夹下存有一个src文件夹，里面包含了个index.js。本处有点小瑕疵，这里是src文件夹，但是到了后面变成了js文件夹，因为这是打包后的js存放的地方，当然这里是不影响使用的，下面我们会提到。 此时目前目录如下： 1.2 动态打包JavaScript  本节实现目的：部署个能按Ctrl+C，就能自动更新代码的Webpack环境。 执行命令行：cnpm i webpack-dev-server html-webpack-plugin -D，安装Webpack的devServer，这个能启动开发模式实时监控代码的webpack配置。同时，安装html-webpack-plugin，这个能解析HTML的插件。 新建dist/index.html文件，由于这个HTML文件无特殊之处，所以这里不做过多讲解： index.html jsliang的设计模式 jsliang的设计模式 根据我们安装的webpack-dev-server与html-webpack-plugin这两个配置，修改webpack.dev.config.js，使其能解析HTML文件和监控dist目录。 webpack.dev.config.js const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'development', // 开发模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname, filename: './dist/src/index.js' }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ], devServer: { // 开发服务 contentBase: path.join(__dirname, './dist'), // 根目录 open: true, // 自动打开浏览器 port: 8080, // 端口 //host: \"192.168.1.107\" // WiFi IPV4地址，打开可共享到手机 } } 修改package.json，告知npm，我们不用webpack这个比较low的方式了，请给我用webpack-dev-server来启动npm run dev。 package.json { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack-dev-server --config ./webpack.dev.config.js\" }, \"keywords\": [ \"javascript\", \"design\", \"pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"html-webpack-plugin\": \"^3.2.0\", \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", \"webpack-dev-server\": \"^3.1.5\" } } 执行命令行：npm run dev，发现浏览器自动打开http://localhost:8080(启动WiFi的情况下应该是打开类似于http://192.168.1.107:8080/)的网址： 此时文件目录为： 1.3 自动打包ES6  本节实现目的：部署个能按Ctrl+C，就能自动打包ES6为ES5，并且能自动更新代码的Webpack环境。 执行命令行：cnpm i babel-core babel-loader babel-polyfill babel-preset-env -D，安装ES6对应的解析配置，执行完毕后package.json会自动新增依赖包： package.json { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack-dev-server --config ./webpack.dev.config.js --mode development\" }, \"keywords\": [ \"javascript\", \"design\", \"pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-polyfill\": \"^6.26.0\", \"babel-preset-env\": \"^1.7.0\", \"html-webpack-plugin\": \"^3.2.0\", \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", \"webpack-dev-server\": \"^3.1.5\" } } 新建.babelrc文件，该文件为ES6解析到ES5必须使用的文件（注，现在市面上大部分浏览器还不能完全直接解析ECMA Script2015语法，所以只能将ES6转为ES5，就用到了.babelrc文件）： .babelrc { \"presets\": [ \"env\" ], \"plugins\": [ ] } 修改webpack.dev.config.js，添加module，告知webpack在加载js文件的时候，需要使用babel-loader。 webpack.dev.config.js const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'development', // 开发模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname, filename: './dist/src/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ], devServer: { // 开发服务 contentBase: path.join(__dirname, './dist'), // 根目录 open: true, // 自动打开浏览器 port: 8080, // 端口 host: \"192.168.1.107\" // WiFi IPV4地址，打开可共享到手机 } } 修改index.js，这里我们换成ES6语法（如果你还没学过ES6，你只需要知道这里弹窗显示了jsliang即可，内容可以忽略）： index.js class Person { constructor(name) { this.name = name; } getName() { return this.name; } } let person = new Person(\"jsliang\"); alert(person.getName()); 执行命令行：npm run dev，即可看到HTML页面弹窗显示 jsliang 。 1.4 完善配置  本节实现目的：npm run dev命令下，部署个能按Ctrl+C，就能自动打包ES6为ES5，并且能自动更新代码的Webpack环境。npm run build命令下，能打包文件到dist目录。 经过上面的努力，终于可以在多终端（电脑+手机）实时查看自己编写的ES6代码了。然而，还是有点小瑕疵。例如：无法将代码打包应用于生产；打包js的目录名称叫src……。所以，Let's Go! 再搞个生产环境，让我们完美结束这份Webpack配置吧~ 新增webpack.prod.config.js，用作打包生产： webpack.prod.config.js const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'production', // 生产模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname + '/dist', filename: './js/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ] } 修改下package.json，使其能使用命令行npm run build： package.json { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack-dev-server --config ./webpack.dev.config.js\", \"build\": \"webpack --config ./webpack.dev.config.js\" }, \"keywords\": [ \"javascript\", \"design pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-polyfill\": \"^6.26.0\", \"babel-preset-env\": \"^1.7.0\", \"html-webpack-plugin\": \"^3.2.0\", \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", \"webpack-dev-server\": \"^3.1.5\" } } 完善下webpack.dev.config.js： wepbakc.dev.config.js const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'development', // 开发模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname + '/dist', filename: './js/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ], devServer: { // 开发服务 contentBase: path.join(__dirname, './dist'), // 监控的目录 open: true, // 自动打开浏览器 port: 9000, // 端口 host: \"192.168.1.107\" // WiFi IPV4地址，打开可共享到手机 } } 检查下其他文件，看看是否与jsliang一致： src/index.js class Person { constructor(name) { this.name = name; } getName() { return this.name; } } let person = new Person(\"jsliang\"); alert(person.getName()); .babelrc { \"presets\": [ \"env\" ], \"plugins\": [ ] } index.html jsliang的设计模式 jsliang的设计模式 执行命令行npm run dev或者npm run build,然后查看目录：OK，都能成功运行，生产环境部署完毕，接下来我们愉快地玩耍设计模式吧！ jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:31:22 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/design-pattern/design-pattern-chapter02.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter02.html","title":"✘ 设计模式手册 - 2 - 面向对象","keywords":"","body":"设计模式手册 - 2 - 面向对象 create by jsliang on 2018年8月24日08:00:00Recently revised in 2019-05-20 17:31:39 未完善版，待完善。 第二章 面向对象 2.1 概念  什么是面向对象？大概1000个人有1001个解释。在这里，jsliang也不去做着1001种解释了，你看着烦我写着累，所以咱用大俗话强行解释一通，懂的就过了，不懂的还不查百度/Chrome就是你的过了。 说起面向对象，我们就要结合面向过程来说了。下面我们有一个游戏场景：  游戏过程： 皮皮虾打开自己的控制面板，检查了下自己状态； 皮皮虾往画面右边走了两步； 皮皮虾夹了下象拔蚌； 皮皮虾受到了象拔蚌的甩鞭反击； 皮皮虾打开自己的控制面板，检查了下自己状态； 皮皮虾发现状态不对，赶紧逃跑。  面向过程： 描绘一只皮皮虾，一个象拔蚌，一个战斗场景; 编写弹窗，显示皮皮虾状态; 编写动画，皮皮虾在游戏场景向右移动两步; 编写动画，皮皮虾攻击象拔蚌; 编写动画，象拔蚌攻击皮皮虾; 编写弹窗，弹窗显示皮皮虾状态; 编写动画，皮皮虾退出战斗场景； 编写动画，败北动画。  面向对象： 准备： 皮皮虾库。存放了皮皮虾的属性状态、动作…… 象拔蚌库。存放了象拔蚌的属性状态、动作…… 游戏场景库。存放了二维坐标、移动动画、战败场景、胜利场景…… 调用了皮皮虾的属性状态。 调用了皮皮虾的属性状态中的头像，调用了游戏场景库中的移动动画，传了两个二位坐标，皮皮虾从左移到右，顺带调用了皮皮虾的跑步动作。 调用了皮皮虾的攻击动作，耍出一套降象十八剪。 调用了象拔蚌的攻击动作，顺带调用了皮皮虾的受击动作。 调用了皮皮虾的属性状态。 调用了皮皮虾败北的动作，顺带调用了场景库的战败场景。  你可能会说，不对啊！面向对象还要做准备，这样不是比面向过程更复杂吗？如果你游戏就这么个场景，那么，使用面向对象就得不偿失了，毕竟做准备也要花功夫的。但是，如果你的游戏，还有火影大战海贼王，也是调用同样的游戏场景库，如果你使用面向过程，是不是要复制粘贴或者重新写过，但是面向对象只需要调用已经写好的游戏场景库，从而省下了大笔时间。 这么说你可能还迷糊，说了那么多话，面向对象究竟长啥样？别急，我们代码的世界见： class Person { constructor(name, age) { this.name = name; this.age = age; } eat() { alert(`${this.name} eat something`); } speak() { alert(`My name is ${this.name}, age ${this.age}`) } } let jsliang = new Person(\"jsliang\"); jsliang.eat(); let JavaScriptLiang = new Person(\"JavaScriptLiang\"); JavaScriptLiang.speak();  在这段代码中，我们使用了封装了个Person的类（如果小伙伴你仅知道ES5，没见过ES6的语法，建议先去看下ES6），然后，jsliang调用了eat这个吃饭的动作，JavaScriptLiang调用了speak这个说话的动作，下次run()、sleep()这些我们也可以放进去，从而实现每个人都可以有属于自己的一套动作。这就是面向对象写法。 很好，经这么一说，jsliang算是勉强过了一遍什么是面向过程和面向对象了。如果小伙伴还是不懂，嗯，如果你没看到开篇那句话的话，那你还是不懂吧~先跟着jsliang撸一遍面向对象再说！ 2.2 三要素 2.2.1 继承  继承，简单来说，就是子类继承父类。继承可将公共方法抽离出来，提高复用，减少冗余。 //父类： 人类Person class People { constructor(name, age) { this.name = name; this.age = age; } eat() { alert(`${this.name} eat something`); } speak() { alert(`My name is ${this.name}, age ${this.age}`); } } //子类： 学生Student class Student extends People { constructor(name, age, id) { super(name, age); this.id = id; } study() { alert(`${this.name} ID is ${this.id}`); } } let jsliang = new People(\"jsliang\", 23); jsliang.speak(); // 在这里，子类学生继承了父类人类，学生既可以调用study()类 // 也可以调用父类中的eat()和speak() let studentLiang = new Student(\"jsliang\", 18, \"003\"); studentLiang.study(); studentLiang.eat(); 2.2.2 封装  封装，简单来说，就是数据的权限和保密。封装的作用有：1、减少耦合，不该外露的不外露；2、利于数据、接口的权限管理 封装有三个关键字：public(完全开放)、protected(对子类开放)、private(对自己开放)。 目前来说，ES6不支持封装，而TypeScript支持。所以，为了做到封装效果，我们可以约定下划线 _ 开头的属性是 private (实际不安全) //父类： 人类Person class People { public name; public age; protected weight; // 定义 protected 属性。受保护的，只有自己和其子类能访问，并且只能在类里面访问，外部调用不会成功 constructor(name, age) { this.name = name; this.age = age; this.weight = 120; } eat() { alert(`${this.name} eat something`); } speak() { alert(`My name is ${this.name}, age ${this.age}`); } } //子类： 学生Student class Student extends People { public id; private girlfriend // 定义private属性 constructor(name, age, id) { super(name, age); this.id = id; this.girlfriend = 'xiaoli' //由于 girlfriend 字段是私有的，所以 People 无法获取，而且只有在 Student 这个类的内部才能访问，外部是无法知道的。但是会有个 bug ，如果你 New 出无数个学生，然后所有学生的女朋友都会叫 xiaoli ，但是这些学生不知道。 } study() { alert(`${this.name} ID is ${this.id}`); } getWeight() { alert(`$this.weight`); // 由于 weight 是受保护的，只有父类和继承它的子类能访问，所以学生类也可以访问体重。 } } let xiaoming = new Student('xiaoming', 10, '001'); xiaoming.getWeight(); alert(xiaoming.girlfriend); // 语法error,因为girlfriend是受保护的 2.2.3 多态  多态，同一接口不同实现。在JavaScript中应用极少，因为多态是需要结合后端语言的接口、重写、重载等功能。多态的优点：1、保持子类的开放性和灵活性；2、面向接口编程；3、JavaScript引用极少。 class People { constructor(name) { this.name = name; } saySomething() { alert(`Hello, my name is ${this.name}`); } } class A extends People { constructor(name) { super(name); } saySomething() { alert(`Hello, my name is A.`); } } class B extends People { constructor(name) { super(name); } saySomething() { alert(`Hello, my name is B`); } } let a = new A('a'); a.saySomething(); let b = new B('b'); b.saySomething();  在上面的例子中，我们可以看出，A 类继承了 People 类，同时，A 类重写了 saySomething() 方法，B 类也是如此，因而，做到了多态效果。 2.2.4 应用  jQuery是使用面向对象编写的。 class jQuery { constructor(selector) { let slice = Array.prototype.slice; let dom = slice.call(document.querySelectorAll(selector)); let len = dom ? dom.length : 0; for(let i = 0; i 2.3 设计原则 什么是设计？设计即是按照哪一种思路或者标注来实现功能。功能相同的代码，可以有不同设计方案来实现。如果仅仅是几行代码，设计可能会浪费时间。但是，伴随着需求的增加，设计的作用就体现出来了。 有哪些设计原则？ 准则1：小即是美。在一开始的时候，jQuery仅仅只有90KB左右。然后，到了Vue.js这边，就只剩30KB左右。而现在，听说有个6KB的js文件，能做到非常好的JavaScript性能。所以，将来的JavaScript一定会往小而精的方面发展，在内核小而美的基础上，发展周边生态。同时，我们的周边生态，一定是有意义的，有作用的，从而产生各部分之和大于它们的原集合，要不然我们就不需要对框架进行分离了，我们直接将周边生态内置于框架内就行了。我们不仅要做到JavaScript框架的小而美，在代码中，我们应该也尽量用精炼的单词，编写精简的代码。 准则2：让每个程序只做好一件事。代码不是万能钥匙，能开车，能开锁。我们的代码，最好能指定某某部分代码实现某个功能，做到分工合理。如果有部分代码，既可以画canvas，又可以操作dom，听起来很美好，实际上，当你接替上一任程序猿的时候，你要把它的具体功能实现猜一遍，它是做这件事的？还是那件事？同时，每个程序，如果是进行数字操作的，那么，就不应做弹窗返回个字符串之类的操作，以免造成混淆。 准则3：快速建立原型。编程界有个词，叫做敏捷开发。当客户提出一个需求的时候，如果你不先通过建立原型，满足用户的需求。随着时间迁移，客户可能会根据市场变化，而修改他原本的决定，从而导致你一直跟着客户变动。所以，在客户提出需求的一刻，我们应该快速建立原型，满足客户的基本需求，然后在进行深度开发。 准则4：舍弃高效率而取可移植性。如果你从事于某个具体行业，该行业可能做了大量的重复性工作。那么，你应该考虑，朝可移植性进行开发，虽然前期可能浪费一些效率，但是，后期的效率提升是值得拥有的。同时，我们在进行可移植性设计的时候，应该尽可能满足绝大多数用户的需求，避免为了极个别的用户，而抛弃大部队。如果花费20%的成本解决80%的需求，那么我们就是胜利的。如果为了20%的需求，浪费掉80%的成本，那么，我们就是失败的。 准则5：采用纯文本来存储数据。大部分人都知道，计算机只认识010101这个二进制数值，文本是二进制的升级版1，图片是二进制的升级版2，视频是二进制的升级版*……所以，越贴近二进制的东东，越小且越容易被计算机识别，因而我们推荐采用纯文本来实现数据存储。效率快存储方便。 准则6：避免强制性的用户界面。现在是以用户为主的时代。如果是00年以前，计算机流行不普遍的时候，强制用户接受某软件、某网站，可以轻松做到。但是，现在如果你的界面做得不好，你的功能开发地不完美，你又不去修改，那么，客户就会离你而去，因为你的竞争对手已经把你的问题给解决了。所以，我们应该避免强制性的用户界面，实现界面可调整，实现功能可定制化，允许用户定制环境，从而赢取更多的客户。 准则7：让每个程序都称为过滤器。 什么是5大设计原则？五大设计原则为：SOLID。 S - 单一职责原则：1、一个程序只做好一件事；2、如果功能过于复杂就拆分开，让每个部分保持独立。 O - 开放封闭原则：1、对扩展开放，对修改封闭；2、增加需求时，扩展新代码，而非修改已有代码；3、这是软件的终极目标。 L - 李？里氏替换原则：1、子类能覆盖父类；2、父类能出现的地方子类就能出现。 I - 接口独立原则：1、保持接口的单一独立，避免出现“胖接口”；2、JavaScript中没有接口（TypeScript例外），使用较少；3、类似于单一职责原则，这里更关注接口。 D - 依赖导致？倒置原则：1、面对接口编程，依赖于抽象而不依赖于具体；2、使用方只关注接口而不关注具体类的实现。  在设计原则中，S O 体现较多，详细介绍；而L I D 体现较少，但是需要了解其用意。 有没有具体例子？有的： // 加载图片 function loadImg(src) { var promise = new Promise(function (resolve, reject) { var img = document.createElement('img'); img.onload = function() { resolve(img); }; img.onerror = function() { reject('图片加载失败'); }; img.src = src; }); return promise; } var src = 'https://www.imooc.com/static/img/index/logo_new.png'; var result = loadImg(src); result.then(function(img) { // part1 console.log('ing.width', img.width); return img; }).then(function(img) { // part2 console.log('img.height', img.height); }).catch(function(ex) { // 统一捕获异常 console.log(ex); }) 在这里，实现了单一职责原则和开放封闭原则。 单一职责原则：每个 then 中的逻辑只做好一件事。 开放封闭原则：如果新增需求，扩展 then 。 对扩展开放，对修改封闭。 2.4 设计模式 何为设计？ 何为模式？ 如何从设计到模式？ 设计模式分为多少种？23种，大致可以分为创建型、组合型、行为型。 创建型：1、工厂模式（工厂方法模式，抽象工厂模式，建造者模式）；2、单例模式；3、原型模式 结构型：1、适配器模式；2、装饰器模式；3、代理模式；4、外观模式；5、桥接模式；6、组合模式；7、享元模式。 行为型-1：1、策略模式；2、模板方法模式；3、观察者模式；4、迭代器模式；5、职责连模式；6、命令模式。 行为型-2：1、备忘录模式；2、状态模式；3、访问者模式；4、中介者模式；5、解释器模式。 如何学习设计模式？ 明白每个设计的道理和用意； 通过经典应用体会它的真正使用场景； 编码时多思考，尽量模仿。 2.5 实例 题目一： 打车时，可以打专车或者快车。任何车都有车牌号和名称。 不同车价格不同，快车每公里1元，专车每公里2元。 行程开始时，显示车辆信息。 行程结束时，显示打车金额（假定行程就5公里）。  问：1、画出UML类图；2、用ES6语法写出该示例。 答： UML类图 ES6代码 class Car { constructor(number, name) { this.number = number; this.name = name; } } class Kuaiche extends Car { constructor(number, name) { super(number, name); this.price = 1; } } class Zhuanche extends Car { constructor(number, name) { super(number, name); this.price = 2; } } class Trip { constructor(car) { this.car = car; } start() { console.log(`行程开始，名称： ${this.car.name}, 车牌号：${this.car.price}`); } end() { console.log(`行程结束，价格：` + (this.car.price * 5)); } } let car = new Kuaiche(100, '桑塔纳'); let trip = new Trip(car); trip.start(); // 行程开始，名称： 桑塔纳, 车牌号：1 trip.end(); // 行程结束，价格：5 题目二： 某停车场，分3层，每层100车位 每个车位都能监控到车辆的驶入和离开 车辆进入前，显示每层的空余车位数量 车辆进入时，摄像头可识别车牌号和时间 车辆出来时，出口显示器显示车牌号和停车时长  问：1、画出UML类图；2、用ES6语法写出该示例。 答： UML类图 ES6代码 // 车辆 class Car { constructor(num) { this.num = num; } } // 入口 摄像头 class Camera { shot(car) { return { num: car.num, inTime: Date.now() } } } // 出口显示屏 class Screen { show(car, inTime) { console.log('车牌号', car.num); console.log('停车时间', Date.now() - inTime); } } // 停车场 class Park { constructor(floors) { this.floors = floors || []; this.camera = new Camera(); this.screen = new Screen(); this.carList = {}; // 存储摄像头拍摄返回的车辆信息 } in(car) { // 通过摄像头获取信息 const info = this.camera.shot(car); // 停到某个停车位 const i = parseInt(Math.random() * 100 % 100); const place = this.floors[0].places[i]; place.in(); info.places = place; // 记录信息 this.carList[car.num] = info; } out(car) { // 获取信息 const info = this.carList[car.num]; // 将停车位清空 const place = info.places; place.out(); // 显示时间 this.screen.show(car, info.inTime); // 清空记录 delete this.carList[car.num]; } emptyNum() { return this.floors.map(floor => { return `${floor.index} 层还有 ${floor.emptyPlaceNum()} 个空闲车位。`; }).join('\\n'); } } // 楼层 class Floor { constructor(index, places) { this.index = index; this.places = places || []; } emptyPlaceNum() { let num = 0; this.places.forEach(p => { if(p.empty) { num = num + 1; } }) return num; } } // 车位 class Place { constructor() { this.empty = true; } in() { this.empty = false; } out() { this.empty = true; } } // 测试 // 初始化停车场 const floors = []; for(let i = 0; i jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:33:00 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/design-pattern/design-pattern-chapter03.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter03.html","title":"✘ 设计模式手册 - 3 - 工厂模式","keywords":"","body":"设计模式手册 - 3 - 工厂模式 create by jsliang on 2018年8月22日11:19:00Recently revised in 2019-05-20 17:34:16 第三章 工厂模式 3.1 使用介绍 将 new 操作单独封装。 遇到 new 时，就要考虑是否使用工厂模式。 举个例子：  你去购买汉堡，只需要跟服务员点餐，做汉堡这些步骤你就不用理会了。然后下一个人去购买汉堡，也是只需要点餐，至于餐厅怎么操作的，就不需要去关心了。在这里，餐厅封装了做汉堡的工作，只需要“接受点餐”、“送餐给顾客”就可以了。 3.2 UML类图及其实现 class Product { constructor(name) { this.name = name; } init() { alert(\"init\"); } fun1() { alert(\"fun1\"); } fun2() { alert(\"fun2\"); } } class Creator { create(name) { return new Product(name); } } // 测试 let creator = new Creator(); let p = creator.create(\"p1\"); p.init(); // init p.fun1(); // fun1 3.3 使用场景 jQuery - $(\"div\") React.createElement vue 异步组件 jQuery class jQuery { constructor(selector) { let slice = Array.prototype.slice; let dom = slice.call(document.querySelectorAll(selector)); let len = dom ? dom.length : 0; for(let i = 0; i React var profile = {[user.firstName, user.lastName].join(' ')} var profile = React.createElement(\"div\", null, React.createElement(\"img\", {src: \"avatar.png\", className: \"profile\"}), React.createElement(\"h3\", null, [user.firstName, user.lastName].join(\" \")); ); class Vnode(tag, attr, children) { // ...省略内部代码... } React.createElement = function(tag, attrs, children) { return new Vnode(tag, attrs, children); } Vue Vue.component('async-example', function(resolve, reject) { setTimeout(function() { resolve({ template: 'I am async!' }) }, 1000) }) 3.4 设计原则验证 构造函数和创建者分离 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:34:55 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/design-pattern/design-pattern-chapter04.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter04.html","title":"✘ 设计模式手册 - 4 - 单例模式","keywords":"","body":"设计模式手册 - 4 - 单例模式 create by jsliang on 2018年8月27日09:15:18Recently revised in 2019-05-20 17:58:32 第四章 单例模式 系统中被唯一使用 一个类只有一个实例 单例模式中需要用到private，而ES6中没有private，所以需要TypeScript 4.1 代码实现 class SingleObject { login() { console.log(\"login...\"); } } SingleObject.getInstance = (function() { let instance; return function() { if(!instance) { instance = new SingleObject(); } return instance; } })() // 测试：注意这里只能使用静态函数 getInstance ，不能 new SingleObject() !!! let obj1 = SingleObject.getInstance(); obj1.login(); // login... let obj2 = SingleObject.getInstance(); obj2.login(); // login... console.log(obj1 == obj2); // true （两者必须完全相等） 4.2 使用场景 jQuery 只有一个 $ ，这就是单例模式的一个例子 登录框 购物车 vuex 和 redux 中的 store jQuery单例模式 // jQuery 只有一个 '$' if (window.jQuery != null) { return window.jQuery; } else { // 初始化 } 如果引用了jQuery，那就不做任何操作；如果没有引用，那就初始化引用。 登录框模拟 class LoginForm { constructor() { this.state = \"hide\"; } show() { if(this.state === \"show\") { alert(\"已经显示\"); return; } this.state = \"show\"; console.log(\"登录框显示成功\"); } hide() { if(this.state === \"hide\") { alert(\"已经隐藏\"); return; } this.state = \"hide\"; console.log(\"登录框隐藏成功\"); } } LoginForm.getInstance = (function() { let instance; return function() { if(!instance) { instance = new LoginForm(); } return instance; } })(); let login1 = LoginForm.getInstance(); login1.show(); let login2 = LoginForm.getInstance(); login2.hide(); console.log(\"login1 === login2\", login1 === login2); // login1 === login2 true 4.3 设计原则验证 符合单一职责原则，只实例化唯一的对象 没法具体开放封闭原则，但是绝对不违反开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:58:33 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/design-pattern/design-pattern-chapter05.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter05.html","title":"✘ 设计模式手册 - 5 - 适配器模式","keywords":"","body":"设计模式手册 - 5 - 适配器模式 create by jsliang on 2018年8月27日09:15:18Recently revised in 2019-05-20 17:36:14 第五章 适配器模式 旧接口格式和使用者不兼容 中间加一个适配转换接口 5.1 UML类图 5.2 代码实现 class Adaptee { specificRequest() { return \"德国标准的插头\"; } } class Target { constructor() { this.adaptee = new Adaptee(); } request() { let info = this.adaptee.specificRequest(); return `${info} -> 转换器 -> 中国标准的插头`; } } // 测试 let target = new Target(); console.log(target.request()); // 德国标准的插头 -> 转换器 -> 中国标准的插头 5.3 使用场景 封装旧接口 vue computed 封装旧接口 // 自己封装的 ajax ，使用方式如下： ajax({ url: 'getData', type: 'Post', dataType: 'json', data: { id: '123' } }).done(function() { }) // 由于历史原因，代码中全都是： // $.ajax({...}) // 做一层适配器 var $ = { ajax: function(options) { return this.ajax(options); } } vue computed Vue Computed 顺序： {{message}} 逆序： {{reversedMessage}} var vm = new Vue({ el: \"#app\", data: { message: \"hello\" }, computed: { reversedMessage: function() { return this.message.split('').reverse().join(''); } } }) 5.4 设计原则验证 将旧接口和使用者进行分离 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:36:33 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/design-pattern/design-pattern-chapter06.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter06.html","title":"✘ 设计模式手册 - 6 - 装饰器模式","keywords":"","body":"设计模式手册 - 6 - 装饰器模式 create by jsliang on 2018年8月30日09:54:33Recently revised in 2019-05-20 17:36:50 第六章 装饰器模式 为对象添加新功能 不改变其原有的结构和功能 手机壳可以简单的看做是一个装饰器模式 6.1 UML类图 6.2 代码实现 class Circle { draw() { console.log(\"画一个圆形\"); } } class Decorator { constructor(circle) { this.circle = circle; } draw() { this.circle.draw(); this.setRedBorder(circle); } setRedBorder() { console.log(\"设置红色边框\"); } } // 测试代码 let circle = new Circle(); circle.draw(); // 画一个圆形 let dec = new Decorator(circle); dec.draw(); // 画一个圆形 // 设置红色边框 6.3 使用场景 ES7 装饰器：  ES7装饰器的三个步骤： npm install babel-plugin-transform-decorators-legacy -D 设置.babelrc配置 { \"presets\": [ \"env\" ], \"plugins\": [ [\"transform-decorators-legacy\"] ] } 然后测试该配置是否生效： // 一个简单的 demo // @testDec 对 Demo 这个 class 的装饰，装饰的方法就是使用 testDec() 这个函数 @testDec class Demo { } function testDec(target) { target.isDec = true; } alert(Demo.isDec); // true  在这里简化下装饰器语法： // 装饰器的原理 @decorator class A {} // 等同于 class A {} A = decorator(A) || A; 装饰类  在这里，我们还可以传参数： // 一个简单的 demo // @testDec 对 Demo 这个 class 的装饰，装饰的方法就是使用 testDec() 这个函数 @testDec(false) class Demo { } function testDec(isDec) { return function(target) { target.isDec = isDec; } } alert(Demo.isDec); // false  然后，我们再根据mixin进行一个示例 function mixins(...list) { return function(target) { Object.assign(target.prototype, ...list); } } const Foo = { foo() { alert('foo') } } @mixins(Foo) class MyClass { } let obj = new MyClass(); obj.foo(); // foo 装饰方法  @readonly 只读属性 class Person { constructor() { this.first = \"A\"; this.last = \"B\"; } // 装饰方法 @readonly name() { return `${this.first} ${this.last}` } } function readonly(target, name, descriptor) { /** * descriptor 属性描述对象 (Object.defineProperty 中会用到)，原来的值如下： * { * value: specifiedFunction, * enumerable: false, * configurable: true, * writable: true * } */ descriptor.writable = false; return descriptor; } var p = new Person(); console.log(p.name()); // A B // 如果设置 p.name = function() {}; 这样子就会报错，因为 name 被我们设置为只读属性  例子2： class Math { // 装饰方法 @log add(a, b) { return a + b; } } function log(target, name, descriptor) { var oldValue = descriptor.value; descriptor.value = function() { console.log(`Calling ${name} with`, arguments); return oldValue.apply(this, arguments); }; return descriptor; } const math = new Math(); const result = math.add(2, 4); // 执行 add 时，会自动打印日志，因为有 @log 装饰器 console.log(\"result\", result); /** * Calling add with Arguments(2) [2, 4, callee: (...), Symbol(Symbol.iterator): ƒ] * result 6 */ 其实，上面的方法，都封装到第三方插件里面去了： core-decorators。这个是第三方开源的lib，提供了常用的装饰器。感兴趣的还可以拜读下官方说明：查看详情  使用 core-decorators 的方式 安装 core-decorators ： npm i core-decorators -S 然后开始编码： readonly： 只读 import { readonly } from 'core-decorators'; class Person { @readonly name() { return 'zhang'; } } let p = new Person(); alert(p.name()); // zhang depercate： 废弃的警告 // 废弃的 API import { deprecate } from 'core-decorators'; class Person { @deprecate faceplam() { } @deprecate(\"We stopped faceplaming\") faceplamHard() { } @deprecate(\"We stopped faceplaming\", {url: \"http://jsliang.top\"}) faceplamHarder() { } } let person = new Person(); person.faceplam(); // deprecate.js:31 DEPRECATION Person#faceplam: This function will be removed in future versions. person.faceplamHard(); // DEPRECATION Person#faceplamHard: We stopped faceplaming person.faceplamHarder(); // deprecate.js:31 DEPRECATION Person#faceplamHarder: We stopped faceplaming // See http://jsliang.top for more details.**** 6.4 设计原则验证 将现有对象和装饰器进行分离，两者独立存在 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:37:57 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/design-pattern/design-pattern-chapter07.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter07.html","title":"✘ 设计模式手册 - 7 - 代理模式","keywords":"","body":"设计模式手册 - 7 - 代理模式 create by jsliang on 2018年8月30日15:47:00Recently revised in 2019-05-20 17:38:16 第七章 代理模式 使用者无权访问目标对象 中间加代理，通过代理做授权和控制 关于代理模式，可以简单理解下 国外网站。有些国外网站被墙了的，需要我们通过一些能访问国外站点的代理服务器去访问 公司网络。有些公司有自己的内容，如果我们在家要访问，那么就需要通过代理，才能访问到。 明星经纪人。如果你要找明星演戏，你是找不到本人的，这时候你需要找它的代理：经纪人。去详谈合作事务，谈妥当后经纪人会帮你转告明星，开始工作。 7.1 UML类图 7.2 代码演示  代理模式中，代理的类提供的接口必须跟被代理的类名一样。 class ReadImg { constructor(fileName) { this.fileName = fileName; this.loadFromDisk(); // 初始化即从硬盘中加载，模拟 } display() { console.log(\"display... \" + this.fileName); } loadFromDisk() { console.log(\"loading... \" + this.fileName); } } class ProxyImg { constructor(fileName) { this.realImg = new ReadImg(fileName); } display() { this.realImg.display(); } } // 测试 let proxyImg = new ProxyImg(\"1.png\"); proxyImg.display(); // loading... 1.png // display... 1.png 7.3 使用场景 网页事件代理 jQuery $.proxy 网页时间代理 HelloWorld a1 a2 a3 a4 a5 $(function() { var div1 = document.getElementById(\"div1\"); div1.addEventListener(\"click\", function(e) { var target = e.target; if(target.nodeName === \"A\") { alert(target.innerHTML); } }) }) $.proxy HelloWorld .red { color: green; } a1 a2 a3 a4 a5 Hello World! $(function() { $(\"#div1\").click(function() { var _this = this; setTimeout(function() { console.log(this); $(_this).css(\"background-color\", \"yellow\"); }, 1000) }) // 使用 $.proxy 解决，这样就少定义一个变量 $(\"#div2\").click(function() { // var fn = function() { // $(this).css(\"background-color\", \"yellow\"); // } // fn = $.proxy(fn, this); // setTimeout(fn, 1000); // 下面代码等效于上面代码 setTimeout($.proxy(function() { $(this).css(\"background-color\", \"yellow\") }, this), 1000); }) }) ES6 Proxy // 明星 let star = { name: \"张××\", age: 25, phone: 'star - 13910733521' } // 经纪人 let agent = new Proxy(star, { get: function(target, key) { if(key === \"phone\") { // 返回经纪人自己的手机号 return 'agent - 18611112222'; } if(key === \"price\") { // 明星不报价，经纪人报价 return 120000; } return target[key]; }, set: function(target, key, val) { if(key === \"customPrice\") { if(val 7.4 设计原则验证 代理类和目标类分离，隔离开目标类和使用者 符合开放封闭原则 7.5 代理模式 VS 适配器模式 适配器模式：提供一个不同的接口（如不同版本的插头） 代理模式：提供一模一样的接口 7.6 代理模式 VS 装饰器模式 装饰器模式：扩展功能，原有功能不变且可直接使用 代理模式：显示原有功能，但是经过限制或者阉割之后的 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:39:02 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/design-pattern/design-pattern-chapter08.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter08.html","title":"✘ 设计模式手册 - 8 - 外观模式","keywords":"","body":"设计模式手册 - 8 - 外观模式 create by jsliang on 2018年8月30日15:47:00Recently revised in 2019-05-20 17:39:23 第八章 外观模式 为子系统中的一组接口提供了一个高层接口 使用者使用这个高层接口  例子1： 去医院看病，接待员去挂号、门诊、划价、取药，而我们不需要亲手去找 8.1 设计原则元整 不符合单一职责和开放封闭原则，因此谨慎使用，不可滥用 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:39:25 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/design-pattern/design-pattern-chapter09.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter09.html","title":"✘ 设计模式手册 - 9 - 观察者模式","keywords":"","body":"设计模式手册 - 9 - 观察者模式 create by jsliang on 2018年8月30日15:47:00Recently revised in 2019-05-20 17:40:14 第九章 观察者模式 发布 & 订阅 一对多 9.1 实例场景 点咖啡，点好之后坐等被叫 9.2 UML类图 9.3 代码场景 网页绑定事件 Promise jQuery callbacks nodejs 自定义事件 网页绑定事件 btn // 等待按钮被点击，被点击就触发 $(\"#btn1\").click(function() { console.log(1); }) $(\"#btn1\").click(function() { console.log(2); }) $(\"#btn1\").click(function() { console.log(3); }) Promise function loadImg(src) { var promise = new Promise(function(resolve, reject) { var img = document.createElement(\"img\"); img.onload = function() { resolve(img); } img.onerror = function() { reject(\"图片加载失败\"); } img.src = src; }) return promise; } var src = \"http://www.imooc.com/static/img/index/logo_new.png\"; var result = loadImg(src); result.then(function(img) { console.log(\"width\", img.width); // width 252 return img; }).then(function(img) { console.log(\"height\", img.height); // height 144 }) jQuery callbacks var callbacks = $.Callbacks(); // 注意大小写 callbacks.add(function(info) { console.log(\"fn1\", info); }) callbacks.add(function(info) { console.log(\"fn2\", info); }) callbacks.add(function(info) { console.log(\"fn3\", info); }) callbacks.fire(\"gogogo!\"); // fn1 gogogo! // fn2 gogogo! // fn3 gogogo! callbacks.fire(\"fire!\"); // fn1 fire! // fn2 fire! // fn3 fire! nodejs 自定义事件 代码1 const EventEmitter = require(\"events\").EventEmitter; const emitter1 = new EventEmitter(); emitter1.on(\"some\", () => { // 监听 some 事件 console.log(\"some event is occured 1\"); }) emitter1.on(\"some\", () => { // 监听 some 事件 console.log(\"some event is occured 2\"); }) // 触发 some 事件 emitter1.emit(\"some\"); // some event is occured 1 // some event is occured 2 代码2 const EventEmitter = require(\"events\").EventEmitter; const emitter = new EventEmitter(); emitter.on(\"showName\", () => { // 监听 some 事件 console.log(\"event occured\", name); }) emitter.emit(\"showName\", \"jsliang\"); // emit 时候可以传递参数过去 // event occured 代码3 const EventEmitter = require('events').EventEmitter; // 任何构造函数都可以继承 EventEmitter 的方法 on emit class Dog extends EventEmitter { constructor(name) { super(); this.name = name; } } var simon = new Dog(\"simon\"); simon.on(\"bark\", function() { console.log(this.name, \" barked\"); }) setInterval(function() { simon.emit(\"bark\"); }, 1000) // simon barked // simon barked // simon barked // ... 代码4 // Stream 用到了自定义事件 var fs = require(\"fs\"); var readStream = fs.createReadStream(\"./dist/js/index.js\"); // 读取文件的 Stream var length = 0; readStream.on(\"data\", function(chunk) { length += chunk.toString().length(); }) readStream.on(\"end\", function() { console.log(length); }) 9.4 设计原则验证 主题和观察者分离，不是主动触发而是被动监听，两者解耦 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:40:48 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/design-pattern/design-pattern-chapter10.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter10.html","title":"✘ 设计模式手册 - 10 - 迭代器模式","keywords":"","body":"设计模式手册 - 10 - 迭代器模式 create by jsliang on 2018年8月30日15:47:00Recently revised in 2019-05-20 17:41:10 第十章 迭代器模式 顺序访问一个集合 使用者无需知道集合的内部结构（封装） 10.1 代码演示 HelloWorld jQuery each jQuery each jQuery each $(function () { var arr = [1, 2, 3]; var nodeList = document.getElementsByTagName(\"p\"); var $p = $(\"p\"); function each(data) { var $data = $(data); // 生成迭代器 $data.each(function (key, val) { console.log(key, val); }) } each(arr); // 0 1 // 1 2 // 2 3 each(nodeList); // 0 ​jQuery each​​ // 1 ​jQuery each​​ // 2 ​jQuery each​​ each($p); // 0 ​jQuery each​​ // 1 ​jQuery each​​ // 2 ​jQuery each​​ }) 10.2 UML类图 10.3 使用场景 jQuery each ES6 Iterator: 为何存在？ES6 语法中，有序集合的数据类型已经有很多。Array Map Set String TypedArray arguments NodeList。需要有一个统一的遍历接口来遍历所有数据类型。（注意，object不是有序集合，可以用Map代替）。是什么？以上数据类型，都有 [Symbol.iterator] 属性。属性值是函数，执行函数返回一个迭代器。这个迭代器就有next方法可顺序迭代子元素。可运行 Array.prototype[Symbol.iterator] 来测试。 jQuery each HelloWorld jQuery each jQuery each jQuery each $(function() { var arr = [1, 2, 3]; var nodeList = document.getElementsByTagName(\"p\"); var $p = $(\"p\"); // 要对这三个变量进行遍历，需要写三个遍历方法 // 第一 arr.forEach(function(item) { console.log(item); // 1 // 2 // 3 }) // 第二 var i, length = nodeList.length; for(i = 0; i jQuery each // jQuery each // jQuery each } // 第三 $p.each(function(key, p) { console.log(key, p); // 0 jQuery each // 1 jQuery each // 2 jQuery each }) }) ES6 Iterator // 旧写法： // function each(data) { // // 生成遍历器 // let iterator = data[Symbol.iterator](); // // console.log(iterator.next()); // 有数据： {value: \"1\", done: false} // // console.log(iterator.next()); // // console.log(iterator.next()); // // console.log(iterator.next()); // 无数据： Cannot read property 'Symbol(Symbol.iterator)' of undefined // let item = {done: false}; // while(!item.done) { // item = iterator.next(); // if(!item.done) { // console.log(item.value); // } // } // } // `Symbol.iterator` 并不是每个人斗志 // 也不是每个人都需要封装一个 each方法 // 因此有了 `for...of` 语法， `for...of`是遍历迭代器的 function each(data) { // 带有遍历器特性的对象： data[Symbol.iterator] 有值 for(let item of data) { console.log(item); } } let arr = [1, 2, 3, 4]; let nodeList = document.getElementsByTagName(\"p\"); let m = new Map(); m.set(\"a\", 100); m.set(\"b\", 200); each(arr); // 1 // 2 // 3 // 4 each(nodeList); // jsliang的设计模式 each(m); // (2) [\"a\", 100] // (2) [\"b\", 200] 10.4 ES6 Iterator 与 Generator Iterator 的价值不限于上述几个类型的遍历 还有 Generator 函数的使用 即只要返回的数据符合 Iterator 接口的要求 即可使用 Iterator 语法，这就是迭代器模式 Generator 应用不是那么广泛了，使用场景比较少 10.5 设计原则验证 迭代器对象和目标对象分离 迭代器将使用者与目标对象隔离开 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:41:32 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/design-pattern/design-pattern-chapter11.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter11.html","title":"✘ 设计模式手册 - 11 - 状态模式","keywords":"","body":"设计模式手册 - 11 - 状态模式 create by jsliang on 2018年9月3日10:30:19Recently revised in 2019-05-20 17:42:49 第十章 状态模式 一个对象有状态变化 每次状态变化都会触发一个逻辑 不能总是用 if...else... 来控制 场景：交通信号灯不同颜色的变化 11.1 UML图 11.2 代码演示 // 状态：红灯、绿灯、蓝灯 class State { constructor(color) { this.color = color; } handle(context) { console.log(`turn to ${this.color} light.`); // 设置状态 context.setState(this); } } // 主体 class Context { constructor() { this.state = null; } // 状态获取 getState() { return this.state; } setState(state) { this.state = state; } } // test let context = new Context(); let green = new State(\"green\"); let yellow = new State(\"yellow\"); let red = new State(\"red\"); // 绿灯亮了 green.handle(context); console.log(context.getState()); // 打印状态 // turn to green light. // State {color: \"green\"} // 黄灯亮了 yellow.handle(context); console.log(context.getState()); // 打印状态 // turn to yellow light. // State {color: \"yellow\"} // 红灯亮了 red.handle(context); console.log(context.getState()); // 打印状态 // turn to red light. // State {color: \"red\"} 11.3 场景 有限状态机 写一个简单的Promise 有限状态机 有限个状态、以及在这些状态之间的变化 如交通信号灯 使用开源 lib： javascipt-state-machine: 详情 javascript-state-machine 来做状态模式： 安装：npm i javascript-state-machine 代码：es6 webpack 环境下 index.html jsliang的设计模式 jsliang的设计模式 --> index.js import StateMachine from 'javascript-state-machine' // 初始化状态机模型 var fsm = new StateMachine({ init: \"收藏\", // 初始状态，待收藏 transitions: [ { name: \"doStore\", from: \"收藏\", to: \"取消收藏\" }, { name: \"deleteStore\", from: \"取消收藏\", to: \"收藏\" } ], methods: { // 监听执行收藏 onDoStore: function() { alert(\"收藏成功\"); // 可以 post 请求 updateText(); }, // 监听取消收藏 onDeleteStore: function() { alert(\"已取消收藏\"); // 可以 post 请求 updateText(); } } }) let $btn = $(\"#btn\"); // 点击事件 $btn.click(function() { if(fsm.is(\"收藏\")) { fsm.doStore(); } else { fsm.deleteStore(); } }) // 更新文案 function updateText() { $btn.text(fsm.state); } // 初始化文案 updateText(); 写一个简单的 Promise 回顾 Promise 的语法 分析：Promise 就是一个有限状态机 写代码 测试验证 function loadImg(src) { const promise = new Promise(function(resolve, reject) { var img = document.createElement(\"img\"); img.onload = function() { resolve(img); } img.onerror = function() { reject(); } img.src = src; }) return promise; } var src = \"http://www.imooc.com/static/img/index/logo_new.png\"; var result = loadImg(src); result.then(function(img) { console.log(\"success 1\"); }, function() { console.log(\"failed 1\"); }) // success 1 result.then(function(img) { console.log(\"success 2\"); }, function() { console.log(\"failed 2\"); }) // success 2 /** * 如果地址错误，则： * logo_new1.png:1 GET http://www.imooc.com/static/img/index/logo_new1.png 404 (Not Found) * failed 1 * failed 2 */ Promise 就是有限状态机 Promise 三种状态： pending fullfilled rejected pending -> fullfilled 或者 pending -> rejected 不能逆向变化 import StateMachine from 'javascript-state-machine'; // 状态机模型 var fsm = new StateMachine({ init: \"pending\", transitions: [ { name: \"resolve\", from: \"pending\", to: \"fullfilled\" }, { name: \"reject\", from: \"pending\", to: \"rejected\" } ], methods: { // 监听 resolve 成功 onResolve: function(state, data) { // 参数：state - 当前状态示例；data - fsm.resolve(xxx) 执行时传递过来的参数 data.successList.forEach(fn => fn()); }, // 失败 onReject: function(state, data) { // 参数：state - 当前状态示例；data - fsm.reject(xxx) 执行时传递过来的参数 data.failList.forEach(fn => fn()); } } }) // 定义 Promise class MyPromise { constructor(fn) { this.successList = []; this.failList = []; fn(() => { // resolve 函数 fms.resolve(this); }, () => { // reject 函数 fsm.reject(this); }) } then(successFn, failFn) { this.successList.push(successFn); this.failList.push(failFn); } } // 测试代码 function loadImg(src) { const promise = new Promise(function(resolve, reject) { let img = document.createElement(\"img\"); img.onload = function() { resolve(img); } img.onerror = function() { reject(); } img.src = src; }) return promise; } let src = \"http://www.imooc.com/static/img/index/logo_new.png\"; let result = loadImg(src); result.then(function() { console.log(\"ok1\"); }, function() { console.log(\"fail1\"); }) // ok1 result.then(function() { console.log(\"ok2\"); }, function() { console.log(\"fail2\"); }) // ok2 11.4 设计原则验证 将状态对象和主题对象分离，状态的变化逻辑单独处理 符合开放封闭原则 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:42:50 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/design-pattern/design-pattern-chapter12.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter12.html","title":"✘ 设计模式手册 - 12 - 其他模式","keywords":"","body":"设计模式手册 - 12 - 其他模式 create by jsliang on 2018年9月3日11:53:05Recently revised in 2019-05-20 17:42:42 第十二章 其他模式  这里讲解前11章之外，比较少用的模式。 原型模式、桥接模式、组合模式、享元模式、策略模式、模板方法模式、职责连模式、命令模式、备忘录模式、中介者模式、访问者模式、解释器模式 12.1 原型模式 clone 自己，生成一个新对象 Java 默认有 clone 接口，不用自己实现 对比 JS 中的原型 prototype： prototype 可以理解为 ES6 class 的一种底层原理 而 class 是实现面向对象的基础，并不是服务于某个模式 若干年后如果 ES6 全面普及，大家可能会忽略掉 prototype 但是 Object.create 却会长久存在 // `Object.create` 用到了原型模式的思想（虽然不是 java 中的 clone ） // 基于一个原型创建一个对象 var prototype = { getName: function() { return this.first + \" \" + this.last; }, say: function() { console.log(\"hello\"); } } // 基于原型创建 x let x = Object.create(prototype); x.first = \"A\"; x.last = \"B\"; alert(x.getName()); // A B x.say(); // hello 12.2 桥接模式 用户把抽象化与实现化解耦 使得二者可以独立变化 原实例场景 class ColorShape { yellowCircle() { console.log(\"yellow circle\"); } redCircle() { console.log(\"red circle\"); } yellowTriangle() { console.log(\"yellow triangle\"); } redTriangle() { console.log(\"red triangle\"); } } // 测试 let cs = new ColorShape(); cs.yellowCircle(); // yellow circle cs.redCircle(); // red circle cs.yellowTriangle(); // yellow triangle cs.redTriangle(); // red triangle 使用桥接模式 class Color { constructor(name) { this.name = name; } } class Shape { constructor(name, color) { this.name = name; this.color = color; } draw() { console.log(`${this.color.name} ${this.name}`); } } // 测试代码 let red = new Color(\"red\"); let yellow = new Color(\"yellow\"); let circle = new Shape(\"circle\", red); circle.draw(); // red circle let triangle = new Shape(\"triangle\", yellow); triangle.draw(); // yellow triangle 设计原则验证 抽象和实现分离，解耦 符合开放封闭原则 12.3 组合模式 生成树形结构，表示“整体-部分”关系 让整体和部分都具有一致的操作模式 123 456 { tag: \"div\", attr: { id: \"div1\", className: \"container\" }, children: [ { tag: \"p\", attr: {}, children: [\"123\"] }, { tag: \"p\", attr: {}, children: [\"456\"] } ] } 整体和单个节点的操作是一致的 整体和单个节点的数据结构也保持一致 设计原则验证 将整体和单个节点的操作抽象出来 符合开放封闭原则 12.4 享元模式 共享内存（主要考虑内存，而非效率） 相同的数据，共享使用 `标签，对内存开销太大 --> a1 a2 a3 a4 var div1 = document.getElementById(\"div1\"); div1.addEventListener(\"click\", function(e) { var target = e.target; if(e.nodeName === \"A\") { alert(target.innerHTML); } }) 设计原则验证 将相同的部分抽象出来 符合开放封闭原则 12.5 策略模式 不同策略分开处理 避免出现大量 if...else... 或者 switch...case... 原代码实现 class User { constructor(type) { this.type = type; } buy() { if(this.type === \"ordinary\") { console.log(\"普通用户购买\"); } else if(this.type === \"member\") { console.log(\"会员用户购买\"); } else if(this.type === \"vip\") { console.log(\"vip 用户购买\"); } } } 策略模式代码实现针对不用的用户，设计不用的类，从而解耦用户等级 class OrdinaryUser { buy() { console.log(\"普通用户购买\"); } } class MemberList { buy() { console.log(\"会员用户购买\"); } } class VipUser { buy() { console.log(\"vip 用户购买\"); } } var u1 = new OrdinaryUser(); u1.buy(); var u2 = new MemberList(); u2.buy(); var u3 = new VipUser(); u3.buy(); // 测试代码 var u1 = new User(\"ordinary\"); u1.buy(); // 普通用户购买 var u2 = new User(\"member\"); u2.buy(); // 会员用户购买 var u3 = new User(\"vip\"); u3.buy(); // vip 用户购买 设计原则验证 不同策略，分开处理，而不是混合在一起 符合开放封闭原则 12.6 模板方法模式 class Action { handle() { handle1(); handle2(); handle3(); } handle1() { console.log(\"1\"); } handle2() { console.log(\"2\"); } handle3() { console.log(\"3\"); } } let action = new Action(); action.handle(); 12.7 职责连模式 一步操作可能分为多个职责来完成 把这些角色都分开，然后用一个链串起来 将发起者和各个处理者进行隔离 // 请假审批，需要组长审批、经理审批、最后总监审批 class Action { constructor(name) { this.name = name; this.nextAction = null; } setNextAction(action) { this.nextAction = action; } handle() { console.log(`${this.name} 审批`); if(this.nextAction != null) { this.nextAction.handle(); } } } let a1 = new Action(\"组长\"); let a2 = new Action(\"经理\"); let a3 = new Action(\"总监\"); a1.setNextAction(a2); a2.setNextAction(a3); a1.handle(); // 组长 审批 // 经理 审批 // 总监 审批 使用场景 职责链模式和业务结合较多，JS 中能联想到链式操作 jQuery 的链式操作， Promise.then 的链式操作 设计原则验证 发起者于各个处理者进行隔离 符合开放封闭原则 12.8 命令模式模式 执行命令时，发布者和执行者分开 中间加入命令对象，作为中转站 将军发布命令，先告诉副官，由副官进行传达，而不是将军一个一个告诉军队 董事长实施战略，先告诉经理，至于各部门如何协调，让经理进行排期。 // 接受者 class Receiver { exec() { console.log(\"执行\"); } } // 命令者 class Command { constructor(receiver) { this.receiver = receiver; } cmd() { console.log(\"触发命令\"); this.receiver.exec(); } } // 触发者 class Invoker { constructor(command) { this.command = command; } invoke() { console.log(\"开始\"); this.command.cmd(); } } // 士兵 let soldier = new Receiver(); // 小号手 let trumpeter = new Command(soldier); // 将军 let general = new Invoker(trumpeter); general.invoke(); // 开始 // 触发命令 // 执行 JS 中的应用 网页富文本编辑器操作，浏览器封装了一个命令对象 document.execCommand(\"bold\") document.execCommand(\"undo\") 设计原则验证 命令对象于执行对象分开，解耦 符合开放封闭原则 12.9 备忘录模式 随时记录一个对象的状态变化 随时可以恢复之前的某个状态（如撤销功能） // 状态备忘 class Memento { constructor(content) { this.content = content; } getContent() { return this.content; } } // 备忘列表 class CareTaker { constructor() { this.list = []; } add(memento) { this.list.push(memento); } get(index) { return this.list[index]; } } // 编辑器 class Editor { constructor() { this.content = null; } setContent(content) { this.content = content; } getContent() { return this.content; } saveContentToMemento() { return new Memento(this.content); } getContentFromMemento(memento) { this.content = memento.getContent(); } } // 测试代码 let editor = new Editor(); let careTaker = new CareTaker(); editor.setContent(\"111\"); editor.setContent(\"222\"); careTaker.add(editor.saveContentToMemento()); // 存储备忘录 editor.setContent(\"333\"); careTaker.add(editor.saveContentToMemento()); // 存储备忘录 editor.setContent(\"444\"); console.log(editor.getContent()); // 444 editor.getContentFromMemento(careTaker.get(1)); // 撤销 console.log(editor.getContent()); // 333 editor.getContentFromMemento(careTaker.get(0)); // 撤销 console.log(editor.getContent()); // 222 /** * 这里是预知了要撤销的步骤 * 假如，不知道要存储了多少条备忘录 * 而我们要一步步回撤，则需要怎么做？ * 个人想法就是还需要一个计步器 * 就是你存了多少备忘录，则记起来 * 当你需要回撤的时候，直接读取最近的备忘条数 * 即可回撤到最近一步操作 */ 设计原则验证 状态对象与使用者分开，解耦 符合开放封闭原则 12.10 中介者模式 中介者原理 class Mediator { constructor(a, b) { this.a = a; this.b = b; } setA() { let number = this.b.number; this.a.setNumber(number * 100); } setB() { let number = this.a.number; this.b.setNumber(number / 100); } } class A { constructor() { this.number = 0; } setNumber(num, m) { this.number = num; if(m) { m.setB(); } } } class B { constructor() { this.number = 0; } setNumber(num, m) { this.number = num; if(m) { m.setA(); } } } // 测试 let a = new A(); let b = new B(); let m = new Mediator(a, b); a.setNumber(100, m); console.log(a.number, b.number); // 100 1 b.setNumber(100, m); console.log(a.number, b.number); // 10000 100 设计原则验证 将各关联对象通过中介者隔离 符合开放封闭原则 12.11 访问者模式 将数据操作和数据结构进行分离 使用场景不多 12.12 解释器模式 描述语言语法如何定义，如何解释和编译 用于专业场景 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:44:13 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"JavaScript-library/design-pattern/design-pattern-chapter13.html":{"url":"JavaScript-library/design-pattern/design-pattern-chapter13.html","title":"✘ 设计模式手册 - 13 - 综合应用","keywords":"","body":"设计模式手册 - 13 - 综合应用 create by jsliang on 2018年9月4日09:37:55Recently revised in 2019-05-20 17:44:37 第十三章 综合应用-购物车  最后，我们使用 jQuery 做一个模拟购物车的示例。 功能如下： 显示购物列表 加入购物车 从购物车删除 涉及的设计模式： 工厂模式 单例模式 装饰器模式 观察者模式 状态模式 模板方法模式 代理模式 13.1 UML类图 13.2 编程环境搭建  如果小伙伴有跟着 部署开发环境 搭建了属于自己的设计模式环境，那么，就让我们优化一下直接跑起我们的综合应用就OK了~如果小伙伴没有去做，那么先跟着 部署开发环境 先跑一遍，再回来做我们的综合应用吧！前往：第一章 部署开发环境  OK，Here we go! 我们目前的目录 目录文件  在这里，我们先过一遍我们的文件，没有配置设计模式环境的小伙伴可以照上面的图新建过文件目录，配置好的小伙伴看看代码和 jsliang 的代码是否一致：  dist - 打包后的文件存放地方  dist/js - 该文件夹为打包后的 js 文件存储位置，这里的 index.js 系自动生成，无需新增该文件  dist/index.html - 打包后的 index.html ，一般是依据原有的 index.html ，打包时 webpack 往里面添加 \\ ，这里我们需要添加下列代码进去。 jsliang的设计模式 Hello 综合应用！ --> -->  node_modules - npm 安装包，在拷贝了其他文件的代码后，我们 npm i 会自动生成  src/index.js - 被打包的 js 文件，暂时不需要添加代码  .babelrc - es6、es7 代码转为 es5 代码所必需的文件 { \"presets\": [ \"env\" ], \"plugins\": [ [\"transform-decorators-legacy\"] ] }  package.json - 项目的依据，所依赖的插件都在这里提示 { \"name\": \"design-pattern\", \"version\": \"1.0.0\", \"description\": \"design pattern for javascript\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"webpack-dev-server --config ./webpack.dev.config.js\", \"build\": \"webpack --config ./webpack.dev.config.js\" }, \"keywords\": [ \"javascript\", \"design pattern\" ], \"author\": \"jsliang\", \"license\": \"ISC\", \"devDependencies\": { \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-plugin-transform-decorators-legacy\": \"^1.3.5\", \"babel-polyfill\": \"^6.26.0\", \"babel-preset-env\": \"^1.7.0\", \"html-webpack-plugin\": \"^3.2.0\", \"webpack\": \"^4.16.5\", \"webpack-cli\": \"^3.1.0\", \"webpack-dev-server\": \"^3.1.5\" }, \"dependencies\": { \"core-decorators\": \"^0.20.0\", \"javascript-state-machine\": \"^3.1.0\", \"jquery\": \"^3.3.1\" } }  webpack.dev.config.js - webpack 开发模式下会使用到的 loader 以及插件等配置 const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'development', // 开发模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname + '/dist', filename: './js/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ], devServer: { // 开发服务 contentBase: path.join(__dirname, './dist'), // 监控的目录 open: true, // 自动打开浏览器 port: 9000, // 端口 // host: \"192.168.1.87\" // WiFi IPV4地址，打开可共享到手机 } }  webpack.prod.config.js - 生产环境，打包文件到 dist 目录，然后发布到服务器上即可生效访问 const path = require('path'); // 加载node中的path模块 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 加载插件html-webpack-plugin module.exports = { mode: 'production', // 生产模式 entry: './src/index.js', // 入口文件 output: { // 出口文件 path: __dirname + '/dist', filename: './js/index.js' }, module: { // 加载模块 rules: [{ test: /\\.js$/, // .js文件加载loader include: path.resolve(__dirname, \"./src\"), // 检查的文件夹 exclude: path.resolve(__dirname, \"./node_modules\"), // 不检查的文件夹 loader: 'babel-loader' // 使用的loader }] }, plugins: [ new HtmlWebpackPlugin({ // HTML加载插件 template: './dist/index.html' }) ] } 复制粘贴完这些代码之后，我们就可以跑起项目来了！ 安装 npm 包：npm i 进入开发模式：npm run dev 生产模式打包：npm run build  很好，上面就是我们原有的目录，让我们往里面新增代码，配置综合应用的环境吧： 搭建完后的目录  如图，我们需要往 src 目录下新增 api 文件夹及其 list.json 以及 src 目录下的 App.js。  然后，我们需要往 webpack.dev.config.js 中的 devServer 添加解决跨域的代码，因为我们将采用其他端口作为我们的 API 地址： proxy: { \"/api/*\": { // url 中匹配到 \"/api\" 之前的东西，将其全部替换成下面 target 中的东西，从而解决跨域问题 target: \"http://localhost:8880\" } }  此刻我们的 index.js 、App.js 以及 list.json 文件内容如下： index.js - 启动文件，通过 index.js 访问 App.js 这个主入口 import App from './demo/App.js' let app = new App('app'); app.init(); App.js - 项目主入口 export default class App { constructor(id) { } init() { console.log(\"初始化成功！\"); } } list.json - api接口文件，提供书籍清单 [ { \"id\": 1, \"name\": \"《JS 基础面试题》\", \"price\": 149, \"discount\": 1 }, { \"id\": 2, \"name\": \"《JS 高级面试题》\", \"price\": 366, \"discount\": 1 }, { \"id\": 3, \"name\": \"《React 模拟大众点评 webapp》\", \"price\": 248, \"discount\": 0 }, { \"id\": 4, \"name\": \"《zepto 设计与源码解读》\", \"price\": 0, \"discount\": 0 } ]  到这里，我们一切准备就绪，只需要执行两步即可： cd 到 demo 目录中，打开接口服务： cd src/demo http-server -p 8880 这时候我们打开下面地址，会发现该 api 接口成功开启： 打开开发模式： npm run start 这时候浏览器会自动打开 localhost:9000 ，如果没有打开，请在浏览器输入 http://localhost:9000 即可访问到：  好的，到此为止，我们已经完美部署了我们综合应用的开发环境，让我们继续前进吧！ 13.3 代码剖析 步骤1 inde.js import App from './demo/App.js' let app = new App('app'); app.init(); App.js import $ from 'jquery' export default class App { constructor(id) { this.$el = $(\"#\" + id); } // 初始化购物车 initShoppingCart() { console.log(\"初始化购物车\"); } // 初始化列表 initList() { console.log(\"初始化列表\"); } init() { this.initShoppingCart(); this.initList(); } } 步骤2 步骤3 ShoppingCart.js export default class ShoppingCart { constructor(app) { } init() { } } List.js export default class ShoppingCart { constructor(app) { } init() { } } App.js import $ from 'jquery' import ShoppingCart from './ShoppingCart/ShoppingCart.js' import List from './List/List.js' export default class App { constructor(id) { this.$el = $(\"#\" + id); } // 初始化购物车 initShoppingCart() { let shoppingCart = new ShoppingCart(this); shoppingCart.init(); } // 初始化列表 initList() { let list = new List(this); list.init(); } init() { this.initShoppingCart(); this.initList(); } } 步骤4 List.js import $ from 'jquery' export default class ShoppingCart { constructor(app) { this.app = app; this.$el = $(''); } // 获取数据 loadData() { } // 生成列表 initItemList(data) { } // 渲染 render() { } init() { } } 步骤5 config.js export const GET_LIST = '/api/list.json' 步骤6 List.js import $ from 'jquery' import { GET_LIST } from '../config/config.js' export default class ShoppingCart { constructor(app) { this.app = app; this.$el = $(''); } // 获取数据 loadData() { // 返回 Promise 实例 return fetch(GET_LIST).then(result => { return result.json(); }); } // 生成列表 initItemList(data) { data.map(itemData => { // 创建一个 Item 然后 init }) } // 渲染 render() { this.app.$el.append(this.$el); } init() { this.loadData().then(data => { this.initItemList(data); }).then(() => { // 渲染 this.render(); }) } } 步骤7 GetCart.js class Cart { constructor() { this.list = []; } add(data) { this.list.push(data); } del(id) { this.list = this.list.filter(item => { if(item.id === id) { return false; } return true; }) } getList() { return this.list.map(item => { return item.name; }).join('\\n'); } } // 返回单例 let getCart = (function() { let cart; return function() { if(!cart) { cart = new Cart(); } return cart; } })() export default getCart; 步骤8 Item.js import $ from 'jquery'; import getCart from '../ShoppingCart/GetCart.js'; export default class Item { constructor(list, data) { this.list = list; this.data = data; this.$el = $(''); this.cart = getCart(); } initContent() { let $el = this.$el; let data = this.data; $el.append($(`名称：${data.name}`)); $el.append($(`价格：${data.name}`)); } initBtn() { let $el = this.$el; let $btn = $('test'); $btn.click(() => { // 添加到购物车 // 从购物车移除 }) $el.append($btn); } // 添加到购物车 addToCartHandle() { this.cart.add(this.data); } // 从购物车删除 deleteFromCartHandle() { this.cart.del(this.data.id); } render() { this.list.$el.append(this.$el); } init() { this.initContent(); this.initBtn(); this.render(); } } 步骤9 CreateItem.js import Item from './Item.js' // 补充：优惠商品的处理逻辑 // 工厂函数 export default function(list, itemData) { return new Item(list, itemData); } List.js import $ from 'jquery' import { GET_LIST } from '../config/config.js' import createItem from './CreateItem.js' export default class ShoppingCart { constructor(app) { this.app = app; this.$el = $(''); } // 获取数据 loadData() { // 返回 Promise 实例 return fetch(GET_LIST).then(result => { return result.json(); }); } // 生成列表 initItemList(data) { // data.map(itemData => { // // 创建一个 Item 然后 init // let item = createItem(this, itemData); // item.init(); // return item; // }) data.forEach(itemData => { // 创建一个 Item 然后 init let item = createItem(this, itemData); item.init(); }) } // 渲染 render() { this.app.$el.append(this.$el); } init() { this.loadData().then(data => { this.initItemList(data); }).then(() => { // 渲染 this.render(); }) } } 步骤10 Item.js import $ from 'jquery'; import getCart from '../ShoppingCart/GetCart.js'; // 引用第三方插件实现状态模式 import StateMachine from 'javascript-state-machine'; export default class Item { constructor(list, data) { this.list = list; this.data = data; this.$el = $(''); this.cart = getCart(); } initContent() { let $el = this.$el; let data = this.data; $el.append($(`名称：${data.name}`)); $el.append($(`价格：${data.price}`)); } initBtn() { let $el = this.$el; let $btn = $(''); let _this = this; let fsm = new StateMachine({ init: '加入购物车', transitions: [ { name: 'addToCart', from: '加入购物车', to: '从购物车删除' }, { name: 'deleteFromCart', from: '从购物车删除', to: '加入购物车' } ], methods: { // 加入购物车 onAddToCart: function() { _this.addToCartHandle(); updateText(); }, // 从购物车删除 onDeleteFromCart: function() { _this.deleteFromCartHandle(); updateText(); } } }) function updateText() { $btn.text(fsm.state); } $btn.click(() => { if(fsm.is('加入购物车')) { fsm.addToCart(); } else { fsm.deleteFromCart(); } }) updateText(); $el.append($btn); } // 添加到购物车 addToCartHandle() { this.cart.add(this.data); } // 从购物车删除 deleteFromCartHandle() { this.cart.del(this.data.id); } render() { this.list.$el.append(this.$el); } init() { this.initContent(); this.initBtn(); this.render(); } } 步骤11 步骤12 ShoppingCart.js import $ from 'jquery'; import getCart from './GetCart.js' export default class ShoppingCart { constructor(app) { this.app = app; this.$el = $('').css({ 'padding-bottom': '10px;', 'border-bottom': '1px solid #ccc' }) this.cart = getCart(); } initBtn() { let $btn = $('购物车'); $btn.click(() => { this.showCart(); }) this.$el.append($btn); } showCart() { alert(this.cart.getList()); } render() { this.app.$el.append(this.$el); } init() { this.initBtn(); this.render(); } } 步骤13 CreateItem.js import Item from './Item.js' function createDiscount(itemData) { // 用代理做折扣显示 return new Proxy(itemData, { get: function(target, key, receiver) { if(key === 'name') { return `${target[key]} 【折扣】`; } if(key === 'price') { return target[key] * 0.8; } return target[key]; } }) } // 工厂函数 export default function(list, itemData) { if(itemData.discount) { itemData = createDiscount(itemData); } return new Item(list, itemData); } 步骤14 log.js export function log(type) { return function(target, name, descriptor) { let oldValue = descriptor.value; descriptor.value = function() { // 在此统一打印日志 console.log(`日志上报 ${type}`); // 执行原有的方法 return oldValue.apply(this, arguments); } return descriptor; } } Item.js import $ from 'jquery'; import getCart from '../ShoppingCart/GetCart.js'; // 引用第三方插件实现状态模式 import StateMachine from 'javascript-state-machine'; import { log } from '../util/log.js' export default class Item { constructor(list, data) { this.list = list; this.data = data; this.$el = $(''); this.cart = getCart(); } initContent() { let $el = this.$el; let data = this.data; $el.append($(`名称：${data.name}`)); $el.append($(`价格：${data.price}`)); } initBtn() { let $el = this.$el; let $btn = $(''); let _this = this; let fsm = new StateMachine({ init: '加入购物车', transitions: [ { name: 'addToCart', from: '加入购物车', to: '从购物车删除' }, { name: 'deleteFromCart', from: '从购物车删除', to: '加入购物车' } ], methods: { // 加入购物车 onAddToCart: function() { _this.addToCartHandle(); updateText(); }, // 从购物车删除 onDeleteFromCart: function() { _this.deleteFromCartHandle(); updateText(); } } }) function updateText() { $btn.text(fsm.state); } $btn.click(() => { if(fsm.is('加入购物车')) { fsm.addToCart(); } else { fsm.deleteFromCart(); } }) updateText(); $el.append($btn); } // 添加到购物车 @log('add') // 装饰器模式 addToCartHandle() { this.cart.add(this.data); } // 从购物车删除 @log('del') deleteFromCartHandle() { this.cart.del(this.data.id); } render() { this.list.$el.append(this.$el); } init() { this.initContent(); this.initBtn(); this.render(); } } 13.4 总结  项目中使用到的模式： 工厂模式：$('×××')，创建商品 单例模式：购物车 装饰器模式：打点统计 观察者模式：网页事件，Promise 状态模式：添加到购物车 & 从购物车删除 模板方法模式：渲染有统一的方法，内部包含了各模块渲染 代理模式：打折商品信息处理 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 17:47:34 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/":{"url":"other-library/","title":"其他资料室","keywords":"","body":"其他资料室 Create by jsliang on 2018-10-28 11:07:33Recently revised in 2019-5-20 08:25:29 All the articles that can not be classified are stored here 这里存放了目前所有无法分类的文章 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Git/":{"url":"other-library/Git/","title":"Git","keywords":"","body":"Git Create by jsliang on 2018-10-25 15:14:00Recently revised in 2019-04-02 21:31:22 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文 二 前言 返回目录 一直以来，jsliang 对 Git 的操作，仅限于：git add .、git commit -m \"更新信息\"、git push 这三个，偶尔还会创建操作个分支。 但是，仅仅是这些是不够的。所以，跟随 廖雪峰 等大神的 Git 教程进行一波自我更新： 《Git 教程 - 廖雪峰》 什么是 Git Git 是目前世界上最先进的分布式版本控制系统。 这么说也许你很懵逼，没关系，我们用毕业论文来讲讲： 如上图。写过毕业论文的小伙伴，应该记忆深刻：《毕业论文》《毕业论文完成版》《毕业论文最终版》《毕业论文最最终版》…… 令人抓狂无比，当我们需要在 最最最最终版 找到之前文件中早早被删除的信息时，我们更加抓狂了：卧槽，我写到哪去了！ 这时候，如果有个软件之类的东西帮我们记录就好了： 文件名 更新信息 时间 毕业论文 第一版，整体内容搭建 2019-3-28 08:41:04 毕业论文完成版 第二版，完成了大部分内容，并进行了排版 2019-3-29 08:41:46 毕业论文最终版 第三版，对第二版进行了删减 2019-3-30 08:42:21 毕业论文最最终版 第四版，对第三版进行了新增 2019-3-31 08:42:42 ... ... ... 毕业论文最最最最终版 第六版，对整了下格式 2019-4-2 08:43:17 OK，这时候我们会发觉，我们要找到被删减的内容，只需要去第二版中查找就行了，这就是为何会有版本管理工具的原因。 而 Git，就是目前较盛行的版本管理工具。 集中式与分布式 历史总是前进的，在 Git 之前，还是有其他的版本管理系统： VSS：最老的版本有锁，需要锁住才能编辑，提交时解锁，独占修改，小规模最好用，大规模最难用。 CSV：代表协作版本系统或者并发版本系统同，是一种版本控制系统，提交失败时解决冲突比较麻烦。 SVN：目标是想取代 CSV，相对于 CSV 采用了分支管理系统，配置成 HTTP 服务时比较简单，稳定。 Git：相对于 SVN 多一个本地库。 历史总是被湮没，每次找资料，都找不全 关于版本管理工具的历史推进，咱在此就不做详述，如果有小伙伴找到比较全的资源，可以发出来分享下。 关于 SVN 和 Git，其实涉及两种管理系统的比较，即：集中式与分布式。 什么是集中式？集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 什么是分布式？区别于集中式版本控制系统，分布式版本控制系统中没有 “中央服务器”，每个人的电脑都是一个完整的版本库。既然你的电脑是一个完整的版本库，假设你改了文件 A，你的同事也改了文件 A，你们需要协作，这时候只需要将各自修改推送给对方，双方就知道对方修改了什么了。这就好比诸葛亮和周瑜在攻打曹操的时候，各自在手心写了一个字，写完之后亮给对方看，相视一笑：嗯，这 b 跟老子想得一样。 而 SVN 和 Git，分别作为集中式与分布式的代表之一。 Git 安装 对于 Git 安装，2018 年 jsliang 入职公司的时候已经安装过，又因为 廖雪峰 大佬已经安排的明明白白了，故不多此一举，贴上安装步骤文章： 《安装 Git》 Git 新建版本库 什么是版本库？ 版本库又名仓库，英文名 repository，可以简单理解为一个目录，这个目录里面的所有文件都可以被 Git 管理起来，用于追踪每个文件的修改、删除。 创建目录：mkdir learngit 前进到这个目录：cd learngit 显示当前目录：pwd 初始化仓库：git init 显示 .git：ls -ah 这时候会出来一个隐藏文件，叫 .git，这个目录就是 Git 用来跟踪管理版本库的，请不要手动修改里面的文件。 添加文件，新建 README.md： README.md Git 学习 === 将文件添加到仓库：git add README.md（git add . 是提交当前目录所有文件） 将文件提交到仓库：git commit -m \"Add a README\" 此处 -m 输入的是本次提交的说明，方便你根据说明查找需要的历史版本 修改文件内容： README.md Git 学习 === > Create by **jsliang** on **2019-3-29 09:08:48** > Recently revised in **2019-3-29 09:08:53** 查看结果：git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: README.md no changes added to commit (use \"git add\" and/or \"git commit -a\") 此刻可以看出，我们查看到了 README.md 被修改了。 查看版本差异：git diff index b379f95..78fb1fe 100644 --- a/README.md +++ b/README.md @@ -1,2 +1,5 @@ Git 学习 -=== \\ No newline at end of file +=== + +> Create by **jsliang** on **2019-3-29 09:09:03** +> Recently revised in **2019-3-29 09:09:07** \\ No newline at end of file 这时候，我们添加了时间，做了新的更改，所以我们又可以进行新一轮的提交： git add . git commit -m \"添加时间\" 我们再添加下证书并提交： README.md Git 学习 === > Create by **jsliang** on **2019-3-29 09:09:03** > Recently revised in **2019-3-29 09:09:07** > jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 git add . git commit -m \"添加协议\" 当我们做的事儿越多，越不可能记住几个字的更改，所以我们需要查找历史记录，见证我们成长的点滴：git log commit 7b88d86f3e079e048c3e5444f91616b826f553a0 (HEAD -> master) Author: jsliang Date: Fri Mar 29 09:21:35 2019 +0800 添加协议 commit 05abb578724b7d8cef860aa4280b0e19241c02a8 Author: jsliang Date: Fri Mar 29 09:14:16 2019 +0800 添加时间 commit 655433cc64356a8f9dc12e9a94808a25e844c0eb Author: jsliang Date: Fri Mar 29 09:03:59 2019 +0800 回退到上一个版本：git reset --hard HEAD^ HEAD is now at 05abb57 添加时间 注意，git log 显示的记录中，commit 后面的就是 HEAD，Git 通过 HEAD 控制版本 如果误回退了呢？尝试回退版本号：git reset --hard 7b88d86 HEAD is now at 7b88d86 添加协议 OK，现在它又回来了。记住：如果你操作失误回退了，请不要关闭命令行窗口，还有机会补救！ 找不到版本号，想恢复新版本：git reflog 7b88d86 (HEAD -> master) HEAD@{0}: reset: moving to 7b88d86 05abb57 HEAD@{1}: reset: moving to HEAD^ 7b88d86 (HEAD -> master) HEAD@{2}: commit: 添加协议 05abb57 HEAD@{3}: commit: 添加时间 可以看到，这里把前面版本的版本号显示出来了。 Git 命令 git fetch 从一个或多个其他存储库中获取分支和/或标签(统称为“引用”)以及完成其历史所必需的对象。 远程跟踪分支已更新(Git术语叫做commit)，需要将这些更新取回本地，这时就要用到git fetch命令。 git 取消忽略文件大小写的更改 在当前项目，输入 git config core.ignorecase false 即可关闭 git 忽略文件大小写的配置。 git 删除文件夹 删除 target 文件夹：git rm -r --cached target 提交更改：git commit -m \"删除 target 目录\" 确认更改：git push git 覆盖上一次 commit 提交信息 git commit -amend -m \"New commit\" git 分支 创建分支：git branch cheny 切换到分支：git checkout cheny 添加修改代码到缓存：git add . 提交：git commit -m \"修改\" 提交到分支：git push origin cheny/git push --set-upstream origin cheny 同时配置 GitLab 和 GitHub 缘由：公司使用 GitLab，个人使用 GitHub，因此需要配置下 Git，方便上传到公司的 GitLab 项目和个人的 GitHub 项目上。 参考文献： 同一台电脑同时使用gitlab和github 配置同时使用 Gitlab 和 Github 的开发环境 Mac 配置步骤 CD 到用户根目录下的 .ssh 文件夹中：cd .ssh 生成 GitLab 秘钥：ssh-keygen -t rsa -C \"注册 gitlab 账户的邮箱\"，提示后输入 id_rsa_gitlab，这样就在 .ssh 目录下生成了 GitLab 的秘钥。 生成 GitHub 秘钥：ssh-keygen -t rsa -C \"注册 github 账户的邮箱\"，提示后输入 id_rsa_github，这样就在 .ssh 目录下生成了 GitHub 的秘钥。 这时候我们 .ssh 目录中有文件： id_rsa_github.pub id_rsa_gitlab.pub id_rsa_github id_rsa_gitlab 提供公钥给服务器 复制 ~/.ssh/id_rsa_gitlab.pub文件内容，进入gitlab / profile / SSH Keys，将公钥内容添加至 gitlab 。 复制 ~/.ssh/id_rsa_github.pub文件内容，进入github / setting / SSH and GPG keys / New SSH key 将公钥内容添加至 github 。 在 .ssh 中添加 config 文件（文本文件，不存在后缀），内容为： config Host github.com HostName github.com User githubuser@xyz.com IdentityFile ~/.ssh/id_rsa_github Host gitlab.com HostName gitlab.com User gitlabuser@xyz.com IdentityFile ~/.ssh/id_rsa_gitlab 这时候我们 .ssh 目录中有文件： id_rsa_github.pub id_rsa_gitlab.pub id_rsa_github id_rsa_gitlab config （可选）在 GitHub 或者 GitLab 仓库大目录中使用下面三条命令： git init git config --global user.name \"githubuser\" git config --global user.email \"githubuser@xyz.com\" 在项目文件夹中使用以下命令： git clone 项目地址 新增/修改文件 git add . git commit -m \"修改配置\" git push 在终端输入账号密码信息后，就会提示上传成功了，最终项目目录中有文件： config id_rsa_github.pub id_rsa_gitlab.pub id_rsa_github id_rsa_gitlab known_hosts 配置 .gitignore 在我们使用Git的过程中，有时候喜欢建一些文件给自己查看使用而不是给大众使用，或者说像是 node_modules 这些文件不希望上传到代码仓库的，这时候就需要设置响应的忽略规则，来忽略这些文件的提交。 全局生效 定义全局 .gitignore 文件，将其放在任意位置即可生效 git config --global core.excludesfile ~/.gitignore 忽略规则 忽略掉所有文件名是 test.html 的文件 test.html 忽略掉 node_modules 文件夹 node_modules 忽略掉所有生成的备份文件 *.*~ 忽略所有 .o 和 .a 文件 *.[oa] 详细用法看文档：详情 VS Code 隐藏 node_modules 值得一提的就是，我们不仅要忽略它的上传，在 Visio Studio Code 这个编辑器中，如果我们也需要忽略它的话，就需要进行相应的设置，VS Code 隐藏工作区中的 node_modules 文件夹： 主菜单 -> 文件 -> 首选项 -> 用户设置： \"file.exclude\": { \"node_modules/\": true } jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/HTTP/":{"url":"other-library/HTTP/","title":"HTTP","keywords":"","body":"HTTP 协议 Create by jsliang on 2018-12-24 08:18:27Recently revised in 2018-12-24 08:18:31 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文 二 前言 返回目录 什么时候涉及 HTTP 协议？ 输入 URL 打开网页 Ajax 获取数据 img 标签加载图片 什么是 HTTP 协议？ HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW：World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP 协议是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于 1990 年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在 WWW 中使用的是 HTTP/1.0 的第六版，HTTP/1.1 的规范化工作正在进行之中，而且 HTTP-NG(Next Generation of HTTP) 的建议已经提出。 HTTP 协议工作于客户端-服务端架构为上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响应信息。 三 正文 返回目录 浏览器输入 URL 后 HTTP 请求返回的完整过程 经典五层模型 物理层 - 主要作用是定义物理设备如何传输数据 数据链路层 - 在通信的实体间建立数据链路连接 网络层 - 为数据在节点之间出书创建逻辑链路 传输层 - 1. 向用户提供可靠的端到端（End-to-End）服务；2. 传输层向高层屏蔽了下层数据通信的细节 应用层 - 构建于 TCP 协议之上，为应用软件提供了很多服务 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Interview/":{"url":"other-library/Interview/","title":"面试","keywords":"","body":"面试体系 Create by jsliang on 2018-12-6 21:17:50Recently revised in 2019-3-13 09:18:17 这里收集了 jsliang 亲身经历的面试知识点及实战，也收集了道听途说的一些小伙伴的面试经历以及网上看到的一些 jsliang 见猎心喜的文章。 本块内容主要分两部分：亲身经历 和 道听途说。小伙伴们可以按自己喜爱观看： 试题 亲身经历 道听途说 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Interview/Hearsay/":{"url":"other-library/Interview/Hearsay/","title":"面试 - 道听途说","keywords":"","body":"面试 - 道听途说 Create by jsliang on 2019-3-13 08:29:16Recently revised in 2019-3-13 08:51:51 该文件夹下的系列文章，皆为道听途说，有的是熟悉的小伙伴提供的，有的是 jsliang 在总结自己面试知识点的时候，感觉非常优秀的文章，小伙伴们可以自行参考： 文章 主要内容 《阿里系公司第一轮电面题》 阿里系公司第一轮电面题，薪酬范围：10K-20K 《中高级前端大厂面试秘籍，为你保驾护航金三银四，直通大厂(上)》 寒冬之中，人才更是尤为珍贵。只要有过硬的操作和装备，在逆风局下，同样也能来一波收割翻盘。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Interview/Hearsay/InterviewOne.html":{"url":"other-library/Interview/Hearsay/InterviewOne.html","title":"✔ 第一篇 - 阿里系公司第一轮电面题","keywords":"","body":"第一篇 - 阿里系公司第一轮电面题 Create by jsliang on 2018-12-6 21:19:00Recently revised in 2018-12-6 21:29:01 薪酬范围：10K-20K 岗位描述： 产品/系统前端技术选型、技术路线规划及系统部署设计，推动所设计架构的有效落实。 配合产品经理，准确理解业务需求，实现产品经理的设计要求，对用户交互和视觉效果有较强的感知力和认知力。 配合后台工程师，设计数据接口协议，实现数据的加载和处理。设计性能优良、交互流畅，易维护、易扩展的数据处理和视图渲染架构。 开发高安全性、强兼容性的用户界面，使之稳定可靠。 为高性能的用户界面设计优秀的编码和技术标准，负责前端开发规范和流程制定。 构建可复制的前端组件库，以确保快速应用原型的想法； 任职资格: 精通HTML5、CSS3和JavaScript语言，深入HTTP及相关网络协议，熟悉跨终端、跨浏览器的开发模式和平台特性，了解业界技术发展状况； 主导或独立负责过一定规模产品前端，前端技术有专研领域，掌握至少一种非前端开发语言并实际完成项目； 有优质技术产品或开源贡献者优先；有前端架构、性能优化、Hybrid研发、iOS/Android应用开发经验可作为加分项； 充分的产品意识、数据意识，善于规划执行、协调沟通，结果导向； 有团队管理经验，带领团队技术攻坚，团队建设上有突出表现。 面试内容： 先说一下 React 和 Vue 的不同点。 原型 propetype 与 _prop_。 问：什么可以改变 this 的指向？答：bind、call、apply。问：那你说一下 bind apply、call。答：简述一下 bind 的内部实现，apply 和 call 的区别。 闭包的理解以及优缺点。 简述一下 js 的垃圾回收机制（因为第三题中我说了，闭包中的东西不会被垃圾回收机制回收，如果滥用会导致性能问题） 问：跨域的几种方式。答：jsonp、core、nginx 性能优化的哪些方式。 简述一下观察者模式。 移动端 1px 的问题。 移动端 300ms 延迟，如何解决的？ 两栏布局， 实现一个高度为屏幕宽度一半的正方形。 重点：写过 Vue 插件么？为什么有些 Vue 插件要使用前要 Vue.use，而有一些不需要。（ PS：有 Vue 插件不需要 use 的吗？） 简单说下 Vue 中的 mixin，你在什么场景使用它。 了解 Webpack 么？Webpack 优化，你做过哪些。（感觉这个巴拉巴拉吹过了）Webpack 原理是什么？ React 中 setstate 以后到页面渲染这之间发生了什么？ (从 diff 算法开始，props 的生命周期钩子说了一下) 简述一下 Redux 的数据流向 说下你理解的排序算法，冒泡排序和快排的区别。（尼玛，巴拉巴拉说了一堆，发现说错了，说成二分法排序了，泪奔） 协商缓存你了解么？怎么判断浏览器是怎么判断是什么缓存的。catch-control 的几种值，这个突然卡壳了，么想起来。 promise 的几种状态，他的内部原理是怎么样的？ 数组去重，以及排序。 说一下 css 选择器的权重。 ajax 预检，如何取消他？ Web 安全 promise.then 和 settimeout 哪个会先执行，为什么？ margin 塌陷的原理。 暂时就想起这么多来，叭叭的说了整整半个小时。 ↑↑↑ 以上来自目前就职于阿里系公司的小伙伴的回忆 ↑↑↑ jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Interview/PersonalExperience/":{"url":"other-library/Interview/PersonalExperience/","title":"面试 - 亲身经历","keywords":"","body":"面试 - 亲身经历 Create by jsliang on 2019-3-13 08:22:22Recently revised in 2019-3-18 08:11:31 该文件夹下的系列文章，皆为本人亲身经历，可为广州级别 9K - 15K 的前端小伙伴提供面试参考： 文章 主要内容 《jsliang 的 2019 面试准备》 jsliang 自我介绍，为冲刺目标岗位，而编写了大而全的面试知识点。 《2019 面试实战 - Round One》 第一回合面试：非常疲惫，但是感觉很有动力，“没有一家解决不了的，如果有，那就再跑一家！” 《2019 面试实战 - Round Two》 第二回合面试：背着电脑负重 10 斤前行 13000 步，进入办公室放下电脑那一刻，轻松上阵！没人能在我的 BGM 里…… 《2019 面试实战 - Round Three》 第三回合面试：面试上瘾了，就是想接触更多人，看到更广阔的世界。 《2019 面试准备 - JS 原型与原型链》 prototype、__proto__、new、call()/apply()/bind()、this 《2019 面试准备 - JS 防抖与节流》 防抖与节流、重绘与回流、浏览器解析 URL、DNS 域名解析、TCP 三次握手与四次挥手、浏览器渲染页面 《2019 面试准备 - 图片》 JPG、PNG、GIF、SVG等不同格式图片的区分，它们的优劣势以及使用场景等…… jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Interview/PersonalExperience/2019-InterviewPreparation.html":{"url":"other-library/Interview/PersonalExperience/2019-InterviewPreparation.html","title":"✔ jsliang 的 2019 面试准备","keywords":"","body":"jsliang 的 2019 面试准备 Create by jsliang on 2019-2-11 15:30:34Recently revised in 2019-3-20 08:15:50 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 并不是只有特定的季节才能跑路，只因为人跑得多了，这条路就定下来了。 金三银四跳槽季，jsliang 于 2019年2月11日 写下了这篇文章，开始准备自己的面试之旅。 至 2019年3月17日 为止，jsliang 搭建出个人的面试知识体系，海量地翻阅了一些前辈留下的资料，结合个人需求进行了几场面试，从而进一步完善该文章并进行了发表，希望对准备跳槽或者正在跳槽中的小伙伴有所帮助。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言  2.1 自我介绍  2.2 跳槽原委  2.3 进击目标  2.4 开篇点题 三 HTML  3.1 HTML 学习推荐  3.2 HTML 语义化  3.3 HTML5 新标签  3.4 常见浏览器及其内核  3.5 cookies、session、sessionStorage、localStorage 四 CSS  4.1 CSS 学习推荐  4.2 CSS reset  4.3 CSS 盒模型  4.4 CSS 单位  4.5 CSS 选择器  4.6 CSS 常见布局  4.7 CSS3 新特性  4.8 BFC  4.9 行内元素和块级元素  4.10 行内样式、内嵌式、链接式以及导入式  4.11 水平垂直居中 五 JavaScript  5.1 JS 学习推荐  5.2 JS 引用方式  5.3 原型与原型链  5.4 作用域与闭包  5.5 浅拷贝与深拷贝  5.6 模块化与组件化  5.7 面向对象与面向过程  5.8 防抖与节流  5.9 ES6  5.10 数组操作 六 Vue  6.1 MVVM  6.2 生命周期  6.3 双向数据绑定  6.4 Virtual DOM  6.5 template 编译  6.6 key  6.7 nextTick  6.8 父子组件通讯 七 微信小程序  7.1 文件主要目录及文件作用  7.2 微信小程序生命周期  7.3 如何封装数据请求  7.4 页面数据传递  7.5 加载性能优化的方法  7.6 微信小程序与原生 APP、Vue、H5 差异  7.7 微信小程序原理 八 浏览器  8.1 浏览器解析 URL  8.2 重绘与回流  8.3 数据存储  8.4 内存管理与垃圾回收  8.5 内存泄漏 九 网络协议  9.1 网络分层  9.2 HTTP/HTTPS  9.3 HTTP 状态码  9.4 TCP 三次握手与四次挥手 十 性能优化  10.1 HTML 优化  10.2 CSS 优化  10.3 JavaScript 优化 十一 算法 十二 其他 十三 总结 十四 参考文献  14.1 关于面试  14.2 关于 HTML  14.3 关于 CSS  14.4 关于 JS  14.5 关于其他 十五 网友反馈 二 前言 返回目录 请时刻准备好自己的简历，不管是互联网经济不佳面临裁员，还是因为公司内部斗争严重心乱如麻，还是因为厌倦了目前的一切……只有随时更新自己，把自己的简历准备好，你才知道哪一刻跑路是最佳选择。 2.1 自我介绍 返回目录 Hello 小伙伴们好，我叫梁峻荣，网名叫 jsliang，由于崇拜前端大佬 技术胖（jspang）的原因，又因为自己学的是前端（JavaScript），所以给自己取了个 jsliang（JavaScriptLiang） 的网名，希望自己能通过建立自己的前端知识体系，从而在前端路上走得更远。并将自己的经验分享给小伙伴，携手小伙伴们一起前行。 下面是讲讲个人故事： 首先，jsliang 高考后的暑期就听大学师兄的建议，开始学习编程，那时候学习了 C 语言，觉得世界上最神奇的事情不过如此，敲两下键盘，按下回车，电脑就会一闪一闪地响应我们！于是在大学的时候，陆陆续续学过 C、C#、.Net 等……。 -_-|| 由于学得都是基础，又都还给老师了，在这里就不多累述了。 然后，在大二就开始接触 HTML，那时候选修了个《网页设计基础》，跟着老师做了个只有几个页面的静态网站。在大三的时候，参加了学校的特训班，分角色按流程从头到尾做了个包含角色管理、购物等功能的网站。同时，由于在特训班的时候，看到后端使用 ThinkPHP（简称 TP），觉得蛮不错的，于是自己捣鼓，使用 TP 3.2.3 + Bootstrap 3 + MySQL 打造了自己的博客（已下线）。 接着，由于选修了门 Node.js 的课，所以也跟着大佬的步伐接触了下 Vue、Koa 这些，那时候对 npm 等诸多不懂，为了折腾这个，我的前端世界自此打开了个大门。 最后，我在自己的毕业设计中使用 Node.js + Vue + ElementUI + MongoDB 打造了个校园外卖、快递代拿等功能的社区单页应用。 在 2018 年 5 月的时候，家里催促，于是直接出来面试。不像其他大佬的毕业等于失业，很幸运地 jsliang 面试第一家就给了 offer，于是就进了这家公司，那时候感觉自己前面的大学生活白过了，只懂 ES5、jQuery、HTML/HTML5、CSS/CSS3 的皮毛。 在熟悉了三个月的业务，公司给的任务能顺利完成后，我觉得自己不够努力：外面的前端翻天覆地，我的技术却只是梭哈 jQuery！ 于是 2018 年 8 月，jsliang 开始写 Markdown，将 5 月份到 8 月份记录到 Word 文档上的笔记整理成了 jsliang 的文档库，并在 jsliang 的掘金 上发表了第一篇文章。 18 年 8 月至今，jsliang 大致经历了以下这些： 学 Webpack，并用 Webpack 构建一个多页面配置。然后幸运的是，刚好碰到公司的一个仿站任务，于是整个前端小组直接用了我的 Webpack + jQuery + VS Code 的 Live Share 套路进行协同开发！ 学 微信小程序，并将它应用到电信开发的微信小程序项目翼小微中。 学 ECharts 报表，并用它做了个 Vue + ECharts 的报表，来展示爱音乐公司的运营数据。 学 Node，然后搭了个企业网站（http://company.jsliang.top），并写了篇小文章（目前最高成就，获得了 1100 多赞）。 学 Vue，由于之前学的 Vue，在工作上有好多没有，逐渐淡忘了，所以从基础开始，准备写一套《Vue 从 0 到 1》。 以上，就是 jsliang 的编程生涯。 今儿，在这里写写 jsliang 为了跳槽，根据个人想法进行的一些前端面试资料整理，小伙伴们觉得不错的点个赞或者去 GitHub 点个 star，觉得有误请指出，谢谢~ 2.2 跳槽原委 返回目录 马老板曾经说过，跳槽有两个原因： 钱没给到位。 心被委屈了。 首先，如果非要给 jsliang 我自己的跳槽定个位，那肯定是钱没给到位，劳动与产出不成正比。在我 2018 年 5 月入职前，与人事的交谈中了解到每年的 8 月和 2 月可以提薪，当初的技术栈是：HTML、CSS、ES5。 然后，2018 年 6 月到 2019 年 1 月，学习并应用到工作中的技术有： jQuery Webpack JSP 微信小程序 Vue ECharts 其中 2018 年 8 月刚转正，也不敢说自己技术进步很大，也不敢说自己项目贡献很大，为公司谋了多大利益，所以没有提薪想法。 2019 年 1 月底感觉自己项目也做了，凌晨 4/5/6 点的体育西路也看过了，技术也提升了，于是跟人事交谈，期望 2 月能加薪，人事表示年终述职演讲得好的给提薪，2 月开工的时候表示提薪名单没我份…… 你没看错，提薪全靠 PPT。PPT 里提高了不给，没提就是没有。当初想法很简单，你随便加个 5/600 我也满足了。 最后，jsliang 曾跟项目总监私下谈话，建议可以发展一些新产品，这样公司或许能获取一些新收入，我也可以进一步挑战我的技术。但是，由于我司是个老牌子公司，并且大部分依赖于接手电信项目进行扩张…… enm...所以心也委屈了。 在 2018 的努力下，GitHub 破 600 近 700 star，掘金破 10 万阅读量，3000 粉丝：GitHub 见证：点击查看掘金见证：点击查看 2.3 进击目标 返回目录 目标城市：广州 目标薪资：10K - 15K 目标技术： 1. 熟悉 HTML/HTML5、CSS/CSS3、ES5/ES6。 2. 了解 OOP 概念，并尝试在工作中使用过 OOP 技巧。 3. 对 MVC/MVVM 架构有一定了解，如有 Vue/React/Angular 或者 微信小程序开发经验更佳。 4. 使用过 Bootstrap 或者 ElementUI 等 UI 库，并对前端 UI 库有一定的个人理解。 5. 了解 Git、Webpack 等工具。 6. 对 Java、Node.js 等后端编程有一定了解。 7. 一年及以上工作经验。 广州前端分析： 广州 13K 薪资要求： 2/3 年工作经验。 熟悉 OOP，并能在工作中使用，且能独立开发插件等…… 你可以不懂 Vue，但 React 你必须得会！ 广州 15k+ 薪资要求： 5 年+ 工作经验。 全能，懂前端，熟悉后端，能写文档…… 带领过小队进行开发。 广州异常偏科公司： 要求必须懂后端。 要求必须懂安卓或者 IOS 开发。 要求必须精通 jQuery 全家桶(jQuery UI、jQuery Mobile 等……)。 该分析数据来自 Boss 直聘 2.4 开篇点题 返回目录 本文的知识点将涉及 HTML、CSS、JS、HTTP、Vue、Webpack、打包工具、性能优化等，没有前置条件，看得懂可以瞅瞅复习下，看不懂可以瞅瞅学习下。 关于面试，在这记下慕课网视频看到的，个人非常认同的三个问答： 问：拿到一个面试题，第一时间看到什么？ 答：考点 问：如何看待网上搜出来的永远看不完的题海？ 答：不变应万变 问：如何对待面试题？ 答：题目到知识再到题目 然后在复习面试题的过程中，个人有些小看法： 个人感言一：为什么我总是比不上别人优秀？ 当编写业务代码中，碰到某个业务 bug 时，我会习惯性地百度这个业务 bug，看看网友是怎么解决的。但是，学霸级的程序猿，会多走一步，他们会思考产生这个业务 bug 的底层原因是什么，下次碰到类似的是如何应用该技术解决。所以，日积月累，我的确比不上人家了。 个人感言二：辞职并不是件便捷的事。 way 1：面试成功，跟自己公司递辞呈，走流程，同时跟对面 hr 申请一个月后入职。 way 2：面试成功，跟自己公司递辞呈，询问能不能快速离职，收到回复跟对面 hr 确认时间。【推荐】 way 3：先递辞呈，同时面试，面试成功的，一律申请走完原公司一个月的流程之后的日子入职。 jsliang 于 2 月底拿到 offer 并递交辞呈，3 月 - 4 月进入一个月倒计时，4 月第一周才能拿到离职证明。 最后在这里祝各位小伙伴能找到称心如意的工作~ 三 HTML 返回目录 HTML 属于结构层，负责描绘出内容的结构。 CSS 属于表示层，负责如何显示有关内容。 JavaScript 属于行为层，负责内容应如何对事件做出反应。 3.1 HTML 学习推荐 返回目录 《前端工程师手册》 《HTML 教程- (HTML5 标准) - 菜鸟教程》 3.2 HTML 语义化 返回目录 语义化的含义就是用正确的标签做正确的事情，HTML 语义化就是让页面的内容结构化，它有如下优点： 便于对浏览器、搜索引擎解析； 便于盲人浏览网页； 便于阅读源代码的人对网站进行分开，维护和理解； 简单来说，能用 、 等 H5 新标签的就不用 ，不要使用 来存放段落等…… 3.3 HTML5 新标签 返回目录 HTML5 中新增标签大致有：、、、、、、等等。 3.4 常见浏览器及其内核 返回目录 Chrome Firefox Safari IE Opera 排版引擎 Blink Gecko Webkit Trident Blink JS 引擎 V8 SpiderMonkey Nitro Chakra V8 国内一些浏览器使用较多的是 Webkit 内核。 针对不同浏览器内核，HTML 辨别： IE 内核浏览器识别： 非 IE 内核浏览器识别： 针对不同浏览器内核，CSS 辨别： /* 设置文字不可选取 */ * { -moz-user-select: none; /* 火狐 浏览器 */ -webkit-user-select: none; /* Webkit 浏览器 */ -o-user-select: none; /* Opera 浏览器 */ -ms-user-select: none; /* IE10 浏览器 */ -khtml-user-select: none; /* 早期浏览器 */ user-select: none; /* 默认 */ } 3.5 cookies、session、sessionStorage、localStorage 返回目录 cookies：存储于浏览器端的数据。可以设置 cookies 的到期时间，如果不设置时间，则在浏览器关闭窗口的时候会消失。 session：存储于服务器端的数据。session 存储特定用户会话所需的属性和配置信息。 cookies 和 session 的区别在于： cookies 数据存放在客户的浏览器上，session 数据存放在服务器上。 前端都是裸君子，没有安全可言，cookies 可能会被黑客利用作数据欺骗。所以重要信息记得存 session。 session 如果在生效期内量过大，会占用服务器性能。 单个 cookies 保存的数据不能超过 4 K，很多浏览器限制一个站点保存最多 20 个 cookies。 sessionStorage：生命周期存在于标签页或窗口，用于本地存储一个会话（session）中的数据，这些数据会随着窗口或者标签页的关闭而被清空。 localStorage：生命周期是永久的，除非用户主动清除浏览器上存储的 localStorage 信息，否则它将会永久存在。 sessionStorage 和 localStorage 操作方法：setItem、getItem 以及 removeItem。 以 localStorage 为例： localStorage.getItem('name'); // 获取 name 的值 localStorage.setItem('name', 'jsliang'); // 设置 name 的值为 jsliang localStorage.removeItem('name'); // 删除 name 的值 参考 1：《前端分享之cookie的使用及单点登录》参考 2：《Cookie、session和localStorage、以及sessionStorage之间的区别》 四 CSS 返回目录 HTML 属于结构层，负责描绘出内容的结构。 CSS 属于表示层，负责如何显示有关内容。 JavaScript 属于行为层，负责内容应如何对事件做出反应。 4.1 CSS 学习推荐 返回目录 《前端工程师手册》 《CSS 权威指南》 《CSS 揭秘》 《CSS 世界》 4.2 CSS reset 返回目录 在工作的过程中，会发现各式各样的浏览器对某个标签有自己独特的样式。 但是在前端开发中，如果不采用统一标准，那么会产生千奇百怪的 bug。所以为了减少后期 bug 的出现，前端开发人员会重置一遍 CSS 样式，尽可能地使开发的网页在各个浏览器相差不大。 下面是 jsliang 在使用的样式重置，当然如果小伙伴有不同的想法，可以去 百度/必应/google 搜索并使用其他版本的样式重置： jsliang 的 CSS 样式重置 4.3 CSS 盒模型 返回目录 在工作的过程中，也许小伙伴需要 div 块的总宽度为 100px，然后发现总是被 margin 撑高，这是因为盒模型定义的问题： CSS 中有个属性叫 box-sizing。 box-sizing: border-box box-sizing: content-box border-box 中，整个 div 的宽、高，包括 margin、padding、border。 content-box 中，整个 div 的宽、高，则不包括上面元素。 如上图，如果一个 div ，你的代码如下： div { box-sizing: border-box; margin: 10px; width: 100px; height: 100px; padding: 10px; } 那么，你的整个宽高还是 100px。 但是，如果你的代码如下： div { box-sizing: content-box; margin: 10px; width: 100px; height: 100px; padding: 10px; } 那么，你的整个盒子宽高是 120px。 如果你在设计页面中，发现内容区被撑爆了，那么，请检查下现在的 border-box 是什么，最好在引用 reset.css 的时候，就对 border-box 进行统一设置，方便管理。 4.4 CSS 单位 返回目录 在 CSS 中，除了我们常用的 px，还有其他单位小伙伴们可以了解一下： 单位 描述 % 百分比 px 像素。计算机屏幕上的一个点为 1px。 em 相对单位。相对于父元素计算，假如某个 p 元素为 font-size: 12px，在它内部有个 span 标签，设置 font-size: 2em，那么，这时候的 span 字体大小为：12 * 2 = 24px rem 相对单位。相对于根元素 html 的 font-size，假如 html 为 font-size: 12px，那么，在其当中的 div 设置为 font-size: 2rem，就是当中的 div 为 24px。 rpx 微信小程序相对单位。1rpx = 屏幕宽度 / 750 px。在 750px 的设计稿上，1rpx = 1px。 除此之外还有 pt、ex 等单位，但由于不太好换算，故在此不提。 4.5 CSS 选择器 返回目录 选择器是匹配元素的一种模式。 关于 CSS 解析器： HTML 经过解析生成 DOM Tree；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。 Render Tree 中的元素与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。 在建立 Render Tree 时，浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。 CSS 解析顺序 在 CSS 的选择器中，它会按照优先级 从右向左解析，因为这样匹配元素的时候，能尽量少地查找，所以选择器最好写地简洁一点。 CSS 常用选择器 通配符：* ID 选择器：#ID 类选择器：.class 元素选择器：p、a 等…… 后代选择器：p span、div a 等…… 伪类选择器：a:hover 等…… 属性选择器：input[type=\"text\"] 等…… 子元素选择器：li:firth-child、p:nth-child(1) 等…… CSS 选择器权重 !important -> 行内样式 -> #id -> .class -> 元素和伪元素 -> * -> 继承 -> 默认 4.6 CSS 常见布局 返回目录 水平垂直居中。这种布局老生常谈，jsliang 在本文也有提到，详解请 点击链接 两列布局。一侧固定，另一侧自适应。 Two Column Layout .container { display: flex; } .child-one { width: 300px; height: 300px; background: red; } .child-two { width: 100%; height: 300px; background: deepskyblue; } 三列布局。类似于两列布局，新增多一个固定宽的 块而已。当然，小伙伴们可能会说：jsliang 你要考虑 flex 的兼容性啊！enm...支持所有最新版本的浏览器！请更新你的浏览器哦亲~ 避免被寄刀片，附上 float 布局：《css常见布局》 4.7 CSS3 新特性 返回目录 经典：CSS3 相关属性你了解吗，说说都有哪些？能说说你工作中常用的一些 CSS3 属性吗？ 那么，CSS3 新特性都有哪些呢？ transition：过渡 transform：旋转、缩放、移动或者倾斜 animation：动画 gradient：渐变 shadow：阴影 border-radius：圆角 为了方便记忆，咱将它们扔到同一个 HTML 文件上，小伙伴拷贝到本地上打开，可以看到一个拥有渐变的小球，做着横向运动，如果你鼠标移动到它上面，它的宽度会放大，并且进行倾斜。 CSS3 新特性 div { width: 100px; height: 100px; border-radius: 50px; background: linear-gradient(red, orange); box-shadow: 10px 10px 5px #888888; position: relative; transition: width 2s; animation: mymove 5s infinite; } div:hover { width:300px; transform: rotate(7deg); } @keyframes mymove { from { left: 0px; } to { left: 200px; } } 参考 1：《CSS3 圆角》参考 2：《CSS3 渐变（Gradients）》参考 3：《CSS3 transition 属性》参考 4：《CSS3 transform 属性》参考 5：《CSS3 animation（动画） 属性》参考 6：《CSS3 box-shadow 属性》参考 7：《个人总结（css3新特性）》 4.8 BFC 返回目录 什么是 BFC？ BFC 就是 块级格式上下文，它是一个独立的渲染区域，让处于 BFC 内部的元素和外部的元素相互隔离，使内外元素的定位不会相互影响。 一定的 CSS 声明可以生成 BFC，浏览器对生成的 BFC 有一系列的渲染规则，利用这些渲染规则可以达到一定的布局效果。 为什么需要 BFC 呢？ 它可以防止 margin 元素重叠（div 中包含 ul，而 div 与 ul 之间的垂直距离，取决于 div、ul、li 三者之间的最大外边距，这时候给 ul 一个 display:inline-block 即可解决这个问题） 清除内部浮动（div 中包含 ul，而 ul 采用 float:left，那么 div 将变成一长条，这时候给 div 加上规则使其变成 BFC 即可） 如何产生 BFC？ display: inline-block position: absolute/fixed 工作中一般可能不会顾及这个： float 很少使用了，尽可能使用 flex css reset 一般会清除掉一些问题，减少 BFC 的使用。 参考文献：《我对BFC的理解》 返回目录 4.9 行内元素和块级元素 返回目录 行内元素：宽度和高度由内容决定，与其他元素共占一行的元素，我们将其叫行内元素。例如：、、 等…… 块级元素：默认宽度由父容器决定，默认高度由内容决定，独占一行并且可以设置宽高的元素，我们将其叫做块级元素。例如：、、 等…… 在日常开发中，我们经常使用 CSS 的 display 属性来打破两者的壁垒：display: inline-block，使它们拥有更多的状态。 4.10 行内样式、内嵌式、链接式以及导入式 返回目录 在引用 CSS 上，分为四种形式：行内样式、内嵌式、链接式以及导入式，下面介绍这四种模式。 行内样式 直接对 HTML 的标记使用 style 属性，然后将 CSS 代码直接写进去： 内嵌式 将 CSS 写 与 之间，并且用 和 标记进行声明： p { color: #fff; background: deepskyblue; } 链接式 通过将 上的 CSS 提起到指定的 CSS 文件上，然后通过 的方式在 HTML 上链接起来。 导入样式 @import url(reset.css); 各种方式的优先级 在优先级上，行内样式 > 链接式 > 内嵌式 > @import 导入式。 4.11 水平垂直居中 返回目录 什么是 Flex 布局？ Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 Flex 布局有哪些便利 /* 设置 Flex 模式 */ display: flex; /* 决定元素是横排还是竖着排，要不要倒序 */ flex-direction: column; /* 决定元素换行格式，一行排不下的时候如何排 */ flex-wrap: wrap; /* flex-flow = flex-direction + flex-wrap */ flex-flow: column wrap; /* 同一排下对齐方式，空格如何隔开各个元素 */ justify-content: space-between; /* 同一排下元素如何对齐，顶部对齐、中部对齐还是其他 */ align-items: center; /* 多行对齐方式 */ align-content: space-between; 如何通过 Flex 实现元素水平垂直居中？ HTML CSS .container { margin: 0 auto; width: 300px; height: 200px; background: deepskyblue; display: flex; /* 实现元素水平居中 */ justify-content: center; /* 实现元素垂直居中 */ align-items: center; } .child { width: 100px; height: 100px; background: #fff; } 除了 Flex，还能使用其他形式进行水平垂直居中吗？ HTML CSS .container { position: relative; width: 300px; height: 200px; background: pink; margin: 0 auto; } .child { position: absolute; width: 100px; height: 100px; top: 50%; left: 50%; /* 下面两种方式均可 */ /* margin-top: -50px; margin-left: -50px; */ transform: translate(-50%, -50%); background: #fff; } 除此之外再谈谈 CSS 水平居中或者垂直居中？ 水平居中： 行内元素：display: inline-block; text-align: center; 块级元素：margin: 0 auto; Flex：display: flex; justify-content: center; 垂直居中： 行高 = 元素高：line-height: height Flex：display: flex; align-items: center; 参考文献：① 《CSS实现垂直居中的常用方法》② 《CSS 用 position: absolute 与 transform 来居中块级元素的问题》 五 JavaScript 返回目录 HTML 属于结构层，负责描绘出内容的结构。 CSS 属于表示层，负责如何显示有关内容。 JavaScript 属于行为层，负责内容应如何对事件做出反应。 5.1 JS 学习推荐 返回目录 《JavaScript 高级程序（第三版）》 《你不知道的 JavaScript》 《JavaScript 忍者秘籍》 《ES6 标准入门》—— 阮一峰 《JavaScript 设计模式》—— 张容铭 《JavaScript 设计模式与开发实践》—— 曾探 5.2 JS 引用方式 返回目录 行内引入： 点击我 内部引入： window.onload = function() { alert(\"js 内部引入！\"); } 外部引入： 注意： 不推荐写行内或者在 HTML 中插入 ，因为浏览器解析顺序缘故，如果解析到死循环之类的 JS 代码，会卡住页面。 建议在 onload 事件之后，即等 HTML、CSS 渲染完毕再执行代码。 5.3 原型与原型链 返回目录 关于 prototype、__proto__、new、call()、apply()、bind()、this 这些的知识点，由于篇幅太长，jsliang 已经抽离了出来，并做了简洁详细讲解，详见： 面试知识点 - JS 原型与原型链 下面放出相关知识点： 实例的 __proto__ 属性（原型）等于其构造函数的 prototype 属性。 Object.proto === Function.prototype Function.prototype.proto === Object.prototype Object.prototype.proto === null 5.4 作用域与闭包 返回目录 在 JS 中，最容易混淆的就是作用域的情况。 在传统的后端语言（例如 C 语言）中，一对花括号 {} 就是一个块级作用域，作用域内变量不会相互影响，但是在 JS 中，像 if 条件语句的 {} 就不算一个独立的作用域： var x = 1; console.log(x); // 1 if(true) { var x = 2; console.log(x); // 2 } console.log(x); // 2 所以有时候我们就需要变通，通过自执行函数创建临时作用域： function foo() { var x = 1; console.log(x); // 1 if(x) { (function(x) { console.log(x); // 1 var x = 2; console.log(x); // 2 })(x) } console.log(x); // 1 } foo(); 说到创建临时作用域，我们就不得不谈一下闭包。 那么，什么是闭包呢？ 闭包简单定义：函数 A 里面包含了 函数 B，而 函数 B 里面使用了 函数 A 的变量，那么 函数 B 被称为闭包。 又或者：闭包就是能够读取其他函数内部变量的函数 function A() { var a = 1; function B() { console.log(a); } return B(); } 闭包经典问题：现在我们有一段代码： for(var i = 0; i 请问这段代码输出什么？ 答案：3 个 3。解析：首先，for 循环是同步代码，先执行三遍 for，i 变成了 3；然后，再执行异步代码 setTimeout，这时候输出的 i，只能是 3 个 3 了。 那么，我们有什么办法依次输出 0 1 2 么？ 使用 let： for(let i = 0; i 在这里，每个 let 和代码块结合起来形成块级作用域，当 setTimeout() 打印时，会寻找最近的块级作用域中的 i，所以依次打印出 0 1 2。 如果这样讲不明白，我们可以执行下下面这段代码： for(let i = 0; i 此时浏览器依次输出的是： 定时器外部：0 定时器外部：1 定时器外部：2 0 1 2 即代码还是先执行 for 循环，但是当 for 结束执行到了 setTimeout 的时候，它会做个标记，这样到了 console.log(i) 中，i 就能找到这个块中最近的变量定义。 使用立即执行函数解决闭包问题 for(let i = 0; i 以上，我们就讲解完了闭包及解决闭包的方式。 观点 1：有些资料表示闭包中产生的大量局部变量，会造成内存消耗过大，从而造成网页的性能问题。观点 2：有些资料表示目前浏览器引擎都基于 V8，而 V8 引擎有个 gc 回收机制，不用太过担心变量不会被回收。提示：所以，如果你觉得不够保险，那就在退出函数之前，将不使用的局部变量全部删除。 5.5 浅拷贝与深拷贝 返回目录 什么是深拷贝？什么是浅拷贝？ 简单来说，有两个对象 A 和 B，B = A，当你修改 A 时，B 的值也跟着发生了变化，这时候就叫浅拷贝。如果不发生变化，就叫深拷贝。 为什么会出现深拷贝与浅拷贝？ 首先我们需要知道基本数据类型（number、string、boolean、null、undefined）与引用数据类型（无序对象，数据以及函数）。 然后在基本数据类型中，例如：let a = 1; let b = a; a = 2; console.log(b)。当我们尝试这样子写时，b 在栈内存中开辟了一个新内存，所以 b 的值不会改变，仍是 1. 接着在引用数据类型中，例如 let a = [1, 2, 3], b = a; a[0] = 3; console.log(b)。当我们尝试这样子写时，b 会偷懒，引用跟 a 同一块的内存地址，从而 a 的修改会影响 b，使得 b 变成 [3, 1, 3]。 最后，我们可以知道在引用数据类型中，会产生浅拷贝的问题。 如何实现深拷贝？ 首先我们尝试使用递归去解决深拷贝： function deepClone(obj) { let objClone = Array.isArray(obj) ? [] : {}; if(obj && typeof obj === \"object\") { for(key in obj) { if(obj.hasOwnProperty(key)) { // 判断 obj 子元素是否为对象，如果是，递归复制 if(obj[key] && typeof obj[key] === \"object\") { objClone[key] = deepClone(obj[key]); } else { // 如果不是，简单复制 objClone[key] = obj[key]; } } } } return objClone; } let a = [1, 2, 3, 4]; let b = deepClone(a); a[0] = 2; console.log(a, b); // Console // a = [2, 2, 3, 4]; // b = [1, 2, 3, 4]; 使用 JSON 对象的 parse 和 stringify 注意：采用 JSON 进行的深拷贝，无法拷贝到 undefined、function、symbol 这类数据，它是有小 bug 的深拷贝。 function deepClone(obj) { let _obj = JSON.stringify(obj); let objClone = JSON.parse(_obj); return objClone } let a = [0, 1, [2, 3], 4]; let b = deepClone(a); a[0] = 1; a[2][0] = 1; console.log(a, b); // Console // a = [1, 1, [1, 3], 4]; // b = [0, 1, [2, 3], 4]; 5.6 模块化与组件化 返回目录 在前端发展中，随着前后端分离，前端社区的不断壮大，前端能做的事情越来越多，承受的任务越来越重，代码也就越来越长了。就好比 jsliang 个人使用 jQuery 开发的时候，动不动就上千行代码，这在一个编辑器上看起来就有点乱了。如果碰上没有代码折叠的编辑器，你就更加难受了。 有的小伙伴的编辑器不是 VS Code，也不能进行代码折叠 所以，面对越来越多的代码，我们就急需将这些代码分门别类，将代码按功能划分，将同一功能的代码整合在一起，于是就有了模块化开发：一个文件就是一个模块，当我们需要某个文件的时候，我们只需要引用这个模块即可…… 首先，是 CommonJS 的提出，在 Node.js 以及 Webpack 都支持 CommonJS，它规定了一个文件就是一个模块，文件内部定义的变量属于这个模块，不会对外暴露从而污染全局变量的规则。在 CommonJS 中，通过 exports 或者 module.exports 进行导出，通过 require 进行 同步加载 所需要依赖的模块。由于它是同步加载模块的形式，所以比较通用于服务器端。 然后，根据 CommonJS 只能同步加载的问题，AMD 根据浏览器的特性，进行了非同步加载模块的提出。同时，AMD 有个问题，就是在使用 require.js 的时候，必须提前加载所有模块。 接着，根据 AMD 的问题，CMD 提出来了：通过按需加载的形式，哪里需要就调用哪里，而不用等到所有的模块都加载了再解析。 最后，ECMA 国际推出了 ES6 的 modules。在 ES6 中，通过 export 关键字导出模块，通过 import 关键字引用代码。当然，由于浏览器厂商诸多，ES6 在浏览器的尚不支持，目前主流做法是先将 ES6 通过 babel 编译成 require。 当然，JS 都进行模块化了，jsliang 想起自己项目中的那一坨 CSS，真心没有回顾的想法！所以我们还需要知道为了方便管理 CSS，大佬们还是有做事儿的：Less 以及 Sass，这两者使 CSS 的编写更有组织性和目的性了。 说起模块化，我们又可以顺带提及组件化了，一开始为了区分这两者，jsliang 也是百度了大量文章，最后成功把自己整蒙了，还是说说感觉可以的解释： 组件化更关注的是 UI 部分：弹出框、头部，内容区、按钮等，都可以编写成组件，然后在适用的地方进行引用。而模块化更侧重于功能或者数据的封装，比如全局的 JSON 配置文件，比如通用的验证方法，比如规范时间戳等。 所以，说到这里，我们就可以提到前端工程化：将整个开发流程就行工程规划，从而提高整个团队的开发效率。 在前端工程化中，最重要的就是提高整个团队在 编码 -> 测试 -> 维护 这三个阶段的生产效率。团队的协调至关重要，将每个任务细分给各个成员，从而获取极致的工作效率，是管理者最喜欢看到的。而在上面的模块化和组件化的应用，就属于前端工程化中的一部分，其目的就是在一些复杂的项目中，方便团队进行合作开发，提高生产效率。 参考文献：① 《到底什么是前端工程化、模块化、组件化》② 《【前端工程化系列】简谈前端模块化开发与开发规范》③ 《个人关于模块化的理解》④ 《组件化开发和模块化开发概念辨析》⑤ 《JavaScript模块化 --- Commonjs、AMD、CMD、es6 modules》⑥ 《浅谈什么是前端工程化》 5.7 面向对象与面向过程 返回目录 什么是面向过程与面向对象？ 面向过程就是做围墙的时候，由你本身操作，叠第一层的时候：放砖头，糊水泥，放砖头，糊水泥；然后第二层的时候，继续放砖头，糊水泥，放砖头，糊水泥…… 面向对象就是做围墙的时候，由他人帮你完成，将做第一层的做法抽取出来，就是放砖头是第一个动作，糊水泥是第二个动作，然后给这两个动作加上步数，最后告诉机器人有 n 层，交给机器人帮你工作就行了。 为什么需要面向对象写法？ 更方便 可以复用，减少代码冗余度 高内聚低耦合 简单来说，就是增加代码的可复用性，减少咱们的工作，使代码更加流畅。 手写个面向对象代码？ function Person(name, phone) { this.name = name; this.phone = phone; this.eat = function() { console.log(name + \" 吃饭\"); } return this; } let p1 = new Person(\"jsliang\", \"18818881888\"); console.log(p1.name); // jsliang p1.eat(); // jsliang 吃饭 当然，jsliang 只能写到这里了，再写下去就是设计模式等知识点了。 所以希望小伙伴们还是了解下面向对象思想，有助于进一步提升自己。 5.8 防抖与节流 返回目录 关于 防抖与节流，jsliang 特意将资料结合起来： 防抖与节流 重绘与回流 浏览器解析 URL DNS 域名解析 TCP 三次握手与四次挥手 浏览器渲染页面 小伙伴们可以前往 《面试知识点 - JS 防抖与节流》 查看。 5.9 ES6 返回目录 ES6 是个大知识点，如果你面试的公司不是 “饱经沧桑” 的那种，那么一定会出点 ES6 问题，例如： 说说 let、var、const 区别 讲讲 Promise 及其使用 因为 jsliang 感觉自己连 ES6 的门还没进，所以在这里就不 自作聪明，推荐下阮一峰大佬的教程： 《ECMAScript 6 入门 - 阮一峰》 希望小伙伴们看完能有所收获，并在工作中大量使用。 5.10 数组操作 返回目录 在 JavaScript 中，用得较多的之一无疑是数组操作，这里过一遍数组的一些用法： map: 遍历数组，返回回调返回值组成的新数组 forEach: 无法break，可以用try/catch中throw new Error来停止 filter: 过滤 some: 有一项返回true，则整体为true every: 有一项返回false，则整体为false join: 通过指定连接符生成字符串 push / pop: 末尾推入和弹出，改变原数组， 返回推入/弹出项【有误】 unshift / shift: 头部推入和弹出，改变原数组，返回操作项【有误】 sort(fn) / reverse: 排序与反转，改变原数组 concat: 连接数组，不影响原数组， 浅拷贝 slice(start, end): 返回截断后的新数组，不改变原数组 splice(start, number, value...): 返回删除元素组成的数组，value 为插入项，改变原数组 indexOf / lastIndexOf(value, fromIndex): 查找数组项，返回对应的下标 reduce / reduceRight(fn(prev, cur)， defaultPrev): 两两执行，prev 为上次化简函数的return值，cur 为当前值(从第二项开始) 相信小伙伴在工作中耍的已经是一套一套的了，或者像 jsliang 一样只会简单的使用 push、map 这几个，感兴趣的小伙伴可以 百度/bing/google 找找一些 奇技淫巧，说不定对工作效率有很大提升~ 六 Vue 返回目录 推荐： 技术胖 慕课网 6.1 MVVM 返回目录 在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互时双向的，因此 View 数据会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需要关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 M - Model。Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑。 V - View。View 代表 UI 组件，它负责将数据模型转化为 UI 展现出来。 VM - ViewModel。ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View。 6.2 生命周期 返回目录 请大致讲下 Vue 的生命周期？ 创建前/后：在 beforeCreated 阶段，Vue 实例的挂载元素 $el 和数据对象 data 以及事件还未初始化。在 created 阶段，Vue 实例的数据对象 data 以及方法的运算有了，$el 还没有。 载入前/后：在 beforeMount 阶段，render 函数首次被调用，Vue 实例的 $el 和 data 都初始化了，但还是挂载在虚拟的 DOM 节点上。在 mounted 阶段，Vue 实例挂载到实际的 DOM 操作完成，一般在该过程进行 Ajax 交互。 更新前/后：在数据更新之前调用，即发生在虚拟 DOM 重新渲染和打补丁之前，调用 beforeUpdate。在虚拟 DOM 重新渲染和打补丁之后，会触发 updated 方法。 销毁前/后：在执行实例销毁之前调用 beforeDestory，此时实例仍然可以调用。在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 Vue 实例已经解除了事件监听以及和 DOM 的绑定，但是 DOM 结构依然存在。 什么是 Vue 生命周期？ Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载 DOM -> 渲染、更新 -> 渲染、销毁等一系列过程，称之为 Vue 的生命周期。 Vue 有几个生命周期，它们的作用主要是什么？ 8 个，创建前/创建后、挂载前/挂载后、更新前/更新后、销毁前/销毁后。Vue 生命周期的作用是方便我们通过它的生命周期，在业务代码中更好地操作数据，实现相关功能。 第一次页面加载会触发 Vue 哪几个钩子？ 会触发 4 个生命钩子：创建前/创建后、挂载前/挂载后 DOM 渲染在哪个周期就已经完成？ 在 beforeMounted 时它执行了 render 函数，对 $el 和 data 进行了初始化，但此时还是挂载到虚拟的 DOM 节点，然后它在 mounted 时就完成了 DOM 渲染，这时候我们一般还进行 Ajax 交互。 6.3 双向数据绑定 返回目录 Vue 采用 数据劫持 结合 发布者-订阅者 模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter 以及 getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 第一步：需要 Observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。 第二步：Compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新数据。 第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情有： 在自身实例化时往属性订阅器（dep）里面添加自己。 自身必须有一个 update() 方法 待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。 第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的桥梁，达到数据变化 -> 视图更新；视图交互变化（input） -> 数据 model 变更的双向绑定效果。 js 实现简单的双向绑定 window.onload = function() { let obj = {}; Object.defineProperty(obj, \"txt\", { get: function() { return obj; }, set: function(newValue) { document.getElementById(\"txt\").value = newValue; document.getElementById(\"show\").innerHTML = newValue; } }) document.addEventListener(\"keyup\", function(e) { obj.txt = e.target.value; }) } Object.defineProperty 接收三个参数：对象，属性名，配置对象这里使用的是 Object.defineProperty，这是 Vue 2.0 进行双向数据绑定的写法。在 Vue 3.0 中，它使用 Proxy 进行数据劫持。 为什么 Vue 3.0 中使用 Proxy 了？ Vue 中使用 Object.defineProperty 进行双向数据绑定时，告知使用者是可以监听数组的，但是只是监听了数组的 push()、pop()、shift()、unshift()、splice()、sort()、reverse() 这八种方法，其他数组的属性检测不到。 Object.defineProperty 只能劫持对象的属性，因此对每个对象的属性进行遍历时，如果属性值也是对象需要深度遍历，那么就比较麻烦了，所以在比较 Proxy 能完整劫持对象的对比下，选择 Proxy。 为什么 Proxy 在 Vue 2.0 编写的时候出来了，尤大却没有用上去？因为当时 es6 环境不够成熟，兼容性不好，尤其是这个属性无法用 polyfill 来兼容。（polyfill 是一个 js 库，专门用来处理 js 的兼容性问题-js 修补器） 参考自《实现双向绑定Proxy比defineproperty优劣如何》 6.4 Virtual DOM 返回目录 Vue 在 render 中 createElement 的时候，并不是产生真实的 DOM 元素，实际上 createElement 描述为 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点。 因此，我们将这样的节点描述为 “虚拟节点”（Virtual Node），简称 VNode。“虚拟 DOM” 是我们对由 Vue 组件树建立的整个 VNode 树的称呼。 作为一枚切图仔，很荣幸地跟小伙伴说：“其实我也不懂 Virtual DOM！” 但是，总会有些面试场合会提到的，所以这里找了几篇资料，小伙伴们可以进一步学习： 《Vue原理解析之Virtual Dom》 《virtual-dom(Vue实现)简析》 其他的就需要小伙伴自己寻找了，如果觉得有不错的解析 Virtual DOM 的文档/视频，小伙伴也可以推荐过来哈~ 6.5 template 编译 返回目录 Vue template 编译的理解 Vue 中 template 就是先转化成 AST 树，再得到 render 函数返回 VNode（Vue 的虚拟 DOM 节点）。 通过 compile 编译器把 template 编译成 AST 语法树（abstract syntax tree - 源代码的抽象语法结构的树状表现形式），compile 是 createCompiler 的返回值，createCompiler 是用以创建编译器的。另外 compile 还负责合并 option。 AST 会经过 generate（将 AST 语法树转换成 render function 字符串的过程）得到 render 函数，render 的返回值是 VNode，VNode 是 Vue 的虚拟 DOM 节点，里面有标签名、子节点、文本等待。 6.6 key 返回目录 key 的作用就是在更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的。 对于 diff 过程来说 key 是起不到提速作用的，详见：key 的作用 6.7 nextTick 返回目录 用法：Vue.nextTick( [callback, context] ) 参数： {Function} [callback] {Object} [context] 说明：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 案例： // 修改数据 vm.msg = 'Hello' // DOM 还没有更新 Vue.nextTick(function () { // DOM 更新了 }) // 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示) Vue.nextTick().then(function () { // DOM 更新了 }) 关于 nextTick 的更多理解，jsliang 就不献丑了，需要学习的小伙伴可以查看： 《Vue.nextTick 的原理和用途》 或者自行查找更优秀的资源。 6.8 父子组件通讯 返回目录 关于 Vue 中的父子组件通讯，相信经常开发 Vue 的小伙伴比 jsliang 知道的多很多。 没怎么使用 Vue 的小伙伴可以看下下面的文章，并尝试自己写一写： 《Vue 中关于 $emit 的用法》 下面咱讲下使用 bus.js 实现非父子组件通讯： 假设在工作中，有三个 .vue 文件：A.vue、B.vue、C.vue。A.vue 是主页面，B.vue 和 C.vue 类似于头部导航条和底部导航栏。现在，B.vue 点击会切换路由，C.vue 需要获取 B.vue 传递的信息。 A.vue bus.js import Vue from 'vue'; // 使用 Event Bus const bus = new Vue(); export default bus; B.vue 首页 import bus from '../utils/bus' export default { methods: { goToPage(route) { this.$router.push(route.path); bus.$emit('meta', route.meta); } } } C.vue {{title}} import bus from '../utils/bus' export default { data() { return { title: '' } }, created() { bus.$on('meta', msg=> { this.title = msg; }) } } 七 微信小程序 返回目录 微信小程序，简称小程序，英文名 Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。 7.1 文件主要目录及文件作用 返回目录 - component —————————————————— 组件文件夹 - navBar —— 底部组件 - navBar.js —— 底部组件的 JS 代码 - navBar.json —— 底部组件的配置文件 - navBar.wxml —— 底部组件的 HTML 代码 - navBar.wxss —— 底部组件的 CSS 代码 - pages ————————————————————— 页面文件夹 - index —— 首页 - index.js —— 首页的 JS 代码 - index.json —— 首页的配置文件 - index.wxml —— 首页的 HTML 代码 - index.wxss —— 首页的 CSS 代码 - public ————————————————————— 图片文件夹 - utils —————————————————————— 工具文件夹 - api.js —— 控制 API 的文件 - md5.js —— 工具 - MD5 加密文件 - timestamp.js —— 工具 - 时间戳文件 - app.json ——————————————————— 设置全局的基础数据等 - app.wxss ——————————————————— 公共样式，可通过 import 导入更多 - project.config.json ———————— 项目配置文件 7.2 微信小程序生命周期 返回目录 onLoad()：页面加载时触发。 onShow()：页面显示/切入前台时触发。 onReady()：页面初次渲染完成时触发。 onHide()：页面隐藏/切入后台时触发。 onUnload()：页面卸载时触发。 7.3 如何封装数据请求 返回目录 封装接口： 项目/utils/api.js // 将请求进行 Promise 封装 const fetch = ({url, data}) => { // 打印接口请求的信息 console.log(`【step 1】API 接口：${url}`); console.log(\"【step 2】data 传参：\"); console.log(data); // 返回 Promise return new Promise((resolve, reject) => { wx.request({ url: getApp().globalData.api + url, data: data, success: res => { // 成功时的处理 if (res.data.code == 0) { console.log(\"【step 3】请求成功：\"); console.log(res.data); return resolve(res.data); } else { wx.showModal({ title: '请求失败', content: res.data.message, showCancel: false }); } }, fail: err => { // 失败时的处理 console.log(err); return reject(err); } }) }) } /** * code 换取 openId * @data { * jsCode - wx.login() 返回的 code * } */ export const wxLogin = data => { return fetch({ url: \"tbcUser/getWechatOpenId\", data: data }) } 调用接口： 项目/pages/login/login.js import { wxLogin, } from '../../utils/api.js' 使用接口： 项目/pages/login/login.js wxLogin({ jsCode: this.data.code }).then( res => { console.log(\"【step 4】返回成功处理：\"); console.log(res.data); }, err => { console.log(\"【step 4】返回失败处理：\"); console.log(err); } ) 7.4 页面数据传递 返回目录 通过 url 携带参数，在 onLoad() 中通过 options 获取 url 上的参数： 代码演示 onLoad: function(options) { console.log(options.userId); } 通过 Storage 来传递参数： wx.setStorageSync('userId', 'jsliang'); wx.getStorageSync('userId'); WXML 传递数据到 JS login.wxml 点击传递数据到 JS login.js clickText(e) { console.log(e.currentTarget.labelid) } 组件调用传参 组件接收数据：component-tag-name Component({ properties: { // 这里定义了innerText属性，属性值可以在组件使用时指定 innerText: { type: String, value: 'default value', } } }) 使用组件的页面定义 json { \"usingComponents\": { \"component-tag-name\": \"../component/component\" } } 使用组件的页面 HTML 代码 通过接口调用传递参数 7.5 加载性能优化的方法 返回目录 通过 this.$preload() 预加载用户可能点击的第二个页面。 组件化页面，出现两次以上的部分都进行封装成组件。 提取共用的 CSS 样式。 优化图片：TinyPNG。 7.6 微信小程序与原生 APP、Vue、H5 差异 返回目录 微信小程序优劣势： 优势： 无需下载 打开速度较快 开发成本低于原生 APP 劣势： 限制多。页面大小不能超过 1M，不能打开超过 5 个层级的页面。 样式单一。小程序内部组件已经成宿，样式不可以修改。 推广面窄。跑不出微信，还不能跑入朋友圈。 微信小程序 VS 原生 APP 微信小程序有着低开发成本、低获客成本、无需下载的优势。 微信小程序 VS H5 依赖环境不同。一个能在多种手机浏览器运行。一个只能在微信中的非完整的浏览器。 开发成本不同。一个可能在各种浏览器出问题。一个只能在微信中运行。 微信小程序 VS Vue 微信小程序看似就是阉割版的 Vue。 7.7 微信小程序原理 返回目录 本质上就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面中进行。 架构为数据驱动的模式，UI 和数据分离，所有页面的更新，都需要通过对数据的更改来实现。 微信小程序分为两个部分：webview 和 appService。其中 webview 主要用来展示 UI，appServer 用来处理业务逻辑、数据及接口调用。它们在两个进程中进行，通过系统层 JSBridge 实现通信，实现 UI 的渲染、事件的处理。 八 浏览器 返回目录 8.1 浏览器解析 URL 返回目录 关于 浏览器解析 URL，jsliang 特意将资料结合起来： 防抖与节流 重绘与回流 浏览器解析 URL DNS 域名解析 TCP 三次握手与四次挥手 浏览器渲染页面 小伙伴们可以前往 《面试知识点 - JS 防抖与节流》 查看。 8.2 重绘与回流 返回目录 关于 重绘与回流，jsliang 特意将资料结合起来： 防抖与节流 重绘与回流 浏览器解析 URL DNS 域名解析 TCP 三次握手与四次挥手 浏览器渲染页面 小伙伴们可以前往 《面试知识点 - JS 防抖与节流》 查看。 8.3 数据存储 返回目录 存储于代码中，代码执行完毕释放内存。 存储于浏览器中，cookie 用于短期存储用户身份，登录状态等较小的信息；localStorage 用于长期存储数据，浏览器关闭不影响它们的内存，相比于 cookie，storage 能存储较多；IndexedDB 是浏览器提供的接近于 NoSQL 的数据库，允许存储大量数据。 存储于数据库中。 8.4 内存管理与垃圾回收 返回目录 V8 将内存分为两类：新生代内存空间和老生代内存空间。 新生代内存空间：主要用来存放存活时间较短的对象。 老生代内存空间：主要用来存放存活时间较长的对象。 这两者通过不同的算法，对内存进行管理操作。 8.5 内存泄漏 返回目录 意外的全局变量：无法被回收。 定时器：未被正确关闭，导致所引用的外部变量无法被释放。 事件监听：没有正确销毁（低版本浏览器可能出现）。 闭包：会导致父级中的变量无法被释放。 DOM 引用：DOM 被删除时，内存中的引用未被正确清空。 如何查看内存变化情况？ 使用 Chrome 的 Timeline（新版本 Performance）进行内存标记，可视化查看内存的变化情况，找出异常点。 九 网络协议 返回目录 9.1 网络分层 返回目录 目前网络分层可分为两种：OSI 模型和 TCP/IP 模型。 OSI 模型 应用层（Application） 表示层（Presentation） 会话层（Session） 传输层（Transport） 网络层（Network） 数据链路层（Data Link） 物理层（Physical） TCP/IP 模型 应用层（Application） 传输层（Host-to-Host Transport） 互联网层（Internet） 网络接口层（Network Interface） 更多详情可以查看下面这篇文章，里面讲得非常详细： 《网络分层TCP/IP 与HTTP》 9.2 HTTP/HTTPS 返回目录 HTTP：超文本传输协议（HTTP）是用于分布式，协作式和超媒体信息系统的应用协议。它是Web上数据交换的基础，是一种 client-server 协议，也就是说请求通常是由像浏览器这样的接受方发起的。 HTTPS：HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 它是一个 URI scheme（抽象标识符体系），句法类同 http: 体系。用于安全的HTTP数据传输。https:URL 表明它使用了 HTTP，但 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP 与 TCP 之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 9.3 HTTP 状态码 返回目录 首先，我们大致区分下状态码： 1**开头 - 信息提示 2**开头 - 请求成功 3**开头 - 请求被重定向 4**开头 - 请求错误 5**开头 - 服务器错误 然后，常见的状态码： 200 - 请求成功，Ajax 接受到信息了。 400 - 服务器不理解请求，工作中常见于跨域的时候后端给我报 400！ 403 - 服务器拒绝请求。 404 - 请求页面错误。 500 - 服务器内部错误，无法完成请求。 最后，小伙伴们如果想要了解更多，还是需要自行查找资料的。 9.4 TCP 三次握手与四次挥手 返回目录 关于 TCP 三次握手与四次挥手，jsliang 特意将资料结合起来： 防抖与节流 重绘与回流 浏览器解析 URL DNS 域名解析 TCP 三次握手与四次挥手 浏览器渲染页面 小伙伴们可以前往 《面试知识点 - JS 防抖与节流》 查看。 十 性能优化 返回目录 通过优化从而提高页面的加载速度。 10.1 HTML 优化 返回目录 避免 HTML 中书写 CSS 代码，因为这样难以维护。 使用 Viewport 加速页面的渲染。 使用语义化标签，减少 CSS 代码，增加可读性和 SEO。 减少标签的使用，DOM 解析是一个大量遍历的过程，减少不必要的标签，能降低遍历的次数。 避免 src、href 等的值为空，因为即时它们为空，浏览器也会发起 HTTP 请求。 减少 DNS 查询的次数。 10.2 CSS 优化 返回目录 优化选择器路径：使用 .c {} 而不是 .a .b .c {}。 选择器合并：共同的属性内容提起出来，压缩空间和资源开销。 精准样式：使用 padding-left: 10px 而不是 padding: 0 0 0 10px。 雪碧图：将小的图标合并到一张图中，这样所有的图片只需要请求一次。 避免通配符：.a .b * {} 这样的选择器，根据从右到左的解析顺序在解析过程中遇到通配符 * {} 会遍历整个 DOM，性能大大损耗。 少用 float：float 在渲染时计算量比较大，可以使用 flex 布局。 为 0 值去单位：增加兼容性。 压缩文件大小，减少资源下载负担。 10.3 JavaScript 优化 返回目录 尽可能把 标签放在 body 之后，避免 JS 的执行卡住 DOM 的渲染，最大程度保证页面尽快地展示出来。 尽可能合并 JS 代码：提取公共方法，进行面向对象设计等…… CSS 能做的事情，尽量不用 JS 来做，毕竟 JS 的解析执行比较粗暴，而 CSS 效率更高。 尽可能逐条操作 DOM，并预定好 CSS 样式，从而减少 reflow 或者 repaint 的次数。 尽可能少地创建 DOM，而是在 HTML 和 CSS 中使用 display: none 来隐藏，按需显示。 压缩文件大小，减少资源下载负担。 十一 算法 返回目录 在算法这块，jsliang 觉得自己还是比较薄弱的，如果小伙伴们跟 jsliang 一样，也想丰富下这方面知识，欢迎一起刷 LeetCode 共同进步： LeetCode 十二 其他 返回目录 在 【其他】 这章，原本 jsliang 想谈谈面试中的一些小技巧，例如谈薪；或者讲讲 HR 面需要询问的问题，例如工作时长、加班机制、调薪机制等…… 但是，最终看来，jsliang 的经历还是有所欠缺，所经历的面试不够 “盛大”，所以说出的话可能就是 “胡言乱语”、“误导观众”，故在此就不献丑了，如果小伙伴们想知道更多，可以通过 QQ 群：798961601 找到我。 ☆ 目前 jsliang 通过 3 天的请假，去了 5 场面试，收获了 3 份 offer。☆ 如果小伙伴不知道简历该怎么写、面试总是镇静不下来、总感觉面试没谱，可以先找 jsliang 聊聊，我会讲讲个人的面试经历，以及听到的其他小伙伴的经历~ 十三 总结 返回目录 在观看这篇文章的过程中，小伙伴可能会有这些疑问： 看完觉得不过瘾啊！你怎么就这么 “短” 啊？ 回答： 系列套餐你值得拥有！ 2019 面试实战 - Round One 2019 面试实战 - Round Two 2019 面试实战 - Round Three 面试知识点 - JS 原型与原型链 面试知识点 - JS 防抖与节流 面试知识点 - 图片 你这杂七杂八的都写了什么呀？看完我晕乎了！ 回答： 每个人的学习经历是不同的，所拥有的技术、知识点以及工作经验等都是不同的。 所以 jsliang 的目的是通过这篇文章充实自己的同时，顺带挖掘自己的不足，例如面向对象造轮子、算法问题等让 jsliang 想进一步折腾，并应用到工作中。 因此，小伙伴应该根据自己实际去扩展补充属于自己的知识点。 毕竟了解自己的，只有自己！ 好像你这里写得也不是很全啊？看完我还是一知半解的！ 回答： 每个人的目的都是不同的，不可能一篇文章写完所有知识点，同时有些知识点可能 jsliang 也不感兴趣、或者 jsliang 的层次不够，接触不到。 并且每个面试官都可能有自己的一套面试题，如果 jsliang 能将所有的面试题都写出来，那还需要面试官做啥，大家都像考国家证书一样直接电脑考试吧~（我也期待！！！） 如果小伙伴对文章存有疑问，想快速得到回复。或者小伙伴对 jsliang 个人的前端文档库感兴趣，也想将自己的前端知识整理出来。或者小伙伴对文章后续的更新感兴趣，掌握更多的面试技巧。欢迎加 QQ 群一起探讨：798961601。 十四 参考文献 返回目录 本文中的许多内容，也许小伙伴看了会觉得眼熟，因为它们大部分是 jsliang 参考大量文献，再经过刷选整理，最后根据自己理解后的一些阐述。 下面是个人觉得非常优秀的文章。 14.1 关于面试 返回目录 《一位前端 2018 绝地求生记》 《中高级前端大厂面试秘籍，为你保驾护航金三银四，直通大厂(上)》 《InterviewMap》 《一篇文章搞定前端面试》 《微信小程序必知面试题》 《微信小程序面试题，附答案》 《小程序踩过的那些面试题坑，附答案解决方法》 14.2 关于 HTML 返回目录 《前端工程师手册》 《HTML 教程- (HTML5 标准) - 菜鸟教程》 《前端分享之cookie的使用及单点登录》 《Cookie、session和localStorage、以及sessionStorage之间的区别》 14.3 关于 CSS 返回目录 《前端工程师手册》 《CSS 权威指南》 《CSS 揭秘》 《CSS 世界》 《我对BFC的理解》 《CSS实现垂直居中的常用方法》 《CSS 用 position: absolute 与 transform 来居中块级元素的问题》 《css常见布局》 《CSS3 圆角》 《CSS3 渐变（Gradients）》 《CSS3 transition 属性》 《CSS3 transform 属性》 《CSS3 animation（动画） 属性》 《CSS3 box-shadow 属性》 《个人总结（css3新特性）》 14.4 关于 JS 返回目录 【推荐】《JavaScript - MDN》 《小邵教你玩转ES6》 《小邵教你玩转JS面向对象》 《实现双向绑定Proxy比defineproperty优劣如何》 《Vue 中关于 $emit 的用法》 《JavaScript 世界万物诞生记》 《js中的new()到底做了些什么？？》 《MDN Function.prototype.call()》 《JavaScript中的call、apply、bind深入理解》 《箭头函数 - 廖雪峰》 《ECMAScript 6 入门 - 阮一峰》 《Vue原理解析之Virtual Dom》 《virtual-dom(Vue实现)简析》 《Vue.nextTick 的原理和用途》 14.5 关于其他 返回目录 《前端性能优化最佳实践》 《到底什么是前端工程化、模块化、组件化》 《【前端工程化系列】简谈前端模块化开发与开发规范》 《个人关于模块化的理解》 《组件化开发和模块化开发概念辨析》 《JavaScript模块化 --- Commonjs、AMD、CMD、es6 modules》 《浅谈什么是前端工程化》 《前端分享之cookie的使用及单点登录》 《Cookie、session和localStorage、以及sessionStorage之间的区别》 《网络分层TCP/IP 与HTTP》 十五 网友反馈 返回目录 查看了下掘金评论区，感谢各位大大的反馈，由于本人将于 2019年4月1日 入职，故将一些个人觉得不错的自己没有察觉的知识点记录下来，区分于原文，更为了猴年马月后的下一次跳槽进一步完善。 意思就是，jsliang 这货懒得改原文了，小伙伴们看着这里进行知识点补充 闭包定义： 函数 A 里面包含了 函数 B，而 函数 B 里面使用了 函数 A 的变量，函数 B 被 return 了出去，那么 函数 B 被称为闭包。 box-sizing 属性： 当值为 border-box 时，宽度 width = content + padding + border，包含内边距与边框。 当值为 content-box 时，宽度 width = content，不包含内边距与边框。 em： em 是一个相对的大小，这里的相对于元素父元素的 font-size。 Side Project： Side Project 对应的中文就是副业、业余项目或者小项目。 感兴趣的小伙伴可以去了解一下。 push 与 shift 系列： 这里原文已备注是有误的，只是一时没空，没有修改。 CSS 选择器加载顺序： 原文：!important -> 行内样式 -> #id -> .class -> 元素和伪元素 -> * -> 继承 -> 默认 网友：“应该是最后的优先级最高。” 这里最后的优先级最高应该是指同等级优先级覆盖。浏览器通过 CSSParser 将 CSS 解析成 CSS Rule Tree 的时候，没错的话应该是按照原文中的排序先加载，然后同等级的时候，后面的属性覆盖前面的属性。 ARIA： 对于 HTML5 的语义化，ARIA 的意思是 Accessible Rich Internet Application，aria-* 的作用就是描述这个 Tag 在可视化的情境中的具体信息。例如： aria-label：为组件指定内置的文本标签，用来替代开发者没有使用 标签 aria-labelledby：会读取与此具有相同的 id 名的值 详情可参考张鑫旭的 《WAI-ARIA无障碍网页应用属性完全展示》 sessionStorage 和 localStorage： 文章描述不够详细。 两列布局/三列布局： child-tow 中设置 width: 100% 的时候 child-one 的宽度会随机而变，设置 flex: 1 就不会。所以看个人需求进行设置。 文章中没有讲到应对兼容性怎么设置，可以考虑使用 float 进行相关的布局。 浅拷贝与深拷贝： 可参考文章：《深拷贝的终极探索（90%的人不知道）》 Promise 与 async/await： 文章描述不够详细。 跨域： 本来打算写的，后面没时间，给我删了这块，评论区有篇文献参考： 《九种跨域方式实现原理（完整版）》 以上，即为目前评论区的补充，感谢各位小伙伴的点赞支持。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-21 10:02:29 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Interview/PersonalExperience/2019-PracticalRoundOne.html":{"url":"other-library/Interview/PersonalExperience/2019-PracticalRoundOne.html","title":"✔ 2019 面试实战 - Round One","keywords":"","body":"2019 面试实战 - Round One Create by jsliang on 2019-2-27 18:51:26Recently revised in 2019-3-3 14:42:54 Hello 小伙伴们，如果觉得本文还不错，记得给 jsliang 的文档库点个 star ， 你们的 star 是我学习折腾的动力！GitHub 地址 并不是只有特定的季节才能跑路，只因为人跑得多了，这条路就定下来了。 金三银四跑路季，jsliang 也去尝试了一波，然后写下这篇文章。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 早上 10:00  3.1 Job Description  3.2 一面技术 - 前端架构师  3.3 二面技术 - 技术负责人  3.4 三面个人 - 人事小姐姐  3.5 四面个人 - 项目负责人 四 下午 16:00  4.1 Job Description  4.2 技术一面 - 笔试题考查  4.3 技术二面 - 前端小姐姐  4.4 整体三面 - 项目负责人 五 总结 二 前言 返回目录 请时刻准备好自己的简历，不管是互联网经济不佳面临裁员，还是因为公司内部斗争严重想换份工作，还是因为厌倦了目前的一切……只有随时更新自己，把自己的简历准备好，你才知道哪一刻跑路是最佳选择。 时间：2019-2-27 地点：广州 年限：一年工作经验 薪酬要求：9K - 15K 场次：上午一场，下午一场 感想：非常疲惫，但是感觉很有动力，“没有一家解决不了的，如果有，那就再跑一家！” 三 早上 10:00 返回目录 公司规模：员工 5000 + 行业：电商 面试前：怕广州 3 号线塞车，又觉得这份工作应该不错，于是 7 点就出门，8 点到了这个公司附近，溜达了一圈，感觉附近饭馆比较多，并且离地铁站 5 分钟左右，还是挺不错的。溜达到 9:20，上楼跟前台小姐姐打招呼后，拿到了两份表：一份个人信息表，一个性格测试表（可能大点的公司都考虑你的性格，毕竟团队开发），印象深刻的是性格测试表还有错别字：“坚定” 写成了 “鉴定”。可能我精神比较集中，一下子就看到了，但是 offer 没下来，就没敢跟人事小姐姐吐槽了，免得给人坏印象。 准备完毕：交表，等待面试。 3.1 Job Description 返回目录 薪酬：10K - 15K 岗位职责： 1、独立完成公司中后台项目的前端开发 2、与后端开发一起，确定接口协议 3、独立完成接口文档的编写并组织评审 4、深入解析代码, 提升代码执行效率, 加强代码兼容性 5、对用户交互有深刻理解，能帮助产品优化交互体验 任职要求： 1、有2年以上前端开发经验 2、对各种Web前端技术（JavaScript，CSS，语义化标签等等）有深刻理解； 3、熟悉服务器端Web应用结构，有服务器端脚本语言经验更佳 4、熟悉WEB应用的MVC，MVVM结构 5、英文4级以上 应具备的知识与技能： 1、精通HTML5、CSS3等网页制作技术，熟悉页面架构和Flex布局； 2、精通JavaScript、Ajax等Web开发技术 3、熟练使用ES6,有Reactjs的使用经验； 4、熟练使用Git,Webpack等工具； 5、熟悉W3C标准，对表现与数据分离、Web语义化等有较为深刻的理解； 6、思路清晰，具备良好的沟通能力和团队协作精神，善于学习、总结，乐于分享。 3.2 一面技术 - 前端架构师 返回目录 对话内容如下： 面试官：“你好，我是 *。” 我：“你好。” 面试官：（翻简历） 面试官：“挺不错的嘛，还有个高 star 的项目？” 面试官：（打开手机） 面试官：“账号多少，我能看看么？” 我：“好的，账号 LiangJunrong，你可以去瞅瞅，那个项目主要是我用来写我个人的前端知识体系的。” 面试官：“那你是如何让更多人知道你的？” 我：“我在掘金上有发表文章，然后如果觉得掘金上自己写的某篇文章还过得去的时候，也会在微信、QQ 上发下掘金的链接。” 面试官：“能介绍下这里面，你觉得最有印象的东西吗？” 我：“最有印象么？” 我：（思考） 我：“这里面最有印象的，一个是微信小程序，关于通讯录的做法。是我在 2018 年 10 月份的时候，驻点电信写微信小程序，其中有个联系人模块，因为微信小程序我是边看文档边查阅资料写的，所以那个联系人模块是完全没有其他插件，自己写的。工作上的功能实现是领导满意的，但是下班之余，觉得修改和新增可以更进一步优化①，于是想了下，可以使用二分法来实现修改、新增后跳转到相应的位置。怎么说呢？就是你已经写好了列表后，按②……” ①：关于修改、新增的操作，小伙伴可以打开自己的爪机，试试修改、新增完之后，是不是页面要滚动到操作之后的位置，然后想想如果是自己，会如何实现。 ②：关于微信通讯录的做法，可参考文章 【微信小程序之奇技淫巧】，里面全程分析了简单做法和优化观点。 ……该部分中 jsliang 和面试官还有一些探讨，太长了这里忽略不提…… 面试官：“能介绍下这个侧边栏实现吗？” 我：“假设我需要跳转到 D 桶（前面面试官讲了下分桶），那么，我首先需要知道 A 桶、B 桶、C 桶各有多少条，然后将条数 每条高度，以及字母 A、B、C 的高度，最后想加起来获得需要滚动到的位置。并且我做了兼容，在 IPhone 6、IPhone X 上都能确却滚动到具体位置。*③” ③：需要清楚的是，在 WXSS 中，你写的是 100rpx，在 IPhone 6、IPhone X 上表现的高度是不一致的，需要根据获取的设备比，从而获取到实际每条的高度。 面试官：“你是小程序做的比较多么？” 我：“小程序的话，我做了 2 个月。然后 Vue 的话，我是毕业设计的时候，用了 Vue + Node + MongoDB。然后在 11 月份的时候，用了 Vue + ECharts 做了报表，展示电信的运营数据。” 面试官：“你能介绍下关于 React 的经验么？” 我：（慌）（强行镇定）React 是那时候在公司总部，需要开发新项目，前端大哥说可以考虑换成 React 开发。但是做到一半的时候，我就被调到电信驻点去了， 所以 React 和 Angular 都是看了一点，想实现的时候，中断了。” 面试官：“那你是说单单使用过微信小程序和 Vue 么？” 我：“（慌）额(⊙o⊙)…我使用过 Vue、微信小程序、jQuery。④” ④：这个公司 JD 要求需要 React，并且日常开发也是使用 React 的。 面试官：“那你就是没实际工作用过 React。” 我：“对，是的。” 面试官：“那你介绍下对 Vue 的了解，并使用 Vue 做的事情吧。” 我：“个人感觉的话，在目前前端上，模块化、组件化比较多，有一些东西，例如：头部组件。当我们使用比较多的时候，我们就要抽离出来，组件化它。然后在需要使用的时候，去使用它。然后在 Vue 的使用上，感觉就是拼积木，把你需要的东西拼接起来。然后在 Vue 中，主要三大块：Vue、VueCli、VueRouter、Vuex 数据状态管理。噢，四大块了。” 面试官：“那你能介绍下 Vuex 吗？” 我：“不好意思，Vuex 介绍不了，毕竟现在最多就是写小程序，虽然之前有使用过，但是代码这些东西，您也知道，太久不使用都会忘了。” 面试官：“嗯，那好，你说使用微信小程序比较多，那你能讲讲热更新部分么？” 我：“不好意思，没了解过。” 面试官：“就是说，我小程序上出了非常严重的 bug，但是你知道，提交给微信审核，需要时间，那么我能不能在不提交审核的情况下进行更新。” 我：（思考）“enm...” 面试官：“那么假如就是这种情况了，你有什么想法吗？或者说依你对小程序的理解，尝试解决下这个 bug？” 我：（思考）（自言自语）不好意思真不知道。 面试官：（换话题）“对 ECharts 有什么介绍么？” 我：（微笑）“ECharts 这个的话，感觉就是非常好玩。当然，在数据操作的时候，你要注意一下。” 面试官：“比如？” 我：“比如说有一次在调取接口，做数据循环输出的时候，因为没注意，直接导致整个浏览器崩溃。” 面试官：“因为渲染次数太多了。” 我：“是的。” 面试官：（翻简历）（打开手机） 面试官：“能介绍你这个刮刮奖么？我觉得挺有意思的。⑤” ⑤：【幸运刮刮乐】 —— jsliang 屏蔽敏感部分，发来玩玩的手机页面。 我：“刮刮奖的话，是一次活动制作，然后我找了一个 Canvas 画图的插件做的。” 面试官：“那现在有个问题：我是如何知道它什么时候展开。” 我：“这个是通过面积计算它来展开的。” 面试官：“你是觉得如何实现的呢？” 我：“enm...不太情况。” 面试官：“当初使用的时候，没有看它源码么？” 我：“没有。” 面试官：“你觉得它是如何计算它刮开的面积？” 我：（尴尬）“计算刮开的面积……” 面试官：“你看，这样这样计算……”（提示）（教导） ……中间省略吧，太丑了…… 面试官：“当初你应该看下它源码实现，因为这是个很经典的话题。” 我：“是的，当初我应该自己用原生 JS 去试试，而不是直接拿来用。或者拿来用的时候，去瞅瞅它的实现。” 面试官：（翻简历） 面试官：“我觉得你还是挺好的，简历上贴了这么多页面。” 我：“是，因为我个人比较喜欢折腾，然后将自己折腾的东西，通过部署服务器让大家也能看看。还有就是做些统计，比如这些页面里面都嵌入了百度统计代码，然后可以查看下都有哪些用户会点击。” 面试官：“那你平时是怎么使用这些数据呢？” 我：“enm...没想过。” 面试官：“就好比说，你通过查看这些数据，发现有些数据是 A 平台过去的，有些数据是 B 平台上去的，然后发现大部分是 A 平台的……” 我：“噢噢，是的，如果大部分是 A 平台的，我可以在 A 平台编写更多文章，然后看下是哪个话题比较多，从而知道该哪个部分投放精力。” 我：“这个还真没有想法，不过经你一说，发觉这个还是不错的，运营方面还真没想到。” 面试官：“是的，你知道怎么获取数据，那么这些数据的使用技巧你也可以去折腾下。毕竟像某个渠道的转化率比较高，你就可以投放该渠道……” 我：“是的是的，这个不错。” 面试官：“嗯，其实你这个也像运营了，毕竟你通过多个渠道去推广自己。” 面试官：“好的，我大致了解了。然后你知道我们这边主要做啥么？” 我：“不太清楚。” 面试官：“是这样的，我们主要使用 React 做后台管理系统。” 我：“enm...我觉得当你业务写到一定程度的时候，你会发现技术有很多是雷同的，在这些技术上可以做到灵活切换。如果是使用 React，我是可以接受的。” 面试官：“好的好的，那你先在这等会，我去跟上面沟通下。” 我：“好的，谢谢~” 总结： 首先，这么详细的对话，当然不是我记忆力好，隔了四天还能记得，而是我当初录了音，今儿整理出来的。（不知道这个录音属不属于禁忌，但是个人觉得，每一次面试就是扩展你的知识面，毕竟面试官能给你带来你不知道的新鲜观点和知识层面） 然后，听到其中一些点，现在也感觉到尴尬，同时感觉那时候应该可以做到更好发挥。 最后，就是这个面试官给人的感觉还是挺好的，至少当某些问题 jsliang 不会的时候，他还会给你讲讲他的观点，而不是直接跳过，让你感到心堵，从而给你更多的压力。 3.3 二面技术 - 技术负责人 返回目录 经过一段时间的等待，迎来第二面面试官： 面试官：“我好，我叫 **” 我：“你好。” 面试官：（翻简历） 面试官：嗯，挺能折腾的嘛小伙子，喜欢写文章是吧？不过你的定位还是小了。来，我们都是程序员，日常接触最多的就是电脑，那么，你知道系统 32 位和 64 位的区别吗？” 我：“（触不及防）“enm...不好意思不记得了。①” ①：讲真我不是电脑发烧友，当初购买自己手提的时候，也是看到哪个参数不懂就去查哪个，大学时代为了把妹精通各种系统重装啥的……别逗了！怎么可能在我身上发生！所以我真不知道，我就是这么菜。 面试官：“你看，是吧~为什么 64 位系统会跑得比 32 位系统快呢？首先我们应该知道计算机系统是由 0101 组成的，然后……②” ②：扯不下去了，跟这位面试官的对话我并没有录音，现在就依稀记得一下关键点，所以记录的是关键部分。如果小伙伴觉得自己知道这些知识点最好，如果小伙伴觉得自己不懂，记得先 mark 到手机记事本啥的，可以去了解了解。 我：“嗯嗯，好的，学到了，我文章又来了个可以折腾的点。” 面试官：“好，既然说到这个存储，那么关于图片，你了解哪些形式，你觉得哪种场合用哪种？它们优劣如何？然后这些图片的应用场景能说说不？” 我：“jpg、png、gif，嗯，大致这三种。然后 gif 支持动画、png 拥有透明背景、jpg 应用比较广泛。通常情况下大小来说，gif 最大，再来是 png，最后是 jpg。” 面试官：“那你知道为什么这三者会存在这种差别么？” 我：（懵逼）“不清楚……” 面试官：“因为计算机对它们的压缩算法不同，还有，你有没考虑过矢量图。” 我：“噢噢，不好意思，刚才忘记说到这个，图片还可以按矢量图和位图来划分，矢量图的话，例如 svg，它不会因为你图片在不同场景的放大缩小而变得模糊。” 面试官：“嗯，你看，图片使用是不是我们工作中要面对的一个话题，这样你是不是应该可以根据这话题写一篇文章了（笑）。” 我：（感兴趣）“是的，我回头就去写一篇关于图片的文章。③” ③：这个真的不是要忽悠面试官，文章我已经开好坑了：【2019 面试准备 - 图片】，写完这篇文章，下一篇就写完这个。 面试官：“很好，我们继续下一个话题，在电商中，商品排放总是有一定道理的。现在我有两种关于商品的排序方式，分别存放在 A 页面与 B 页面中。然后，在只有前端的情况下，如何让 50% 的用户访问到 A 页面，50% 的用户访问到 B 页面。” 我：“enm...不能使用后端，或者 Nginx 负载均衡轮询？” 面试官：“不行。” 我：（深思）（自言自语）“enm...不清楚。” 面试官：“其实你刚才也提到过使用随机数的设想（自言自语中提到了），那么，我们如何让页面访问的概率为 1/2 呢？我们可不可以将这个数尽可能放大，然后再划分？” 我：（恍然）“嗯，可以将它们 %2，这样，我们就只有两种情况，一个是 0，一个是 1。因为随机范围足够大了，所以用户访问的概率也分为一半一半了。” 面试官：“很好，既然你知道 50% 和 50% 是这样子搞了，那么，你能不能做到 25% 与 75% 的划分？” 我：（笨地捉急） 面试官：“不要急，你想想，当我们 %2 的时候，会获取到两种情况，那么，一个数 %3，会有几种情况？是的，三种，0 1 2，还是通过取余，所以，我们只需要将一个尽可能大的范围的数，将它 %4，这样就有 0 1 2 3 四种情况，我们是不是就可以划分 25% 和 75%了。” 我：（再度恍然） 面试官：“那你知道取余在工作中的用法吧？” 我：“不清楚……” 面试官：“你可以了解下视频缓存，我们能不能不能因为视频有多大，我们就开多大位置给它？不能是吧，那么，我们就要在一个位置，将它存下来……④” ④：由于没有录音佐证我的记忆是否真实，所以这里进行对话省略，免得看文章的小伙伴对面试官有误解，觉得面试官其实也不懂。按照我面试之后的想法，其实就是开辟一段内存，然后浏览器接受服务器传过来的数据，在内存中，进行 %n 的形式来存储数据（n 为开辟的内存大小），接着当我们需要读取视频数据的时候，我们只需要通过先进先出的形式，将最新存进内存的数据读取出来，这样就做到了视频的还原。 我：“是的，学到了！” ……记忆回放到这里，其他都是不太深刻的问题了…… 面试官：“总体来说还是不错的，行，你等会，我叫人事过来跟你谈谈。” 我：“好的，谢谢！” 总结： 首先，一开始我以为面试官开头，也是“面试造火箭，工作拧螺丝”，但是后面说到图片以及图片排序方式，我觉得这个也是挺正常的，毕竟是电商企业。 然后，关于个人知识体系，当时跟面试官说了句：“现在程序员，一流通数学，二流通算法。我是比较想多点学习算法的。”（其实这话是刚好那天票圈在说程序员等级制，我当然是不入流啦！）当时面试官还给了下肯定。 最后，觉得还是心态放好来，毕竟如果好多问题你都不会，你应该想想能不能扯开到你熟悉的领域，因为你表现不好，心态又不好，面试官肯定印象极差。 3.4 三面个人 - 人事小姐姐 返回目录 经过一段时间的等待，迎来了一开始的人事小姐姐： 人事小姐姐；（笑）“刚才聊得怎么样？” 我：“第一面还不错，第二面有点小紧张。” 人事小姐姐：“有点小紧张？” 我：“对！” 人事小姐姐：“然后对咱这边的项目及一些情况，有些了解没？” 我：“不太清楚。①” ①：看过前面的小伙伴应该知道，一面面试官最后提到了，是的，我那 7 秒钟鱼的记忆！ 人事小姐姐：“我们公司是个跨境电商，然后人数的话……（介绍公司一些情况，这里不多累述）” 人事小姐姐：“介绍就到这里，然后你还有什么问题想要跟我咨询下的？” 我：（瞎扯些话题） 人事小姐姐：“嗯，你这里写最迟要 4月1日 入职是吧？” 我：“是的，因为你也知道，一般合同都会签个离职一个月进行交接的，签合同的时候，标明正常离职需要 30 天，你也清楚，规矩还是不能说坏就坏的……②” ②：关于入职时间，是个很令人烦恼的问题。如果你跟公司关系很好，可以申请快速办理离职手续，那就非常好；如果你跟公司关系不好，又有点钱，那么可以看看合同上写了什么，我这边合同上写的就是赔付一个月工资，不过这么做感觉不妥当；所以还是老老实实报个最稳当的时间吧，毕竟如果招聘你的公司真心想要你，肯定会为你考虑下，要不然那些希望你快速入职的，还真不好说。 人事小姐姐：“关于薪酬这块……③” ③：薪酬这个省略不能说了，毕竟收到了 offer。 人事小姐姐：“然后你还有其他问题想确认或者了解吗？” 我：“加班换调休还是薪酬还是其他……” ……省略中间内容…… 人事小姐姐：“好的，因为我们这边进行项目制，所以我叫项目负责人过来跟你聊聊最终项目以及薪酬方面的事。” 我：“好的，谢谢！” 总结： 首先，应该提提我的大忌，就是主动给自己降了薪资，因为人事小姐姐还没提到这个，但是我因为经过前两面，感觉自己表现有点糟，所以给自己给自己降了薪资，只表示我想进来。（还能安慰自己的是，这家公司真的比原先的大好多，平台大了薪资没要到一开始提的，尚能接受） 然后，如果到了人事面，你最好咨询下： 薪酬：最重要的吧，毕竟你跳槽的第一目的应该就是拿更高的工资…… 加班：换调休还是薪酬，什么时候开始算加班等…… 工作时间：早上几点到晚上几点，一周几天…… 社保和五险一金：如果你之前有工作的，记得问清楚这个交接问题，中间需不需要自己续…… 调薪机制：一年调几次，根据什么判断（我现在的公司根据 PPT 判断的！）…… 请假：请假工资怎么算…… 最后，态度和善点，我感觉前面两面，我心态有点差了，但是毕竟还要继续，所以尽量展现最好的给每一个面试官。 3.5 四面个人 - 项目负责人 返回目录 经过一段时间的等待，迎来了最终的项目负责人： 项目负责人：“先介绍下自己吧，个人以及工作经历。” 我：“个人的话，18 年 5 月开始正式实习，到 8 月的时候，感觉个人的前端知识体系比较乱，所以开始写我的文档库；然后 9 月到 10 月的时候，驻点电信做微信小程序，因为没经验，所以是边学边做；然后 11 月的时候，用 ECharts 做了数据报表；然后 12 月的时候，做了 Node 的项目；然后就到了现在。①” ①：个人比较喜欢用 然后 来连接话题，可能感觉能比较清晰表达我的逻辑吧！ 项目负责人：“是毕业之后就在这个公司了是吧？” 我：“是的。” 项目负责人：“你离开平台是因为太小了？” 我：“是的，因为我觉得平台太小，个人提升有限，就好比现在一些简历上的，很多都是我自己折腾的。②” ②：关于离职原因，钱当然是个原因，但是你不能这么说，要不然你面试的公司会觉得你市侩。当然，我这里说平台小也是个原因，因为之前公司，不管是总部，还是驻点电信，都是一个人开发项目，这样子你代码写起来是随意了，但是总想和别人合作的，毕竟大的项目，都不是一人搞定的。 项目负责人：“那么，这里提到的提升，大多是个人方面的提升，例如更高的技术之类的。但是，在工作中，我们要尽可能的协调业务、支撑业务的，所以你这么看这个？” 我：“因为业务这东西的话，一开始可能这里做一下，那里做一下。但是，等你做到很熟练的时候，你会发现有些地方是有共同性的，所以我们可以抽取出来，然后在出来新需求的时候，如果有这个，我们就可以快速应用。所以说，业务和技术不能完全分开，因为业务好多东西需要技术支撑，然后技术上你的研究，最终还是可以应用到业务上的。③” ③：这个问题的回答，需要感谢下 @邵威儒 大佬，因为他平时写公司业务的时候，就是非常勤快，然后一些常用的，他会封装成组件，来了新的需求就复制粘贴拼接下就 OK 了，给我非常大的震撼。例如：n 个设计稿，公司排期一个月，他一周就解决了。 项目负责人：“在你接触代码这么久的时间中，你有没有感觉给你比较深刻印象的事情。” 我：“个人感觉就是有些地方还是需要提升自己。例如：算法。就好比第一位面试官跟我说的微信小程序的通讯录，就用到二分法。” ……继续扯了些其他杂七杂八话题…… 项目负责人：“好的，你稍等下。”（离开） 我：“好的！” ……一段时间后…… 项目负责人：“刚才跟你一面、二面面试官聊了一下，综合评估了下，你这边还是比较 OK 的，你最早什么时候入职。” 我：“4 月 1 日，你也知道，合同都会签的。” 项目负责人：“好的，这段时间我会让人事持续跟你沟通，offer 的话问题不大，然后薪资……（省略）具体事情我再让人事跟你沟通。最后你还有什么问题么？” ……中间继续扯了一些其他的…… 我：“好的，就这些了，没了。” 项目负责人：“” 总结： 首先，到这里感觉整个人都很放松了，毕竟在人事面的时候知道这是最后一面了，也很累，毕竟坐了好久。 然后，如果能接触到项目负责人，最好多接触下，多聊聊，毕竟不出意外，这就是你的直系领导了。换工作的话，虽然平台也很重要，但是领导也是个非常重要的部分，像 jsliang 公司的领导层就比较乱，所以感觉还是希望有个好领导的。 最后，希望小伙伴们最好都能走到面试最后咯~上午的面试就到此了，当场允诺发 offer 还是很少见的。 四 下午 16:00 返回目录 公司规模：20 - 99人 行业：游戏 面试前：地处科大科技园那边，提前了一个钟到，不想提前上去（jsliang 觉得有时候提前上去，万一前面面试的还没搞完，会尴尬，一般都是提前半个钟到），无聊，就坐马路前看看车水马龙。 4.1 Job Description 返回目录 薪酬：10K - 20K 岗位职责： 1. 负责web前端开发框架的搭建； 2. 负责web前端研发（包括PC和Mobile）； 能力要求： 1. 扎实的html,js,css知识； 2. 熟悉vue等前端开发框架； 3. 熟悉bootstrap或elementui等前端UI库； 4. 熟悉响应式网页开发； 5. 能编写可维护性高的前端代码； 7. 2年以上专业岗位工作经验，有相关作品可展示优先。 4.2 技术一面 - 笔试题考查 返回目录 描述一下渐进增强和优雅降级。 CSS 中可以让文字垂直和水平方向上重叠的两个属性是什么？ 如何解决使用 inline-block 引起的空白间隙的问题？ 使用 CSS 创建一个三角形（一个箭头向右的三角图标）。 使用 CSS 实现三个 div 等比排列在一行，两列宽度固定中间自适应。 有一个长度为 100 的数组，请求出该数组的前 10 个元素之和。 写一个程序打印 1 到 100 这些数字，遇到数字为 3 的倍数，打印 “A” 替代该数字；遇到 5 的倍数，用 “B” 代替；遇到即是 3 的倍数又是 5 的倍数，打印 “AB”。 跨域通信有哪些方案，各有什么不同？ 哪些常见操作会造成内存泄漏？ 主流前端框架如 Angular/React/Vue 等之间有哪些差异及特点，选取一个描述其组件生命周期。 这里 jsliang 还是冒着被寄刀片的危险，不给答案了！毕竟给了答案，小伙伴可能不会更深层次地了解这个问题。 4.3 技术二面 - 前端小姐姐 返回目录 提交完笔试题答案后，来了位前端小姐姐，开始面试： 前端小姐姐：“你好，你先来个自我介绍吧~” 我：“你好，我叫梁峻荣，前端网名 jsliang，日常活跃于 GitHub 和掘金。然后个人比较喜欢折腾，在去年 8 月的时候开始写自己文档库，在 9 月和 10 月做过小程序，11 月的时候做了 ECharts 报表，12 月的时候做了个原生 Node 仿企业网站，然后就到了现在。” 前端小姐姐：“你挑一个你的工作项目来讲讲。” 我：“那我讲讲微信小程序吧①，当时大概 20 来张 PSD，就说了下小程序是做什么的，然后我就边看官方文档边写小程序了。大概一个半月后，期间修修改改，就把小程序搞出来了。其中最有挑战的就是联系人模块，就像我们手机的联系人，在新增和修改的时候，用到了二分法。” ①：是不是感觉跟上一家公司的面试过程好像，是的就是这么难受，毕竟经历的真不多！ 前端小姐姐：“你工作主要用到的技术栈有哪些？” 我：“首先，刚才说了有微信小程序；然后，因为日常驻点于电信，所以 jQuery、H5 还是要懂的；最后，就是用 Vue 写的报表，以及最近要写的管理平台。” 前端小姐姐：“ECharts 报表的话，你是直接使用 API 的吗？有进行更改吗？” 我：“没有。” 前端小姐姐：“能讲讲可视化拖拽页面吗？” 我：“就是使用 jQueryUI 的 API，进行拖拽生成新的 div 块，然后运营可以配置这个 div 块的数据，最后将这些数据，生成到一个新的 HTML 页面上。” 前端小姐姐：“这个也是使用 jQueryUI 的 API，没有根据实际开发，对它 API 进行一些修改吗？” 我：（尴尬）“没有。” 前端小姐姐：“那你有自己开发的东西吗？” 我：“8 月份的时候，有自己折腾过 Webpack，然后自己搞了一份 Webpack 多页面配置，结合 VS Code 的 Live Share 和 本地局域网 进行小组开发。” 前端小姐姐：“讲下 CSS 选择器的优先级吧。” 我：“首先，就是 !important 这个；然后就是行内样式；再到 #id，再到 .class，再到标签，再到通配符 *，最后还有一些，不记得了。 前端小姐姐：“嗯，好的，能讲讲 postion 定位吗？” 我：“首先，position 定位的话，默认是 static。然后，如果 position: fixed 的时候，就是相对于根元素进行定位。然后，如果是 position: absolute 的时候，根据前面那个进行了 position: relative 的标记，进行相对定位。然后，positon: relative，我常用的就是将它作为 positon: relative 的定位作用。” 前端小姐姐：“这四种脱离文档流的有哪些，不脱离的有哪些？” 我：“absolute 和 fixed 脱离了文档流，而 static 和 relative 没有脱离文档流。” 前端小姐姐：“H5 和 CSS3 用得多么？” 我：“H5 用来写活动页，CSS3 的话，不是很多。” 前端小姐姐：“那你讲讲 CSS3 属性你用哪些比较多？” 我：“rgba、圆角、渐变等……” 前端小姐姐：“渐变的话，假如有一个长方体，上面一种颜色，下面一种颜色，你会怎么做？” 我：“不好意思，因为一般都是做右边和下边的渐变，写得也是比较少，所以不清楚。②” ②：不是不清楚，是真不清楚，如果按钮有渐变，我肯定直接裁剪，用背景图来实现这个按钮！ 前端小姐姐：“好的，动画有使用过么？” 我：“抱歉，没用过，毕竟业务逻辑比较简单，不过之前大三的时候，学过一段时间 CSS3，但是因为不常用，忘了。” 前端小姐姐：“那 H5 的呢？” 我：“H5 的话，比如 、、， 的话也是简单了解，比如刮奖游戏，用到了蒙层，就是用 写的。” 前端小姐姐：“知道 H5 有个可拖拽属性吗？” 我：（胡言乱语） 前端小姐姐：“就是将一个东西，从一个位置拖拽到另一个位置。” 我：“没有。” 前端小姐姐：“好的，了解过缓存这些吗？” 我：“cookies、session、LocalStorage、SessionStorage。” 前端小姐姐：“什么场景使用那些技术？” 我：“cookies 的话，在跟后端交互，例如登录啥的，比较常用③。然后 SessionStorage，它会在浏览器关闭的时候清空掉。最后 LocalStorage，它会在浏览器进行长期存储。“ ③：cookies 我还真忘了，毕竟日常都用了 storage，所以想知道的小伙伴可以百度/Google/必应一下，别听我瞎扯。 前端小姐姐：“那 LocalStorage 会根据时间清空吗？还是会一直存在浏览器上？” 我：“LocalStorage 是不会主动删除的，但是我们可以设置它的过期时间。” 前端小姐姐：“然后，enm...能讲下什么是闭包吗？” 我：“简单来说，假如有两个函数 A 和 B，然后 B 函数在 A 函数内，同时 B 能使用函数 A 的变量，那么我们称函数 B 为闭包。④举个简单的，网上常用的例子：for 循环中定义了定时器 setTimeout，里面就涉及闭包了。” ④：关于对话中的一些知识点，最终将会整理成一篇文章，最近还没完成，但是大致有了 1400 多行的文章了：【jsliang 的 2019 面试准备】，刚兴趣的小伙伴可以关注我 GitHub 或者掘金账号，会持续更新哈~ 前端小姐姐：“那为什么使用闭包呢？” 我：“其实，工作中我个人不太喜欢闭包，也不推荐闭包，因为它能把人整懵逼了。同时，现在 ES6 的块级定义也有利于减少闭包产生。所以，能不写闭包，就不写闭包。” 前端小姐姐：“那你不使用闭包的原因是什么？” 我：“1. 代码不好维护，不管是你自己，还是你的接手人。2. 闭包会产生内部变量，浏览器不会销毁，从而卡内存。” 前端小姐姐：“你使用 ES6 语法比较多吗？” 我：“学过，但是使用不多，例如箭头函数，例如 let 变量。” 前端小姐姐：“那你使用过 Promise 吗？” 我：“肯定得用，像微信小程序中，比如一个页面，要调用好几个接口，然后调用要有顺序，这时候就要写 Promise 了。” 前端小姐姐：“可以讲下 Promise 你的用法嘛？” 我：“可能我使用的比较简单，都是用那些简单的。” 前端小姐姐：“还有其他 ES6 语法你用过吗？比如 let、var 以及 const” 我：“let 的话就是局部使用，例如使用 for 之类的，因为它不会污染全局变量；var 的话就是全局变量，可以在一个大的局域内进行调用；最后 const 一般都是在调用接口的时候，用 const 来防止接口返回的数据被修改。” 前端小姐姐：“那你知道哪个被定义声明变量后，再定义声明变量的话，会报错？” 我：“let 吧！\" 前端小姐姐：“好的，框架上的话，Vue、React、Angular 哪个用的比较多？” 我：“Vue 用得比较多，好比我的毕设，好比 ECharts 报表，以及最近的管理平台。” 前端小姐姐：“好的，路由方面能说说么？” 我：“噼里啪啦扯话题……” ……听了下录音，我扯到模块化去了，这里就不爆丑了…… 前端小姐姐：“能讲下 v-if 与 v-show 的区别吗？” 我：“v-if 的话，是往 DOM 树上添加或者删除元素；v-show 的话，使用 display: none 这些来控制显示元素。” 前端小姐姐：“v-for 你使用过程中，有遇到什么问题或者关注点吗？” 我：“避免将 v-if 和 v-for 放在同一个元素上，因为 v-for 优先级比 v-if 更高。然后使用 v-for 的话，注意下 v-bind:key，因为关系到一些代码优化了。” 前端小姐姐：“v-bind:class 有使用过吗？有什么要注意的吗？” 我：“就是那个动态渲染 class 是吗？使用过，然后需要注意的话，尽量别写太复杂的判断在上面了，毕竟维护起来麻烦，然后接手的看起来也懵逼。” 前端小姐姐：“然后 ElementUI 里面的栅格化，加入说一行分成三列，中间列隐藏的时候，第三列往前挤，但是我希望布局不能动，有啥办法？” 我：“中间列使用两个块，一个有内容的，一个大的空块，然后根据判断来显示隐藏哪一块。” 前端小姐姐：“关于响应式，还有其他了解吗？” 我：“？？？” 前端小姐姐：“例如 rem？” 我：“噢噢，在做 H5 活动页的时候，使用 rem，但是这个有问题，就是不管在多少屏幕下看起来都一样，手机看起来好的，但是到了 PC 端，就不太好看了。” 前端小姐姐：“你有遇到什么兼容问题吗？” 我：“浏览器兼容的话，IE 10 以下不考虑，其他就是微信和 IPhone 的兼容，让人难受了。” 前端小姐姐：“然后，我看你简历有说到正则小游戏⑤，能聊聊这个么？” ⑤：jsliang 写的 正则小游戏。 我：“一般来说，登录注册这些使用正则比较多，如果你让我写一个，我肯定要回去看看，毕竟很少用就忘了；但是如果你让我看看某个正则啥意思，还是能看出来的。” 前端小姐姐：“token 失效问题遇到过么？” 我：“没有。” 前端小姐姐：“能讲下原型链么？” 我：“原型链涉及到面向对象，如果在一些比较赶的项目中，可能不会使用，因为一般直接用面向过程的方法来写，一般原型链都是涉及到继承方面的东东。⑥” ⑥：这是个大块，前端必考题，具体的可以查看我的文章 【jsliang 的 2019 面试准备】，当然现在还没写完，jsliang 介绍起来也结巴，所以感觉那时候回答的也不是非常好。 前端小姐姐：“好的。能聊聊 Ajax 的原理，以及你的使用方法吗？” 我：“不好意思，不太清楚，一般都是用 jQuery 封装好的，或者 Axios。” 前端小姐姐：“那你能讲下 get 和 post 请求吗？” 我：“get 的话会在浏览器的 url 上看到，post 的话相对于 get 安全点。当然，这个安全也是有限的，毕竟前端没有说特别安全的地方。然后就是 get 请求能传的比较少，post 请求能传的数据比较多。” 前端小姐姐：“好的，大致我就清楚了，请稍等回，我跟负责人说下。” 我：“好的，谢谢。” 总结： 首先，小姐姐考点，还是比较全的，从 HTML 到 CSS 再到 JS，最后到我简历的一些点，都能聊到。 然后，小姐姐的话题，个人感觉还是比较贴近她工作的，很多时候牵扯的知识点，在工作上应该都是她印象比较深刻的。 最后，感慨下：哇塞好厉害的小姐姐！ 4.4 整体三面 - 项目负责人 返回目录 几分钟后，项目负责人来了： 项目负责人：“你好。” 我：“你好。” 项目负责人：“毕业一年了，然后能聊聊为什么跳槽么？” 我：“因为我觉得平台太小，个人提升有限，就好比现在一些简历上的，很多都是我自己折腾的。” 项目负责人：“好的，咱说说薪酬方面……” 我：“……噼里啪啦……” ……省略中间部分，聊聊 jsliang 的技术栈，聊聊技术使用，聊聊个人技术提升…… 项目负责人：“好的，大致清楚了。那今天面试就到这里了，你回去等通知吧。” 我：“好的，谢谢。” 总结： 首先，感觉中间跟项目负责人聊得有点尴尬，虽然最后聊到了薪酬和工作方面，但是关于薪资和平台方面的，回来听录音感觉还是有冲突。 然后，关于个人提升方面，要坚信你的提升是有自己理由的，不能说被否决的就觉得自己提升没用。 最后，只能遗憾到现在也没回复，可能已经凉凉了吧。 五 总结 返回目录 写到这里，jsliang 的第一轮面试就完毕啦，特意抽取了一天来面试，收获多多，感慨几许： 首先，面试不一定造火箭，有可能是人家项目中真实存在这个情况，就好比上午二面的图片，好比下午前端小姐姐的 CSS3 和动画之类的。 然后，面试可以给你更多的 idea，从而根据面试过程中出现的一些点，去扩宽自己知识面。面试第一目的肯定是拿到 offer，但是每次面试请尝试记住面试过程及面试题目，面试后总结出来，针对自己的不足进行知识拓展。 最后，jsliang 在这里祝小伙伴们面试成功，在金三银四的季节找到更适合自己的职位！ jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-21 09:48:44 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Interview/PersonalExperience/2019-PracticalRoundTwo.html":{"url":"other-library/Interview/PersonalExperience/2019-PracticalRoundTwo.html","title":"✔ 2019 面试实战 - Round Two","keywords":"","body":"2019 面试实战 - Round Two Create by jsliang on 2019-3-7 22:26:08Recently revised in 2019-3-10 16:22:59 Hello 小伙伴们，如果觉得本文还不错，记得给 jsliang 的文档库点个 star ， 你们的 star 是我学习折腾的动力！GitHub 地址 并不是只有特定的季节才能跑路，只因为人跑得多了，这条路就定下来了。 金三银四跑路季，jsliang 进行了第二回合的面试，并写下这篇文章。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 早上 09:30  3.1 Job Description  3.2 技术一面 - 机密试题考查  3.3 技术二面 - 男女混合双打  3.4 个人三面 - 研发总监考查  3.5 个人四面 - 撩人事小姐姐  3.6 个人五面 - 惊人智商考查 四 下午 15:00  4.1 Job Description  4.2 Block chain  4.3 Just chat 五 总结 二 前言 返回目录 请时刻准备好自己的简历，不管是互联网经济不佳面临裁员，还是因为公司内部斗争严重想换份工作，还是因为厌倦了目前的一切……只有随时更新自己，把自己的简历准备好，你才知道哪一刻跑路是最佳选择。 时间：2019-3-7 地点：广州 年限：一年工作经验 薪酬要求：9K - 15K 场次：上午一场，下午一场 感想：背着电脑负重 10 斤前行 13000 步，进入办公室放下电脑那一刻，轻松上阵！没人能在我的 BGM 里…… 三 早上 09:30 返回目录 公司规模：员工 3000 + 行业：计算机软件 面试前：人生最可怕的噩梦，就是面对广州死亡三号线 + 中途会被要求下站的六号线！jsliang 于 7:15 分出发，在漫长的等地铁之后，终于在 8:15 分抵达目的地。出地铁一瞅，好家伙：山清水秀鸟语花香（黑云压城城欲摧）。撑开伞，雨中漫步一会，走了一个地铁站左右，去大门登记，进入并等待面试。 3.1 Job Description 返回目录 岗位职责： 1、负责前端页面开发和维护，并根据需求优化产品性能、用户体验、交互效果及各种主流浏览器的兼容适配工作； 2、对Web前端新技术进行预研，掌握业内主流技术，保持公司前端开发技术的先进性； 3、优化与重构前端代码，并整理出可重用的代码模块； 4、配合产品经理和UI设计师，通过各种前端技术手段，提高用户体验并满足性能要求。 岗位要求： 1、2年以上前端开发工作经验。 2、精通JavaScript、JQuery、AJAX、HTML5、DIV+CSS等Web前端开发技术 3、至少熟悉主流JS库或框架如:Bootstrap、AngularJS、backbone、React、Vue等中的一种； 4、熟悉Grunt，Gulp，Webpack等前端自动化构建工具； 5、熟悉模块化开发（Requirejs、Seajs、Commonjs），并具有相关项目经验； 6、熟悉Web Components 标准，并能够独立设计、开发web组件； 7、熟悉各种Web前端技术、深刻理解Web标准，对浏览器兼容性问题有丰富经验； 8、对用户体验、交互操作流程、及用户需求有深入理解； 9、热爱前端，热爱设计，对新鲜事物充满好奇心。 10、主动了解最新前端技术动态，对HTML5技术领域、Web发展趋势具有良好的洞察力和关注度，求知欲强。 3.2 技术一面 - 笔试题考查 返回目录 人事小姐姐将我带到了一个空旷的厅子，交给我一份 【机密】 试卷，吓得我正襟危坐，拿起笔来开始答题： 一、选择题： 下面哪些属性不会让 div 脱离文档流？ A. position: absolute; B. position: fixed; C. position: relative; D. float: left; 下面有关 HTML 的 Doctype 和严格模式与混杂模式的描述，错误的是？ A. 声明位于文档中的最前面，处于 标签之前。告诉浏览器的解析器，用什么文档类型规范来解析这个文档。 B. 在标准模式下，浏览器根据规范呈现页面，在混合模式中，页面以一种比较宽松的向后兼容的形式解析这个文档。 C. DOCTYPE 不存在或格式不正确会导致文档以标准模式呈现。 D. 浏览器根据 DOCTYPE 是否存在以及使用哪种 DTD 来选择要使用的呈现方法。 元素的 alt 和 title 有什么异同，选出正确的说法？ A. 不同的浏览器，表现一样。 B. alt 和 title 同时设置的时候，alt 作为图片的替代文字出现，title 是图片的解释文字。 C. alt 和 title 同时设置的时候，title 作为图片的替代文字出现，alt 是图片的解释文字。 D. 以上说法都不正确。 下面可以让 div 水平居中的 css 设置是？ A. { margin: 0 auto; } B. { margin: auto auto; } C. { margin: auto 0; } D. { margin: 0 0; } 以下全部属于行内元素的是？ A. B. C. D. 下述有关 CSS 属性 postion 的属性值的描述，说法错误的是？ …………………… …………………… …………………… …………………… 选择题就到此结束了。 因为 jsliang 就坐在一个毫无屏障的大厅上答题。人来人往的，并且试题标明需要关闭电子设备，为了不被赶出去，为了能进入之后的环节，所以俺怂了~只在答完题假装拿手机找人事小姐姐的时候，乘机拍了前五题的，哈哈。不过下面的问答题还好我记得，下面咱一起瞅瞅！ 二、问答题 请看下面代码： function foo() { var i = 1; return function() { i++; console.log(i); } } var a = foo(), b = foo(); a(); a(); b(); 请写出上面代码的输出结果。 这题考查的是闭包，小伙伴可以先自己想想答案，然后复制代码到控制台看看结果。 请看下面代码： 请按照上面代码的格式，实现该图片的近似垂直居中和完全垂直居中。 一开始表示 jsliang 是懵逼的，不按套路出牌啊，不都是水平垂直居中么？不管了，我直接用 less 格式写下了 position 和 flex 的垂直居中方式，然后备注下如果要加上水平居中要怎么搞。 下面有个页面，左边块宽 100px，高 120px，中间 10px 缝隙，右边宽度占剩余页面的 100%，高度占整个页面高度的 100%，请写出相关代码（HTML + CSS）。 很经典的一个布局，注意右边高度 100% 要设置好喔~ 总结： 面试题要求 45 分钟写完，jsliang 30 分钟左右搞定了。总体来说在 jsliang 的面经文章上（即将发布）都有出现，个人觉得难度 5 颗星是最高难度的话，那这份题卷顶多 2 颗半星，当然后面知道 15 道选择题我还是错了 2 道。 不过，看到我的字，enm...我是觉得……程序猿写的字不好看就不好看了吧！I dont care!……安慰一波受伤的心灵。 这里不会给答案的哈，毕竟 jsliang 觉得，如果给了答案，小伙伴们的思维就被我的思路限制住了，或者我给出的是错误答案，就更引导错误了，然后评论区“大神”一堆分析，我体无完肤~所以还不如让小伙伴们自己敲一遍体验更深刻！ 3.3 技术二面 - 男女混合双打 返回目录 笔试题做完之后，微信上呼叫人事小姐姐收了卷，然后坐等 5 分钟左右，便来了两个人 —— 一男一女。 一开始我还以为那个女的是人事小姐姐，男的就是接下来我要应付的面试官了。但是当他们自我介绍完，我才知道，卧槽那个姐姐也是前端的啊，接下来就更有趣了…… 前端小姐姐：“你好，我叫 A，旁边这位叫 B。” 短发小哥：“你好。” 我：“你好。” 前端小姐姐：“你先自我介绍一下。” 我：噼里啪啦介绍一通……① ①：如果小伙伴对我的经历感兴趣，请关注下一篇文章：《jsliang 的 2019 面试准备》(尚未发布) 前端小姐姐：“介绍了下对三大框架的理解，并让我对比了下 Vue 和 微信小程序 以及 Vue 和 jQuery。”② ②：这点在我之前的文章有提及，详情可见：《2018 前端开发分享》，在此不进行额外累述。 前端小姐姐：“能讲下 Vue 实现双向数据绑定的原理吗？” 我：“Vue 2.0 通过 Object.defineProperty() 进行数据劫持。而 Vue 3.0 使用的是 Proxy。” 前端小姐姐：“能讲讲具体的实现思路吗？” 我：（囧）（忘记具体实现了）“不好意思，我就听过，但是具体的没看过。” 前端小姐姐：（沉默）有没有用 Node 写过后台。 我：“我用了 Node + Vue + MongoDB 写过毕设，用了原生 Node 写过一个仿企业建站，提供简单的增删改查 API 给 jQuery 使用。” 前端小姐姐：（翻简历）“你这工作项目还挺多的啊！” 我：“是的。” 前端小姐姐：“开发周期长不长？” 我：“像微信小程序的话就两个月，jQuery + jQueryUI 打造的那个可视化拖拽系统就一个半月左右。” 前端小姐姐：“你这些项目是独立开发还是团队开发？” 我：“独立开发，毕竟前端就我一个幸运儿。” 前端小姐姐：“你这还有个 Angular + ECharts？” 我：“Angular + ECharts 这个没写完，因为折腾到一半的时候，我被流放到电信驻点去了。” 前端小姐姐：“那你把你做的项目里面，比较有成就感的拿出来讲讲。” 我：“整个微信小程序的开发过程是最有成就感的。因为我被安排到电信驻点的时候，还不知道电信需要开发微信小程序，然后我就拿了一套 PSD 图，边看官方文档边折腾，最终在自己说的两个月期限内写完了。” 前端小姐姐：“那你觉得项目模块中，哪个比较复杂？” 我：“在微信小程序中有个通讯录模块，这个通讯录模块就跟我们手机的通讯录一样。其中有个新增和修改功能，就像我们手机的新增和修改，当我们新增后，页面会滚动到相应的位置，修改也是。然后，我在自己做通讯录模块的时候，想了一下，想用二分法来实现这查找功能。不过后来因为时间不够的缘故，就没有具体写完了。”③ ③：详情可见我的文章：《微信小程序之奇技淫巧》 前端小姐姐：“你说你搞过 ES6 这方面的知识，那你知道 ES6 这方面的兼容性吗？” 我：“没有。” 前端小姐姐：“那你面向的用户是哪些人群？” 我：“第一是电信内部人员吧，第二就是 H5 活动页会通过短信形式发送到电信用户手上，所以要考虑手机端的兼容，常见的就是 IPhone 和微信的兼容。” 前端小姐姐：“好的，了解了。enm...那我出道题吧。”④ ④：震惊！前端小姐姐开始手写代码了！ 题目：一个机构树的快速定位，快速找到目标树的 Id： var tree = [ { parentTreeId: 1, nodeOne: **, nodeTwo: ** }, { parentTreeId: 2, nodeOne: **, nodeTwo: **, childNode: 1 }, { childTreeId: 1 parentId: 2 childNodeOne: ** } …… ] 请问我要如何快速找到某 Id 对应的节点。⑤ ⑤：由于记忆不太清晰，这里 jsliang 尽力模仿了小姐姐的代码。 jsliang 使用了 for in + 递归 的形式进行了查找，不过因为 jsliang 也不确定，所以感兴趣的小伙伴，赶紧行动起来，查找一番吧~ （经过一段时间的写代码以及和前端小姐姐的讨论……） 前端小姐姐：“好的，树节点问题咱就讨论到这，下面我再问一个问题，有关定位的。” 题目：假设我有一个页面，页面上有一张图，大致就是： 代码结构如下： 当我点击这张图片中的某个位置（不仅是人身体，其他空白地方也可以），就会显示一个 input 框，输入一些信息后，点击其他地方会关闭，然后当你鼠标移动过去后，就会显示刚才输入的信息，请问这你会怎么实现？ jsliang 觉得这是个有趣的问题，小伙伴们可以自己试试哈~ tips：获取设备宽高，获取相对于图片的点击位置，定位新 input 的位置，定义 input 的 hover…… （又经过一段时间的写代码以及和前端小姐姐的讨论……） 前端小姐姐：“好的，我们接着下一个问题。” 题目：现在，我有四个接口：A、B、C、D，首先我要查询 A 接口，查询 A 接口之后才能根据 A 接口返回的数据查询 B、C、D 三个接口，请问有没有比较好点的做法？ jsliang 的思路是链式调用 + 异步调用，回答问题的时候用了 Promise，小伙伴们可以想想自己会怎么解决吧~ （又又经过一段时间的写代码以及和前端小姐姐的讨论……） 前端小姐姐：“好的，大致清楚了，那么你能讲讲你离职的原因和对下一家公司的期望么？” 我：“是的，因为我觉得平台太小，个人提升有限，因为电信这边一直使用 jQuery 开发的；同时，因为一个人开发，总感觉缺少点什么，可能我比较希望找个团队一起折腾，共同分享，共同进步。⑥” ⑥：关于离职原因，钱当然是个原因，但是你不能这么说，要不然你面试的公司会觉得你市侩。当然，我这里说平台小也是个原因，因为之前公司，不管是总部，还是驻点电信，都是一个人开发项目，这样子你代码写起来是随意了，但是总想和别人合作的，毕竟大的项目，都不是一人搞定的。 前端小姐姐：“好的，那你对我们这边还有什么问题要问的吗？” 我：“我想知道如果我进来这公司，大概是做什么？” 前端小姐姐：“如果你进来的话，大概是做 ……⑦。然后，平时开发的话，是采用组件化开发形式，分工合作的。接着，我们需要进行兼容到 IE8，以及我们使用的技术是 Angular 1，团队是 30 多个人，前端 10 多个。最后，我们可能会涉及的有 ECharts 报表以及地图之类的开发。” ⑦：这部分就不能讲了，因为跟某些地方牵扯上关系的，jsliang 还是有所顾忌的。 我：“好的，谢谢，我大致了解了。” （前端小姐姐询问特短发大哥还有啥需要询问的。） 特短发大哥：“你是觉得自己基础部分比较好还是应用部分比较好？” 我：“我觉得我应用部分用的比较多，但是我更希望自己能补充下我的基础部分，因为我 18 年 8 月的时候开始写文档库，就是想查漏补缺，将自己的知识体系进行完善。当你的知识体系完善的时候，你的综合水平就上去了。” 特短发大哥：“你觉得你的文档库中，哪个部分比较容易写？” 我：“我觉得我的文档库中，比较容易写的地方，就是那些直接调用 API 的地方，这些地方很少考虑基础，直接调用 API 即可，完全靠你的使用次数和熟练度。” 特短发大哥：“好的，那最后你给我写个 1 分钟倒计时吧。” 我：（拿起纸笔写了起来） 特短发大哥：“好的，那你稍等下，我们合计下并找下人事。” 我：“好的，谢谢。” 总结： 这一面大概是总体面试流程中较有难度，并且比较有趣的环节了，毕竟手写代码还是挺好（刺）玩（激）的，虽然短发大哥不咋说话，但是咋看大哥就是传说中的背后 Boss，全程观看我跟姐姐的对话，而且接下来他的举动，可以看出他还是个有趣的人。 3.4 个人三面 - 研发总监考查 返回目录 再次经过 5 分钟的等待后，短发大哥带我去办公室，路上很嗨皮地跟我聊了下，询问我平时玩不玩游戏，还是平时有其他活动啥的……最后将我带到了研发总监的办公室。 深刻记住他这句话！因为他可能知道我会走到五面，然后他知道五面是啥玩意，特此调侃下我！ 研发总监：“你好。” 我：“你好。” 研发总监：“能说下最近工作项目么？” 我：“在开发一个 Vue + ElementUI 的后台管理项目。” 研发总监：“噢噢，能讲下 JavaScript 的闭包么？” 我：“简单来说，有个函数 A 以及一个函数 B，函数 A 里面包含了 函数 B，而 函数 B 里面使用了 函数 A 的变量，那么 函数 B 被称为闭包。” 研发总监：“那闭包会产生什么问题？” 我：“闭包会造成大量的局部变量，会造成内存消耗过大，从而造成网页的性能问题。不过我特地就闭包询问了一些前端前辈，他们说目前浏览器引擎都基于 V8，而 V8 引擎有个 gc 回收机制，不用太过担心变量不会被回收。” 研发总监：“那你有遇到过这种内存泄漏的问题吗？能举个例子吗？” 我：“记得我有次在 for 循环里面，写了个 setTimeout，然后因为数据量过大，从而导致页面卡住，最后浏览器都崩溃了。” 研发总监：“那你是怎么解决这个问题的？” 我：“一般在 for 中使用 let 变量了，因为 let 会产生块级作用域，从而减少产生闭包的可能。” 研发总监：“能讲讲谷歌的盒子模型和 IE 的盒子模型的区别吗？” 我：（尴尬）“这个具体不太清楚，但我可以给你讲个类似的，叫 box-sizing。” 研发总监：“那你讲讲这个。” 我：“在 box-sizing 中，大致有两种情况，一种是：box-sizing: border-box，这种情况下，实际宽 = 盒子宽 + padding + border + margin；还有一种情况是 box-sizing: content-box，这种情况下，实际宽不包括这些，最终可能因为 实际宽 = 盒子宽 + border + margin 从而冲破页面。” 研发总监：“能讲讲 Vue 和 jQuery 的区别？” 我：（这里就不罗列了，上面面试问答提到过了） 研发总监：“能讲讲 Vue 的数据绑定原理吗？” 我：“不能。但是我知道 Vue 2.0 版本使用的是 Object.defineProperty() 进行数据劫持。而 Vue 3.0 使用的是 Proxy。” 研发总监：“知道为什么 3.0 使用 Proxy，而 2.0 使用 Object.defineProperty() 吗？” 我：“不知道，看文章介绍说是 Object.defineProperty() 有的功能 Proxy 都有，而且比它更丰富。” 研发总监：“你离职的原因是什么？” 我：（还能是什么，跟二面一样再吐槽一遍呗~） 研发总监：“对于薪资你有什么要求？” 我：（这里省略啦~没啥好说的，小伙伴面试想要多少就直接提多少，市场讨价还价还是要有的） （最后聊了下其他杂七杂八的东西，例如调薪啦，培训啦，工作时间啦，加班啦，加班怎么算啦等等……） 总结： 看过我第一回合面试文章的小伙伴都知道，到了这个环节，只要你不作死，一般都没什么问题的了，毕竟这面面的不全是技术，主要是看你在将来工作上可能有的表现，以及跟人的沟通能力。 3.5 个人四面 - 撩人事小姐姐 返回目录 又又经过 5 分钟的等待后，人事小姐姐带我去了会议室，跟我聊了一下： 人事小姐姐：“经过两轮面试，感觉如何？” 我：“还好吧~” 人事小姐姐：“住哪啊？” 我：…… 人事小姐姐：“哇，那你过来就有点早了~” 我：…… 人事小姐姐：“感觉这边如何？” 我：…… 人事小姐姐：…… 我：………… 人事小姐姐：“嗯，因为我们公司机制，今晚你可能还需要做两套题，一套呢，是岗位匹配度的题目；另一套呢，是智商测试题。你做完这两套，合格的话第二天我就可以给你发 offer 了。” 我：（呆）“能不能不做？” 人事小姐姐：（笑）“不能。” 我：（囧）“好的吧。” 人事小姐姐：“嗯嗯，好的，也到饭点了，你要不要跟我下去吃个饭，你也可以体验下未来的饭堂。” 我：（愣）“不了不了，我还有事。” 人事小姐姐：“嗯，好的吧，那我送你到电梯口。” 我：“好地，谢谢~” 总结： 日常到了这环节，要不就是人事小姐姐会让你回去静等消息，要不就是人事小姐姐会让你回去等 offer 邮件，要不就是……人事小姐姐让你回去做职位匹配与智商测试题！过了才给 offer ！！！ 3.6 个人五面 - 惊人智商考查 返回目录 在人事小姐姐的告知下，想要 offer 还要做两份测试题，然后晚上回去我真的收到了两份邮件，开始了痛苦的五面。 岗位匹配度测试 研发类岗位匹配度测试 第一部分 题量 114 题 不限时（约需 11 分钟） 第二部分 题量 51 题 不限时（约需 9 分钟） 第三部分 题量 6 题 6 分钟 第四部分 题量 6 题 6 分钟 第五部分 题量 6 题 6 分钟 第六部分 题量 13 题 10 分钟 智商题测试 能力倾向 CATA 测评 第一部分 题量约 10 题 限时（约需 10 分钟） 第二部分 题量约 10 题 限时（约需 10 分钟） 第三部分 题量约 10 题 限时（约需 10 分钟） 总结： 感觉自从高中毕业后，对于考试题类没感情，尤其是像岗位匹配度测试这种，是考情商的吧？不是哪个好就选哪个或者选对自己影响较好的那个么，没有老老实实根据实际情况真实选答的吧？ 我的智商可能真不过关，那些看图演示答出下一个图，找规律啥的搞得我懵懵的。答题完后第二天，人事小姐姐就电话通知我，我的智商题测试差了 3 分及格，并说已经重发邮件给我了，让我再做一遍…… 还好不是再让我做一遍 岗位匹配度测试，要不然我真的会崩溃，至此上午的面试就完结啦！ 四 下午 15:00 返回目录 公司规模：员工 1-20 人 行业：区块链 面试前：在经过上午的折腾过后，中午吃了个“特贵”的“营养蒸饭”，看下时间还有一个钟，等不急了，早点搞定早点回去休息。又是一番折腾下（讲真要进个大厦还是挺麻烦的，可能为了大厦安全着想），终于进入面试等待状态。 4.1 Job Description 返回目录 岗位职责： 1.负责互联网产品的前端开发工作，不断优化用户体验，提升产品的兼容性和易用性； 2.根据产品需求，分析并给出最优的页面前端架构解决方案； 3.与产品经理，设计师和后端工程师紧密合作，实现产品交互流程和视觉界面的开发需求； 4.把控代码质量，定期维护并更新前端开发规范； 5.创新能力强，善于学习并总结、分享新技术； 6.具备良好的服务意识、责任心、较强的学习能力、团队沟通与协作能力； 需要掌握技能 岗位要求： 1.熟练掌握JS、HTML5、CSS3等前端技术 2.熟练使用jQuery等主流Javascript库/框架 3.熟练使用Ajax进行交互开发 4.熟练使用Photoshop对设计图进行切割和导出 5.熟悉各种浏览器兼容处理 4.2 Block chain 返回目录 在介绍这份工作的面试之前，咱们还是讲讲区块链吧，毕竟一开始 jsliang 也不是很懂区块链这块，面试的时候没跟面试官勾搭到一块，面试完回去后，特地咨询了下在区块链公司工作的大佬 邵威儒，并查了下相关资料，同样不懂的小伙伴可以跟着一起了解了解。 什么是区块链？ 区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。 区块链（Blockchain），是比特币的一个重要概念，它本质上是一个去中心化的数据库，同时作为比特币的底层技术，是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了一批次比特币网络交易的信息，用于验证其信息的有效性（防伪）和生成下一个区块。 ……以上来自百度百科…… 好的，说人话。 区块链本质上是解决信任问题，降低信任成本的技术方案，它是比特币的底层技术。 咱们先从比特币交易来看区块链具体操作： 首先，A 和 B 交易，将每笔交易在全网广播，让全网承认有效，必须广播给每个节点。 然后，吃瓜观众矿工节点在接收到交易信息后，都会拿出账簿本记载该次交易。一旦记录，就不可撤销，不可随意销毁。 接着，矿工节点是通过电脑运行的比特币软件对交易进行确认的，所以为了鼓励矿工的服务，对它所记录和确认的交易，系统为矿工提供比特币作为奖励。 n 个矿工都记录了，比特币归谁呢？当然是系统会出一道运算题，谁算的最快，谁就能获取记录入账权利，赢得奖励啦~ 最后，获得该记账的矿工将向全网广播这笔交易，账簿公开，其他矿工进行核对确认，交易达到 6 个以上确认就被记录在案。都确认无误后，记录就会合法，从而进行下一个记录的争夺战啦~ 在这些步骤中，矿工的每个记录，就是一个区块（block），会盖上时间戳，每个新产生的区块会严格按照时间线顺序推进，形成不可逆的链条，所以叫做区块链（Block Chain)。 参考文献：《几张图看懂区块链技术到底是什么？》 区块链特点？ 去中心化。颠覆性特点，没有中间商赚差价！不存在任何中心机构和中心服务器，所有交易都发生在每个人电脑或手机上安装的客户端应用程序中。实现点对点直接交互，既节约资源，使交易自主化、简易化，又排除被中心化代理控制的风险。 开放性。公共记账的技术方案，系统完全开放透明，账簿对所有人公开，实现数据共享，任何人都可以查账。 不可撤销、不可篡改和加密安全性。区块链采用单向哈希算法，每个新产生的区块严格按照时间线形顺序推进，时间的不可逆性、不可撤销导致任何试图入侵篡改区块链内数据信息的行为易被追溯，从而导致被其他节点排斥，造假成本极高，从而可以限制相关不法行为。 区块链现状及预测？ 各国反应： 美国：大多数数字货币交易发生在法律灰色地带，美国证券交易委员会正逐步加强对数字货币市场的监管。 英国：英国金融市场行为监管局（FCA）针对 ICO 和数字货币风险发布警告。FCA 表示，ICO 是高风险、投机性强的投资活动。若 ICO 落入 FCA 的监管范围，将具体情况具体分析。 韩国：韩国是对数字化货币态度最严格的国家之一。韩国民众对数字货币非常狂热，也催生了一些黑暗交易，韩国政府对数字货币的态度从暧昧转向成全面干预，甚至准备进行全面封杀，近期韩国接二连三的下发政策，禁止开放匿名加密货币。 日本：日本是对数字货币态度最开放的国家之一，刚刚向 11 个交易所颁发了牌照，即在日本进行数字货币投资交易是获得允许的。 中国：出台了很多管制措施，如取缔数字资产交易所和 ICO，禁止在线访问海外交易平台。在香港地区，管理者采取了更加宽松的策略，但是它禁止交易平台在未被官方允许的情况下把数字货币像证券那样进行任何交易。台湾地区正在观望。 ICO：ICO（是Initial Coin Offering缩写），首次币发行，源自股票市场的首次公开发行（IPO）概念，是区块链项目首次发行代币，募集比特币、以太坊等通用数字货币的行为。 参考文献：《2018年区块链现状报告：发展情况如何?》 国内环境：中国区块链市场充斥大量三无项目，无应用技术、无技术团队、无业务逻辑。ICO 被监管机构叫停，但泡沫没有破裂迹象。所以总结就是相关政府严厉监管，技术团队努力攻关完善区块链，国人驻足观望。 4.3 Just chat 返回目录 最后就是面试场景啦~ ……-_ -|| ……- -|| …… - -|| …… - -|| …… - -|| …… -_ -|| 这里真的就没什么好讲的了，毕竟两位面试官都不懂技术，然后让我过来面试的主要原因，是因为： 我的参与项目比较多，尤其是 PC 端、手机端、ECharts、微信小程序等都有所涉及。 我是计算机相关专业毕业。 我是比较活跃的，了解过我的小伙伴都知道，我 GitHub 快破 800 star 了，然后掘金也是挺活跃的。 所以，enm...碰上不懂技术的面试官，就尽大可能谈心咯：我工作最怕的不是不能做出来，是你给我的时间不够~ 最后的最后，面试官在 Boss 直聘上给了 offer 以及详细薪酬，让我回去考虑要不要过去。 五 总结 返回目录 至此，jsliang 的第二轮面试就结束啦~ 首先，还是那句话，面试不一定造火箭，有可能是人家项目中真实存在这个情况，就好比上午二面的小姐姐的问题，你说她是自己想出来的，我看不尽然，说不定就是真实上线的案例中抽取出来的。 然后，面试可以给你更多的 idea，从而根据面试过程中出现的一些点，去扩宽自己知识面。面试第一目的肯定是拿到 offer，但是每次面试请尝试记住面试过程及面试题目，面试后总结出来，针对自己的不足进行知识拓展。 最后，jsliang 在这里祝小伙伴们面试成功，在金三银四的季节找到更适合自己的职位！ jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Interview/PersonalExperience/2019-PracticalRoundThree.html":{"url":"other-library/Interview/PersonalExperience/2019-PracticalRoundThree.html","title":"✔ 2019 面试实战 - Round Three","keywords":"","body":"2019 面试实战 - Round Three Create by jsliang on 2019-3-15 16:40:52Recently revised in 2019-3-17 21:31:15 Hello 小伙伴们，如果觉得本文还不错，记得给 jsliang 的文档库点个 star ， 你们的 star 是我学习折腾的动力！GitHub 地址 并不是只有特定的季节才能跑路，只因为人跑得多了，这条路就定下来了。 金三银四跑路季，jsliang 进行了第三回合的面试，并写下这篇文章。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 上午 10:00 3.1 一面笔试题 3.2 二面小程序 四 总结 二 前言 返回目录 请时刻准备好自己的简历，不管是互联网经济不佳面临裁员，还是因为公司内部斗争严重想换份工作，还是因为厌倦了目前的一切……只有随时更新自己，把自己的简历准备好，你才知道哪一刻跑路是最佳选择。 时间：2019-3-15 地点：广州 年限：一年工作经验 薪酬要求：9K - 15K 场次：上午一场 感想：面试上瘾了，就是想接触更多人，看到更广阔的世界。 三 上午 10:00 返回目录 拿完体检单，“顺带” 去面试一下~ 3.1 一面笔试题 返回目录 什么是闭包，闭包的优缺点是什么？请简单描述一下。 简单描述一下 TCP 与 UDP 的区别。 点击 button 页面会刷新，如何阻止？ 事件触发共经历几个阶段？请分别阐述。 请写出代码输出的结果。如何合理改动代码，是它返回期望的结果？ for(var i = 1; i function demo() { this.length = 10; var fn = function() { console.log(this.length); // 输出多少？ } arr = [fn, 'hello layui']; fn.length = 100; arr[0](); } 3.2 二面小程序 返回目录 面试官：“你好，先自我介绍一下。” 我：（噼里啪啦一顿介绍） 面试官：“好的，说一下你做小程序遇到的问题。” 我：“问题的话，就是在没经验下，看文档开发小程序。然后做得最难的就是通讯录模块，新增/修改的时候需要使用二分法判断下拉到具体位置。①” ①：详情可见我的文章：《微信小程序之奇技淫巧》 面试官：“那你说一下做小程序碰到的样式问题。” 我：“最烦的就是改小程序内部的组件的样式，例如微信小程序视频组件等。” 面试官：“额(⊙o⊙)…好的，其实小程序也没啥好问的。” 我：“是的。个人感觉小程序就是 Vue 的阉割版。” 面试官：“好的，那就这些吧，嗯，你可能要过两三天等复试，因为我们这边属于国企，所以流程还是要走的。” 我（惊讶）“噢噢，好的，谢谢~” 四 总结 返回目录 是的，很轻松的一个上午，压根没感觉到面试的紧张感，可能因为面试内容仅仅讨论小程序，所以没太多需要沟通的。 就这样，我的 2019 面试之旅结束了，剩下的就是将我的面试准备内容贴出来（爆大招），给小伙伴们更多的参考，为自己的面试做充足的准备。 最后祝小伙伴们找到合适的工作咯~ jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Interview/PersonalExperience/JS-原型与原型链.html":{"url":"other-library/Interview/PersonalExperience/JS-原型与原型链.html","title":"✔ 面试知识点 - JS 原型与原型链","keywords":"","body":"面试知识点 - JS 原型与原型链 Create by jsliang on 2019-2-21 08:42:02Recently revised in 2019-2-23 09:44:08 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址 本文涉及知识点： prototype __proto__ new call()/apply()/bind() this 在本文中，jsliang 会讲解通过自我探索后关于上述知识点的个人理解，如有纰漏、疏忽或者误解，欢迎各位小伙伴留言指出。 如果小伙伴对文章存有疑问，想快速得到回复。或者小伙伴对 jsliang 个人的前端文档库感兴趣，也想将自己的前端知识整理出来。欢迎加 QQ 群一起探讨：798961601。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 题目 四 解题 五 知识拓展  5.1 问题少年：旅途开始  5.2 原型及原型链  5.3 new 为何物  5.4 call() 又是啥  5.5 this 指向哪 六 总结 七 参考文献 八 工具 二 前言 返回目录 广州小伙伴在帮我进行面试摸底的时候，提出了问题：能否谈谈 this 的作用？ 题目的目的： 了解 this，说一下 this 的作用。 Vue 的 this.变量，this 指向 Vue 的哪里。（指 Vue 的实例） Vue 里写个 setTimeout，发现 this 改变（call()、apply()、=>） ……大致如此…… 但是，我发现了我走了一条不归路，无意间我看了下 prototype！ 然后，我爬上了一座高山…… 三 题目 返回目录 相信有的小伙伴能自信地做出下面这些题~ 题目 1 var A = function() {}; A.prototype.n = 1; var b = new A(); A.prototype = { n: 2, m: 3 } var c = new A(); console.log(b.n); console.log(b.m); console.log(c.n); console.log(c.m); 请写出上面编程的输出结果是什么？ 题目 2 var F = function() {}; Object.prototype.a = function() { console.log('a'); }; Function.prototype.b = function() { console.log('b'); } var f = new F(); f.a(); f.b(); F.a(); F.b(); 请写出上面编程的输出结果是什么？ 题目 3 function Person(name) { this.name = name } let p = new Person('Tom'); 问题1：1. p.proto等于什么？ 问题2：Person.proto等于什么？ 题目 4 var foo = {}, F = function(){}; Object.prototype.a = 'value a'; Function.prototype.b = 'value b'; console.log(foo.a); console.log(foo.b); console.log(F.a); console.log(F.b); 请写出上面编程的输出结果是什么？ 四 解题 返回目录 题目 1 答案： b.n -> 1 b.m -> undefined; c.n -> 2; c.m -> 3; 题目 2 答案： f.a() -> a f.b() -> f.b is not a function F.a() -> a F.b() -> b 题目 3 答案 答案1：Person.prototype 答案2：Function.prototype 题目 4 答案 foo.a => value a foo.b => undefined F.a => value a F.b => value b 如果小伙伴们查看完答案，仍不知道怎么回事，那么，我们扩展下自己的知识点，畅快了解更多地知识吧！ 五 知识拓展 返回目录 原型和原型链估计是老生常谈的话题了，但是还是有很多小白（例如 jsliang 自己）就时常懵逼在这里。 首图祭祖，让暴风雨来得更猛烈些吧！ 5.1 问题少年：旅途开始 返回目录 因为爱（了解来龙去脉），所以 jsliang 开始学习（百度）之旅，了解原型和原型链。 首先，jsliang 去了解查看原型链 prototype。 然后，在了解途中看到了 new，于是百度查看 JS 的 new 理念。 接着，接触 new 会了解还有 call()，而 call()、apply() 以及箭头函数 => 又是相似的东西。 最后，当我们查找 call() 的时候，它又涉及到了 this，所以我们 “顺便” 查阅 this 吧。 5.2 原型及原型链 返回目录 首先，为什么需要原型及原型链？ 我们查看一个例子： function Person(name, age) { this.name = name; this.age = age; this.eat = function() { console.log(age + \"岁的\" + name + \"在吃饭。\"); } } let p1 = new Person(\"jsliang\", 24); let p2 = new Person(\"jsliang\", 24); console.log(p1.eat === p2.eat); // false 可以看到，对于同一个函数，我们通过 new 生成出来的实例，都会开出新的一块堆区，所以上面代码中 person 1 和 person 2 的吃饭是不同的。 拥有属于自己的东西（例如房子、汽车），这样很好。但它也有不好，毕竟总共就那么点地儿（内存），你不停地建房子，到最后是不是没有空地了？（内存不足） 所以，咱要想个法子，建个类似于共享库的对象（例如把楼房建高），这样就可以在需要的时候，调用一个类似共享库的对象（社区），让实例能够沿着某个线索去找到自己归处。 而这个线索，在前端中就是原型链 prototype。 function Person(name) { this.name = name; } // 通过构造函数的 Person 的 prototype 属性找到 Person 的原型对象 Person.prototype.eat = function() { console.log(\"吃饭\"); } let p1 = new Person(\"jsliang\", 24); let p2 = new Person(\"梁峻荣\", 24); console.log(p1.eat === p2.eat); // true 看！这样我们就通过分享的形式，让这两个实例对象指向相同的位置了（社区）。 然后，说到这里，我们就兴趣来了，prototype 是什么玩意？居然这么神奇！ 孩子没娘，说来话长。首先我们要从 JavaScript 这玩意的诞生说起，但是放这里的话，故事主线就太长了，所以这里有个本文的剧场版《JavaScript 世界万物诞生记》，感兴趣的小伙伴可以去了解一下。这里我们还是看图，并回归本话题： JS 说，我好寂寞。因为 JS 的本源是空的，即：null。 JS 说，要有神。所以它通过万能术 __proto__ 产生了 No1 这号神，即：No1.__proto__ == null。 JS 说，神你要有自己的想法啊。所以神自己想了个方法，根据自己的原型 prototype 创建了对象 Object，即：Object.prototype == No1; No1.__proto__ == null。于是我们把 prototype 叫做原型，就好比 Object 的原型是神，男人的原型是人类一样，同时 __proto__ 叫做原型链，毕竟有了 __proto__，对象、神、JS 之间才有联系。这时候 Object.prototype.__proto__ == null。 JS 说，神你要有更多的想法啊，我把万能术 __proto__ 借你用了。所以神根据 Object，使用 __proto__ 做了个机器 No2，即 No2.__proto__ == No1，并规定所有的东西，通过 __proto__ 可以连接机器，再找到自己，包括 Object 也是，于是 Object 成为所有对象的原型，Object.__proto__.__proto__ == No1，然后 String、Number、Boolean、 Array 这些物种也是如此。 JS 说，神你的机器好厉害喔！你的机器能不能做出更多的机器啊？神咧嘴一笑：你通过万能术创造了我，我通过自己原型创造了对象。如此，那我造个机器 Function，Function.prototype == No2, Function.__proto__ == No2，即 Function.prototype == Function.__proto__ 吧！这样 No2 就成了造机器的机器，它负责管理 Object、Function、String、Number、Boolean、Array 这几个。 最后，说到这里，我们应该很了解开局祭祖的那副图，并有点豁然开朗的感觉，能清楚地了解下面几条公式了： Object.__proto__ === Function.prototype; Function.prototype.__proto__ === Object.prototype; Object.prototype.__proto__ === null; 5.3 new 为何物 返回目录 这时候，我们知道 prototype 以及 __proto__ 是啥了，让我们回归之前的代码： function Person(name) { this.name = name; } // 通过构造函数的 Person 的 prototype 属性找到 Person 的原型对象 Person.prototype.eat = function() { console.log(\"吃饭\"); } let p1 = new Person(\"jsliang\", 24); let p2 = new Person(\"梁峻荣\", 24); console.log(p1.eat === p2.eat); // true 可以看出，这里有个点，我们还不清楚，就是：new 为何物？ 首先，我们来讲讲函数：函数分为构造函数和普通函数。 怎么回事呢？No2 始机器 在创造机器 Function 的过程中，创造了过多的机器，为了方便区分这些机器，No1 神 将机器分为两类：创造物种类的 Function 叫做构造函数（通常面向对象），创造动作类的 Function 叫做普通函数（通常面向过程）。打个比喻：function Birl() {} 、function Person() {} 这类以首字母大写形式来定义的，用来定义某个类型物种的，就叫做 构造函数。而 function fly() {}、function eat() {} 这类以首字母小写形式来定义的，用来定义某个动作的，就叫做普通函数。 注意，它们本质还是 Function 中出来的，只是为了方便区分，我们如此命名 然后，我们尝试制作一个会飞的鸟： // 定义鸟类 function Bird(color) { this.color = color; } // 定义飞的动作 function fly(bird) { console.log(bird + \" 飞起来了！\"); } 接着，我们要使用鸟类这个机器创造一只鸟啊，No1 神 挠挠头，折腾了下（注意它折腾了下），跟我们说使用 new 吧，于是： // 定义鸟类 function Bird(color) { this.color = color; } // 创造一只鸟 let bird1 = new Bird('蓝色'); // 定义飞的动作 function fly(bird) { console.log(bird.color + \"的鸟飞起来了！\"); } fly(bird1); // 蓝色的鸟飞起来了！ 说到这里，我们知道如何使用类型创造机器和动作创造机器了。 最后，我们如果有兴趣，还可以观察下 No1 神 在 new 内部折腾了啥： 假如我们使用的是：let bird1 = new Bird('蓝色'); // 1. 首先有个类型机器 function ClassMachine() { console.log(\"类型创造机器\"); } // 2. 然后我们定义一个对象物品 let thingOne = {}; // 3. 对象物品通过万能术 __proto__ 指向了类型机器的原型（即 No 2 始机器） thingOne.__proto__ = ClassMachine.prototype; // 4. ？？？ ClassMachine.call(thingOne); // 5. 定义了类型机器的动作 ClassMachine.prototype.action = function(){ console.log(\"动作创造机器\"); } // 6. 这个对象物品执行了动作 thingOne.action(); /* * Console： * 类型创造机器 * 动作创造机器 */ OK，new 做了啥，No 1 神安排地明明白白了。 那么下面这个例子，我们也就清楚了： function Person(name){ this.name = name } Person.prototype = { eat:function(){ console.log('吃饭') }, sleep:function(){ console.log('睡觉') } }; let p = new Person('梁峻荣',28); // 访问原型对象 console.log(Person.prototype); console.log(p.__proto__); // __proto__仅用于测试，不能写在正式代码中 /* Console * {eat: ƒ, sleep: ƒ} * {eat: ƒ, sleep: ƒ} */ 所以很多人会给出一条公式： 实例的 __proto__ 属性（原型）等于其构造函数的 prototype 属性。 现在理解地妥妥的了吧！ 但是，你注意到 new 过程中的点 4 了吗？！！！ 5.4 call() 又是啥 返回目录 在点 4 中，我们使用了 call() 这个方法。 那么，call() 又是啥？ 首先，我们要知道 call() 方法是存在于 Funciton 中的，Function.prototype.call 是 ƒ call() { [native code] }，小伙伴可以去控制台打印一下。 然后，我们观察下面的代码： function fn1() { console.log(1); this.num = 111; this.sayHey = function() { console.log(\"say hey.\"); } } function fn2() { console.log(2); this.num = 222; this.sayHello = function() { console.log(\"say hello.\"); } } fn1.call(fn2); // 1 fn1(); // 1 fn1.num; // undefined fn1.sayHey(); // fn1.sayHey is not a function fn2(); // 2 fn2.num; // 111 fn2.sayHello(); // fn2.sayHello is not a function fn2.sayHey(); //say hey. 通过 fn1.call(fn2)，我们发现 fn1、fn2 都被改变了，call() 就好比一个小三，破坏了 fn1 和 fn2 和睦的家庭。 现在，fn1 除了打印自己的 console，其他的一无所有。而 fn2 拥有了 fn1 console 之外的所有东西：num 以及 sayHello。 记住：在这里，call() 改变了 this 的指向。 然后，我们应该顺势看下它源码，搞懂它究竟怎么实现的，但是 jsliang 太菜，看不懂网上关于它源码流程的文章，所以咱们还是多上几个例子，搞懂 call() 能做啥吧~ 例子 1： function Product(name, price) { this.name = name; this.price = price; } function Food(name, price) { Product.call(this, name, price); this.category = 'food'; } let food1 = new Food('chees', 5); food1; // Food {name: \"chees\", price: 5, category: \"food\"} 可以看出，通过在 Food 构造方法里面调用 call()，成功使 Food 拓展了 name 以及 price 这两个字段。所以： 准则一：可以使用 call() 方法调用父构造函数。 例子 2： var animals = [ { species: 'Lion', name: 'King' }, { species: 'Whale', name: 'Fail' } ] for(var i = 0; i 可以看到，在匿名函数中，我们通过 call()，成功将 animals中的 this 指向到了匿名函数中，从而循环打印出了值。 准则二：使用 call() 方法调用匿名函数。 例子 3： function greet() { var reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' '); console.log(reply); } var obj = { animal: 'cats', sleepDuration: '12 and 16 hours' }; greet.call(obj); // cats typically sleep between 12 and 16 hours 准则三：使用 call() 方法调用函数并且指定上下文的 this。 最后，讲到这里，小伙伴们应该知道 call() 的一些用途了。 说到 call()，我们还要讲讲跟它相似的 apply()，其实这两者都是相似的，只是 apply() 调用的方式不同，例如： function add(a, b){ return a + b; } function sub(a, b){ return a - b; } // apply() 的用法 var a1 = add.apply(sub, [4, 2]); // sub 调用 add 的方法 var a2 = sub.apply(add, [4, 2]); a1; // 6 a2; // 2 // call() 的用法 var a1 = add.call(sub, 4, 2); 是的，apply() 只能调用两个参数：新 this 对象和一个数组 argArray。即：function.call(thisObj, [arg1, arg2]); 以上，我们知道 apply() 和 call() 都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部的 this 指向）。然后，因为这两个方法会立即调用，所以为了弥补它们的缺失，还有个方法 bind()，它不会立即调用： call()、apply() 以及 bind() 我是一个盒子！ window.onload = function() { var fn = { num: 2, fun: function() { document.getElementById(\"box\").onclick = (function() { console.log(this.num); }).bind(this); // }).call(this); // }).apply(this); } /* * 这里的 this 是 fun，所以可以正确地访问 num, * 如果使用 bind()，会在点击之后打印 2； * 如果使用 call() 或者 apply()，那么在刷新网页的时候就会打印 2 */ } fn.fun(); } 再回想下，为什么会有 call()、apply() 呢，我们还会发现它牵扯上了 this 以及箭头函数（=>），所以下面我们来了解了解吧~ 5.5 this 指向哪 返回目录 在绝大多数情况下，函数的调用方式决定了 this 的值。它在全局执行环境中 this 都指向全局对象 怎么理解呢，我们举个例子： // 在浏览器中， window 对象同时也是全局对象 conosle.log(this === window); // true a = 'apple'; conosle.log(window.a); // apple this.b = \"banana\"; console.log(window.b); // banana console.log(b); // banana 但是，日常工作中，大多数的 this，都是在函数内部被调用的，而： 在函数内部，this 的值取决于函数被调用的方式。 function showAge(age) { this.newAge = age; console.log(newAge); } showAge(\"24\"); // 24 然而，问题总会有的： 一般 this 指向问题，会发生在回调函数中。所以我们在写回调函数时，要注意一下 this 的指向问题。 var obj = { birth: 1995, getAge: function() { var b = this.birth; // 1995; var fn = function() { return this.birth; // this 指向被改变了！ // 因为这里重新定义了个 function， // 假设它内部有属于自己的 this1， // 然后 getAge 的 this 为 this2， // 那么，fn 当然奉行就近原则，使用自己的 this，即：this1 }; return fn(); } } obj.getAge(); // undefined 在这里我们可以看到， fn 中的 this 指向变成 undefined 了。 当然，我们是有补救措施的。 首先，我们使用上面提及的 call() ： var obj = { birth: 1995, getAge: function() { var b = this.birth; // 1995 var fn = function() { return this.birth; }; return fn.call(obj); // 通过 call()，将 obj 的 this 指向了 fn 中 } } obj.getAge(); // 1995 然后，我们使用 that 来接盘 this： var obj = { birth: 1995, getAge: function() { var b = this.birth; // 1995 var that = this; // 将 this 指向丢给 that var fn = function() { return that.birth; // 通过 that 来寻找到 birth }; return fn(); } } obj.getAge(); // 1995 我们通过了 var that = this，成功在 fn 中引用到了 obj 的 birth。 最后，我们还可以使用箭头函数 =>： var obj = { birth: 1995, getAge: function() { var b = this.birth; // 1995 var fn = () => this.birth; return fn(); } } obj.getAge(); // 1995 讲到这里，我们再回首 new 那块我们不懂的代码： // 1. 首先有个类型机器 function ClassMachine() { console.log(\"类型创造机器\"); } // 2. 然后我们定义一个对象物品 let thingOne = {}; // 3. 对象物品通过万能术 __proto__ 指向了类型机器的原型（即 No 2 始机器） thingOne.__proto__ = ClassMachine.prototype; // 4. ？？？ ClassMachine.call(thingOne); // 5. 定义了类型机器的动作 ClassMachine.prototype.action = function(){ console.log(\"动作创造机器\"); } // 6. 这个对象物品执行了动作 thingOne.action(); /* * Console： * 类型创造机器 * 动作创造机器 */ 很容易理解啊，在第四步中，我们将 ClassMachine 的 this 变成了 thingOne 的 this 了！ 以上，是不是感觉鬼门关走了一遭，终于成功见到了曙光！！！ 六 总结 返回目录 在开始的时候，也许有的小伙伴，看着看着会迷晕了自己！ 不要紧，我也是！ 当我跟着自己的思路，一步一步敲下来之后，我才发觉自己仿佛打通了任督二脉，对一些题目有了自己的理解。 所以，最重要的还是 折腾 啦！ 毕竟： 不折腾的前端，和咸鱼有什么区别！ 七 参考资料 返回目录 下面列举本文精选参考文章，其中一些不重要的零零散散 30 来篇文章已被刷选。 《JavaScript 世界万物诞生记》 《小邵教你玩转JS面向对象》 《js中的new()到底做了些什么？？》 《MDN Function.prototype.call()》 《JavaScript中的call、apply、bind深入理解》 《箭头函数 - 廖雪峰》 八 工具 返回目录 在线作图 Process On jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Interview/PersonalExperience/JS-防抖与节流.html":{"url":"other-library/Interview/PersonalExperience/JS-防抖与节流.html","title":"✔ 面试知识点 - JS 防抖与节流","keywords":"","body":"面试知识点 - JS 防抖与节流 Create by jsliang on 2019-2-23 20:55:34Recently revised in 2019-3-12 22:46:04 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址 本文涉及知识点： 防抖与节流 重绘与回流 浏览器解析 URL DNS 域名解析 TCP 三次握手与四次挥手 浏览器渲染页面 在本文中，jsliang 会讲解通过自我探索后关于上述知识点的个人理解，如有纰漏、疏忽或者误解，欢迎各位小伙伴留言指出。 如果小伙伴对文章存有疑问，想快速得到回复。或者小伙伴对 jsliang 个人的前端文档库感兴趣，也想将自己的前端知识整理出来。欢迎加 QQ 群一起探讨：798961601。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 防抖与节流  3.1 防抖  3.2 节流 四 重绘与回流 五 浏览器解析 URL 六 DNS 域名解析 七 TCP 三次握手与四次挥手 八 浏览器渲染页面 九 总结 十 参考文献 二 前言 返回目录 在工作中，我们可能碰到这样的问题： 用户在搜索的时候，在不停敲字，如果每敲一个字我们就要调一次接口，接口调用太频繁，给卡住了。 用户在阅读文章的时候，我们需要监听用户滚动到了哪个标题，但是每滚动一下就监听，那样会太过频繁从而占内存，如果再加上其他的业务代码，就卡住了。 所以，这时候，我们就要用到 防抖与节流 了。 那么，讲到 防抖与节流，我们可以顺带探秘下 重绘与回流。 说起 重绘与回流，我们就顺带把 浏览器输入 URL 后发生的事情 也关注一下，从而引出 DNS、TCP 等知识点，最终串起来构成本文的轮廓，方便 jsliang 和小伙伴们对这块知识的整理与记忆。 三 防抖与节流 返回目录 通过代码去了解某样事物，往往是了解某个知识点最快的形式。 3.1 防抖 返回目录 下面我们有段防抖小案例代码。 如果小伙伴们手头有电脑，并感兴趣想先自己思考下什么是防抖。可以将代码复制到浏览器，尝试点击按钮，并关注下控制台，看看 Console 是如何打印的。 如果小伙伴们手头没有电脑，那么咱一起先瞅瞅代码实现，再看看下面 GIF 演示。（这样效果没有自己敲的直白有效） 防抖 点我防抖！ window.onload = function() { // 1、获取这个按钮，并绑定事件 var myDebounce = document.getElementById(\"debounce\"); myDebounce.addEventListener(\"click\", debounce(sayDebounce)); } // 2、防抖功能函数，接受传参 function debounce(fn) { // 4、创建一个标记用来存放定时器的返回值 let timeout = null; return function() { // 5、每次当用户点击/输入的时候，把前一个定时器清除 clearTimeout(timeout); // 6、然后创建一个新的 setTimeout， // 这样就能保证点击按钮后的 interval 间隔内 // 如果用户还点击了的话，就不会执行 fn 函数 timeout = setTimeout(() => { fn.call(this, arguments); }, 1000); }; } // 3、需要进行防抖的事件处理 function sayDebounce() { // ... 有些需要防抖的工作，在这里执行 console.log(\"防抖成功！\"); } 很好，相信小伙伴们已经看完了代码，下面我们看看它的演示： 这时候，我们可以抛出防抖的概念了： 防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。 结合上面的代码，我们可以了解到，在触发点击事件后，如果用户再次点击了，我们会清空之前的定时器，重新生成一个定时器。意思就是：这件事儿需要等待，如果你反复催促，我就重新计时！ 空讲无益，show you 场景： 有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。 小伙伴们可以尝试看着上面的案例，先自己实现一遍这个场景的解决，如果感觉不行，那就看：《防抖和节流的应用场景和实现》 知识点补充：何为 arguments？首先，后端转前端的同学，可以将 arguments 理解为能实现重载函数功能的工具。然后，我们举个例子：在 function test() 这个方法中，由于我们不确定变量有多少，比如 test(\"jsliang\", 24)，又或者 test(\"LiangJunrong\", \"jsliang\", \"24\")，这时候只需要在函数 test 中用 arguments 接收就行了。最后，在 function test() { let arr1 = argument[0] } 中，arr1 就可以获取到传进来的第一个变量。所以，fn.call(this, arguments) 其实是将不确定变量替换到函数中了。 参考资料 1：《闲聊 JS 中的 apply 和 call》参考资料 2：《js 中 arguments 的用法》 3.2 节流 返回目录 说完防抖，下面我们讲讲节流，规矩就不说了，先上代码： 节流 点我节流！ window.onload = function() { // 1、获取按钮，绑定点击事件 var myThrottle = document.getElementById(\"throttle\"); myThrottle.addEventListener(\"click\", throttle(sayThrottle)); } // 2、节流函数体 function throttle(fn) { // 4、通过闭包保存一个标记 let canRun = true; return function() { // 5、在函数开头判断标志是否为 true，不为 true 则中断函数 if(!canRun) { return; } // 6、将 canRun 设置为 false，防止执行之前再被执行 canRun = false; // 7、定时器 setTimeout( () => { fn.call(this, arguments); // 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true canRun = true; }, 1000); }; } // 3、需要节流的事件 function sayThrottle() { console.log(\"节流成功！\"); } 很好，看完代码的小伙伴应该大致清楚是怎么回事了，下面我们看 GIF 实现： 看完代码和 GIF 实现，我们可以明白，节流即是： 节流：指定时间间隔内只会执行一次任务。 那么，节流在工作中的应用？ 懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取。 用户点击提交按钮，假设我们知道接口大致的返回时间的情况下，我们使用节流，只允许一定时间内点击一次。 这样，在某些特定的工作场景，我们就可以使用防抖与节流来减少不必要的损耗。 那么问题来了，假设面试官听到你这句话，是不是会接着问一句：“为什么说上面的场景不节制会造成过多损耗呢？” OK，这就涉及到浏览器渲染页面的机制了…… 四 重绘与回流 返回目录 在说浏览器渲染页面之前，我们需要先了解两个点，一个叫 浏览器解析 URL，另一个就是本章节将涉及的 重绘与回流： 重绘(repaint)：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此损耗较少。 常见的重绘操作有： 改变元素颜色 改变元素背景色 more …… 回流(reflow)：又叫重排（layout）。当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。 常见的回流操作有： 页面初次渲染 浏览器窗口大小改变 元素尺寸/位置/内容发生改变 元素字体大小变化 添加或者删除可见的 DOM 元素 激活 CSS 伪类（:hover……） more …… 重点：回流必定会触发重绘，重绘不一定会触发回流。重绘的开销较小，回流的代价较高。 看到这里，小伙伴们可能有点懵逼，你刚刚还跟我讲着 防抖与节流 ，怎么一下子跳到 重绘与回流 了？ OK，卖个关子，先看下面场景： 界面上有个 div 框，用户可以在 input 框中输入 div 框的一些信息，例如宽、高等，输入完毕立即改变属性。但是，因为改变之后还要随时存储到数据库中，所以需要调用接口。如果不加限制…… 看到这里，小伙伴们可以将一些字眼结合起来了：为什么需要 节流，因为有些事情会造成浏览器的 回流，而 回流 会使浏览器开销增大，所以我们通过 节流 来防止这种增大浏览器开销的事情。 形象地用图来说明： 这样，我们就可以形象的将 防抖与节流 与 重绘与回流 结合起来记忆起来。 那么，在工作中我们要如何避免大量使用重绘与回流呢？： 避免频繁操作样式，可汇总后统一一次修改 尽量使用 class 进行样式修改，而不是直接操作样式 减少 DOM 的操作，可使用字符串一次性插入 OK，至此我们就讲完两个部分了，那么问题又来了：“浏览器渲染过程中，是不是也有重绘与回流？”“从浏览器输入 URL 到渲染成功的过程中，究竟发生了什么？” 我们，继续深入探索…… 五 浏览器解析 URL 返回目录 为了能让我们的知识层面看起来更有深度，我们应该考虑下面两个问题了： 从浏览器输入 URL 到渲染成功的过程中，究竟发生了什么？ 浏览器渲染过程中，发生了什么，是不是也有重绘与回流？ OK，兴致来了，我们就先从 浏览器解析 URL 看起，先来看看当用户输入 URL，到浏览器呈现给用户页面，经历了以下过程： 版本 A： 用户输入 URL 地址。 对 URL 地址进行 DNS 域名解析。 建立 TCP 连接（三次握手）。 浏览器发起 HTTP 请求报文。 服务器返回 HTTP 响应报文。 关闭 TCP 连接（四次挥手）。 浏览器解析文档资源并渲染页面。 讲到这里，突然想起一个对话： 学生：“老师，这门课的考试重点是什么？” 老师：“全都是重点！” enm...老师会不会被打我不知道，但是 jsliang 这样写会被怼我就清楚，所以，咱还是结合上面的图，进一步勾勒我们的结构： 很好，jsliang 感觉自己的画图技术又进了一步~ ①：虽然很感激网上有那么多的文章可以参考，但是在我查了二十来篇文章后，jsliang 觉得这部分十有八九有问题撒，问了些小伙伴，它们有的说对，有的说错。不过，不妨碍小伙伴们继续往下看哈。②：为了避免出篓子，下面贴出另外一个版本，小伙伴们可以在评论区说出你支持哪个版本哈： 版本 B 用户输入 URL 地址。 对 URL 地址进行 DNS 域名解析。 进行 TCP 连接。 进行 HTTP 报文的请求与响应。 浏览器解析文档资源并渲染页面。 在这里我们可以清晰的了解到从 用户输入 URL，到浏览器呈现给用户页面，经历了哪些过程。 那么剩下的就简单了： 什么是 DNS 解析，它是怎么个流程？ 什么是 TCP 三次握手，什么是 TCP 四次挥手，它们的流程是怎样的？ 浏览器解析文档资源并渲染页面是个怎样的流程？ Let's go~ 逐步完成下面三个知识点！ 参考文献 1：《网页解析的全过程(输入url到展示页面)》参考文献 2：《浏览器渲染页面过程剖析》 六 DNS 域名解析 返回目录 首先，我们解决第一个问题： 什么是 DNS 解析，它是怎么个流程？ DNS（Domain Name System）是 域名系统 的英文缩写，提供的服务是用于将主机名和域名转换为 IP 地址的工作： 域名：http://jsliang.top DNS IPV4：119.147.15.13 IPV4 是造假的，仅用来说明 DNS 解析后能返回 IP 地址 所以，当用户在浏览器输入 http://jsliang.top 时，DNS 经历了以下步骤： 浏览器根据地址，在自身缓存中查找 DNS（域名服务器） 中的解析记录。如果存在，则直接返回 IP 地址；如果不存在，则查找操作系统中的 hosts 文件是否有该域名的 DNS 解析记录，如果有就返回。 在条件 1 中的浏览器缓存或者操作系统的 hosts 文件中都没有这个域名的 DNS 解析记录，或者已经过期，则向域名服务器发起请求解析这个域名。 先向本地域名服务器中请求，让它解析这个域名，如果解析不了，则向根域名服务器请求解析。 根服务器给本地域名服务器返回一个主域名服务器。 本地域名服务器向主域名服务器发起解析请求。 主域名服务器接收到解析请求后，查找并返回域名对应的域名服务器的地址。 域名服务器会查询存储的域名和 IP 的映射关系表，返回目标 IP 记录以及一个 TTL（Time To Live）值。 本地域名服务器接收到 IP 和 TTL 值，进行缓存，缓存的时间由 TTL 值控制。 将解析的结果返回给用户，用户根据 TTL 值缓存在本地系统缓存中，域名解析过程结束。 看文字总是难以理解的，跟着 jsliang 画张图过一遍，就感觉清晰了： 七 TCP 三次握手与四次挥手 返回目录 然后，我们解决第二个问题： 什么是 TCP 三次握手，什么是 TCP 四次挥手，它们的流程是怎样的？ 什么是 TCP 呢？TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 简单来说，它的作用就是将数据流从一台主机可靠地传输到另一台主机。 至于具体的工作原理，这里暂时涉及不到，我们目前只想知道两个点：三次握手与四次挥手。 三次握手： 第一次握手：起初两端都处于 CLOSED 关闭状态，Client 将标志位 SYN 置为 1，随机产生一个值 seq = x，并将该数据包发送给 Server，Client 进入 SYN-SENT 状态，等待 Server 确认。 第二次握手：Server 收到数据包后由标志位 SYN = 1 得知 Client 请求建立连接，Server 将标志位 SYN 和 ACK 都置为 1，ack = x + 1，随机产生一个值 seq = y，并将该数据包发送给Client以确认连接请求，Server 进入 SYN-RCVD 状态，此时操作系统为该 TCP 连接分配 TCP 缓存和变量。 第三次握手：Client 收到确认后，检查 seq 是否为 x + 1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack = y + 1，并且此时操作系统为该 TCP 连接分配 TCP 缓存和变量，并将该数据包发送给 Server，Server 检查 ack 是否为 y + 1，ACK 是否为 1，如果正确则连接建立成功，Client 和 Server 进入 established 状态，完成三次握手，随后 Client 和 Server 就可以开始传输数据。 文字太乱，show you picture： 四次挥手： 第一次挥手：Client 的应用进程先向其 TCP 发出连接释放报文段（FIN = 1，序号 seq = u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN-WAIT-1（终止等待1）状态，等待 Server 的确认。 第二次挥手：Server 收到连接释放报文段后即发出确认报文段，（ACK = 1，确认号 ack = u + 1，序号 seq = v），Server 进入 CLOSE-WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，Client 到 Server 的连接释放。 注：Client 收到 Server 的确认后，进入 FIN-WAIT-2（终止等待2）状态，等待 Server 发出的连接释放报文段。 第三次挥手：Server 已经没有要向 Client 发出的数据了，Server 发出连接释放报文段（FIN = 1，ACK = 1，序号 seq = w，确认号 ack = u + 1），Server 进入 LAST-ACK（最后确认）状态，等待 Client 的确认。 第四次挥手：Client 收到 Server 的连接释放报文段后，对此发出确认报文段（ACK = 1，seq = u + 1，ack = w + 1），Client 进入 TIME-WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，Client 才进入 CLOSED 状态。 文字太乱，show you picture： OK，至此我们就理解了 TCP 及其三次握手和四次挥手过程，为了方便小伙伴们形象记忆，jsliang 搞了个小故事，希望小伙伴们能加深印象： 三次握手 + 四次挥手形象记忆： jsliang：（对妹子发起微信好友申请）“你好，我可以加你好友吗？” —— 第一次握手 妹子：（通过审核）“你好，很高兴认识你~” —— 第二次握手 jsliang：“你好，我叫梁峻荣，前端折腾小能手……” —— 第三次握手 ……（聊天内容） …………（聊天内容） ………………（聊天内容） …………（聊天内容） ……（聊天内容） jsliang：（感冒拍了张纸篓都是纸巾的图）“啊，好难受今天。” —— 第一次挥手 妹子：“卧槽，你好恶心！” —— 第二次挥手 妹子：“咱还是当不认识吧，互删了，谢谢！” —— 第三次挥手 jsliang：（呆）“不是，你听我说！” —— 第四次挥手 妹子：（果断删除好友） —— CLOSED jsliang：（！“我今天感冒了。” 妹子开启了好友验证，你还不是她好友。请先发送好友验证请求，对方验证通过后，才能聊天。） ——— CLOSED OK，成功出糗，相信小伙伴们有了个很好的了解了。 那么，我们继续前行探索。 参考文献 1：《TCP三次握手和四次挥手过程》参考文献 2：《TCP的三次握手与四次挥手（详解+动图）》 八 浏览器渲染页面 返回目录 最后，我们解决第三个问题： 浏览器解析文档资源并渲染页面是个怎样的流程？ 话不多说，一起来看： 浏览器通过 HTMLParser 根据深度遍历的原则把 HTML 解析成 DOM Tree。 浏览器通过 CSSParser 将 CSS 解析成 CSS Rule Tree（CSSOM Tree）。 浏览器将 JavaScript 通过 DOM API 或者 CSSOM API 将 JS 代码解析并应用到布局中，按要求呈现响应的结果。 根据 DOM 树和 CSSOM 树来构造 render Tree。 layout：重排（也可以叫回流），当 render tree 中任一节点的几何尺寸发生改变，render tree 就会重新布局，重新来计算所有节点在屏幕的位置。 repaint：重绘，当 render tree 中任一元素样式属性（几何尺寸没改变）发生改变时，render tree 都会重新画，比如字体颜色，背景等变化。 paint：遍历 render tree，并调动硬件图形 API 来绘制每个节点。 文字讲解肯定还是不够清晰的，但是 jsliang 画了几张图也累了，所以咱们 盗 来了一张图： 这样，我们就对 浏览器渲染页面过程 一清二楚啦~ 参考文献：《一篇文章搞定前端面试》 九 总结 返回目录 至此，我们回顾下自己做了什么？ 我们在工作中碰到一些问题，这些问题会卡住页面，于是我们查资料，知道想要减少浏览器的开销，我们就需要使用 防抖与节流。 使用 防抖与节流 解决完问题后，我们好奇为什么会有这样的操作，于是我们深入了解了下 重绘与回流。 重绘与回流 只告诉了我们浏览器在 CSS 上的渲染，我们需要进一步了解 浏览器渲染页面 的详细过程，但洋葱还是要一层一层剥开的，所以我们需要从 浏览器解析 URL 开始了解。 在 浏览器解析 URL 中，我们顺带了解下 DNS 域名解析、TCP 三次握手与四次挥手 这两个知识点。 最后，我们终于知道了 浏览器渲染页面 是怎么一回事。 综上，如果我们仅仅是需要关注面试的一个点，我们很可能因为不知头尾，而被面试官问得哑口无言。 但是，如果我们知道一个知识点，并对其进行思路发散，深入学习，相信面试官问起来的时候，小伙伴们就可以侃侃而谈，而不会被问地体无完肤了！ 最后祝小伙伴们找到合适的满意的工作~ 十 参考文献 返回目录 《函数防抖和节流》 《节流 & 防抖》 《JS奇淫巧技：防抖函数与节流函数》 《闲聊 JS 中的 apply 和 call》 《js 中 arguments 的用法》 《防抖和节流的应用场景和实现》 《网页解析的全过程(输入url到展示页面)》 《浏览器渲染页面过程剖析》 《一篇文章搞定前端面试》 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Interview/PersonalExperience/Other-图片.html":{"url":"other-library/Interview/PersonalExperience/Other-图片.html","title":"✔ 面试知识点 - 图片","keywords":"","body":"面试知识点 - 图片 Create by jsliang on 2019-3-1 13:27:47Recently revised in 2019-3-5 21:35:45 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址 在我们日常工作中，我们会经常使用 JPG、PNG、GIF、SVG 等格式图片。 但是，你真的懂图片吗？不同格式图片的区分，它们的优劣势以及使用场景等…… 下面，jsliang 将根据搜集的资料，进行关于图片的科普。 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文  3.1 BMP  3.2 JPEG  3.3 PNG  3.4 GIF  3.5 SVG  3.6 Base64  3.7 WebP  3.8 雪碧图 四 总结 五 参考文献 二 前言 返回目录 在 jsliang 2 月 27 日进行面试的时候，突然被一个系列的问题问倒了：你熟悉图片吗？能讲讲 JPG、PNG、GIF 的适用场景吗？然后 PNG 为什么会有 PNG-8 和 PNG-24？知道 SVG 吗？能讲讲它们与 JPG、PNG、GIF 的差别吗？…… 刚开始 jsliang 还能回答下，后来就感觉招架不住了！ 于是，爱折腾 的我回头就是一个查资料，写下了这篇文章。 三 正文 返回目录 首先，我们要清楚的是，图片从类型上分，可以分为 位图 和 矢量图。 位图：位图又叫点阵图或像素图，计算机屏幕上的图是由屏幕上的发光点（即像素）构成的，每个点用二进制数据来描述其颜色与亮度等信息。因为这些点是离散的，类似于点阵，同时因为多个像素的色彩组合就形成了图片，所以叫这种图为点阵图或者位图。常见位图有 JPG、PNG、GIF 等格式。 矢量图：矢量图又叫向量图，它是由一系列计算机指令来描述和记录一幅图，一幅图可以解为点、线、面等组成的子图。生成的矢量图文件存储量很小，特别适用于文字设计、图案设计等，而在前端中比较常用的矢量图有 SVG 等格式…… 然后，我们按压缩划分，可以将图片分为 无损压缩 和 有损压缩。 无损压缩：无损压缩是对文件本身的压缩，使图片占用的存储空间变小，并且不会损害图片的质量。常见无损压缩有 PNG 等。 有损压缩：有损压缩是对图像本身的改变，会对图片质量造成损害，随着压缩次数越来越多，那么图片质量会越来越差。常见有损压缩有 JPG 等。 最后，究根结底，我们需要知道在计算机中，像素是用二进制来表示的。不同图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，那么它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。 一个二进制位表示两种颜色 【 0|1 黑|白 】，如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 中颜色。例如： PNG-8：它有 2^8 种颜色，即 256 种颜色。 PNG-24：它有 2^24 种颜色，即 1677216 种颜色（1600 万种颜色）。 OK，知道了这些基础知识，我们就按图片出现的顺序，一一讲解下常用的图片知识吧！ 3.1 BMP 返回目录 早期使用的图片格式，叫 BMP，取自英文单词 BitMap，Windows 中文版译作 位图，它的文件结构很简单，没有压缩，一个一个像素地记录下来。 如果你的系统是 Windows，你可以打开 画图 工具，然后点击另存为，你可以看到保存的选项中有个 24位位图 的格式，即 1600 万色的图片。 当然，历史总在前进，BMP 这种没有压缩的图片格式，逐渐被后起之秀代替了。 不知道为什么，查不到 JPG、PNG、GIF 的出现顺序，下面只好按我个人记忆方式来编文章段落。 3.2 JPEG 返回目录 关键字：有损压缩、体积小、加载快、不支持透明 简要介绍： JPEG/JPG 格式，是应用最广泛的图片格式之一，特点如下： JPEG/JPG 采用特殊的有损压缩算法，将不易被人眼察觉的图像颜色删除，从而达到较大的压缩比，因此它的压缩文件尺寸较小，下载速度快，成为互联网最广泛使用的格式。 JPEG/JPG 因为属于有损压缩，所以当压缩级别逐渐增大的时候，图片质量会逐渐损耗，所以压缩要适当。 在合适的场景下，即便我们将图片体积压缩至原有体积的 50% 以下，JPG 仍能保持住 60% 的品质，且因为 JPG 格式以 24 位图存储单个图，可以呈现多达 1600 万种颜色，足以满足大多数场景， 适用场景： 大的背景图 轮播图 Banner 图 3.3 PNG 返回目录 关键字：无损压缩、质量高、体积大、支持透明 简要介绍： PNG（可移植网络图形格式）是一种无损压缩的高保真的图片格式，它的压缩比高于 GIF，支持图像透明，可以利用 Alpha 通道调节图像透的明度。 PNG 分 PNG-8 和 PNG-24。 PNG-8：PNG-8 是无损压缩的索引色彩模式。PNG-8 是 GIF 格式很好的替代，虽然不能像 GIF 一样有动画，也不兼容 IE6 等老旧浏览器。PNG-8 最多支持 256 中颜色。 PNG-24：PNG-24 是无损压缩的直接色彩模式。PNG-24 会比 JPEG、GIF、PNG-8 占用更大的存储空间。PNG-24 可以呈现 1600 万种颜色。 2^8 = 256，2^24 = 1677216 适用场景： 普遍场景 小的 Logo，颜色简单且对比强烈的图片或者背景。 颜色简单、对比度强的透明小图。 什么时候使用 PNG-8，什么时候使用 PNG-24 呢？ 理论上，位数最大的就是最好的，直接上 PNG-24；但是实际上，为了避免体积过大的问题，一般在适合使用 PNG 的场景中，优先选择比较小巧的 PNG-8。 如何确定是使用 PNG-8 还是 PNG-24，这就看你的 UI 设计师或者负责人能接受那个了，除非你设计功底非常好，要不然不要做这个选择！ 3.4 GIF 返回目录 关键字：支持动画 简要介绍： GIF 格式，不仅仅支持静止图片，也可以支持动画，并且支持透明背景图像，适用于多种操作系统，体积很小，网上小动画很多是 GIF 格式。但是色域不太广，只支持 256 种颜色，这意味着颜色种类少。 GIF 格式的压缩率一般在 50% 左右。 适用场景： 动图 3.5 SVG 返回目录 关键字：文本文件、体积小、不失真、兼容性好 简要介绍： SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式，是可缩放的矢量图形。与 JPG、PNG、GIF 等位图不同，SVG 可以直接用代码来描绘图像，并通过任意文字处理工具打开 SVG 图像，通过改变部分代码来使图像具有交互功能，并可以随时插入到 HTML 中通过浏览器来观看。 SVG 格式的图片可以任意放大图形显示，并且不会损失图片质量；SVG 格式可编辑和可搜寻；SVG 格式平均来讲，比 JPG 和 GIF 格式文件要小，并且下载也比较快。 SVG 文件通常是极小的，但是当图形的复杂度变高的时候，SVG 文件大小会随之上升，因为 SVG 在渲染的时候需要比像素图更多的计算能力，这也意味着性能的损耗。所以在 Logo 等图上，应尽可能简洁。 适用场景： SVG loading 效果图：SVG-Loaders 转换工具：在线 JPG、PNG 转 SVG 工具 矢量图标库：阿里巴巴矢量图标 3.6 Base64 返回目录 关键字：文本文件、依赖编码、小图标解决方案 简要介绍： Base64 并非一种图片格式，而是一种编码方式，它类似于雪碧图，是作为小图标解决方案而存在的。和雪碧图一样，Base64 图片的出现，也是为了减少加载网页图片时对服务器的请求次数，从而提升网页性能。Base64 是作为雪碧图的补充而存在的。 Base64 是一种用于传输 8 Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。 适用场景： 图片的实际尺寸很小。尽可能在图片不超过 2KB 的情况下（可查看掘金的 Base64 图）。 图片无法以雪碧图的形式与其他小图结合（合成雪碧图仍是主要的减少 HTTP 请求的途径，Base64 是雪碧图的补充）。 图片的更新频率非常低（不需要我们重复编码和修改文件内容，维护成本较低） 为什么大图不使用 Base64？因为 Base64 编码后，图片大小会膨胀为源文件的 4/3，如果将大图编码到 HTML 或者 CSS 中，这样后者的体积增加，即便减少了 HTTP 请求，也无法弥补庞大的体积带来的性能开销。 如何获取： Webpack 的 loader：url-loader 在线编码工具：图片转换Base64 3.7 WebP 返回目录 关键字：年轻的全能型选手 简要介绍： 2010 年由 Google 提出，转为 Web 开发的一种旨在加快图片加载速度的图片格式，支持有损压缩和无损压缩。 WebP 像 JPEG 一样对图片细节丰富，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片。 官方介绍：与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。 无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。 适用场景： 由于 WebP 支持情况仅 Chrome、UC 等几家浏览器支持，所以局限性较大，目前暂不考虑使用。 参考自 Can I Use 网站中的浏览器支持程度：webp 3.8 雪碧图 返回目录 雪碧图，CSS Sprites，听起来就很清爽的一种图片，刚开始的时候 jsliang 以为是大街小巷上卖的 3 块钱瓶装雪碧饮料上的图片，后来知道压根不是同一码事。 雪碧图不属于图片格式，而是一种图片应用形式。但是因为它在前端赫赫有名，经常使用，故此将其记载下来。 雪碧图又叫精灵图，因为 Sprites 的原因叫 “雪碧”，出现的原因是随着网速的提升，同时因为请求次数过多的时候会卡网页，所以我们就将 N 张小图集成到一张大图上，从而提升页面打开的速度。这种多张小图放在一张大图上的操作，就叫做精灵图（雪碧图 - CSS Sprites） 那么，平时如何使用雪碧图呢？ .img{background:url(../images/img.png) no-repeat;} .my-head{height:160px;width:120px;background-position:0 0;} .my-picture{height:292px;width:1253px;background-position:0 -160px;} @mixin img{background:url(../images/img.png) no-repeat; } @mixin my-head{height:160px;width:120px;background-position: 0 0;} @mixin my-picture{height:292px;width:1253px;background-position: 0 -160px;} 如上面代码所示，现在网上有非常多的雪碧图制作工具，我们只需要将小图发到工具上去，就可以生成大图，同时获得它的 css/sass 代码，而不需要自己一个一个定位。 这是 Windows 版本的工具，网上有很多雪碧图/精灵图制作工具，这里就不推荐本人使用的了。 MDN 定义：图像精灵（sprite，意为精灵），被运用于众多使用大量小图标的网页应用之上。它可取图像的一部分来使用，使得使用一个图像文件替代多个小文件成为可能。相较于一个小图标一个图像文件，单独一张图片所需的 HTTP 请求更少，对内存和带宽更加友好。 四 总结 返回目录 至此，我们对图片的介绍就结束了，在这里我们列个表进行汇总： 格式 使用场景 JPG/JPEG 1. 大的背景图； 2. 轮播图； 3. Banner 图 PNG 1. 小 Logo； 2. 透明背景 GIF 动态图片 SVG 能适应不同设备且画质不能损坏的图片 Base64 大小不超过 2KB，且更新率低的图片 雪碧图 小图太多的时候，集中成一张图片减少 HTTP 请求 雪碧图不属于格式，但属于一种应用形式 最后，在开发中会常用到一些资料，下面是 jsliang 在图片方面的个人资源，如果小伙伴有其他的好用资源推荐，可以 QQ 或者评论留言： 常用优秀资源： SVG loading 效果：SVG-Loaders 矢量图标库：Iconfont-阿里巴巴矢量图标库 在线制作 Logo：U 钙网 压缩 PNG 或者 JPG：TinyPNG 获取图片素材： 千库网：地址 包图网：地址 在线转换工具： JPG、PNG 转 SVG JPG、PNG、GIF 转 Base64 JPG、PNG、GIF 转 ICO 其他资料支持： Can I Use —— 查看各种浏览器支持程度：caniuse.com 五 参考文献 返回目录 《jpg、png、svg、gif等图片格式的区别》 《PNG、JPEG、GIF、SVG应该用哪个？》 《图片优化——质量与性能的博弈》 《横向对比 gif、jpeg、png、svg，教你如何合理选择图像格式》 《JPG？GIF？PNG？前端如何选择图片格式？》 《矢量图与位图的区别》 《无损压缩和有损压缩是数码图像文件压缩的两种类型。》 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/LeetCode/":{"url":"other-library/LeetCode/","title":"LeetCode","keywords":"","body":"LeetCode Create by jsliang on 2019-5-16 22:12:29Recently revised in 2019-5-16 22:31:12 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 简单难度攻略 四 中等难度攻略 五 困难难度攻略 二 前言 返回目录 LeetCode 是个题库，里面有很编程多面试的题目，可以在线编译运行。 在这里，你可以使用 C、C++、Java、Python、PHP、JavaScript 共 14 种编程语言进行解题。 在这里，你可以接触到许许多多算法相关的知识，并且提升自己的职业竞争能力，在面试的时候秀一秀自己的代码。 三 简单难度攻略 返回目录 题目 原题地址 解题攻略 001 - 两数之和（two-sum） #1 原题 #1 解题 007 - 整数反转（reverse-integer） #7 原题 #7 解题 四 中等难度攻略 返回目录 暂无 五 困难难度攻略 返回目录 暂无 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 09:46:49 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/LeetCode/Easy/":{"url":"other-library/LeetCode/Easy/","title":"LeetCode - 简单模式","keywords":"","body":"LeetCode - 简单模式 Create by jsliang on 2019-05-20 18:59:51Recently revised in 2019-05-20 18:59:55 LeetCode 简单难度攻略 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:03:21 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/LeetCode/Easy/001-两数之和（two-sum）.html":{"url":"other-library/LeetCode/Easy/001-两数之和（two-sum）.html","title":"✔ 001 - 两数之和（two-sum）","keywords":"","body":"001 - 两数之和（two-sum） Create by jsliang on 2019-05-16 22:19:13Recently revised in 2019-05-17 15:10:49 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 LeetCode 攻略地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 解题  3.1 解法 - for()  3.2 解法 - indexOf()  3.3 解法 - Map 二 前言 返回目录 难度：简单 涉及知识：数组、哈希表 题目地址：https://leetcode-cn.com/problems/two-sum/ 题目内容： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 三 解题 返回目录 官方题解：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/ 解题千千万，官方独一家，上面是官方使用 Java 进行的题解。 小伙伴可以先自己在本地尝试解题，再看看官方解题，最后再回来看看 jsliang 讲解下使用 JavaScript 的解题思路。 3.1 解法 - for() 返回目录 解题代码： var twoSum = function(nums, target) { for (let i = 0; i 执行测试： nums：[1, 3, 2, 5, 6] target: 8 return： [1, 3] 解题思路：使用双重 for 循环破解。 第一遍过滤 nums 数组，标记为 i。 第二遍再次过滤 nums 数组，标记为 i + 1，因为我们是对数组中的两个数字相加，所以不能重复使用同一个数字。 判断第二次遍历的数字中，它是否等于 target - nums[i]，如果成立就返回两个数字的索引。（并不考虑后面还有可成立的答案）。 3.2 解法 - indexOf() 返回目录 解题代码： var twoSum = function(nums, target) { let result = []; nums.map((item, index) => { if (nums.indexOf(target - item) > -1 && nums.indexOf(target - item) != index) { result = [index, nums.indexOf(target - item)].sort((a, b) => a > b); } }); return result; }; 执行测试： nums：[4, 3, 2, 5, 6] target: 8 return： [2, 4] 知识点： map()：遍历数组，item 返回遍历项，index 返回当前索引。map() 详细介绍 indexOf()：判断数组中是否存在判断条件中的值。如果存在，则返回第一次出现的索引；如果不存在，则返回 -1。indexOf() 详细介绍 sort()：排序，保持返回数组的数字为顺序排列。sort() 详细介绍 解题思路： 首先，我们开辟一块内存 result。 然后，我们通过 map() 遍历 nums，并使用 indexOf() 寻找除当前 item 的 index 之外和 item 相加之和为 target 的结果。 最后，我们返回查找的最新结果，该结果进行了排序（[4, 2] 的返回通过 sort() 排序变成 [2, 4]） 例如，在上面测试 twoSum([1, 3, 2, 5, 6], 8) 的结果就有： [1, 3] [2, 4] [3, 1] [4, 2] 我们取最后一次的结果并排序返回，即：[2, 4] 进一步思考：如果我们将 map() 换成 for()，你知道该如何操作么？ 3.3 解法 - Map 返回目录 解题代码： var twoSum = function(nums, target) { let map = new Map(); for (let i = 0; i 执行测试： nums：[4, 3, 2, 5, 6] target: 8 return： [1, 3] 知识点： Map：保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。Map 详细介绍 解题思路： 首先，我们需要了解 Map 这个对象。 它可以通过 set() 的形式，以 [key, value] 的形式保存一组数据。（题目中对应 key 就是存入的 target - nums[i] 值，value 就是索引） 它可以通过 get() 的形式，获取到传入 key 值对应的 value。 它可以通过 has() 的形式，判断 Map 对象里面是否存储了传入 key 对应的 value。 然后，我们遍历 nums 数组。 最后，我们判断 nums[i] 是否存在于 Map 对象中。没有的话，就存入 target - nums[i] 到 Map 中。有的话，因为上次存入的是 target- nums[i]，有点类似于解题的钥匙，既然我们看到 nums[i] 存在于 Map 中，它是解题的钥匙，所以我们只需要返回 [map.get(nums[i]), i] 这组值即可。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:06:50 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/LeetCode/Easy/007-整数反转（reverse-integer）.html":{"url":"other-library/LeetCode/Easy/007-整数反转（reverse-integer）.html","title":"✔ 007 - 整数反转（reverse-integer）","keywords":"","body":"007 - 整数反转（reverse-integer） Create by jsliang on 2019-05-19 09:42:39Recently revised in 2019-05-19 16:04:13 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 LeetCode 攻略地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 解题  3.1 解法 - 转字符串  3.2 解法 - 数学算法 二 前言 返回目录 难度：简单 涉及知识：数组、数学 题目地址：https://leetcode-cn.com/problems/reverse-integer/ 题目内容： 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 三 解题 返回目录 官方题解：https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/ 解题千千万，官方独一家，上面是官方使用 C++ / Java 进行的题解。 小伙伴可以先自己在本地尝试解题，再看看官方解题，最后再回来看看 jsliang 讲解下使用 JavaScript 的解题思路。 3.1 解法 - 转字符串 返回目录 解题代码： var reverse = function(x) { // 转数组 let numberToArray = String(Math.abs(x)).split(''); // 转字符串 let result = ''; for (const i = 0; i 0 ? Number(result) : - Number(result); // 超 [-Math.pow(2, 31), Math.pow(2, 31) - 1] 判断 if (result > Math.pow(2, 31) - 1 || result 执行测试： x：-1234 return： -4321 LeetCode Submit： ✔ Accepted ✔ 1032/1032 cases passed (88 ms) ✔ Your runtime beats 99.53 % of javascript submissions ✔ Your memory usage beats 46.01 % of javascript submissions (35.8 MB) 知识点： String：将其他值转成字符串。String 详细介绍 Number：将其他值转成数字值。Number 详细介绍 pop()：pop() 方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。pop() 详细介绍 Math：JS 中的内置对象，具有数学常数和函数的属性和方法。Math 详细介绍 解题思路： 首先，将传入的数字 x 转换成字符串，并分割成数组。 然后，遍历该数组，将最后一个取出来放到 result 中。 最后，判断这个 result 是否超过题目限制，如果超过则变成 0 。 进一步思考： 3.2 解法 - 数学算法 返回目录 解题代码： var reverse = function(x) { let result = 0; let y = Math.abs(x); while (y != 0) { result = result * 10 + y % 10; y = Math.floor(y / 10); if (result > Math.pow(2, 31) - 1 || result 0 ? result : -result; }; 执行测试： x：-1234 return： -4321 LeetCode Submit： ✔ Accepted ✔ 1032/1032 cases passed (108 ms) ✔ Your runtime beats 97.4 % of javascript submissions ✔ Your memory usage beats 23.63 % of javascript submissions (36 MB) 知识点： Math：JS 中的内置对象，具有数学常数和函数的属性和方法。Math 详细介绍 解题思路： 首先，我们初始化数值。 然后，我们需要知道的是，一个数对 10 取余，可以得到这个数的个位数；一个数乘于 10 并加上一个个位数，可以将这个数字放到末尾。 最后，我们判断一开始传入的数值正负，再返回对应结果即可。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 19:05:33 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Monologue/":{"url":"other-library/Monologue/","title":"独白","keywords":"","body":"独白 Create by jsliang on 2018-11-3 11:21:35Recently revised in 2019-4-20 19:07:53 2019 【04-20】 人都有一个娱乐忍耐值，我的估计就是 3 周！今天忍不住出去逛逛了。 【04-03】 也许你压根不明白你想要什么，但是没关系，跑起来再说，时间很宝贵！ 【03-23】 兔死狗烹，你最终会碰到人性邪恶的一面的。不管怎样，撑住！ 【01-21】 别老是让一个人积极，以为这是应该的。不只是你希望得到更好的关爱，关爱你的那个也是。 2018 【12-17】 解决 bug 寻求答案就是破案，先找机器人(就是百度、google)，因为它们答案是死的，可能提供不了线索给你。然后就是问群，群里都是 pass by，就是一堆路人，就好比你玩游戏，要触发隐藏任务，肯定要跟路人打交道。接着就是问大佬，当然你的问题要谨慎，假如你连续三次问大佬你吃饭了吗，肯定就会被屏蔽了(就是别问大佬白痴问题！)。最后就得绕路了，因为你实在解决不了了，倒不如找找另一条路，例如跳个崖就找到绝世武功什么的。 【12-16】 这两天都在看这部小说。也许在别人眼里，这是堕士气、懒筋骨、没志气……但好生一想却又毫无道理。人生有穷日，代码无穷时，连自己喜欢的事情都没法干了，我还剩什么？捧着部手机，看着那些文字中的奥秘，想着能不能找到作者，将它脑子剖开看看是如何构造才会有如此精妙的思路……再说回写文章的事儿，我觉得自己写的文章路人从来没有资格 批评，因为我不认识它们，我也不知道它们评论是心存理论，还是鄙视。爱不爱接受它们的点评是我的事儿。捧杀捧杀，从不来捧，何来杀的资格。将心中所想写成文，将文成所感分享于人，撰文的目的向来就这么简单罢了，可惜我至今方才领悟。 【12-15】 这部小说，叫 《将夜》。我现在的状态，颇为神奇，整个人思维有点凌乱……或许不能为乱，是思维有所超脱，精神有所升华，世间竟有如此思路的故事，教人难以自拔。 【12-12】 非常同意 写文章时间 = 学习敲代码的时间 1.5* 😂 说真的，要把学到的东西消化后打出让别人懂的文章是非常耗费时间的。  更何况，还要肯整理分享出来。 那些只会评论说别人没有技术的键盘侠，怎不想想都工作这么久还是只能看别人整理的文章跟留言而已​​... 个人非常欣赏肯知识分享的作者，加油加油~ 👍 ——来自掘金的评论，看完无比感动 【11-08】 前端有多折腾？【10-25】 想起一个 Vue + Koa2 + MongoDB 搭建商城，于是就开始搭建商城，然后搭建到一半，发现 Vue 的基础太差了,于是 【10-29】 去整 Vue 基础知识，期间发现 Vue 学习中，Axios 也是个学习点，但是 Axios 需要点基础后端支撑，所以【11-08】准备整点 Node 知识，开个 Koa 基础学学，好配合 Axios…… 【11-05】 今天，发表 Vue 的文章，收到了褒贬不一的评价，这里引用其话语：“我现在 觉得看别人的技术书籍都没有官方的好.因为别人吃过一遍，可能还没有消化好就出来欺世盗名...然后我们看他写的...学到的就更少了”、“为什么不直接翻官方文档，然后再以别人的技术文章为辅”。再三咀嚼这话，我觉得还是有道理的，就好比我在文章开头，都会说明我参考了哪里的视频，哪里的文章，最后还特意引用了官方文档。而我写文章的目的，仅仅是为了加深我的印象，并且将我的学习、工作经验分享出来，让其他人看了，可以减少重复躺坑时间。 【11-04】 工作中有效的规划能让你更好地进步。 【11-04】 给自己点独处时间，独处能让你更好应对生活。 【11-03】 你听别人说话，看别人的文章，总觉得有那么丁点道理，但是回头你又忘了道理在哪。 【11-03】 你需要的是沉淀，而不用急着向别人说你正在努力，不需要。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Monologue/GitHubRunawayRace.html":{"url":"other-library/Monologue/GitHubRunawayRace.html","title":"✔ 暴走前端 - GitHub 竞赛","keywords":"","body":"暴走前端 - Github 竞赛 Create by jsliang on 2018-12-17 08:16:35Recently revised in 2019-05-16 10:19:13 不折腾的前端，和咸鱼有什么区别！ 一 竞赛宣言 这是一个竞赛，目标是让你成长，顺带让 GitHub Contribution 长成青青草原。 只要你提供 GitHub 账号，只要你记录自己的成长，就可以参加！ 二 竞赛规则 需提供一个仅包含 README.md 的仓库，或者在自己的文档库提供一个 Markdown 页面，像记日记一般用于记录个人成长。jsliang 的参赛地址 比赛内容不限，但请在 README.md 中记录你每天点滴成长。同时小伙伴应注意适当休息，磨刀不误砍柴工，休赛记得提醒 jsliang！ 可选择按天、周、月参与。 每天的比赛金为 5 元，每周的比赛金为 35 元。 竞赛第二天 jsliang 会查看小伙伴前一天的 Markdown 页面以及 GitHub Contribution 中显示的提交，以此作为判断是否打卡。 当天没有打卡则扣除小伙伴当天的比赛金。 当天成功打卡则均摊其他失败者的比赛金。 一个月未参与竞赛的小伙伴会被清理出微信群。 如果小伙伴想参赛，但是又不知道自己想发展啥，可以咨询 jsliang。 jsliang 会根据他自己以及他大佬的经历给你建议，上班期间划水费 10 元/小时，下班期间免费咨询（调皮）。 本活动玩法参考自 支付宝 - 体育服务 的 早起打卡 及 天天红包赛。 三 参赛方式 本次活动规则解释归 jsliang 所有，需要参赛的小伙伴可加 jsliang 微信，并在好友通过后直接言明参赛（减少大家沟通时间），jsliang 会直接拉小伙伴进微信群。 下面是参考： jsliang 我想参与你组织的 暴走前端 - GitHub 竞赛： 我竞赛的 README.md 仓库在 jsliang 的参赛地址（GitHub 仓库地址） 我参赛昵称是 广州-jsliang（进群请修改成该昵称） 目前我的发展是先搞 React 基础，然后写几个 React Demo，最后深入探究下 React 源码。 本周我想开始参与，截止至周日还有 3 天，我先交 15 元（3 天 * 5 元）给你报名，今天开始记录。 jsliang 微信： 四 成员名单 昵称 GitHub 账号 竞赛记录地址 1. jsliang GitHub 参赛地址 2. Liutaochange GitHub ——空—— 3. jerry GitHub ——空—— 4. 邵威儒 GitHub ——空—— 5. HESUIJUN GitHub ——空—— 6. 豆包君 GitHub 参赛地址 7. huqi GitHub 参赛地址 8. imNaive GitHub ——空—— 9. teachat8 GitHub 参赛地址 五 比赛历史 2019-5-13 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 [x] huqi 参与周竞赛，已交 35 元。 [x] teachat8 参与周竞赛，已交 35 元。 上一周情况 [x] 梁峻荣 参赛 7 天，完成了 7 天的提交。 [x] 豆包君 参赛 7 天，完成了 6 天的提交。 [x] huqi 参赛 7 天，完成了 7 天的提交。 [x] teachat8 参赛 7 天，完成了 7 天的提交。 2019-5-5 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 [x] huqi 参与周竞赛，已交 35 元。 [x] teachat8 参与周竞赛，已交 35 元。 上一周情况 [x] 梁峻荣 参赛 7 天，完成了 7 天的提交。 [x] 豆包君 参赛 7 天，完成了 7 天的提交。 2019-4-29 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 上一周情况 [x] 梁峻荣 参赛 7 天，完成了 7 天的提交。 [x] 豆包君 参赛 7 天，完成了 7 天的提交。 [x] teachat8 参赛 7 天，完成了 7 天的提交。 2019-4-23 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 [x] teachat8 参与周竞赛，已交 35 元。 上一周情况 [x] 梁峻荣 参赛 7 天，完成了 7 天的提交。 [x] 豆包君 参赛 7 天，完成了 7 天的提交。 [x] teachat8 参赛 7 天，完成了 7 天的提交。 2019-4-15 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 [x] teachat8 参与周竞赛，已交 35 元。 上一周情况 [x] 梁峻荣 参赛 7 天，完成了 7 天的提交。 [x] 豆包君 参赛 7 天，完成了 7 天的提交。 [x] teachat8 参赛 7 天，完成了 7 天的提交。 2019-4-8 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 [x] teachat8 参与周竞赛，已交 35 元。 上一周情况 [x] 梁峻荣 参赛 7 天，完成了 7 天的提交。 [x] 豆包君 参赛 7 天，完成了 7 天的提交。 [x] huqi 参赛 7 天，完成了 7 天的提交。 [x] teachat8 参赛 7 天，完成了 7 天的提交。 2019-4-1 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 [x] huqi 参与周竞赛，已交 35 元。 [x] teachat8 参与周竞赛，已交 35 元。 [x] jerry 参与周竞赛，已交 35 元。 上一周情况 [x] 梁峻荣 参赛 7 天，完成了 6 天的提交。 [x] 豆包君 参赛 7 天，完成了 7 天的提交。 [x] huqi 参赛 7 天，完成了 7 天的提交。 [x] imNaive 参赛 7 天，完成了 7 天的提交。 2019-3-25 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 [x] huqi 参与周竞赛，已交 35 元。 [x] imNaive 参与周竞赛，已交 35 元。 上一周情况 [x] 梁峻荣 参赛 7 天，完成了 7 天的提交。 [x] 豆包君 参赛 7 天，完成了 7 天的提交。 2019-3-17 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 上一周情况 [x] 梁峻荣 参赛 7 天，完成了 7 天的提交。 [x] 豆包君 参赛 7 天，完成了 7 天的提交。 2019-3-3 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 上一周情况 [x] 梁峻荣 参赛 7 天，完成了 7 天的提交。 [x] 豆包君 参赛 7 天，完成了 6 天的提交。 [x] Liutaochange 参赛 4 天，完成了 4 天的提交。 2019-2-25 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 上一周情况 [x] 梁峻荣 参赛 7 天，完成了 7 天的提交。 [x] 豆包君 参赛 7 天，完成了 7 天的提交。 2019-1-28 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 上一周情况 [x] 豆包君 参赛 7 天，完成了 7 天的提交。 [x] 梁峻荣 参赛 7 天，完成了 7 天的提交。 [x] huqi 参赛 7 天，完成了 7 天的提交。 2019-1-21 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 [x] huqi 参与周竞赛，已交 35 元。 上一周情况 [x] 豆包君 参赛 7 天，完成了 5 天的提交。 [x] 梁峻荣 参赛 7 天，完成了 6 天的提交。 2019-1-13 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 上一周情况 [x] 豆包君 参赛 7 天，完成了 7 天的提交。 [x] 梁峻荣 参赛 7 天，完成了 7 天的提交。 2019-1-7 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 上一周情况 [x] 豆包君 参赛 7 天，完成了 6 天的提交。 [x] 梁峻荣 参赛 7 天，完成了 7 天的提交。 2018-12-31 这一周参赛 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 上一周情况 [x] 梁峻荣 参赛 7 天，完成了 7 天的提交。 [x] Liutaochange 参赛 7 天，完成了 7 天的提交。 [x] jerry 参赛 7 天，完成了 7 天的提交。 [x] 豆包君 参赛 7 天，完成了 7 天的提交。 [x] 邵威儒 参赛 7 天，完成了 6 天的提交。 [ ] HESUIJUN 参赛 1 天，提交 1 天。 2018-12-24 这一周缴费 [x] 梁峻荣 参与周竞赛，已交 35 元。 [x] Liutaochange 参与周竞赛，已交 35 元。 [x] 豆包君 参与周竞赛，已交 35 元。 [x] jerry 参与周竞赛，已交 35 元。 [x] 邵威儒 参与周竞赛，已交 35 元。 [x] HESUIJUN 参与天竞赛 上一周的情况 [x] 梁峻荣 完成了 7 天的提交。 [x] Liutaochange 完成了 7 天的提交。 [ ] jerry 完成了 6 天的提交，有一天记录在了博客。 [x] 豆包君 完成了 7 天的提交。 [ ] 邵威儒 完成了 5 天的提交，但是提交到 gitee 上了。 [ ] HESUIJUN 完成了 3 天的提交。 2018-12-17 上一周的情况： [x] 梁峻荣 完成了 7 天的提交。 [x] Liutaochange 完成了 7 天的提交。 [ ] jerry 完成了 6 天的提交，最后一天有所收获，但未记录于 GitHub 上。 [x] 豆包君 完成了 7 天的提交。 [ ] 邵威儒 完成了 3 天的提交，剩余 4 天偷懒。 [ ] HESUIJUN 完成了 0 天的提交，正在咨询情况。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-16 10:19:13 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Monologue/TheArtOfQuestioning.html":{"url":"other-library/Monologue/TheArtOfQuestioning.html","title":"✔ 提问的艺术","keywords":"","body":"提问的艺术 create by jsliang on 2019-3-26 15:28:38Recently revised in 2019-3-27 22:48:38 提问是一门学问，更是种艺术，不懂得提问的人，终归让人难受。 —— 鲁迅 jsliang 上图来自《别像弱智一样提问》 一 引子 作为一枚编程界的渣，又喜欢去四处折腾，折腾又 hold 不住各种妖娆千奇百怪的问题缠身。所以 jsliang 就成了问题少年，QQ/微信群加了一堆，大佬加了一堆，就想着解决不了的时候拖有经验的 大佬 下水，一起解决下这些 “有趣” 的问题。 因为继承了大学师兄的优良传统：“不要什劳子问题都直接丢给大佬，会被拉黑的哦~”。所以询问问题之前和询问问题的时候，jsliang 有自己的一套： 先自己折腾，尝试一番。如果能搞定，那感情好的；如果搞不定，这时候对问题来龙去脉有点思路了。 百度、bing、Google（好吧，Google 在国内被墙了，还真没咋用过梯子，所以 Google 不常用）。根据折腾时候给出的思路，尝试找到比较相似的解决方案，再次进行折腾，如果还搞不定，那就询问下群里大佬。 向群友求助：“小伙伴们，有使用过框架 A 的吗？我编译的时候它报 B 的错误，然后我尝试用 C 方法进行解决了，但是没成功，于是百度了关键字 D，再尝试了 E 方法，现在想知道是哪里出问题了，可以帮忙看看嘛？谢谢~” 向大佬提问：“大佬，在不，问你个问题！在框架 A 中，我编译的时候它报 B 的错误，然后我尝试用 C 方法进行解决了，但是没成功，于是百度了关键字 D，再尝试了 E 方法，不知道是我的思路错了，还是解决中疏漏了哪个步骤，你有空帮忙看看不？谢谢~” 即便最终在大佬的帮助下，jsliang 解决了问题，但是 jsliang 感觉还是很慌的：我是不是偷懒没百度？我提问的时候语气有没有很恭敬？如果下次大佬不回我咋办？…… 好吧，不管怎样，心虚啊，有时候总感觉自己提问姿势还是不太对，然后刚好看到文章 《别像弱智一样提问》 和 《提问的智慧》。 enm......陷入深思，我是不是就是里面的那个弱智...... 二 反例 萌新：“大佬，在不？问你个问题撒~” 大佬：（要介绍妹子么？回不回？）“在的，你说。” 萌新：“关于 A 这个框架中的 §№☆●◎□◆○◎★▲△■※￡¤￠℃￥ξοωχυλβιμητσ 问题，怎么搞啊？” 大佬：（没用过 A，百度了下，看到一堆现成解决方案，揉揉头）“你说这个问题啊，是有解决方案的，下次你可以先百度瞅瞅。我对 A 也没用过，不过我看了几篇文章，觉得可以说明白你那些问题。”（发送几篇参考文献） 萌新：（没回复了） ……过了一天…… 萌新：“大佬，在不，问你个问题撒~” 大佬：（极不情愿，回不回？）“在的，怎么了，下次你可以一次性把问题发出来，我看到就会回你的。” 萌新：“是这样的，在框架 A 中，关于 §№☆●◎□◆○◎★▲△■※￡¤￠℃￥ξοωχυλβιμητσ 的问题，不知道怎么搞，弄了好久没弄出来。” 大佬：（还是没用过 A，百度了下，又看到一堆现成解决方案，又揉揉头）“这个问题百度也是有解决方案的，大致瞅了下，这几篇也是可以的。”（发送几篇参考文献） 萌新：“大佬，你看下能不能直接告诉我怎么解决不，我这里急着要解决啊，我看这些文章来解决问题的话太耗时了，赶不及啊~” 大佬：（皱眉，瞅了下那几篇文章）“大致就是 1、 ，2、，就可以解决了。” 萌新：（又不见了） ……又过了一天…… 萌新：“大佬，在不？问你个问题撒~” 大佬：（回不回？不回了不回了） 萌新：“Hello？大佬哪去了？” 大佬：（跑去某个群里水了两句，放松了一下，准备回去工作） 萌新：“艹！你这 sb，叫你两句大佬还牛起来了是吧，摆架子是吧？！有空去群里水就是不回我，就你这垃圾 ……” 大佬：（拉黑删好友二连） 虽然，现实中应该很少几率会出现最后破口大骂的情形。 但是，至少 jsliang 还是曾见过几次的，为那几个大佬默哀几秒。 当然，今天不是来讲这个的，此处略去不表，jsliang 谈谈自己关于这则故事的观点： 在不？ 这句话有没有让在座大多数小伙伴一阵心肌梗塞的感觉？你是回呢还是不回呢？ 直接提问。有问题先 百度、bing、Google 撒，毕竟大佬很忙的撒，好不容易处理完自己事情，看到你这问题，结果一百度发现感觉又回到了工作状态，这是另类为你打工啊~ 问完就溜。就算 TCP 关闭还要挥手啊，你这一不说解决没有，二不来声谢谢，很闹心的！ 重复提问。大佬说了不懂框架 A 啦，下次可以注意点，要不然就像你每天被人问：“有女票吗？”问多几次，你会不会想砍了它啊。 只要结果。过分了吧，大佬成为百度中转站不说，还要帮你提炼解决方法。 破口大骂。……这…… 三 提问常识 除了上面 jsliang 提到的自己的观点，《别像弱智一样提问》 中还有更多强烈呼喊： 要知道，Free 的正确翻译是 自由，而非 免费。即便回答你的人由时间。 要知道，愿意回答问题的人，都是 可爱 的人。 要知道，向帮助你的人 付费 是一个高尚的行为。即便回答你的人不是为了钱。 要知道，花钱买时间是一个常识。如果你不能认同，要么你钱包穷，要么你思想穷。 要知道，给对方发工资的不是你或者你老板。 要知道，提问的时候你才是 孙子，对 大爷 客气点。 要知道，不回答你的问题，对其他人没有任何损失。 要知道，准确描述一件事情 是一项基本生存技能。 要知道，搜索 是一项基本生存技能，学不会用 Google 的话，你可能真的不适合你所从事的行业。 要知道，英文 是一项基本生存技能，不认识英文的话，你可能真的不适合你所从事的行业。 四 提问描述 向 大佬 提问的时候，要学会正确的描述问题。 把 大佬 当成你的老板时，你提问就是在给他做报告，你会怎么做？当然是用最精炼的文字和图片，向老板阐述明白一个事情的来龙去脉。 要知道，如果你不是妹子，大佬没功夫猜你想什么！ 所以，提问的时候，给的条件越多，你的问题得到解决的概率也快，解决速度越快。 大致来说，就是： 你好，我这里有一个问题： 关于什么框架，版本是多少。 我想要实现怎样效果。 我自己做出了什么效果。 我通过搜索查找，又做到了怎样效果。 群成员的回复，我又做了什么尝试。 现在关于某个部分，还是没法解决。 如果你看到，并且有空的话，能回复下么，谢谢~ OK，如果得到解答，最好就再回复句 谢谢！没得到解答也最好回复句 谢谢！ 记住，谢谢 两字不用钱，也不会让你觉得委屈，但是能让大佬觉得舒服，感觉自己得到了应用的尊敬！那么你下次的提问就可能还会得到解决，你就还有明天！ 五 总结 到此，jsliang 就讲述完自己关于 提问 的观点，如果小伙伴还有其他经历，或者对 提问的艺术 有自己独到的见解，可以到评论区给出你的吐槽，或者到 jsliang 的文档库 QQ 群：798961601 跟其他小伙伴一起分享~ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Monologue/稳食艰难.html":{"url":"other-library/Monologue/稳食艰难.html","title":"✔ 稳食艰难 - 云服务器推广","keywords":"","body":"云服务器推广 Create by jsliang on 2018-12-25 09:28:00Recently revised in 2019-4-28 18:20:35 jsliang 的唯一稳食途径，感谢小伙伴们的支持！ 一 目录 目录 介绍 jsliang.top jsliang 的网站列表 cv.jsliang.top 通过 ECharts + Vue 打造个人线上简历 playregex.jsliang.top 通过游戏来了解正则表达式 lucky.jsliang.top 悠闲刮刮乐，仅供娱乐 deadline.jsliang.top jsliang 的工作时间轴 webpack.jsliang.top Webpack 学习成果，Webpack 多页面配置 game.jsliang.top 一个小游戏，只兼容 PC，适配移动端失败 company.jsliang.top Node 打造企业网站，支持注册、登录及留言 work.jsliang.top jsliang 工作成果，给领导或者工作小伙伴查看 如果小伙伴需要订购云服务器来存放像 jsliang 个人网站类的静态或者有 Node 后端的网页，但却不知道怎么选择，可以加 jsliang QQ：1741020489 咨询，下面是一些优惠推广： 二 腾讯云推广 新用户点这里： 新客户无门槛 2775 元代金券 购买云服务器： 12 月优惠低至 168 元/年 三 阿里云推广 新用户点这里： 新用户云产品 1888 通用代金券 购买云服务器： 高性能云服务器 - 低至 293元/年 购买企业级云服务器： 企业级高性能云服务器 四 疑问讲解 为什么买云服务器？ 平时我们电脑开服务的时候，就是 Node 连接 MySQL/MongoDB，然后提供接口给前端，这样我们就可以通过浏览器加载前端的网页，别人就可以跑到我们电脑前，看我们的电脑上的项目。 但是别人要跑到你面前来看项目，这是不是很麻烦，所以可以将自己电脑当服务器来使用，就是通过部署 Nginx、Apache 之类的服务，别人就可以通过 IP 地址访问到我们的项目了（如果解析了域名，那就通过访问域名来访问我们的服务） 因为项目放自己电脑，如果用自己电脑开服务的话，每次别人想访问你的项目，你就要开着电脑。万一你哪天没开机，别人岂不是见不到了？但是你电脑 24 小时开机，电脑是不是损坏的快？而且需要算电费。 所以这时候就可以买云服务器了，你可以将云服务器看成一台 24 小时不停机的电脑，电费、损坏之类的都不用你管，你只需要在上面部署好项目，开启服务，别人就可以 24 小时访问你的项目啦~ 什么是 10%-15% 性能基线？ 在回答这个问题之前我们先了解个问题：什么是 CPU 使用率？CPU 使用率其实就是你运行的程序占用的 CPU 资源，表示你的机器在某个时间点的运行程序的情况。使用率越高表明你运行的程序越多，反之越少。CPU 对线程的响应并不是连续的，通常会在一段时间后自动中断线程。未响应的线程增加，就会不断加大 CPU 的占用（Node 是单线程的喔~）。CPU 使用率高的原因有很多，但是一般都是由于病毒木马或开机启动项过多所致。 在日常使用云服务器过程中，不怎么用不到 CPU，偶尔占用下 CPU 10%，存放博客、放几个企业站是毫无压力的。 但是，当你的 CPU 使用率过高的时候，就会产生 CPU 积分，当你的 CPU 积分耗尽时，你的 CPU 使用率不能超过 15% （10%-15%性能基线）。 1 个 CPU 积分 = 一个 vCPU 核以 100% 使用率运行 1 分钟 1 个 CPU 积分 = 一个 vCPU 核以 50% 使用率运行 2 分钟 1 个 CPU 积分 = 2 个 vCPU 核以 25% 使用率运行 2 分钟 如果一个 vCPU 核一小时（60 分钟）都以 100% 使用率运行，一个 vCPU 核每小时需要 60 个 CPU 积分，而 CPU 积分是每天会重置的。 所以，当你购买云服务器的时候，如果你单纯放放博客、企业站等访问量不大的时候（Node 等后端不会大量调动），购买入门级配置（10% - 15% 性能基线，更优价格），如果 CPU 使用过高的产品，建议选择性能均衡配置（CPU性能不限，更高性价比） jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-29 08:12:11 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Monologue/MorningAndEvening/":{"url":"other-library/Monologue/MorningAndEvening/","title":"✔ 朝花夕拾","keywords":"","body":"朝花夕拾 - 记录程序猿点点滴滴 Create by jsliang on 2019-3-23 18:30:22Recently revised in 2019-04-30 10:51:28 程序猿也是人，也有自己的生活。 有些时候，我们感觉自己是个孤独的群体，我们需要释放自己的心情，需要给自己鼓舞，需要让自己拥有越来越多的东西。 在这里，记录 jsliang 生活的点点滴滴：幼稚的我、艰苦的生活、未来期盼…… 日期 主题 2019-04-29 工作与生活 2019-04-05 生日 2019-03-31 徒步 2019-03-22 搬家 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-30 10:56:41 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Monologue/MorningAndEvening/2019-04-29.html":{"url":"other-library/Monologue/MorningAndEvening/2019-04-29.html","title":"✔ 朝花夕拾 - 工作与生活","keywords":"","body":"朝花夕拾 - 工作与生活 Create by jsliang on 2019-04-29 22:09:30Recently revised in 2019-05-02 19:32:26 2018 年 5 月 2 日，jsliang 正式开始了前端编程生涯，距今恰好一年。 关注的话题却不再是纯粹的编程，而是从编程变成了养生编程，毕竟生活不能只有代码，还有健康和未来。 一 目录 目录 一 目录 二 前言 三 疾病科普  3.1 颈椎病  3.2 腰间盘突出  3.3 肾虚  3.4 过劳肥  3.5 脱发  3.6 胃病  3.7 失眠  3.8 其他 四 健身运动  4.1 软件：keep  4.2 健身方式  4.3 其他推荐 五 生活饮食 六 个人推荐 七 寄语 二 前言 返回目录 Hello 小伙伴们五一假期快乐~ 还记得 jsliang 的个人介绍或者最喜欢说的一句话么： 不折腾的前端，和咸鱼有什么区别 然而，今儿看到 jsliang 的粉丝群有个小伙伴透露：它的同事犯了尿毒症…… 说者无意，听者有心。 编程本就是份高危行业，GitHub 的 996.ICU 风波影响至今犹在。 jsliang 在查完尿毒症的前因后果后，觉得应该给自己科普，并给小伙伴们分享下，危害程序猿的疾病以及日常如何保持身体健康。毕竟： 折腾过渡的前端，和咸鱼没有区别 关心自己的健康，才能无病无灾持续的折腾~ 下面的分享都是 非专业 角度的科普，欢迎提议，排斥搞事，如有对应，及时就医。 更多养生咨询以及前端学习，请关注 jsliang 的文章分享 QQ 群：798961601 三 疾病科普 返回目录 最不靠谱的科普，来自最喜欢折腾的人。 下面的科普内容，绝大部分来源于网络，介绍一些疾病的造成原因和初期表现以及调理推荐。 由于网络具有不可信原则，所以如果小伙伴感觉自己在下列描述的问题方面很严重的时候，为了你的身体着想，请及时就医。 3.1 颈椎病 返回目录 3.1.1 前因 职业原因，长期从事低头伏案工作的人员最易患颈椎病，如作家、教师、会计、绘图、缝纫工、IT业工作者及机关工作人员等，还有长期仰头工作的人员例如天花板的粉刷工人。 吸烟，饮食不当等因素会影响淋巴回流，间接对颈椎不利 开车等惯性损伤，高速行车中的突然刹车而造成颈椎病已是相当常见，我们常常称之为 “挥鞭” 样损伤。 外伤，指外力暴力造成的颈椎受伤 气候环境，颈椎病病人常因风寒、潮湿等环境改变、季节气候变化而加重。 年老退变，随着老年人的机体、内脏、形态、功能的逐步衰老退化，运动系统也会随着衰老而退变。 咽后壁发炎可导致颈椎椎体不稳，进而引发低血压和血压波动。 3.1.2 表现 颈部肌肉酸痛、僵硬。肌肉酸痛不仅表现在脖子后方，也会表现在两侧的颈肩部和肩胛区。（初期） 如果小伙伴经常有上述表现，请重视，防止进一步恶化。 3.1.3 调理 减少玩手机用电脑和看电视的时间 不要葛优躺 不要躺着脖子和头靠在床头看电视 不要低头办公一次很久 结合合理的按摩、热敷和锻炼 通过改变生活习惯，可以缓解甚至治愈。 3.1.4 参考文献 颈椎病 - 百度百科 颈椎病 - 维基百科 颈椎病有什么症状？ - 知乎 3.2 腰间盘突出 返回目录 3.2.1 前因 跷二郎腿（骨盆倾斜，一边高一边低） 售货员、老师、理发师等长期站立（腰部肌肉长时间紧绷） 睡姿不良（软床腰部无支撑会导致肌肉长时间紧绷） 单手提重物（椎间盘两边受力不一致） 跑步姿势不良（椎间盘受力，颠簸导致脉冲式压力） 穿高跟鞋（重心前移，骨盆前倾） 需要扭腰的运动（高尔夫、兵乓球等） 弯腰搬重物（腰椎间盘受压力过大） 慢性咳嗽、便秘（腹压增加、椎间盘受力增加） 3.2.2 表现 腰疼 坐骨神经疼 腹股沟区痛 间歇性跛行 肌肉瘫痪乏力 马尾综合征 3.2.3 调理 请及时就医，防范于未然。 3.2.4 参考文献 腰椎间盘突出症 - 百度百科 腰间盘突出如何有效康复 - 知乎 腰椎间盘突出早期症状 - 三博疾病网 3.3 肾虚 返回目录 3.3.1 前因 过度喝饮料 吃过于松软的面包 暴饮暴食 酒后喝浓茶 饮食太咸 经常憋尿 饮水过少 滥用镇痛药 过量服用某些中草药 3.3.2 表现 变胖 脱发增多 眼睑浮肿 性欲冷淡 更年期提前骚扰 怕冷 腰酸腿痛 尿频尿急 腰痛 头晕耳鸣 失眠多梦 夜间多尿 便秘 哮喘 3.3.3 自测 男性自测： 将少许尿液倒入一杯清水中，如果水仍很清净，表示身体健康；如果变得混浊或有油质浮于水面，绝大多数是肾虚。 在正常饮水情况下，夜尿在 3 次以上。 小便无力，滴滴答答，淋漓不尽。 早晨起床，眼睛浮肿。 不提重物，走到三楼就两腿无力。 坐在椅子上看电视，超过两个小时就感到腰酸。 在厨房做饭，站立时间超过一个小时，就感到两腿发软。 总想闭目养神，不愿思考问题，注意力不集中。 洗头时，头发大量脱落。 总感到有困意，却睡不着，好不容易睡着了，又睡睡醒醒。 若同时出现以上情况中的3种情况，就很可能是肾虚。 女性自测： 全身方面：全身倦怠、头脑不清醒、注意力不集中、记忆力减退等。 神经肌肉方面：经常失眠、头晕脑胀、腰酸背痛、下肢乏力等。 心血管方面：心悸气喘、胸闷、浮肿等。 胃肠道方面：食欲不振、恶心、胃疼、腹痛腹泻、便秘等。 五官方面：视疲劳、鼻塞、眩晕、耳鸣、咽喉不舒服等。 其他方面：“性趣” 减退、抑郁、焦虑、恐惧等。 对照上面症状，如果有 2 个以上方面出现问题，应及早去医院检查。 3.3.4 饮食调理 黑芝麻 核桃 山药 羊肾 枸杞 何首乌 3.3.5 参考文献 肾虚 - 百度百科 肾虚 - 维基百科 肾虚 - baby 百科 肾虚有哪些症状？吃什么调理？ - 新浪 有这10个症状说明你肾虚了 - 人民网 3.4 过劳肥 返回目录 过劳肥是由于工作压力大、饮食不规律、凌晨才睡觉，工作越繁忙的人越容易变胖的一种现象。 3.4.1 前因 睡得少或彻夜未眠（睡眠不足） 繁重工作所造成的心理压力 饮食不健康 久坐且缺乏运动 3.4.2 调理 餐后 3 小时再去睡觉。充分消化吸收糖类和脂肪。 中午小憩一下。午睡 20 分钟左右适宜。 适当锻炼。 喝花草茶或柠檬水。有助于心情的纾解。 补充维生素和纤维素。 3.4.3 参考文献 过劳肥 - 百度百科 如何避免过劳肥？ - 知乎 3.5 脱发 返回目录 脱发是个敏感话题，N+ 程序猿碰到该话题不可避免尴尬或者有话要说。 jsliang 不是职业医生，所以给不了小伙伴太多意见，说多必错，请见谅。 而且据 jsliang 了解，脱发可能是各种原因导致，所以小伙伴发现自己有掉发严重（洗头发现掉发很多）的时候，请及时就医~ 下面给点养生小建议： 食物补充营养。胡萝卜、番茄、黑芝麻、黑枸杞等食物对头发有好处，可以适当多吃。 避免熬夜。超过 11 点的都叫熬夜，11 点前就睡觉是个不错的选择。 保持充足睡眠。jsliang 的休息时间是 23:00 - 06:50。 适当运动。jsliang 每天有半小时 + 的运动时间。 饮食清淡。作为一枚广东人，jsliang 的饮食相当清淡，不怎么吃辛辣油炸。 jsliang 身边有许多懂养生的小伙伴，当然也有做了植发的朋友，小伙伴们想了解养生、植发可以加我 QQ：1741020489。在此不多讨论，欢迎吐槽和咨询。 参考文献 脱发 - 百度百科 有哪些好的治疗脱发方法？ - 知乎 3.6 胃病 返回目录 3.6.1 前因 饮食无规律 工作紧张压力大 喝酒 抽烟 乱吃止痛药 3.6.2 调理 作息正常，三餐准时 戒烟、酒、咖啡、浓茶、碳酸性饮料 推荐食物：馒头、土豆、酸奶等…… 餐后不宜工作和强运动，可以适当慢步行走 胃不能治，只能靠养，是件长期的工作，请咨询好你的医师。当然，很严重的时候你就别想着养好了，请及时就医。 3.6.3 参考文献 胃病 - A+医学百科 引起胃病的原因 胃病 - 知乎 3.7 失眠 返回目录 长期失眠是抑郁的导火线之一，所以感觉自己防止不了的时候，请及时就医。 3.7.1 前因 环境影响。建议搬家或者戴耳塞。 压力大。 心情不好。 3.7.2 调理 睡觉的时候避免复杂话题，如钱、事等。jsliang 比较喜欢睡觉的时候想小说的内容，一些动漫打斗场景啥的。 调整作息时间。23:00 - 08:00 之间的时间段为宜。避免晚睡。 床头常年放干花和鲜果皮袋子。果香/花香能使人安神。 使用合适的枕头，最好配备一个硬的一个软的。 3.7.3 参考文献 程序员如何应对失眠 - 知乎 程序员如何改掉晚睡习惯? - 编程学习网 3.8 其他 返回目录 除了上面的 7 个之外，其实还有其他要注意的点，例如前言中提到的尿毒症，例如常见但没有提到的肩周炎（这个不知道怎么表述，感觉和颈椎病很相似）。 所以，本文仅仅抛砖引玉，希望引起小伙伴们的重视，对一些 “小病小痛” 不要忽视，以免变得不可根治。 四 健身运动 返回目录 996 我阻止不了，但我觉得小伙伴们可以安排下自己的锻炼计划。 4.1 软件：keep 返回目录 身边很多小伙伴推荐使用 keep 软件健身，每天至少做一组的 keep，不过 jsliang 一直没下载，都是按照自己的计划，每天定时半小时 + 的锻炼。 听说按照里面的健身方式，可以科学有效的进行健身，改天 jsliang 试试再进一步科普，感兴趣的小伙伴可以自行下载。 4.2 健身方式 返回目录 走路 跑步 游泳 骑行 仰卧起坐 瑜伽 太极拳 羽毛球 4.3 其他推荐 返回目录 锻炼每周至少一次，一次一个钟 有氧运动 30 分钟每天 一组 keep 上面是小伙伴们推荐的一些方式，感兴趣的小伙伴们可以坚持每天试试。 五 生活饮食 返回目录 吃得下饭，往往是件美好的事情 下面我们看看小伙伴们推荐的关于饮食方面的建议： 三餐正常。早餐吃好，午餐吃饱，晚餐精而少 饮食清淡。多吃青菜，膳食搭配 适当补充蛋白质 多吃水果 尽量不要吃煎炸油腻 吃饱不要倒头睡 六 个人推荐 返回目录 早睡。 11 点后睡觉，称为熬夜。 早睡都做不到的话，其他就都别谈了。 像跑步、健身、努力工作，如果没有早睡作为前提，通通没用的。 只有早睡，白天精神气才有可能足，精神气足了，干事情才有劲。 有规律准时吃饭，并吃饱吃好。 三餐准时吃。 早餐吃好，午餐吃饱，晚餐精而少。 懂养生的吃货别虐待自己~ 每天坚持一定的步数。懒癌是阻碍程序员健康的一大罪证 jsliang 每天坚持 8000+ 步，避免爬几层楼梯就气喘吁吁。 避免久坐。每隔 1 小时，起来走走 5 分钟 保持每天营养摄入的均衡。 30% 水果及蔬菜。 30% 的谷物及淀粉食物。 16%的精益蛋白质，比如肉类、鱼类、蛋类和豆类食品。 16%的牛奶及奶制品。 8%的脂肪及糖类食品。 尽可能远眺。工作 20 分钟后，眺望 6 米远的事物，持续 20 秒钟。 七 寄语 返回目录 先有 996.ICU 影响巨广，后有 马云、刘强东 鼓吹年轻人应当 996。 996.ICU - GitHub 马云刘强东突然一起鼓吹996，是什么鬼？ - 搜狐新闻 我们不管谁是对的，最重要的是： 身体是革命的本钱，别让银行卡尾数有很多 0，但你却丢了那个最重要的 1。 防范常见疾病，才能给我们的身体尽可能的保障，才能想折腾就折腾，不想折腾随意浪。 最后祝小伙伴们身体健康，能吃能喝能输出。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-02 19:53:07 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Monologue/MorningAndEvening/2019-04-05.html":{"url":"other-library/Monologue/MorningAndEvening/2019-04-05.html","title":"✔ 朝花夕拾 - 生日","keywords":"","body":"朝花夕拾 - 生日 Create by jsliang on 2019-4-5 16:58:15Recently revised in 2019-4-5 20:49:01 生活太匆忙，人生恨苦短。 不知不觉，已经到了人生第二个本命年，恰巧的是，今天又是本命年的生日。 闲来无事，整理下 2018-2019 这一年的资料，分享下此时此刻的心情与感慨。 主题：【写在生日，本命有感】 时间：【2019-04-05】 地点：【员岗】 歌曲 1：【来吧 甜蜜的吐槽 —— 卢恒宇、李姝洁、王冲】 歌曲 2：【写给父亲 —— 卢恒宇、李姝洁】 注意：图片过多，谨慎打开 一 毕业季 2018 年 5 月 —— 2018 年 6 月 开始实习，在毕业那天正式转正，大学生活就这么结束了，开始广东漂泊之旅？哈哈！ 二 工作岗位 2018 年 5 月 —— 至今 2018 年 5 月，开始第一家公司工作，写写 H5 页面，轻松快活。 2018 年 9 月，被派到电信驻点，写微信小程序、数据报表等等。 2019 年 4 月，开始第二家公司工作，入职没几天，没啥好照片。 三 办公位置变化 2018 年 5 月 —— 至今 2018 年 5 月，第一家公司的时候，自己买了新电脑和新显示器，大大的显示器盒子还在办公桌旁边，再加上个大大的鼠标垫，自己购买的一套装备。 2018 年 9 月，驻点电信之旅开始，由于电信提供显示器了，所以 心疼 地买了个显示器转接头，鼠标垫也忘记拿过来了，位置狭窄偏僻，空气不好，勉强活着。 2019 年 4 月，第二家公司之旅开始，刚入职一周，没拍摄到好照片。当然令人开心的是，公司提供 Mac 了，人生第一台 Mac，虽然所有权不是我的，哈哈。 四 文档库成就 2018 年 8 月 —— 至今 掘金 —— 获得第 2019 个关注者的截图，现在如果再看，可能没那么兴奋了，目前关注者 6979，加油努力，期待 10000 个关注者。 GitHub —— 获得第 1003 个 star 截图，本来打算第 1000 个 star 截图的，但是那几天太忙了，没反应过来，被冲破了。 掘金 —— 人生小巅峰，因为那篇关于 Node 文章突破 1000 点赞，获得了年度排行第 7 位。 五 粉丝互动 2019 年 3 月 因为写了一系列的面试经历，及最后的个人面试体系分享，收获了一些粉丝的夸奖，还是非常开心的。当然，有夸奖也有贬低，有时候看到一些 “莫名其妙” 的话，还是小难受的，哈哈~ 六 租房 2018 年 5 月 —— 2019 年 3 月 2018 年 5 月，第一次租房，能花 900 租到 35 平方的，距离地铁贼近的房子，个人幸运度还是蛮高的。 2019 年 3 月，第二次租房，这次的租房比上次来说，空间小了，光线更充足了，价格却更贵了，950 租到 30 平方的。 七 个人健康 2018 年 5 月 —— 至今 编程是份高风险的工作！请大家注重锻炼，保持身体健康！请关注身边的程序猿/程序媛！ 编程是份高风险的工作！请大家注重锻炼，保持身体健康！请关注身边的程序猿/程序媛！ 编程是份高风险的工作！请大家注重锻炼，保持身体健康！请关注身边的程序猿/程序媛！ 那天看到个人偶像发的票圈，整个人都愣住了，后来一听他的经历，整个人都懵逼了，太拼了。还好大佬目前还是健健康康的。 但是，编程这份工作，真的不是那么好混的。加班，熬夜，掉发，时刻威胁生命健康。幸好身边的大佬挺注重生活的，所以跟着榜样时刻锻炼自己，现在晚上 11 点睡 6 点半起床。 请记住：钱可以慢慢赚，生命就只有一条，你以为玩超级玛丽呢！ 八 后记 最后，谈谈今年印象最深的事。 还记得某次面试，有场对话： 面试官：“能冒昧询问下你上家公司的薪资吗？” 我：“n 千。”（n 代表一个数字） 面试官：“既然你上家公司的薪资是 n 千，现在你提的薪资是 2n 千了，你觉得你哪方面值得翻一番？” 我：“我觉得 方面可以加 n 千， 方面可以……”（一顿分析） 现在回想起来，想说的是，面试贵司之前的公司，真的给我工资翻番了，而且在这之后的几家给 offer 的公司，基本也给我翻番工资了。 最后的最后，如果小伙伴们想关注 前端程序猿的个人知识体系构建，可查看： jsliang 的文档库 如果小伙伴们想关注 程序猿的生活日常，可以查看： jsliang 的文档库 之 朝花夕拾 what's more，下面有个小广告，需要购买服务器的小伙伴可以点点~ jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Monologue/MorningAndEvening/2019-03-31.html":{"url":"other-library/Monologue/MorningAndEvening/2019-03-31.html","title":"✔ 朝花夕拾 - 徒步","keywords":"","body":"朝花夕拾 - 徒步 Create by jsliang on 2019-3-31 20:25:20Recently revised in 2019-4-1 07:56:28 时间：【2019-03-31】 地点：【佛山】 经过为期 4 个半多小时的长途跋涉走完 21.2 公里的时候，我已经精疲力尽了，所以和建光师弟跑去【佛山祖庙】溜达 最后在当晚 19:00 - 20:00 多，我和建光师弟跑去终点处，和完成竞赛的非常疲惫的两位老哥进行合影 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Monologue/MorningAndEvening/2019-03-22.html":{"url":"other-library/Monologue/MorningAndEvening/2019-03-22.html","title":"✔ 朝花夕拾 - 搬家","keywords":"","body":"朝花夕拾 - 搬家 Create by jsliang on 2019-3-23 18:35:08Recently revised in 2019-3-24 11:06:53 时间：【2019-03-22】 地点：永泰 —— 员岗 周五下午，早早收拾好，到点准时开溜。 回到永泰，吃了 最后的晚餐，期间点的麻辣烫还阴差阳错送错了，为接下来的遭遇埋下了 伏笔。 吃饱晚饭后，回去收拾，期间顺带跟老板娘结账，拿回押金。 开始出发，所搬东西有： 是的，这就是我要搬的东西，大致情形就是： 背电脑包 右肩抗黄色袋子 左手提棕色袋子 + 显示器 右手拖行李箱 目测应该是两个我的大小，两个我的大小，两个大小，大小…… Now, here we go! 首先，第一段路程，是从 5 楼租房去到 300 米外地铁口。 5 楼租房还是好下的，毕竟老板娘帮忙拿了一袋。 本来想放点东西到楼下电脑店，我可以分两趟搬。没想到老板娘出马还是被拒了（老板娘跟楼下电脑店小哥很熟的），没得法子，还是需要挂着两个我搬家。 一路走走停停，路过三岔路口时，派传单的小姐姐还说了一句：“哟，搬家呐~”。回来两天了，至今仍没想清楚，那句是询问呢，还是嘲讽涅？ 经过一番折腾，终于到了地铁口，然后发现手居然有点脱力感觉，可能是我好久没进行这样的 “壮举” 了，有点不适，心噗通噗通跳，而且这种下雨天天气我还出汗了。 然后，第二段路程，是从地铁口下去地铁站。 因为这边是没有电扶梯和电梯，所以要考虑怎么下去了。于是分了两批，先拿行李箱和棕色袋子下去，回头再拿黄色袋子下去。愣是拖了 10 分钟，没办法，实在累。 走完过道，然后过安检，enm......安检人员是真没看到我吧，我愣是搞了 2 分钟，才把所有东西过完安检机，然后东西搬下安检机，又花了 2 分钟。 到闸机的时候，我先将大的东西直接到闸机对面，再人过去。 过完闸机终于有电梯了，o(╥﹏╥)o 第一次搭地铁的电梯。 分两趟将电梯中的东西挪出来，地铁来了就将黄色袋子（里面是床被）扔进去，然后再提着棕色袋子和行李箱进去。 接着，第三段路程，是 地铁 3 号线 在长隆地铁站 转地铁 7 号线。 如果不是这次搬家，我还真察觉不到，转线那段路那么长。 抬着东西，磕磕碰碰，3 号线 长隆地铁站 转 7 号线是真的好遥远，咬着牙，一步一个脚印，还好中途碰到两个做 “不孕不育” 的老哥（别笑，真的是人家的工作），跟我同方向，也是去员岗的，顺带帮我拿下去了，感谢。 最后，第四段路程，是从员岗地铁站到租房。 500 米距离，讲真从来没觉得这么远过。 一路上，磕磕碰碰，周围行人不断超越我，然后开始下起小雨，冒雨前行，接着开始下起大雨，忍着拎起东西就是一阵小跑。 事后想起，我是真的佩服自己，最后一段路还能 “冲刺” 一波！可能这就是人的潜能吧！同时，感慨的是，人在苦时莫自弃，总能熬过去的。 到此，搬家就结束啦，事后休息了两天，到今天（周日），还是感觉到手非常疲惫，敲了一会字就需要休息下。 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Monologue/Logs/":{"url":"other-library/Monologue/Logs/","title":"✔ jsliang 日常","keywords":"","body":"jsliang 日常 Create by jsliang on 2018-12-21 11:29:02Recently revised in 2019-04-29 09:53:28 没有什么是一篇文章理不清的。 如果有，那就写篇思路大纲！ 一 日常作息 晚上 11:00 睡，早上 06:30 起床。 07:30 - 09:00 学习一个半钟。 21:30 - 23:00 学习一个半钟。 周末休息，学习 || 娱乐。 二 写作感言 做笔记很重要，但它的重要性并不在于写一篇两篇就能让你超神，受人景仰，它是一件长期的事情。 在我看来，它有两个优点： 方便你梳理你乱糟糟的记忆，打通你的任督二脉。 方便你在长期没接触的情况下回顾你曾经的工作。 当然，它还是有毛病的： 耗费时间。如果说做一个 Demo 需要半个钟的话，那么写完做这个 Demo 的文章，快则一小时，慢则几小时。 损耗精力。如果不是特别喜欢写文章，你会发现写完一篇文章跟虚脱了一样。 当然，如果你能持续下去，你会发现，每写完一篇都是很大的鼓舞，写完特别想去浪，特别想吃东西，特别想放松 by 2019-3-21 08:39:14 三 学习计划 【2019-04-30】完善 掘金 仿站项目，在开发中进一步学习了解。 【2019-04-25】已出版 React 的三个 Demo，并了解了 Git 的使用，接下来会持续学习 React 系列。 【2019-03-21】已写完面试部分，并且周一开启了 React 之旅，途中需要顺手学习 Git。 【2019-03-02】3 月计划写完面经：总贴一篇，实战两篇；然后学习 Git 团队开发的使用；最后学 React 并折腾简单业务。 【2019-01-14】折腾完 Vue 基础 + Vue 基础实战，准备折腾 Vue-Router、Vue-Cli 等系列…… 【2018-12-21】目前准备折腾完善 Vue 部分的文章。 【2018-10-29】我怀念之前写 Vue + Node 的日子了，现在一直用着 jQuery，感觉好 low，没有一点技术提升，于是开始跟着技术胖的视频，折腾 Vue + Koa2 + MongoDB 搭建商城。然后，发现 Vue 基础知识不够，于是看着开课吧的视频学习 Vue 基础，写了 Vue 开篇、Vue 基础、Vue Router、VueCli、Axios 等 Vue 系列文章。但是，学 Axios 的途中，突然发现它居然使用 Koa 提供服务的，但是开课吧不提供 Node 视频，而且正巧答应了大学老师帮她准备一下 Node 原生的教程，于是自己去百度资料，折腾了篇 Node 基础，中途发现还有 MySQL 也需要补充下知识，但是没空、没时间折腾，只写了篇 MySQL 安装及图形化工具。没事，放着先，反正 MySQL 大致的我都懂。接着，然后因为 Node 讲了基础，那么肯定还需要部署，所以折腾写了篇关于 Nginx 以及服务器部署 的文章。 【2018-10-20】临近 1024，碰巧看到微信群某位小伙伴搭了个静态文章页，于是来了心思，去折腾了下 GitHub Pages 和 VuePress，也没想那么多，搞定了自己的后直接将自己搭建过程写成了文章：1024，快速打造你的文档库/静态博客。于是，又火了一遍。 【2018-9-17】以此同时，写了篇 微信小程序 bug 集中营，一开始并没人看到，阅读量也不多，后来写得 bug 数量越来越多了，于是某天删了重新发表过，突然就破了个 200 点赞，写文章的兴趣就这么上来了。 【2018-9-17】 jsliang 在掘金上发表了人生的第一篇文章：pug模板引擎，然而因为没什么人用这个引擎，所以阅读量只有可怜的 90，点赞数只有 1。当然，你知道的，点赞数为 1 是因为我自己点的。 【2018-8-21】文档库没成立以前，jslaing 是写在 doc 上的，例如 Webpack 的学习，Nginx 的折腾…… jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-30 10:55:34 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Monologue/Logs/2019-05.html":{"url":"other-library/Monologue/Logs/2019-05.html","title":"✔ jsliang 日常 - 2019-05","keywords":"","body":"jsliang 日常 - 2019-05 Create by jsliang on 2019-5-12 12:38:18Recently revised in 2019-5-22 08:27:59 不折腾的前端，和咸鱼有什么区别！ 2019-05-22 [ ] 公司项目 [ ] 重构文档库 2019-05-21 [x] 公司项目 [x] 重构文档库 2019-05-20 [x] 使用 GitBook 重构文档库 2019-05-19 [x] 刷 LeetCode [x] 写公司 GitBook 2019-05-18 [x] 休息 2019-05-17 [x] 刷 LeetCode [x] 开始新个人项目 2019-05-16 [x] 分析新项目 [x] 整理书签 [x] 刷 LeetCode 2019-05-15 [x] 项目上线 [x] 学习 2019-05-14 [x] 开发公司项目 2019-05-13 [x] 开发公司项目 2019-05-12 [x] 毫无动力，看下技术文章 2019-05-11 [x] 参与同学毕业典礼 2019-05-10 [x] 学习 2019-05-09 [x] 公司项目上线 2019-05-08 [x] 开发公司项目 [ ] 开发 React 仿掘金 2019-05-07 [x] 开发公司项目 [x] 开发 React 仿掘金 2019-05-06 [x] 开发公司项目 [ ] 开发 React 仿掘金 2019-05-05 [x] 发蒙，休息 2019-05-04 [x] 心事不宁，出门走走 [x] 休息 2019-05-03 [x] 开发公司项目 PLM-604 [ ] 开发仿掘金项目 2019-05-02 [x] 编写养生编程小册子并整理如何新建一个页面 2019-05-01 [x] 休息，整理健康小册子 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-22 17:07:45 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Monologue/Logs/2019-04.html":{"url":"other-library/Monologue/Logs/2019-04.html","title":"✔ jsliang 日常 - 2019-04","keywords":"","body":"jsliang 日常 - 2019-04 Create by jsliang on 2019-04-29 09:45:38Recently revised in 2019-5-12 12:37:51 不折腾的前端，和咸鱼有什么区别！ 2019-04-30 [x] 分享健康小册子 2019-04-29 [x] 撰写 GitHub 竞赛新规则 [x] 学习 React Router。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-15 15:02:51 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Monologue/History/November2018.html":{"url":"other-library/Monologue/History/November2018.html","title":"✔ 历史 - 2018年11月-2019年3月进阶指南","keywords":"","body":"历史 - 2018年11月-2019年3月进阶指南 Create by jsliang on 2018-11-14 13:18:02Recently revised in 2018-11-14 21:39:53  你，是否对自己目前的工作内容很不满意？ 你，是否已经厌倦了公司内部的尔虞我诈？ 你，是否想要学习更多的技术换份新工作？ 我，是的…… 一 对比清单 目前现状 进阶目标 坐标： 广州 广州、深圳 薪资： 5.5K 10K+ 职位： 前端工程师 前端工程师 工作经验： 半年(应届生) 一年 工作内容： 1. 使用 jQuery 进行电信活动页的编写 2. 进行 Java 的 JSP 页面的维护 3. 进行 PHP 开发的公众号中 H5 页面的开 4. 小程序的开发与维护 1. 能使用 Vue 全家桶进行项目开发 2. 有 Node.js 编程经验，并进行过 Node.js 实践 3. 熟悉 HTTP 协议，了解项目性能优化方法 4. 熟悉 ES6，并尝试在项目中使用过 ES6 设计模式 拥有技能： 1. 知道基础的 HTML、CSS、JavaScript，基本的 PSD 图能完美切成网页 2. 了解并会使用 jQuery 进行 3. 有微信小程序相关的开发经验 4. 学习过 Webpack 中文文档，并搭建过 Webpack 多页面配置 5. 曾经使用过 ElementUI + Express + MongoDB 做毕业设计 6. 曾经使用过 Bootstrap + ThinkPHP + MySQL 做博客 7. ……其他省略，不值一提 1. Vue 基础知识 2. Vue-Router 3. Vue-Cli 4. Axios 5. Node 基础知识 6. Koa 7. MongoDB 8. MySQL 二 实践进度 【10-25】想用 Vue + Koa + MongoDB 搭建一套商城，于是学习 jspang 的教程。 【10-28】跟着学习了几天，发现一些基础知识真的忘得差不多了，不知道 Vue 基础知识，不知道 Node 基础知识，不知道 Koa 怎么玩，好纠结，好难受。 【10-29】敲下 Vue 的 README 文章，开始 Vue 学习。 【11-08】发现自己所有知识点都塞进一篇文章了，感觉不好，所以拆分成 VueBase、VueRouter、VueCli、Axios 这四篇文章。同时，发现自己 Axios 没法跟着教程下去了，想搞点 Node 基础，弄个 Koa 服务来帮助自己。 目前笔记  -> Vue + Koa2 + MongoDB 搭建商城 -> Vue 开篇 -> Vue 基础 -> VueRouter 学习 -> VueCli 实践 -> Axios 探索 三 留笔做念  不单单是留念，更想去实现！ Follow me~ 坚持每天更新自己！ 我们，每周一更新，一起关注彼此进度! 我的 GitHub 更新记录： 我的 GitHub 项目：  留笔名单： 姓名 最新更新 加入时间 缺更记录 jsliang 2018-11-14 2018-10-25 11-10、11-11、11-12、11-13 何穗君 暂无 2018-11-14 暂无 更多... 更多... 更多... 更多...  ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ 【点我了解入群姿势】  ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Node/":{"url":"other-library/Node/","title":"Node","keywords":"","body":"Node Create by jsliang on 2018-11-22 08:21:23Recently revised in 2018-12-3 22:41:12 一 Node 目录 目录 Node 导言 Node 基础 Koa 框架 二 Node 介绍 什么是 Node.js？  Node.js 是一个 JavaScript 运行环境(runtime)。它让 JavaScript 可以开发后端程序，实现几乎其他后端语言实现的所有功能。传说中 能与 PHP、JSP、Python、Ruby 等后端语言平起平坐。但是，实际上 Node 一般用作中间件。例如：在浏览器端和 Java 端使用 Node 作为中间件，Node 调用 Java 后端发布的接口，同时 Node 可以发布 HTTP 接口给浏览器端调用。 参考链接：浅谈前后端分离与实践之 nodejs 中间层服务(二) | 知乎 Node 优点？ Node 语法完全是 JS 语法，只要你懂了 JS 基础就可以学会 Node 后端开发。 Node 超强的高并发能力。在 Java、PHP 或者 .Net 等服务端语言中，会为每一个客户端的连接创建一个新的线程，而每个线程需要耗费大约 2 MB 内存。也就是说，理论上一个 8GB 的服务器，可以同时连接的最大用户数为 4000 个左右。而 Node 不会为每个客户创建新的线程，仅仅使用一个线程。所以，使用 Node，一个 8GB 的服务器，可以同时处理超过 4 万用户的连接。 实现高性能服务器。Node 基于 V8 引擎，V8 引擎是 Google 公司使用 C++ 开发的一种高性能引擎。这意味着开发者编写的高端 JavaScript 脚本代码与开发者编写的低端的 C 语言具有非常相近的执行效率。 开发周期短、开发成本低、学习成本低。花最小的硬件成本，追求更高的并发，更高的处理性能。 Node 应用？ 三 编程开发环境  Node 系列教程文章中，需要的前置知识为：Node、npm、cnpm、Visio Studio Code。 下面是这些技术的详细介绍： Node.js  在开发学习中，我们需要安装配置 Node 的环境。 首先，我们需要先下载 Node 并安装到我们的电脑上。 然后，我们需要了解 Node 与 NPM 之间的关系。 最后，由于 npm 在国内有一定限制，所以，我们需要换成淘宝的 npm 镜像：cnpm，从而提高我们的 npm 包的下载安装速度。 个中繁杂，由于系统还要考虑 Win、Mac 等缘故，这里不一一累述，请小伙伴们按照下面的链接先行安装 Node，不明之处可去百度或者 Google。 Node 下载 | Node.js 中文网 Node 安装步骤 | 菜鸟教程 Node 与 Npm | 廖雪峰 cnpm | 淘宝 NPM 镜像  最后的最后，如果小伙伴们觉得环境装好了，请输入 cnpm -v 查看自己的版本，jsliang 的 Node、Npm、Cnpm 版本如下。 Visio Studio Code  如果你是个前端开发，那么 Visio Studio Code（以下简称 VS Code）一定不能错过，因为这是一款轻量级的代码编辑器，支持语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性。所以，下个 VS Code 愉快玩耍吧！ Visio Studio Code 安装 | 官网 Visio Studio Code 安装及使用技巧 | 博客园 四 技术支撑 IT 营 IT 营 Node.js Koa2 视频教程 avi 版本（课件+源码+视频） jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Node/Koa.html":{"url":"other-library/Node/Koa.html","title":"✘ Koa","keywords":"","body":"Koa Create by jsliang on 2018-11-8 13:34:30Recently revised in 2018-11-8 13:34:52  Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件，而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Node/NodeBase.html":{"url":"other-library/Node/NodeBase.html","title":"✔ Node 基础","keywords":"","body":"Node 基础 Create by jsliang on 2018-11-8 13:42:42Recently revised in 2018-12-22 14:58:29  Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址  本文重点内容： Node 基础 - 通过对 Node 基础的了解学习，打下 Node 基础 Node API - 开启服务提供 API 给前端调用 Node 连接 MySQL - 通过 npm 安装 mysql，从而实现数据库的链接 Node 实战 - 企业官网从 0 开始，打造能注册、登录以及留言的企业官网 Node 部署 - 如何通过部署云服务器，让小伙伴们可以查看到你的网站  本文延伸链接： Node 部署项目、云服务器以及域名的使用：链接 本文 Node 基础代码下载地址：链接 本文 Node 成品代码下载地址：链接  本文成品演示： Node 项目演示：jsliang 前端有限公司 一 目录  不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 基础学习  3.1 HTTP - 开始 Node 之旅  3.2 URL 模块  3.3 CommonJS  3.4 包与 npm  3.5 fs 文件管理  3.6 fs 案例  3.7 fs 流  3.8 创建 Web 服务器  3.9 非阻塞 I/O 事件驱动  3.10 get 与 post  3.11 Node 连接 MySQL 四 Web 实战 —— 企业官网  4.1 编程环境  4.2 后端接口  4.3 注册功能  4.4 登录功能  4.5 留言功能 五 工具整合  5.1 supervisor - 监听 Node 改动  5.2 PM2 - Node 进程管理 六 参考资料 七 线上部署 八 归纳总结 二 前言 返回目录  本文主要目的： 整合 Node 基础，加深 jsliang 对 Node 的学习了解，并且方便日后复习。 整合 Node 工具，方便查找在 Node 开发中，有哪些工具比较有利于开发。 给初学 Node 的小伙伴做一个参考，如有疑问还请在 QQ 群：798961601 中咨询。 三 基础 返回目录  万丈高楼平地起，地基还得自己起。 3.1 HTTP - 开始 Node 之旅 返回目录  话不多说，先上代码： 01_http.js // 1. 引入 http 模块 var http = require(\"http\"); // 2. 用 http 模块创建服务 /** * req 获取 url 信息 (request) * res 浏览器返回响应信息 (response) */ http.createServer(function (req, res) { // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8 res.writeHead(200, { \"Content-Type\": \"text/html;charset=UTF-8\" }); // 往页面打印值 res.write('Hello NodeJS'); // 结束响应 res.end(); }).listen(3000); // 监听的端口  那么，上面代码，我们要怎么用呢？  首先，将上面的代码复制粘贴到 01_http.js 中。 然后，启动 VS Code 终端：Ctrl + ~。 接着，输入 node 01_http.js 并回车。 最后，打开 localhost:3000：  OK，搞定完事，现在我们一一讲解上面代码： 首先，我们需要先开启仙人模式。哦，不是，是 HTTP 模式。我们都知道，像 PHP 这类老牌子的后端语言，需要 Apache 或者 Nginx 开启 HTTP 服务。然而我们的 Node 不需要： var http = require(\"http\"); 然后，开启 HTTP 服务，并设置开启的端口： /** * req 获取 url 信息 (request) * res 浏览器返回响应信息 (response) */ http.createServer(function (req, res) { // ... 步骤 3 代码 }).listen(3000); // 监听的端口 接着，我们设置 HTTP 头部，并往页面打印值，最后结束响应： // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8 res.writeHead(200, { \"Content-Type\": \"text/html;charset=UTF-8\" }); // 往页面打印值 res.write('Hello NodeJS'); // 结束响应 res.end(); 最后，我们往浏览器输入 http://localhost:3000/，将访问到我们开启的 Node 服务，从而往页面渲染页面。  至此，小伙伴们是不是也开启了自己的 Node 之旅？ 3.2 URL 模块 返回目录  URL 模块是什么呢？ 我们在控制台（终端）开启 Node 模式，并打印出 url 来看一下：  好家伙，它有 Url、parse、resolve、resolveObject、format、URL、URLSearchParams、domainToASCII、domainToUnicode 这么多模块。 那么，这些模块都有什么用呢？  话不多说，先上代码： 02_url.js // 1. 引入 url 模块 var url = require(\"url\"); // 2. 引入 http 模块 var http = require(\"http\"); // 3. 用 http 模块创建服务 /** * req 获取 url 信息 (request) * res 浏览器返回响应信息 (response) */ http.createServer(function (req, res) { // 4. 获取服务器请求 /** * 访问地址是：http://localhost:3000/?userName=jsliang&userAge=23 * 如果你执行 console.log(req.url)，它将执行两次，分别返回下面的信息： * / ?userName=jsliang&userAge=23 * / /favicon.ico * 这里为了防止重复执行，所以排除 req.url == /favicon.ico 的情况 */ if(req.url != \"/favicon.ico\") { // 5. 使用 url 的 parse 方法 /** * parse 方法需要两个参数： * 第一个参数是地址 * 第二个参数是 true 的话表示把 get 传值转换成对象 */ var result = url.parse(req.url, true); console.log(result); /** * Url { * protocol: null, * slashes: null, * auth: null, * host: null, * port: null, * hostname: null, * hash: null, * search: '?userName=jsliang&userAge=23', * query: { userName: 'jsliang', userAge: '23' }, * pathname: '/', * path: '/?userName=jsliang&userAge=23', * href: '/?userName=jsliang&userAge=23' } */ console.log(result.query.userName); // jsliang console.log(result.query.userAge); // 23 } // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8 res.writeHead(200, { \"Content-Type\": \"text/html;charset=UTF-8\" }); // 往页面打印值 res.write('Hello NodeJS'); // 结束响应 res.end(); }).listen(3000);  在上面的代码中：  首先，我们引入该章节的主角 url 模块： // 1. 引入 url 模块 var url = require(\"url\");  然后，我们引入 http 模块： // 2. 引入 http 模块 var http = require(\"http\");  接着，我们创建 http 模块，因为 url 的监听，需要 http 模块的开启： // 3. 用 http 模块创建服务 /** * req 获取 url 信息 (request) * res 浏览器返回响应信息 (response) */ http.createServer(function (req, res) { // ... 第 4 步、第 5 步代码 // 设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8 res.writeHead(200, { \"Content-Type\": \"text/html;charset=UTF-8\" }); // 往页面打印值 res.write('Hello NodeJS'); // 结束响应 res.end(); }).listen(3000);  最后，我们访问我们给出的地址：http://localhost:3000/?userName=jsliang&userAge=23，并通过它查看 url 的 parse 模块怎么用，输出啥： // 4. 获取服务器请求 /** * 访问地址是：http://localhost:3000/?userName=jsliang&userAge=23 * 如果你执行 console.log(req.url)，它将执行两次，分别返回下面的信息： * / ?userName=jsliang&userAge=23 * / /favicon.ico * 这里为了防止重复执行，所以排除 req.url == /favicon.ico 的情况 */ if(req.url != \"/favicon.ico\") { // 5. 使用 url 的 parse 方法 /** * parse 方法需要两个参数： * 第一个参数是地址 * 第二个参数是 true 的话表示把 get 传值转换成对象 */ var result = url.parse(req.url, true); console.log(result); /** * Url { * protocol: null, * slashes: null, * auth: null, * host: null, * port: null, * hostname: null, * hash: null, * search: '?userName=jsliang&userAge=23', * query: { userName: 'jsliang', userAge: '23' }, * pathname: '/', * path: '/?userName=jsliang&userAge=23', * href: '/?userName=jsliang&userAge=23' } */ console.log(result.query.userName); // jsliang console.log(result.query.userAge); // 23 }  从中，我们可以看出，我们可以通过 query，获取到我们想要的路径字段。  当然，上面只讲解了 parse 的用法，我们可以将上面代码中 if 语句里面的代码全部清空。然后，输入下面的内容，去学习 url 模块更多的内容： url 模块所有内容： console.log(url); /** * Console： { Url: [Function: Url], parse: [Function: urlParse], // 获取地址信息 resolve: [Function: urlResolve], // 追加或者替换地址 resolveObject: [Function: urlResolveObject], format: [Function: urlFormat], // 逆向 parse，根据地址信息获取原 url 信息 URL: [Function: URL], URLSearchParams: [Function: URLSearchParams], domainToASCII: [Function: domainToASCII], domainToUnicode: [Function: domainToUnicode] } */ parse 如何使用 console.log(url.parse(\"http://www.baidu.com\")); /** * Console： Url { protocol: 'http:', slashes: true, auth: null, host: 'www.baidu.com', port: null, hostname: 'www.baidu.com', hash: null, search: null, query: null, pathname: '/', path: '/', href: 'http://www.baidu.com/' } */ parse 带参数： console.log(url.parse(\"http://www.baidu.com/new?name=zhangsan\")); /** * Console： Url { protocol: 'http:', slashes: true, auth: null, host: 'www.baidu.com', port: null, hostname: 'www.baidu.com', hash: null, search: '?name=zhangsan', query: 'name=zhangsan', pathname: '/new', path: '/new?name=zhangsan', href: 'http://www.baidu.com/new?name=zhangsan' } */ format 的使用： console.log(url.format({ protocol: 'http:', slashes: true, auth: null, host: 'www.baidu.com', port: null, hostname: 'www.baidu.com', hash: null, search: '?name=zhangsan', query: 'name=zhangsan', pathname: '/new', path: '/new?name=zhangsan', href: 'http://www.baidu.com/new?name=zhangsan' })) // Console： // http://www.baidu.com/new?name=zhangsan resolve 的使用： console.log(url.resolve(\"http://www.baidu.com/jsliang\", \"梁峻荣\")); // Console： // http://www.baidu.com/梁峻荣  当然，url 这里我们只讲解了个入门，更多的还请看官网 API：url | Node.js v10.14.1 文档 3.3 CommonJS 返回目录 什么是 CommonJS？  CommonJS 就是为 JS 的表现来制定规范，因为 JS 没有模块系统、标准库较少、缺乏包管理工具，所以 CommonJS 应运而生，它希望 JS 可以在任何地方运行，而不只是在浏览器中，从而达到 Java、C#、PHP 这些后端语言具备开发大型应用的能力。 CommonJS 的应用？ 服务器端 JavaScript 应用程序。（Node.js） 命令行工具 桌面图形界面应用程序。 CommonJS 与 Node.js 的关系？  CommonJS 就是模块化的标准，Node.js 就是 CommonJS（模块化）的实现。 Node.js 中的模块化？ 在 Node 中，模块分为两类：一是 Node 提供的模块，称为核心模块；二是用户编写的模块，成为文件模块。核心模块在 Node 源代码的编译过程中，编译进了二进制执行文件，所以它的加载速度是最快的，例如：HTTP 模块、URL 模块、FS 模块；文件模块是在运行时动态加载的，需要完整的路劲分析、文件定位、编译执行过程等……所以它的速度相对核心模块来说会更慢一些。 我们可以将公共的功能抽离出一个单独的 JS 文件存放，然后在需要的情况下，通过 exports 或者 module.exports 将模块导出，并通过 require 引入这些模块。  现在，我们通过三种使用方式，来讲解下 Node 中的模块化及 exports/require 的使用。  我们先查看下目录：  方法一：  首先，我们新建 03_CommonJS.js、03_tool-add.js、node_modules/03_tool-multiply.js、node_modules/jsliang-module/tools.js 这 4 个文件/文件夹。 其中 package.json 我们暂且不理会，稍后会讲解它如何自动生成。  在 03_tool-add.js 中： 03_tool-add.js // 1. 假设我们文件其中有个工具模块 var tools = { add: (...numbers) => { let sum = 0; for (let number in numbers) { sum += numbers[number]; } return sum; } } /** * 2. 暴露模块 * exports.str = str; * module.exports = str; * 区别： * module.exports 是真正的接口 * exports 是一个辅助工具 * 如果 module.exports 为空，那么所有的 exports 收集到的属性和方法，都赋值给了 module.exports * 如果 module.exports 具有任何属性和方法，则 exports 会被忽略 */ // exports 使用方法 // var str = \"jsliang is very good!\"; // exports.str = str; // { str: 'jsliang is very good!' } // module.exports 使用方法 module.exports = tools;  那么，上面的代码有啥含义呢？ 第一步，我们定义了个工具库 tools。 第二步，我们通过 modules.exports 将 tools 进行了导出。 所以，我们在 03_CommonJS.js 可以通过 require 导入使用： var http = require(\"http\"); var tools1 = require('./03_tool-add'); http.createServer(function (req, res) { res.writeHead(200, { \"Content-Type\": \"text/html;charset=UTF-8\" }); res.write('Hello NodeJS'); console.log(tools1.add(1, 2, 3)); /** * Console： * 6 * 6 * 这里要记得 Node 运行过程中，它请求了两次， * http://localhost:3000/ 为一次， * http://localhost:3000/favicon.ico 为第二次 */ res.end(); }).listen(3000);  这样，我们就完成了 exports 与 require 的初次使用。  方法二：  当我们模块文件过多的时候，应该需要有个存放这些模块的目录，Node 就很靠谱，它规范我们可以将这些文件都放在 node_modules 目录中（大家都放在这个目录上，就不会有其他乱七八糟的命名了）。  所以，我们在 node_modules 中新建一个 03_tool-multiply.js 文件，其内容如下： 03_tool-multiply.js var tools = { multiply: (...numbers) => { let sum = numbers[0]; for (let number in numbers) { sum = sum * numbers[number]; } return sum; } } module.exports = tools;  在引用方面，我们只需要通过： // 如果 Node 在当前目录没找到 tool.js 文件，则会去 node_modules 里面去查找 var tools2 = require('03_tool-multiply'); console.log(tools2.multiply(1, 2, 3, 4));  这样，就可以成功导入 03_tool-multiply.js 文件了。  方法三：  如果全部单个文件丢在 node_modules 上，它会显得杂乱无章，所以我们应该定义个自己的模块：jsliang-module，然后将我们的 tools.js 存放在该目录中： jsliang-module/tools.js var tools = { add: (...numbers) => { let sum = 0; for (let number in numbers) { sum += numbers[number]; } return sum; }, multiply: (...numbers) => { let sum = numbers[0]; for (let number in numbers) { sum = sum * numbers[number]; } return sum; } } module.exports = tools;  这样，我们就定义好了自己的工具库。 但是，如果我们通过 var tools3 = require('jsliang-module'); 去导入，会发现它报 error 了，所以，我们应该在 jsliang-module 目录下，通过下面命令行生成一个 package.json PS E:\\MyWeb\\node_modules\\jsliang-module> npm init --yes  这样，在 jsliang-module 中就有了 package.json。 而我们在 03_CommonJS.js 就可以引用它了： 03_CommonJS.js var http = require(\"http\"); var tools1 = require('./03_tool-add'); // 如果 Node 在当前目录没找到 tool.js 文件，则会去 node_modules 里面去查找 var tools2 = require('03_tool-multiply'); /** * 通过 package.json 来引用文件 * 1. 通过在 jsliang-module 中 npm init --yes 来生成 package.json 文件 * 2. package.json 文件中告诉了程序入口文件为 ：\"main\": \"tools.js\", * 3. Node 通过 require 查找 jsliang-module，发现它有个 package.json * 4. Node 执行 tools.js 文件 */ var tools3 = require('jsliang-module'); http.createServer(function (req, res) { res.writeHead(200, { \"Content-Type\": \"text/html;charset=UTF-8\" }); res.write('Hello NodeJS'); console.log(tools1.add(1, 2, 3)); console.log(tools2.multiply(1, 2, 3, 4)); console.log(tools3.add(4, 5, 6)); /** * Console： * 6 * 24 * 15 * 6 * 24 * 15 * 这里要记得 Node 运行过程中，它请求了两次， * http://localhost:3000/ 为一次， * http://localhost:3000/favicon.ico 为第二次 */ res.end(); }).listen(3000);  到此，我们就通过三种方法，了解了各种 exports 和 require 的姿势以及 Node 模块化的概念啦~  参考文献： CommonJS 规范 | 博客园 - Little Bird js模块化编程之彻底弄懂CommonJS和AMD/CMD！ | 博客园 - 方便以后复习 [js高手之路] es6系列教程 - 不定参数与展开运算符(...) | 博客园 - ghostwu 3.4 包与 npm 返回目录  Node 中除了它自己提供的核心模块之外，还可以自定义模块，以及使用 第三方模块。 Node 中第三方模块由包组成，可以通过包来对一组具有相互依赖关系的模块进行统一管理。  那么，假如我们需要使用一些第三方模块，应该去哪找呢？ 百度。百度查找你需要安装的第三方模块的对应内容。 npm 官网。如果你已经知道包的名字或者包的作用。那么，直接在 npm 官网上搜索，想必会更快找到想要安装的包。  那么，npm 是啥？ npm 是世界上最大的开放源代码的生态系统。我们可以通过 npm 下载各种各样的包。 在我们安装 Node 的时候，它默认会顺带给你安装 npm。 npm -v：查看 npm 版本。 npm list：查看当前目录下都安装了哪些 npm 包。 npm info 模块：查看该模块的版本及内容。 npm i 模块@版本号：安装该模块的指定版本。  在平时使用 npm 安装包的过程中，你可能需要知道一些 npm 基本知识： i/install：安装。使用 install 或者它的简写 i，都表明你想要下载这个包。 uninstall：卸载。如果你发现这个模块你已经不使用了，那么可以通过 uninstall 卸载它。 g：全局安装。表明这个包将安装到你的计算机中，你可以在计算机任何一个位置使用它。 --save/-S：通过该种方式安装的包的名称及版本号会出现在 package.json 中的 dependencies 中。dependencies 是需要发布在生成环境的。例如：ElementUI 是部署后还需要的，所以通过 -S 形式来安装。 --save-dev/-D：通过该种方式安装的包的名称及版本号会出现在 package.json 中的 devDependencies 中。devDependencies 只在开发环境使用。例如：gulp 只是用来压缩代码、打包的工具，程序运行时并不需要，所以通过 -D 形式来安装。  例子： cnpm i webpack-cli -D npm install element-ui -S  那么，这么多的 npm 包，我们通过什么管理呢？ 答案是 package.json。 如果我们需要创建 package.json，那么我们只需要在指定的包管理目录（例如 node_modules）中通过以下命名进行生成： npm init：按步骤创建 package.json。 npm init --yes：快速创建 package.json  当然，因为国内网络环境的原因，有些时候通过 npm 下载包，可能会很慢或者直接卡断，这时候就要安装淘宝的 npm 镜像：cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org 3.5 fs 文件管理 返回目录  本章节我们讲解下 fs 文件管理： 如需快速找到下面某个内容，请使用 Ctrl + F fs.stat 检测是文件还是目录 fs.mkdir 创建目录 fs.writeFile 创建写入文件 fs.appendFile 追加文件 fs.readFile 读取文件 fs.readdir 读取目录 fs.rename 重命名 fs.rmdir 删除目录 fs.unlink 删除文件 此章节文件目录：  首先，我们通过 fs.stat 检查一个读取的是文件还是目录： 05_fs.js // 1. fs.stat let fs = require('fs'); fs.stat('index.js', (error, stats) => { if(error) { console.log(error); return false; } else { console.log(stats); /** * Console： * Stats { * dev: 886875, * mode: 33206, * nlink: 1, * uid: 0, * gid: 0, * rdev: 0, * blksize: undefined, * ino: 844424931461390, * size: 284, * blocks: undefined, * atimeMs: 1542847157494, * mtimeMs: 1543887546361.2158, * ctimeMs: 1543887546361.2158, * birthtimeMs: 1542847157493.663, * atime: 2018-11-22T00:39:17.494Z, * mtime: 2018-12-04T01:39:06.361Z, * ctime: 2018-12-04T01:39:06.361Z, * birthtime: 2018-11-22T00:39:17.494Z } */ console.log(`文件：${stats.isFile()}`); // Console：文件：true console.log(`目录：${stats.isDirectory()}`); // Console：目录：false return false; } })  通过 Console 打印出来的信息，我们基础掌握了 fs.stat 的作用。  然后，我们尝试通过 fs.mkdir 创建目录： 05_fs.js // 2. fs.mkdir let fs = require('fs'); /** * 接收参数 * path - 将创建的目录路径 * mode - 目录权限（读写权限），默认 0777 * callback - 回调，传递异常参数 err */ fs.mkdir('css', (err) => { if(err) { console.log(err); return false; } else { console.log(\"创建目录成功！\"); // Console：创建目录成功！ } })  通过 node 05_fs.js，我们发现目录中多了一个 css 文件夹。  那么，有创建就有删除，创建的目录如何删除呢？这里讲解下 fs.rmdir： 05_fs.js // 8. fs.rmdir let fs = require('fs'); /** * 接收参数 * path - 将创建的目录路径 * mode - 目录权限（读写权限），默认 0777 * callback - 回调，传递异常参数 err */ fs.rmdir('css', (err) => { if(err) { console.log(err); return false; } else { console.log(\"创建目录成功！\"); // Console：创建目录成功！ } })  通过 node 05_fs.js，我们发现目录中的 css 文件夹被删除了。  接着，我们通过 fs.writeFile 来创建写入文件： 05_fs.js // 3. fs.writeFile let fs = require('fs'); /** * filename (String) 文件名称 * data (String | Buffer) 将要写入的内容，可以是字符串或者 buffer 数据。 * · encoding (String) 可选。默认 'utf-8'，当 data 是 buffer 时，该值应该为 ignored。 * · mode (Number) 文件读写权限，默认 438。 * · flag (String) 默认值 'w'。 * callback { Function } 回调，传递一个异常参数 err。 */ fs.writeFile('index.js', 'Hello jsliang', (err) => { if(err) { console.log(err); return false; } else { console.log('写入成功！'); } })  值得注意的是，这样的写入，是清空原文件中的所有数据，然后添加 Hello jsliang 这句话。即：存在即覆盖，不存在即创建。  有创建就有删除，感兴趣的可以使用 fs.unlink 进行文件的删除，再次不做过多讲解。  既然，上面的是覆盖文件，那么有没有追加文件呢？有的，使用 fs.appendFile 吧： 05_fs.js // 4. fs.appendFile let fs = require('fs'); fs.appendFile('index.js', '这段文本是要追加的内容', (err) => { if(err) { console.log(err); return false; } else { console.log(\"追加成功\"); } })  这样，我们就成功往里面追加了一段话，从而使 index.js 变成了： index.js Hello jsliang这段文本是要追加的内容  在上面，我们已经做了：新增、修改、删除操作。那么小伙伴一定很熟悉下一步骤是做什么了： fs.readFile 读取文件 fs.readdir 读取目录 05_fs.js let fs = require('fs'); // 5. fs.readFile fs.readFile('index.js', (err, data) => { if(err) { console.log(err); return false; } else { console.log(\"读取文件成功！\"); console.log(data); // Console： // 读取文件成功！ // } }) // 6. fs.readdir 读取目录 fs.readdir('node_modules', (err, data) => { if(err) { console.log(err); return false; } else { console.log(\"读取目录成功！\"); console.log(data); // Console： // 读取目录成功！ // [ '03_tool-multiply.js', 'jsliang-module' ] } })  如上，我们成功做到了读取文件和读取目录。  最后，我们再回顾一开始的目标： 1. fs.stat 检测是文件还是目录2. fs.mkdir 创建目录3. fs.writeFile 创建写入文件4. fs.appendFile 追加文件5. fs.readFile 读取文件6. fs.readdir 读取目录 fs.rename 重命名8. fs.rmdir 删除目录9. fs.unlink 删除文件  很好，我们就剩下重命名了： 05_fs.js let fs = require('fs'); // 7. fs.rename 重命名 fs.rename('index.js', 'jsliang.js', (err) => { if(err) { console.log(err); return false; } else { console.log(\"重命名成功！\"); } })  当然，如果 fs.rename 还有更劲爆的功能：剪切 05_fs.js let fs = require('fs'); // 7. fs.rename 重命名 fs.rename('jsliang.js', 'node_modules/jsliang.js', (err) => { if(err) { console.log(err); return false; } else { console.log(\"剪切成功！\"); } })  OK，通通搞定，现在目录变成了： 3.6 fs 案例 返回目录  在上一章节中，我们了解了 fs 的文件管理。 那么，在这里，我们尝试使用 fs 做点小事情： 06_fsDemo.js /** * 1. fs.stat 检测是文件还是目录 * 2. fs.mkdir 创建目录 * 3. fs.writeFile 创建写入文件 * 4. fs.appendFile 追加文件 * 5. fs.readFile 读取文件 * 6. fs.readdir 读取目录 * 7. fs.rename 重命名 * 8. fs.rmdir 删除目录 * 9. fs.unlink 删除文件 */ // 1. 判断服务器上面有没有 upload 目录，没有就创建这个目录 // 2. 找出 html 目录下面的所有的目录，然后打印出来 let fs = require('fs'); // 图片上传 fs.stat('upload', (err, stats) => { // 判断有没有 upload 目录 if(err) { // 如果没有 fs.mkdir('upload', (error) => { if(error) { console.log(error); return false; } else { console.log(\"创建 upload 目录成功！\"); } }) } else { // 如果有 console.log(stats.isDirectory()); console.log(\"有 upload 目录，你可以做更多操作！\"); } }) // 读取目录全部文件 fs.readdir('node_modules', (err, files) => { if(err) { console.log(err); return false; } else { // 判断是目录还是文件夹 console.log(files); let filesArr = []; (function getFile(i) { // 循环结束 if(i == files.length) { // 打印出所有目录 console.log(\"目录：\"); console.log(filesArr); return false; } // 判断目录是文件还是文件夹 fs.stat('node_modules/' + files[i], (error, stats) => { if(stats.isDirectory()) { filesArr.push(files[i]); } // 递归调用 getFile(i+1); }) })(0) } }) 3.7 fs 流 返回目录  话不多说，我们了解下 fs 流及其读取： // 新建 fs const fs = require('fs'); // 流的方式读取文件 let fileReadStream = fs.createReadStream('index.js'); // 读取次数 let count = 0; // 保存数据 let str = ''; // 开始读取 fileReadStream.on('data', (chunk) => { console.log(`${++count} 接收到：${chunk.length}`); // Console：1 接收到：30 str += chunk; }) // 读取完成 fileReadStream.on('end', () => { console.log(\"——结束——\"); console.log(count); console.log(str); // Console：——结束—— // 1 // console.log(\"Hello World！\"); }) // 读取失败 fileReadStream.on('error', (error) => { console.log(error); })  在这里，我们通过 fs 模块的 createReadStream 创建了读取流，然后读取文件 index.js，从而最后在控制台输出了： 1 接收到：259 ——结束—— 1 console.log(\"尽信书，不如无书；尽看代码，不如删掉这些文件。\"); console.log(\"尽信书，不如无书；尽看代码，不如删掉这些文件。\"); console.log(\"尽信书，不如无书；尽看代码，不如删掉这些文件。\");  其中 console.log() 那三行就是 index.js 的文本内容。  然后，我们试下流的存入： let fs = require('fs'); let data = 'console.log(\"Hello World! 我要存入数据！\")'; // 创建一个可以写入的流，写入到文件 index.js 中 let writeStream = fs.createWriteStream('index.js'); // 开始写入 writeStream.write(data, 'utf8'); // 写入完成 writeStream.end(); writeStream.on('finish', () => { console.log('写入完成！'); // Console：写入完成 });  我们打开 index.js，会发现里面的内容变成了 console.log(\"Hello World! 我要存入数据！\")，依次，我们通过流的形式进行了读取和写入的操作。 3.8 创建 Web 服务器 返回目录  在这里，我们利用 http 模块、url 模块、path 模块、fs 模块创建一个 Web 服务器。  什么是 Web 服务器？ Web 服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以像浏览器等 Web 客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个 Web 服务器是 Apache、Nginx、IIS。  下面，我们使用 Node 来创建一个 Web 服务： 08_WebService.js // 引入 http 模块 let http = require(\"http\"); // 引入 fs 模块 let fs = require(\"fs\"); http.createServer((req, res) => { // 获取响应路径 let pathName = req.url; // 默认加载路径 if (pathName == \"/\") { // 默认加载的首页 pathName = \"index.html\"; } // 过滤 /favicon.ico 的请求 if (pathName != \"/favicon.ico\") { // 获取 08_WebService 下的 index.html fs.readFile(\"./08_WebService/\" + pathName, (err, data) => { if (err) { // 如果不存在这个文件 console.log(\"404 Not Found!\"); fs.readFile('./08_WebService/404.html', (errorNotFound, dataNotFound) => { if(errorNotFound) { console.log(errorNotFound); } else { res.writeHead(200, { \"Content-Type\": \"text/html; charset='utf-8'\" }); // 读取写入文件 res.write(dataNotFound); // 结束响应 res.end(); } }) return; } else { // 返回这个文件 // 设置请求头 res.writeHead(200, { \"Content-Type\": \"text/html; charset='utf-8'\" }); // 读取写入文件 res.write(data); // 结束响应 res.end(); } }); } }).listen(8080);  这样，我们在浏览器输入 localhost:8080 即可以看到：  好家伙，感情它就加载了整个 index.html 文件，连 CSS 这些没引入么？ 所以，下一步，我们要动态加载 html、css 以及 js： 08_WebService.js // 引入 http 模块 let http = require(\"http\"); // 引入 fs 模块 let fs = require(\"fs\"); // 引入 url 模块 let url = require(\"url\"); // 引入 path 模块 let path = require(\"path\"); http.createServer((req, res) => { // 获取响应路径 let pathName = url.parse(req.url).pathname; // 默认加载路径 if (pathName == \"/\") { // 默认加载的首页 pathName = \"index.html\"; } // 获取文件的后缀名 let extName = path.extname(pathName); // 过滤 /favicon.ico 的请求 if (pathName != \"/favicon.ico\") { // 获取 08_WebService 下的 index.html fs.readFile(\"./08_WebService/\" + pathName, (err, data) => { // 如果不存在这个文件 if (err) { console.log(\"404 Not Found!\"); fs.readFile( \"./08_WebService/404.html\", (errorNotFound, dataNotFound) => { if (errorNotFound) { console.log(errorNotFound); } else { res.writeHead(200, { \"Content-Type\": \"text/html; charset='utf-8'\" }); // 读取写入文件 res.write(dataNotFound); // 结束响应 res.end(); } } ); return; } // 返回这个文件 else { // 获取文件类型 let ext = getExt(extName); // 设置请求头 res.writeHead(200, { \"Content-Type\": ext + \"; charset='utf-8'\" }); // 读取写入文件 res.write(data); // 结束响应 res.end(); } }); } }).listen(8080); // 获取后缀名 getExt = (extName) => { switch(extName) { case '.html': return 'text/html'; case '.css': return 'text/css'; case '.js': return 'text/js'; default: return 'text/html'; } }  这样，当我们再次请求的时候，浏览器就变成了：  当然，在上面，我们仅仅模拟了 html、css、js 这三种文件类型而已，我们需要模拟更多的文件类型： 08_ext.json 代码详情请点击上面的链接  在上面的 json 文件中，我们定义了各种的文件类型，此刻文件目录如下所示：  这时候，我们需要修改下我们的 js 文件，让它适应多种请求响应了： 08_WebService.js // 引入 http 模块 let http = require(\"http\"); // 引入 fs 模块 let fs = require(\"fs\"); // 引入 url 模块 let url = require(\"url\"); // 引入 path 模块 let path = require(\"path\"); http.createServer((req, res) => { // 获取响应路径 let pathName = url.parse(req.url).pathname; // 默认加载路径 if (pathName == \"/\") { // 默认加载的首页 pathName = \"index.html\"; } // 获取文件的后缀名 let extName = path.extname(pathName); // 过滤 /favicon.ico 的请求 if (pathName != \"/favicon.ico\") { // 获取 08_WebService 下的 index.html fs.readFile(\"./08_WebService/\" + pathName, (err, data) => { // 如果不存在这个文件 if (err) { console.log(\"404 Not Found!\"); fs.readFile( \"./08_WebService/404.html\", (errorNotFound, dataNotFound) => { if (errorNotFound) { console.log(errorNotFound); } else { res.writeHead(200, { \"Content-Type\": \"text/html; charset='utf-8'\" }); // 读取写入文件 res.write(dataNotFound); // 结束响应 res.end(); } } ); return; } // 返回这个文件 else { // 获取文件类型 let ext = getExt(extName); console.log(ext); // 设置请求头 res.writeHead(200, { \"Content-Type\": ext + \"; charset='utf-8'\" }); // 读取写入文件 res.write(data); // 结束响应 res.end(); } }); } }).listen(8080); // 获取后缀名 getExt = (extName) => { // readFile 是异步操作，所以需要使用 readFileSync let data = fs.readFileSync('./08_ext.json'); let ext = JSON.parse(data.toString()); return ext[extName]; }  如此，我们做了个简单的 Web 服务器。 3.9 非阻塞 I/O 事件驱动 返回目录  Java、PHP 或者 .NET 等服务端语言，会为每一个客户端的连接创建一个新的线程。 Node 不会为每一个客户连接创建一个新的线程，而仅仅使用一个线程。 当有用户连接了，就会触发一个内部事件，通过非租塞 I/O、事件驱动机制，让 Node 程序宏观上也是并行的。 使用 Node，一个 8GB 内存的服务器，可以同时处理超过 4 万用户的连接。  在这一章节中，主要解决： Node 的非阻塞 I/O 是什么？ Node events 模块是什么？  首先，在我们正常编程中，我们是希望程序能够一行一行按照我们的意愿编写的： 09_io.js console.log(\"1\"); console.log(\"2\"); console.log(\"3\"); /** * Console： * 1 * 2 * 3 */  但是，事与愿违。 我们有时候，会执行一些异步方法（函数）： 09_io.js console.log(\"1\"); // console.log(\"2\"); let fs = require('fs'); getExt = () => { fs.readFile('08_ext.json', (err, data) => { console.log(\"2\"); }) } getExt(); console.log(\"3\"); /** * Console： * 1 * 3 * 2 */  在上面代码中，由于 fs.readFile 是 Node 的异步函数。所以，程序先执行了 1 和 3，最后才执行 fs.readFile 的 2 部分。 在这里，可以看出 Node 不会因为一段代码的逻辑错误，从而导致其他代码无法运行。  这样子，就导致了一个问题：步骤 3 可能拿不到步骤 2 的执行结果了！这就是 Node 的非租塞性 I/O 驱动。 那么，我们有没有办法解决这个问题呢？ 有的！ 通过回调函数 通过 Node 的 events 模块  首先，我们通过回调函数来解决这个异步问题： 09_io.js let fs = require(\"fs\"); getExt = (callback) => { fs.readFile('08_ext.json', (err, data) => { callback(data); }) } getExt( (result) => { console.log(result.toString()); })  通过回调，我们可以将 getExt 的数据提取出来。  然后，我们通过 Node 的 events 模块来解决这个异步问题： // 引入 fs 模块 let fs = require(\"fs\"); /** * Node 事件循环： * 1. Node 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。 * 2. Node 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。 * 3. Node 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件。 */ // 引入 events 模块 let events = require(\"events\"); // 实例化事件对象 let EventEmitter = new events.EventEmitter(); getExt = () => { fs.readFile('08_ext.json', (err, data) => { // 将 data 广播出去 EventEmitter.emit('data', data.toString()); }) }; getExt(); // 监听 data EventEmitter.on('data', (ext) => { console.log(ext); });  在这里，EventEmitter.on 通过监听 data 的形式，获取了 getExt 内部的执行结果。 如此，我们就了解了 Node 的 I/O 事件及 events 模块 3.10 get 与 post 返回目录  话不多说，先上代码： index.js // 加载 http 模块 var http = require('http'); // 虚拟 SQL 读取出来的数据 var items = []; // 创建 http 服务 http.createServer(function (req, res) { // 设置跨域的域名，* 代表允许任意域名跨域 res.setHeader('Access-Control-Allow-Origin', '*'); // 设置 header 类型 res.setHeader('Access-Control-Allow-Headers', 'Content-Type'); // 跨域允许的请求方式 res.setHeader('Content-Type', 'application/json'); // 判断请求 switch (req.method) { // post 请求时，浏览器会先发一次 options 请求，如果请求通过，则继续发送正式的 post 请求 case 'OPTIONS': res.statusCode = 200; res.end(); break; // 如果是 get 请求，则直接返回 items 数组 case 'GET': let data = JSON.stringify(items); res.write(data); res.end(); break; // 如果是 post 请求 case 'POST': let item = ''; // 读取每次发送的数据 req.on('data', function (chunk) { item += chunk; }); // 数据发送完成 req.on('end', function () { // 存入 item = JSON.parse(item); items.push(item.item); // 将数据返回到客户端 let data = JSON.stringify(items); res.write(data); res.end(); }); break; } }).listen(3000) console.log('http server is start...');  首先，我们加载了 http 模块，并创建了服务。 然后，我们设置了跨域的处理方式，允许进行跨域。 接着，我们进行了请求的判断处理，由于只做简单演练，故只判断是 get 请求还是 post 请求。 最后，我们将请求的结果返回给客户端。  在上面，我们进行了后端 Node 的部署，那么前端页面要怎么做呢？ index.html Node Web Todo List {{ item }} 添加 new Vue({ el: document.getElementById('app'), data: function () { return { items: [], item: '', } }, created() { // 进入页面请求数据 axios.get('http://localhost:3000/').then(res => { console.log(\"\\n【API - get 数据】\"); console.log(res); this.items = res.data; }).catch(function (err) { console.log(err) }) }, methods: { // 点击按钮提交数据 postApi() { axios.post('http://localhost:3000/', { item: this.item }).then(res => { console.log(\"\\n【API - post 数据】\") console.log(res); this.items = res.data; }).catch(function (err) { console.log(err) }) } } })  我们通过 Vue 进行了布局，通过 Axios 进行了接口的请求。从而完成了对数据的操作。 3.11 Node 连接 MySQL 返回目录 关于 MySQL 的安装，可以查看 jsliang 写的：MySQL 安装及图形化工具  首先，我们通过可视化工具进行表的设计： 名 类型 长度 键 id int 11 主键 name varchar 255 age varchar 255  然后，我们进行表的填充： id name age 1 jslliang 23 2 梁峻荣 23  接着，我们安装 Node 连接 MySQL 的包： npm i mysql -D  再来，我们编写 Node 的 index.js： index.js var mysql = require('mysql'); var connection = mysql.createConnection({ host: 'localhost', user: 'root', password: '123456', database: 'node' }); connection.connect(); connection.query('SELECT * FROM user', function (error, results, fields) { if (error) throw error; console.log(results); }); connection.end();  最后，我们通过 node index.js，打开该服务： [ RowDataPacket { id: 1, name: 'jsliang', age: '23' }, RowDataPacket { id: 2, name: '梁峻荣', age: '23' } ]  如此，我们便完成了 Node 连接 MySQL。  ———————华丽分割线———————  当然，增删改查是后端的基本操作，所以在这里，我们可以补全基本的增删改查功能。  先看目录： 新增表字段 add.js var mysql = require('mysql'); var connection = mysql.createConnection({ host: 'localhost', user: 'root', password: '123456', database: 'node' }); connection.connect(); let addSql = \"INSERT INTO user(id,name,age) VALUES(0,?,?)\"; let addSqlParams = [\"jsliang\", \"23\"]; connection.query(addSql, addSqlParams, function (err, res) { if (err) { console.log(\"新增错误：\"); console.log(err); return; } else { console.log(\"新增成功：\"); console.log(res); } }); connection.end();  我们只需要直接 node add.js，就能往数据库中新增数据了。 删除表字段 delete.js // 连接 MySQL var mysql = require('mysql'); // MySQL 的连接信息 var connection = mysql.createConnection({ host: 'localhost', user: 'root', password: '123456', database: 'node' }); // 开始连接 connection.connect(); // 新增的 SQL 语句及新增的字段信息 var delSql = 'DELETE FROM user where id = 2'; // 连接 SQL 并实施语句 connection.query(delSql, function (err, res) { if (err) { console.log(\"删除错误：\"); console.log(err); return; } else { console.log(\"删除成功：\"); console.log(res); } }); // 终止连接 connection.end(); 修改表字段 update.js // 连接 MySQL var mysql = require('mysql'); // MySQL 的连接信息 var connection = mysql.createConnection({ host: 'localhost', user: 'root', password: '123456', database: 'node' }); // 开始连接 connection.connect(); // 新增的 SQL 语句及新增的字段信息 let updateSql = \"UPDATE user SET name = ?,age = ? WHERE Id = ?\"; let updateSqlParams = [\"LiangJunrong\", \"23\", 1]; // 连接 SQL 并实施语句 connection.query(updateSql, updateSqlParams, function (err, res) { if (err) { console.log(\"修改错误：\"); console.log(err); return; } else { console.log(\"修改成功：\"); console.log(res); } }); // 终止连接 connection.end(); 查询表字段 read.js // 连接 MySQL var mysql = require('mysql'); // MySQL 的连接信息 var connection = mysql.createConnection({ host: 'localhost', user: 'root', password: '123456', database: 'node' }); // 开始连接 connection.connect(); // 新增的 SQL 语句及新增的字段信息 let readSql = \"SELECT * FROM user\"; // 连接 SQL 并实施语句 connection.query(readSql, function (err, res) { if (err) throw err; console.log(res); }); // 终止连接 connection.end();  以上，我们打通了 Node 与 MySQL 的壁垒，实现了数据的增删改查。 四 Web 实战 —— 企业官网 返回目录  在进行代码实战的时候，我们很多时候会遇到一些小事儿，例如：logo 制作、ico 制作、icon 挑选等……  下面这些都是 jsliang 平时碰到的，小伙伴有需要的可以 mark 啦~ logo 制作 ico 制作 icon 挑选  另外，由于 HTML 与 CSS 没什么好讲的，所以本章节的前提静态页面 jsliang 已经写好了，小伙伴们在学习前可以预先下载： 本文静态页面代码地址 4.1 编程环境 返回目录  首先，我们查看下我们的前端基本代码：地址  如上，我们仅需要了解 FrontEndCode 目录以及 NodeWeb 目录即可，其他目录为上面章节练习参考。  然后，我们进行后端功能分析： 留言板。用户点击 留言板 的时候，需要先判断用户是否登录。如果用户尚未登录，则直接跳转到 登录页；如果用户登录了，则显示 留言板页面。  在 留言板页面 中，存在两个接口： 获取留言内容：调取 getMessage 接口，返回全部留言信息，由于预计信息不多，故这里不做分页功能，有需要的小伙伴在实现完这个功能后，可以进行分页接口的设计。 提交留言内容：调取 sendMessage 接口，将用户名、用户 id、留言内容发送给后端。 在 登录页面 中，存在一个接口： 登录：调取 login 接口，提交用户填写的姓名和密码。 在 注册页面 中，存在一个接口： 注册：调取 register 接口，提交用户填写的姓名和密码。  由此，我们可以设计下前后端的接口结合： 接口文档 接口 类型 参数 返回信息 getMessage：获取留言信息 get 无参 n 条记录：id(用户 id)、user_name(用户名)、user_message(用户留言内容)、time(留言时间) sendMessage：提交留言信息 post id(用户 id)、user_name(用户名)、user_message(用户留言内容) status 状态 login：登录 post id(用户 id)、user_name(用户名)、user_password(用户密码) status 状态 register：注册 post id(用户 id)、user_name(用户名)、user_password(用户密码) status 状态  最后，我们进行 MySQL 数据库的表设计： user 表 名 类型 长度 键 id int 11 主键 user_name varchar 255 user_password varchar 255 time datetime message 表 名 类型 长度 键 id int 11 主键 user_message varchar 255 user_id varchar 255 外键 user_name varchar 255 time datetime 4.2 后端接口 返回目录  在我们进行实操之前，先确认我们是否能写接口，所以我们可以新建一个 test 文件夹，里面放一个 index.html 以及一个 index.js 来测试一下。 - text - index.html - index.js  首先，我们就 4.1 提到的接口，提前进行后端接口的设置： index.js // 连接 MySQL：先安装 npm i mysql -D var mysql = require('mysql'); // MySQL 的连接信息 var connection = mysql.createConnection({ host: 'localhost', user: 'root', password: '123456', database: 'nodebase' }); // 开始连接 connection.connect(); // 引入 http 模块：http 是提供 Web 服务的基础 const http = require(\"http\"); // 引入 url 模块：url 是对用户提交的路径进行解析 const url = require(\"url\"); // 引入 qs 模块：qs 是对路径进行 json 化或者将 json 转换为 string 路径 const qs = require(\"querystring\"); // 用 http 模块创建服务 /** * req 获取 url 信息 (request) * res 浏览器返回响应信息 (response) */ http.createServer(function (req, res) { // 设置 cors 跨域 res.setHeader(\"Access-Control-Allow-Origin\", \"*\"); // 设置 header 类型 res.setHeader('Access-Control-Allow-Headers', 'Content-Type'); // 跨域允许的请求方式 res.setHeader('Content-Type', 'application/json'); if (req.method == \"POST\") { // 接口 POST 形式 console.log(\"\\n【POST 形式】\"); // 获取前端发来的路由地址 let pathName = req.url; console.log(\"\\n接口为：\" + pathName); // 接收发送过来的参数 let tempResult = \"\"; // 数据接入中 req.addListener(\"data\", function (chunk) { tempResult += chunk; }); // 数据接收完成 req.addListener(\"end\", function () { var result = JSON.stringify(qs.parse(tempResult)); console.log(\"\\n参数为：\"); console.log(result); if (pathName == \"/sendMessage\") { // 提交留言信息 console.log(\"\\n【API - 提交留言信息】\"); } else if (pathName == \"/login\") { // 登录 console.log(\"\\n【API - 登录】\"); } else if (pathName == \"/register\") { // 注册 console.log(\"\\n【API - 注册】\"); } // 接口信息处理完毕 }) // 数据接收完毕 } else if (req.method == \"GET\") { // 接口 GET 形式 console.log(\"\\n【GET 形式】\"); // 解析 url 接口 let pathName = url.parse(req.url).pathname; console.log(\"\\n接口为：\" + pathName); if (pathName == \"/getMessage\") { // 获取留言信息 console.log(\"\\n【API - 获取留言信息】\"); } else if(pathName == \"/\") { // 首页 res.writeHead(200, { \"Content-Type\": \"text/html;charset=UTF-8\" }); res.write('jsliang 前端有限公司服务已开启！详情可见：Node 基础'); res.end(); } } }).listen(8888); // 监听的端口 // 获取当前时间 function getNowFormatDate() { var date = new Date(); var year = date.getFullYear(); // 年 var month = date.getMonth() + 1; // 月 var strDate = date.getDate(); // 日 var hour = date.getHours(); // 时 var minute = date.getMinutes(); // 分 var second = date.getMinutes(); // 秒 if (month >= 1 && month = 0 && strDate  通过判断 req.method 属于 GET 还是 POST 形式，从而确定加载的接口： 在 POST 中，判断是属于 提交留言信息、登录 还是 注册； 在 GET 中，判断是不是 获取留言信息。  同时，我们在其中定义了 MySQL 的连接以及一个 getNowFormatDate 用来获取当前时间，格式为：2018-12-21 10:03:59  然后，我们通过一个前端页面来演示我们的接口是否能使用： index.html 演示代码 用户名 密&nbsp;&nbsp;&nbsp;码 注册 $(function () { // 测试 get 接口 $.ajax({ url: \"http://localhost:8888/getMessage\", type: \"POST\", data: { username: \"jsliang\" }, success: function (res) { console.log(res); }, error: function (err) { console.log(err); } }) $(\"#register\").click(function () { // 测试 post 接口 $.ajax({ url: \"http://localhost:8888/login\", type: \"POST\", data: { username: $(\"#user\").val(), password: $(\"#password\").val() }, success: function (res) { console.log(res); }, error: function (err) { console.log(err); } }) }) });  最后，我们通过 node index.js，并打开 index.html，通过 F12 控制台查看我们的接口是否正常：  可以看到我们的接口能正常调通，这样我们就可以连接数据库，进行这 4 个接口的设计了。 如果小伙伴们觉得每次更新 Node 代码后，又要重启一遍 node index.js 觉得麻烦，可以通过 supervisor 来监听 Node 代码的改动，supervisor 的安装使用：supervisor 4.3 注册功能 返回目录  很好，我们回到仿企业网站的页面上，准备编写接口以及丰富 Node 的接口。  首先，我们开启前端和 Node 服务： 打开命令行/终端 开启前端 cd FrontEndCode live-server 安装 live-server：npm i live-server -g 开启后端 cd NodeWeb supervisor index.js 安装 supervisor：npm i supervisor -g  然后，我们在注册页面通过点击事件来触发调接口： register.html 注册-jsliang 前端有限公司 $(function () { $(\"#register-submit\").click(function () { let userName = $(\"#userName\").val(); let userPassword = $(\"#userPassword\").val(); if (!userName) { alert(\"请输入用户名\"); $(\"#userName\").focus(); } else if (!userPassword) { alert(\"请输入密码\"); $(\"#userPassword\").focus(); } else if (userName.length > 10) { alert(\"请输入少于 10 位的用户名\"); $(\"#userName\").focus(); } else if (userPassword.length > 20) { alert(\"请输入少于 20 位的密码\"); $(\"#userPassword\").focus(); } else { // 如果用户输入的没毛病，那就加载接口 $.ajax({ url: \"http://localhost:8888/register\", type: 'post', dataType: 'json', data: { username: userName, password: userPassword }, success: function (res) { console.log(res); if (res.code == \"0\") { alert(\"注册成功，前往登录！\"); window.location.href = \"./login.html\"; } }, error: function (err) { console.log(err.responseText); if (err.responseText == \"注册失败，姓名重复！\") { alert(\"用户名已被注册！\"); } else if (err.responseText == \"注册失败，名额已满！\") { alert(\"注册失败，名额已满！\"); } else if (err.responseText == \"注册失败，密码为空！\") { alert(\"注册失败，密码为空！\"); } else if (err.responseText == \"注册失败，姓名过长！\") { alert(\"注册失败，姓名过长！\"); } else if (err.responseText == \"注册失败，密码过长！\") { alert(\"注册失败，密码过长！\"); } else { alert(\"未知错误！\"); } } }) } }) })  如此，我们在用户点击 注册 按钮的时候，进行接口的调用，发送数据到了后端，如果成功了，那就弹窗，并跳转到登录页；如果没成功，就弹窗提示。  接着，我们编写 Node，前端调用接口后，Node 判断这两个参数是否为空，如果不为空，则将数据存储到数据库。 index.js // ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码 if (pathName == \"/sendMessage\") { // 提交留言信息 console.log(\"\\n【API - 提交留言信息】\"); } else if (pathName == \"/login\") { // 登录 console.log(\"\\n【API - 登录】\"); } else if (pathName == \"/register\") { // 注册 console.log(\"\\n【API - 注册】\"); result = JSON.parse(result); let username = result.username; // 用户名 let password = result.password; // 密码 let time = getNowFormatDate(); // 时间 if (!username) { // 用户名为空 res.end(\"注册失败，用户名为空。\"); return; } else if (!password) { // 密码为空 res.end(\"注册失败，密码为空！\"); return; } else if(username.length > 10) { // 姓名过长 res.end(\"注册失败，姓名过长！\"); return; } else if(password.length > 20) { // 密码过长 res.end(\"注册失败，密码过长！\"); return; } else { // 查询 user 表 // 使用 Promise 的原因是因为中间调用了两次数据库，而数据库查询是异步的，所以需要用 Promise。 new Promise( (resolve, reject) => { // 新增的 SQL 语句及新增的字段信息 let readSql = \"SELECT * FROM user\"; // 连接 SQL 并实施语句 connection.query(readSql, function (error1, response1) { if (error1) { // 如果 SQL 语句错误 throw error1; } else { console.log(\"\\nSQL 查询结果：\"); // 将结果先去掉 RowDataPacket，再转换为 json 对象 let newRes = JSON.parse(JSON.stringify(response1)); console.log(newRes); // 判断姓名重复与否 let userNameRepeat = false; for(let item in newRes) { if(newRes[item].user_name == username) { userNameRepeat = true; } } // 如果姓名重复 if(userNameRepeat) { res.end(\"注册失败，姓名重复！\"); return; } else if(newRes.length > 300) { // 如果注册名额已满 res.end(\"注册失败，名额已满！\"); return; } else { // 可以注册 resolve(); } } }); }).then( () => { console.log(\"\\n第二步：\"); // 新增的 SQL 语句及新增的字段信息 let addSql = \"INSERT INTO user(user_name,user_password, time) VALUES(?,?,?)\"; let addSqlParams = [result.username, result.password, time]; // 连接 SQL 并实施语句 connection.query(addSql, addSqlParams, function (error2, response2) { if (error2) { // 如果 SQL 语句错误 console.log(\"新增错误：\"); console.log(error2); return; } else { console.log(\"\\nSQL 查询结果：\"); console.log(response2); console.log(\"\\n注册成功！\"); // 返回数据 res.write(JSON.stringify({ code: \"0\", message: \"注册成功！\" })); // 结束响应 res.end(); } }); }) // Promise 结束 } // 注册流程结束 }  最后，我们在查看下该功能是否成功： 4.4 登录功能 返回目录  在上面，我们完成了注册功能，那么相对来说，登录功能就容易通了，因为查询部分我们已经试过了一次。 login.html 登录-jsliang 前端有限公司 $(function () { $(\"#login-submit\").click(function () { let userName = $(\"#userName\").val(); // 用户名 let userPassword = $(\"#userPassword\").val(); // 密码 if (!userName) { alert(\"请输入用户名\"); $(\"#userName\").focus(); } else if (!userPassword) { alert(\"请输入密码\"); $(\"#userPassword\").focus(); } else if (userName.length > 10) { alert(\"请输入少于 10 位的用户名\"); $(\"#userName\").focus(); } else if (userPassword.length > 20) { alert(\"请输入少于 20 位的密码\"); $(\"#userPassword\").focus(); } else { $.ajax({ url: \"http://localhost:8888/login\", type: 'post', dataType: 'json', data: { username: userName, password: userPassword }, success: function (res) { console.log(res); if (res.code == \"0\") { sessionStorage.setItem(\"id\", res.data.id); sessionStorage.setItem(\"userName\", res.data.userName); alert(\"登录成功！\"); window.location.href = \"./messageBoard.html\"; } else if (res.code == \"1\") { alert(\"登录失败，密码错误！\"); } }, error: function (err) { console.log(err.responseText); if (err.responseText == \"不存在该用户！\") { alert(\"不存在该用户！\"); } else if (err.responseText == \"登录失败，用户名为空！\") { alert(\"登录失败，用户名为空！\"); } else if (err.responseText == \"登录失败，密码为空！\") { alert(\"登录失败，密码为空！\"); } else if (err.responseText == \"登录失败，姓名过长！\") { alert(\"登录失败，姓名过长！\"); } else if (err.responseText == \"登录失败，密码过长！\") { alert(\"登录失败，密码过长！\"); } else { alert(\"未知错误！\"); } } }) } }) })  编写完前端的代码后，我们进行 Node 代码的编辑： index.js // ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码 if (pathName == \"/sendMessage\") { // 提交留言信息 console.log(\"\\n【API - 提交留言信息】\"); } else if (pathName == \"/login\") { // 登录 console.log(\"\\n【API - 登录】\"); result = JSON.parse(result); let username = result.username; // 用户名 let password = result.password; // 密码 if (!username) { // 用户名为空 res.end(\"登录失败，用户名为空！\"); return; } else if (!password) { // 密码为空 res.end(\"登录失败，密码为空！\"); return; } else if(username.length > 10) { res.end(\"登录失败，姓名过长！\"); return; } else if(password.length > 20) { res.end(\"登录失败，密码过长！\"); return; } else { // 新增的 SQL 语句及新增的字段信息 let readSql = \"SELECT * FROM user WHERE user_name = '\" + username + \"'\"; // 连接 SQL 并实施语句 connection.query(readSql, function (error1, response1) { if (error1) { throw error1; } else { if(response1 == undefined || response1.length == 0) { // 不存在用户 res.end(\"\\n不存在该用户！\"); return; } else { // 存在用户 console.log(\"\\n存在该用户！\"); let newRes = JSON.parse(JSON.stringify(response1)); console.log(newRes); if(newRes[0].user_password == password) { // 密码正确 // 返回数据 res.write(JSON.stringify({ code: \"0\", message: \"登录成功！\", data: { id: newRes[0].id, userName: newRes[0].user_name } })); res.end(); } else { // 密码错误 // 返回数据 res.write(JSON.stringify({ code: \"1\", message: \"登录失败，密码错误！\" })); res.end(); } // 判断密码正确与否完毕 } // 存在用户处理结束 } }); } // 登录步骤结束 } else if (pathName == \"/register\") { // 注册 console.log(\"\\n【API - 注册】\"); }  很好，前端和后端都编写完毕，是时候查验下功能是否实现了： 4.5 留言功能 返回目录  现在，我们就剩下留言功能了，一鼓作气做好它吧！ messageBoard.html 留言板-jsliang 前端有限公司 $(function() { let userName = sessionStorage.getItem(\"userName\"); let userId = sessionStorage.getItem(\"id\"); // 查询留言板 if(userName && userId) { // 如果有存储 $.ajax({ url: \"http://localhost:8888/getMessage\", type: 'get', dataType: 'json', success: function (res) { console.log(res); let li = ``; for(let item in res.data) { li = li + ` ☆ ${res.data[item].user_message} —— ${res.data[item].user_name} [${res.data[item].user_id}] ${res.data[item].time} `; } $(\"#message-board-ul\").append(li); }, error: function (err) { console.log(err); } }) } else { // 如果没有存储 window.location.href = \"../login.html\"; } // 提交留言 $(\"#message-submit\").click(function() { let messageText = $(\"#message\").val() if(!messageText) { alert(\"留言内容不能为空\"); } else if(messageText.length > 140) { alert(\"留言长度不能超过 140 位！\"); } else { $.ajax({ url: \"http://localhost:8888/sendMessage\", type: 'post', dataType: 'json', data: { userid: userId, username: userName, message: messageText }, success: function (res) { console.log(res); if(res.code == \"0\") { alert(\"新增成功！\"); window.location.reload(); } }, error: function (err) { console.log(err); console.log(err.responseText); if (err.responseText == \"登录失败，留言内容为空！\") { alert(\"登录失败，留言内容为空！\"); } else if (err.responseText == \"登录失败，字数超过限制！\") { alert(\"登录失败，字数超过限制！\"); } else { alert(\"未知错误！\"); } } }) } }) })  接着编写下 Node 后端： index.js // ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码 if (pathName == \"/sendMessage\") { // 提交留言信息 console.log(\"\\n【API - 提交留言信息】\"); result = JSON.parse(result); let id = result.userid; // id let userName = result.username; // 用户名 let messageText = result.message; // 留言内容 let time = getNowFormatDate(); // 时间 if(!messageText) { res.end(\"登录失败，留言内容为空！\"); return; } else if(messageText.length > 140) { res.end(\"登录失败，字数超过限制！\"); return; } else { // 新增的 SQL 语句及新增的字段信息 let addSql = \"INSERT INTO message(user_message, user_id, user_name, time) VALUES(?, ?, ?, ?)\"; let addSqlParams = [messageText, id, userName, time]; // 连接 SQL 并实施语句 connection.query(addSql, addSqlParams, function (error1, response1) { if (error1) { // 如果 SQL 语句错误 throw error1; } else { console.log(\"\\n新增成功！\"); // 返回数据 res.write(JSON.stringify({ code: \"0\", message: \"新增成功！\" })); // 结束响应 res.end(); } }) } } else if (pathName == \"/login\") { // 登录 console.log(\"\\n【API - 登录】\"); } else if (pathName == \"/register\") { // 注册 console.log(\"\\n【API - 注册】\"); } // ... 其他代码省略，请自行前往章节 4.2 后端接口 获取其他代码 if (pathName == \"/getMessage\") { // 获取留言信息 console.log(\"\\n【API - 获取留言信息】\"); // 解析 url 参数部分 let params = url.parse(req.url, true).query; console.log(\"\\n参数为：\"); console.log(params); // 新增的 SQL 语句及新增的字段信息 let readSql = \"SELECT * FROM message\"; // 连接 SQL 并实施语句 connection.query(readSql, function (error1, response1) { if (error1) { throw error1; } else { let newRes = JSON.parse(JSON.stringify(response1)); console.log(newRes); // 返回数据 res.write(JSON.stringify({ code: \"1\", message: \"查询成功！\", data: newRes })); // 结束响应 res.end(); } }); // 查询完毕 } else if(pathName == \"/\") { // 首页 res.writeHead(200, { \"Content-Type\": \"text/html;charset=UTF-8\" }); res.write('jsliang 前端有限公司服务已开启！详情可见：Node 基础'); res.end(); }  敲完代码再看下功能是否实现：  综上，我们完成了所有的功能模块：注册、登录以及留言。 五 工具整合 返回目录  工欲善其事，必先利其器。 掌控好了工具，可以方便你更快地进行开发。 5.1 supervisor - 监听 Node 改动 返回目录 supervisor 官网  正如其官网所说，它是一个进行控制系统： 安装插件：npm i supervisor -g 运行文件：supervisor app.js 查看运行：localhost:3000  平时，我们 node app.js 后，当我们修改了 app.js 的内容，就需要关闭 node 命令行再执行 node app.js。 而我们使用 supervisor 后，我们修改了 app.js 中的内容，只要点击保存，即可生效保存后的代码，实现实时监听 node 代码的变动。  关于这个工具，网上更详细的攻略有： 详细版：用Supervisor守护你的Node.js进程 | 简书 - Mike的读书季 5.2 PM2 - Node 进程管理 返回目录 PM2 - npm  PM2 是 Node 进程管理工具，可以利用它来简化很多 Node 应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。  下面就对 PM2 进行入门性的介绍，基本涵盖了 PM2 的常用的功能和配置： 全局安装 PM2：npm i pm2 -g 监听应用：pm2 start index.js 查看所有进程：pm2 list 查看某个进程：pm2 describe App name/id 停止某个进程：pm2 stop App name/id。例如： 先通过 pm2 list 查看： App name id status index 0 online  只需要执行 pm2 stop index 或者 pm2 stop 0 即可。 停止所有进程：pm2 stop all 重启某个进程：pm2 restart App name/id 删除某个进程：pm2 delete App name/id  如上，如果说我们的 supervisor 是监听单个进程的话，那么 PM2 就是监听多个进程。  更多攻略： PM2 官网 PM2 用法简介 | 简书 - LeavesLife PM2实用入门指南 | 博客园 - 程序猿小卡 六 参考资料 返回目录  在编写这篇文章的过程中，有一些参考资料是值得保留阅读的： 经典：该类值得我们研读 经典，就是随着时间流逝，它还是那么有参考价值。 API 文档 | Node.js 中文网 Node.js 教程 | 菜鸟教程 Express 文档 | Express 中文网 尝试：该类值得我们参考借鉴 Node 基础模块 nodejs之querystring模块 | 博客园 - whiteMu Node 编写接口 用Node编写RESTful API接口 | php 中文网 - 不言 MySQL 学习 MySQL 教程 | 菜鸟教程 Node 连接数据库 node.js前后台交互示例 -- 使用node.js实现用户注册功能 | 博客园 - 返回主页 党兴明 node.js实现简单的登录注册页面 - 博客园 - 返回主页 bestjarvan Node 仿 Express nodejs模块：简单http请求路由，仿express | CSDN - TTUZ 初学nodejs一：别被Express的API搞晕了 | 前端乱炖 - 飞天小黑神猪 NodeJs 实战——原生 NodeJS\b 轻仿 Express 框架从需求到实现（一） | 倔强的石头 - 掘金 NodeJs 实战——原生 NodeJS\b 轻仿 Express 框架从需求到实现（二） | 倔强的石头 - 掘金 仿 Express | Github - wallaceyuan Node.js 封装仿照 express 的路由 | CSDN - c. 学习node中express框架中间件的相关知识及实践 | Github - BadWaka 七 线上部署 返回目录  关于线上部署及域名、服务器相关的配置，jsliang 在另外一篇文章有所交代：云服务器建站。  如果小伙伴需要订购云服务器来存放像 jsliang 个人网站类的静态或者有 Node 后端的网页，但却不知道怎么选择，可以加 jsliang QQ：1741020489 咨询，下面是一些优惠推广：  腾讯云推广：  新用户点这里： 新客户无门槛 2775 元代金券  购买云服务器： 12 月优惠低至 168 元/年  阿里云推广：  新用户点这里： 新用户云产品 1888 通用代金券  购买云服务器： 高性能云服务器 - 低至 293元/年  购买企业级云服务器： 企业级高性能云服务器 八 归纳总结 返回目录  综上，搞定一切！ 兴许在前面代码的摧残下，能看到这里的小伙伴已经寥寥无几了，但我坚信我该交代的基本都交代了，不该交代的也交代了~ 所以，如果小伙伴看完真觉得不错，那就点个赞或者给个 star 吧！你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址  如果小伙伴看完这里要评论的话，可以加个暗语：Node 基础，***，这样 jsliang 看到必回，哈哈~ Node 基础，我完成了！ Node 基础，我想说 jsliang 肯定还偷懒了，没写成最完美的，我不管我打赏了你赶紧给我完善下！ ……  so, that's all, thanks~  后记：  撰文不易，如果文章对小伙伴有帮助，希望小伙伴们给勤劳敲代码、辛苦撰文的 jsliang 进行微信/支付宝打赏，你们的每一次打赏都是最好的鼓励，谢谢~ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/npm/":{"url":"other-library/npm/","title":"Npm","keywords":"","body":"npm 学习 Create by jsliang on 2018-10-28 11:14:22Recently revised in 2018-12-23 21:23:54  npm 是啥？ npm 是世界上最大的开放源代码的生态系统。我们可以通过 npm 下载各种各样的包。 在我们安装 Node 的时候，它默认会顺带给你安装 npm。 npm -v：查看 npm 版本。 npm list：查看当前目录下都安装了哪些 npm 包。 npm info 模块：查看该模块的版本及内容。 npm i 模块@版本号：安装该模块的指定版本。  在平时使用 npm 安装包的过程中，你可能需要知道一些 npm 基本知识： i/install：安装。使用 install 或者它的简写 i，都表明你想要下载这个包。 uninstall：卸载。如果你发现这个模块你已经不使用了，那么可以通过 uninstall 卸载它。 g：全局安装。表明这个包将安装到你的计算机中，你可以在计算机任何一个位置使用它。 --save/-S：通过该种方式安装的包的名称及版本号会出现在 package.json 中的 dependencies 中。dependencies 是需要发布在生成环境的。例如：ElementUI 是部署后还需要的，所以通过 -S 形式来安装。 --save-dev/-D：通过该种方式安装的包的名称及版本号会出现在 package.json 中的 devDependencies 中。devDependencies 只在开发环境使用。例如：gulp 只是用来压缩代码、打包的工具，程序运行时并不需要，所以通过 -D 形式来安装。  例子： cnpm i webpack-cli -D npm install element-ui -S  那么，这么多的 npm 包，我们通过什么管理呢？ 答案是 package.json。 如果我们需要创建 package.json，那么我们只需要在指定的包管理目录（例如 node_modules）中通过以下命名进行生成： npm init：按步骤创建 package.json。 npm init --yes：快速创建 package.json  当然，因为国内网络环境的原因，有些时候通过 npm 下载包，可能会很慢或者直接卡断，这时候就要安装淘宝的 npm 镜像：cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org 常用模块 记录一些常用的 npm 包的简介 npm 详细地址 介绍 http-server 有关博客的说明 / npmjs.com说明 http-server 是一个简单的零配置命令行 HTTP 服务器，基于 nodeJs 。 live-server 有关博客的说明 / npmjs.com说明 比http-server 更好用的 npm 包，能热更新（ Ctrl+S 即时刷新）。 babel-core 有关博客的说明 / npmjs.com说明 把es6中的新语法（箭头函数、rest参数等）解析成ast这种形式，然后配合各个插件分析语法进行相应的处理。 babel-loader 有关博客的说明 / npmjs.com说明 一种loader解析器，配合Webpack解析ES6编写的js文件。 babel-preset-* 有关博客的说明 / npmjs.com说明 babel-reset-2015包含了es6对应的新语法，如果配置了babel-reset-latest，则包含了es2015、es2016、es2017的插件（之后可能包括es2018等）。注：在安装过程中jsliang发现，官方已不建议使用babel-preset-*系列了，而是推荐使用下面介绍的babel-preset-env包。 babel-polyfill 有关博客的说明 / npmjs.com说明 实现浏览器对不支持API的兼容（兼容旧环境、填补）。 babel-preset-env 有关博客的说明 / npmjs.com说明 如果不做任何配置，该loader等同于bable-preset-latest，如果你需要根据不同浏览器或者node版本进行配置，推荐使用babel-preset-env进行配置使用 babel-plugin-transform-decorators-legacy 有关博客的说明 / npmjs.com说明 该插件能使ES7的装饰器能被解析成ES5语法并被使用。 core-decorators Github / npmjs.com说明 该插件能使ES7的装饰器能被解析成ES5语法并被使用。 react-transition-group 有关博客的说明 / npmjs.com说明 该插件能使ES7的装饰器能被解析成ES5语法并被使用。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/RegularExpression/":{"url":"other-library/RegularExpression/","title":"正则表达式","keywords":"","body":"正则表达式 Create by jsliang on 2018-11-14 10:41:20Recently revised in 2018-12-23 21:23:21  Hello 小伙伴们，如果觉得本文还不错，记得给个 star，你们的 star 是我学习的动力！GitHub 地址  正则表达式：正则，也叫做规则，让计算机能够读懂人类的规则。 正则表达式是繁琐的，越学你会觉得越发发狂。 但是，它又是强大的。正则在我眼里，就是作弊码，学会之后的应用可以大大提高你的开发效率。 所以，你可以老老实实打怪，但是你用了它会觉得编程更爽快。  综上，有了 jsliang 编写这篇文章来记录自己所学的冲动。 为此，也是灵感触发，jsliang 写了个 PC 小游戏（请用电脑打开网址）： 正则小游戏地址 一 目录  不折腾的前端，和咸鱼有什么区别~ 目录 一 目录 二 整合  2.1 常用正则  2.2 匹配规则  2.3 常用方法 三 正则旅途  3.1 初识正则  3.2 正则解析  3.3 正则练习  3.4 渐入佳境：() 匹配子项  3.5 渐入佳境：[] 字符类 四 回顾总结 五 文章更正 二 整合 目录  本章节整理总结了所有的参考文献，方便日后快速回顾回忆。 如果你还没正式开始正则表达式，请快速浏览跳过本章节。  精选参考文献/视频/手册： 正则表达式-教程 | 菜鸟教程 正则表达式在线测试 | 菜鸟教程 正则表达式手册 | 开源中国社区 鬼斧神工之正则表达式 | 慕课网 正则表达式真的很 6，可惜你不会写 | 前端之巅 正则表达式 - 快速参考 | Miscrosoft Docs 揭开正则表达式的神秘面纱 | 正则工作室 正则表达式 JavaScript | MDN 2.1 常用正则表达式 目录 验证姓名 2 到 9 位中文昵称：^[\\u4e00-\\u9fa5]{2,9}$ 验证密码 只能是字母、数字和下划线，长度不限制：^\\w+$ 允许 小写字母 a-z、大写字母 A-Z、数字 0-9、下划线 _、 连接符 -，且长度在 6-18 位数：/^[a-zA-Z0-9_-]{6,18}$/ 必须包含数字+小写字母+大写字母的密码，且长度在8-10位之间：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 验证 Email 允许有一个字符符合 [A-Za-z0-9] 之后可以为 [A-Za-z0-9-+.] + @ + 允许有一个字符符合 [A-Za-z0-9] 之后可以为 [A-Za-z0-9-.] + . + 允许有一个字符符合 [A-Za-z0-9] 之后可以有 [A-Za-z0-9-.] 的邮箱：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 验证身份证 18 位身份证号，尾数是数字或者字母 X：^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$ 15 或者 18 位身份证号，尾数可以是数字及 X 或者 x：(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 验证手机号 以 1 开头，第二位数是 3/4/5/7/8 的 11 位手机号码：^1[3,4,5,7,8,9]\\d{9}$ 移动号码：^134[0-8]\\d{7}$|^(?:13[5-9]|147|15[0-27-9]|178|1703|1705|1706|18[2-478])\\d{7,8}$ 电信号码：^(?:133|153|1700|1701|1702|177|173|18[019])\\d{7,8}$ 联通号码：^(?:13[0-2]|145|15[56]|176|1704|1707|1708|1709|171|18[56])\\d{7,8}|$ 2.2 匹配规则 目录 字符 描述 例子 \\ 将下一个字符标记为特殊字符、或原义字符、或向后引用、或八进制转义符。 \\n 表示换行符、\\d 匹配 [0-9] 的数字 ^ 匹配输入字符串的开始位置。 ^abc 表示匹配有 abc 开头的字符串 $ 匹配输入字符串的结束位置。 ^\\d$ 表示匹配一个 [0-9] 的数字 * 匹配前面的子表达式零次或多次。 zo* 能匹配 z 或者 zoo。* 等价于 {0,}。 + 匹配前面的子表达式一次或多次。 zo+ 能匹配 zo 或者 zoo，但不能匹配 z。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。 do(es)? 可以匹配 does 或 does 中的 do。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。 o{2} 不能匹配 Bob 中的 o，但是能匹配 food 中的两个 o。 {n,} n 是一个非负整数。至少匹配 n 次。 o{2,} 不能匹配 Bob 中的 o，但能匹配 foooood 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o*。 {n,m} m 和 n 均为非负整数，其中 n 例如，o{1,3} 将匹配 fooooood 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 *、+、?、{n}、{n,}、{n,m} 后面时（例如 +?），匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。 对于字符串 oooo，o+? 将匹配单个 o，而 o+ 将匹配所有 o。 . 匹配除 \\n 之外的任何单个字符。. 是一个很强大的 元符号，请慎用。 要匹配包括 \\n 在内的任何字符，请使用 `(. \\n)的模式。要匹配小数点本身，请使用.。a.e能匹配nave中的ave或者匹配water中的ate` (子表达式) 标记一个子表达式的开始和结束位置。 (\\w)\\1 能匹配 deep 中的 ee (?:子表达式) 匹配 z子表达式 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符 `( )` 来组合一个模式的各个部分是很有用。 `industr(?:y ies)就是一个等同于industry industries` 但更简略的正则表达式。 (?=子表达式) 一般用法：××(?=子表达式)，它的意思就是 ×× 后面的条件限制是 ?= 后面的 子表达式 `Windows(?=95 98 NT 2000)能匹配Windows2000中的Windows，但不能匹配Windows3.1中的Windows。\\w+(?=.)能匹配He is. The dog ran. The sun is out.中的is、ran和out` (?!子表达式) 类似于 (?=子表达式)，表示不等于后面的 子表达式。 `Windows(?!95 98 NT 2000)能匹配Windows3.1中的Windows，但不能匹配Windows2000中的Windows。\\b(?!un)\\w+\\b能匹配unsure sure unity used中的sure和used` (? 同上。 `(? 98 NT 2000)Windows能匹配2000Windows中的Windows，但不能匹配3.1Windows中的Windows。(?能匹配1851 1999 1950 1905 2003中的99、50和05` (? 同上。 `(? 98 NT 2000)Windows能匹配3.1Windows中的Windows，但不能匹配2000Windows中的Windows。\\b(?!un)\\w+\\b能匹配unsure sure unity used中的sure和used` `x y` 匹配 x 或者 y。 `z food能匹配z或者food。(z f)ood则匹配zood或food`。 [xyz] 字符集合。匹配所包含的任意一个字符。 [abc] 可以匹配 plain 中的 a。 [^xyz] 求反。匹配未包含的任意字符。 例如，[^abc] 可以匹配 plain 中的 p。[^aei] 匹配 reign 中的 r、g 和 n [a-z] 字符范围。匹配指定范围内的任意字符。 [a-z] 可以匹配 a 到 z 范围内的任意小写字母字符。注意：[A-Z] 才匹配大写英文字母 [^a-z] 求反。匹配任何不在指定范围内的任意字符。 [^a-z] 可以匹配任何不在 a 到 z 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。 er\\b 可以匹配 never 中的 er，但不能匹配 verb 中的 er。 \\B 匹配非单词边界。 er\\B 能匹配 verb 中的 er，但不能匹配 never 中的 er。 \\cx 匹配由 x 指明的控制字符。 例如，\\cM 匹配一个 Control-M 或者回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 c 字符。 \\d 匹配一个数字字符。等价于[0-9]。 4 = IV 中的 4 \\D 匹配一个非数字字符。等价于0-9。 4 = IV 中的 `、=、 、I和V` \\f 匹配一个换页符。等价于\\x0c和\\cL。 [\\f]{2,} 能匹配 \\f\\f\\f 中的 \\f\\f\\f。 \\n 匹配一个换行符。等价于\\x0a和\\cJ。 \\r\\n(\\w+) 能匹配 \\r\\nThese are\\ntwo lines. 中的 \\r\\nThese \\r 匹配一个回车符。等价于\\x0d和\\cM。 \\r\\n(\\w+) 能匹配 \\r\\nThese are\\ntwo lines. 中的 \\r\\nThese \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\w\\s 能匹配 ID A1.3 中的 D \\S 匹配任何非空白字符。等价于 \\f\\n\\r\\t\\v。 \\s\\S 能匹配 int __ctr 中的 _ \\t 匹配一个制表符。等价于\\x09和\\cI。 (\\w+)\\t 能 匹配 item1\\titem2\\t 中的 item1\\t 和 item2\\t \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。 [\\v]{2,} 能匹配 \\v\\v\\v 中的 \\v\\v\\v \\w 匹配包括下划线的任何单词字符。等价于 [A-Za-z0-9_]。 ID A1.3 中的 I、D、A、1 和 3 \\W 匹配任何非单词字符。等价于 [^A-Za-z0-9_]。 ID A1.3 中的 `、.`。 2.3 常用方法 目录  JavaScript 正则默认： 正则匹配成功就会结束，不会继续匹配。如果想查找全部，就要加标识 g（全局匹配） test()  规则：正则表达式搜索字符串指定的值，从而去匹配字符串。如果匹配成功就返回 true，如果匹配失败就返回 false。 用法：正则.test(字符串) 案例： js 代码片段 var str = \"123abc\"; var re = /\\D/; // 匹配非数字 if(re.test(str)) { console.log(\"不全是数字！\"); } else { console.log(\"全是数字！\"); } Console：不全是数字 search()  规则：正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，如果匹配失败就返回 -1 用法：字符串.search(正则) 案例： js 代码片段 var str = \"abcdef\"; var re1 = /d/i; // 3 var re2 = /h/i; // -1 console.log(str.search(re1)); console.log(str.search(re2)); Console：3-1 match()  规则：正则去匹配字符串，如果匹配成功，就返回匹配成功的数组，如果匹配不成，就返回 null 用法：字符串.match(正则) 案例： js 代码片段 var str = \"123fadf321dfadf4fadf1\"; //(4) [\"123\", \"321\", \"4\", \"1\"] var re = /\\d+/g; console.log(str.match(re)); Console：(4) [\"123\", \"321\", \"4\", \"1\"] replace()  规则：正则去匹配字符串，匹配成功的字符串去替换成新的字符串。函数的第一个参数，是匹配成功的字符；第二个参数：可以是字符串，也可以是一个回调函数。 用法：字符串.replace(正则,新的字符串) 案例： 简单案例 js 代码片段 var str = 'aaa'; var re = /a+/g; str = str.replace(re, \"b\"); console.log(str); // b Console：b 敏感词过滤 html 代码片段 敏感词过滤 替换前 替换后 js 代码片段 window.onload = function() { var aT = document.getElementsByTagName(\"textarea\"); var oInput = document.getElementById(\"input1\"); var re = /非诚|中国船|监视之下/g; oInput.onclick = function() { // 一律单个替换： aT[1].value = at[0].value.replace(re, \"*\"); // 多个替换： aT[1].value = aT[0].value.replace(re, function(str) { var result = \"\"; for(var i=0; i Console替换前：非诚勿扰在中国船的监视之下寸步难行替换后：**勿扰在***的****寸步难行 三 正则旅途 目录  什么是正则表达式？正则表达式：正则，也叫做规则，让计算机能够读懂人类的规则。 正则表达式都是用来操作字符串的。  本文学习目标： 通过小故事给小伙伴学习 JavaScript 的正则表达式 让小伙伴能了解基本正则表达式的意思，并能自己写正则表达式 3.1 初识正则 目录  正则长咋样？怎么用？很简单，三行代码带你入门 var regex = /^\\d+$/; var myNumber = '123'; console.log(regex.test(myNumber)); // true  上面的正则，能验证字符串 myNumber 是不是纯数字组成，就这么简单，正则入门了！ 但是，如果我要是敢就这么结束文章，我敢保证你们想拍死我！所以，我们通过一个表达式的故事来初识正则表达式：  某天，盗贼小白给了盗贼小黑一个盒子，盒子像俄罗斯套娃一样，有 3 层嵌套：  并且，他们约定了交易密码提取方式：小白将给小黑提供一串字符串，小黑只需要将字符串中的所有相连的数字找出来，然后把它们拼接成一个新数组，数组的第一项就是第一个盒子的密码，以此类推…… \"abc123def456hash789\" -> [123, 456, 789] - > [外层盒子1密码, 中间层盒子2密码, 最内层盒子3密码]  现在假设盗贼小黑使用 JavaScript 进行常规查找： index.html 正则表达式 正则表达式 | jsliang 学习记录 window.onload = function () { var str = \"abc123def456hash789\" function findNum(str) { var arr = []; var tmp = ''; for (var i = 0; i = \"0\" && str.charAt(i)  写到这里，小黑觉得不妥，上面代码写得太麻烦太复杂了，于是决定使用正则表达式查找： index.html 正则表达式 正则表达式 | jsliang 学习记录 window.onload = function() { var str = \"abc123def456hash789\"; function findNum(str) { return str.match(/\\d+/g); } console.log(findNum(str)); }  小黑瞬间觉得自己很牛逼有木有？！只需要一行代码，就能解决字符串查找的时候用的一大串代码！  那么，讲到这里，小伙伴们应该对正则有了个简单的了解，称热打铁，Here we go~ 3.2 正则解析 目录  在上文中，盗贼小黑通过使用 str.match(/\\d+/g)，解决了获取箱子密码的问题。 那么，这串正则表达式是什么意思呢？我们先抛开这个，解析一串简单的： ^[a-z0-9_-]{6,12}$  首先，^ 表示匹配字符串的开始位置，结合后面的 [a-z0-9_-] 表示该字符串开头可以为 a-z 的字母，0-9 的数字，_ 下划线，- 连接符。 然后，[a-z] 表示匹配 a-z 中任意单个字母；[0-9] 表示匹配 0-9 中任意单个数字；[_] 表示匹配下划线；[-] 表示匹配连接符 -。所以，将前面的连起来，[a-z0-9_-] 表示字符串可以包含数字、字母、_、- 这四种形式的字符串。 接着，{6, 12} 表示该字符串的长度为 6-12 位。 最后，$ 表示结束标志，^ 的相反。 ^ 与 $ 同时使用时，表示精确匹配。  终上所述，小伙伴们应该猜测到了这个正则表达式的用途：校验用户名。该用户名只能包含字符、数字、下划线 (_) 和连接字符 (-)，并且用户名的长度最长为 12 位，最短为 6 位。  那么，它在 JavaScript 中要如何使用呢？我们通常用 /正则表达式/ 两个斜杠来包裹我们要写的正则表达式： var reg = /^[a-z0-9_-]{6,12}$/  看，这样就是一条规则了，如果你需要让他匹配一个字符串 str。那么，只需要在代码中使用 test() 测试方法： var str = 'abc-cba_abc'; var reg = /^[a-z0-9_-]{6,12}$/; console.log(reg.test(str)); // true  这样，我们就告诉了 JavaScript：reg 通过 test() 方法去测试 str 是否符合 reg的规则，如果符合则返回 true，如果不符合则返回 false。这里返回的是 true，因为我们的 str 是符合 reg 规则的。 test() 方法及其他好用的方法已经整合到 【2.3 JS 正则方法】 里面了，迫不及待的小伙伴们可点击链接先行查看。  下面贴出完整代码： index.html 正则表达式 正则表达式 | jsliang 学习记录 window.onload = function() { var str = 'abc-cba_abc'; var reg = /^[a-z0-9_-]{6,12}$/; console.log(reg.test(str)); // true } 3.3 正则练习 目录  通过上面的了解，小伙伴对正则表达式应该有了初始的了解，下面我们猜测一下，下面的 Console 1 - Console 3中， 哪些是 true，哪些是 false： index.html 正则表达式 正则表达式 | jsliang 学习记录 window.onload = function() { var str = \"Cheer for yourself\"; var reg1 = /^Cheer/; var reg2 = /yourself$/; var reg3 = /for/; console.log(reg1.test(str)); console.log(reg2.test(str)); console.log(reg3.test(str)); }  答案是，这三个都返回 true。在这三个 console.log() 中： 第一个判断该字符串是否以 Cheer 开头； 第二个判断该字符串是否以 yourself 结尾； 第三个判断该字符串是否包含 for。 在日常工作中，经常利用该方法，判断用户输入的 string 里面是否包含某些文字，例如：jsliang 是傻逼，就需要判断替换为 jsliang 是帅哥，至于怎么替换敏感字，迫不及待的小伙伴们可前往 【2.3 JS 正则方法】 先行了解~ 3.4 渐入佳境：() 匹配子项 目录  所谓匹配子项，其实就是我们的小括号 () 。它还有另外一个意思，叫分组操作。下面我们引用章节 【2.2 正则表达式规则】 中的定义： 表达式 释义 用法 (子表达式) 标记一个子表达式的开始和结束位置。 (\\w)\\1 能匹配 deep 中的 ee  如果光解释意思，小伙伴们可能稀里糊涂。所以我们先上代码： js 代码片段 var str = \"2018-11-28\"; var re = /(\\d+)(-)/g; str = str.replace(re, function($0, $1, $2){ // 第一个参数：$0（母亲) // 第二个参数：$1（第一个孩子） // 第三个参数：$2 (第二个孩子) console.log(\"$0：\" + $0); // 2018- 以及 11- console.log(\"$1：\" + $1); // 2018 以及 11 console.log(\"$2：\" + $2); // - 以及 - return $1 + '.'; }); console.log(str); // 2018.11.28 Console：$0：2018-$1：2018$2：-$0：11-$1：11$2：-2018.11.28  首先，我们解析下这段正则： /(\\d+)/ 表示任意 1 个及以上的数字 /(-)/ 表示匹配字符 - g 表示匹配一次以上  所以这段正则的意思就是匹配一次及以上的 数字- 形式的字符串。  然后，我们使用了 replace() 方法。我们观察 Console 打印出来的结果，可以看出：$0 即是我们的正则 var re = /(\\d+)(-)/g 去匹配 var str = \"2018-11-28\" 所得到的结果，这里我们匹配成功了两次，即 2018- 及 11-；$1 即是我们的一个小括号 (\\d+) 的匹配结果，所以结果为 2018 以及 11；$2 即是我们的第二个小括号 (-) 的匹配结果，所以结果为 - 以及 -。 最后，我们做的事情就是，将 $1 加上 .，并返回最终结果给 str，即最终结果：2018.11.28。 在这里提到了 replace() 方法，详情可了解：点击前往  【Once again】 如果小伙伴们感觉还是不过瘾，那么我们再来一段： js 代码片段 var str = \"abc\"; var re = /(a)(b)(c)/; console.log(str.match(re)); Console(4) [\"abc\", \"a\", \"b\", \"c\", index: 0, input: \"abc\", groups: undefined]  这里我们不做过多讲述，相信小伙伴们经过这两个案例，应该对 () 有了一定的了解。 3.5 渐入佳境：[] 字符类 目录  何为字符类？ 所谓字符类，就是一组类似的元素 [] 这样的中括号的整体，所代表一个字符。 话不多说，先上代码： js 代码片段 var str1 = \"abcd\"; var re1 = /a[bcd]c/; console.log(re1.test(str1)); // true var str2 = \"abc\"; var re2 = /a[^bcd]c/; console.log(re2.test(str2)); // false var str3 = \"a.c\"; var re3 = /a[a-z0-9A-Z]c/; console.log(re3.test(str3)); // false Consoletruefalsefalse  首先，我们先解析第一部分： /a/：匹配字母 a /[bcd]/：匹配字母 bcd 中的一位 /[d]：匹配字母 d  所以，可以看出，我们用 re1 来测试 str1 是否符合，它会返回 true。  然后，我们解析第二部分： ^ 如果写在 [] 里面的话，就代表排除的意思。在这里就代表着 a 和 c 中间不能是 bcd 中的任意一个  所以，可以看出，我们用 re2 来测试 str1 是否符合，它会返回 false。  最后，我们解析第三部分： /[a-z0-9A-Z]/：匹配小写字母 a-z，或者数字 0-9，或者大写字母 A-Z。即 a 与 c 之间只能是上面匹配地上的字符。  所以，可以看出，我们用 re3 来测试 str3 是否符合，它会返回 false。 四 回顾总结 目录  在第三章中，我们介绍了强大之处，介绍了它的使用方法，并通过小练习、() 以及 [] 的讲解，让小伙伴们更进一步了解在 JavaScript 中正则的使用…… 但！ 这是完结吗？！ 不！ 由于 jsliang 时间有限，没法一一给小伙伴们介绍正则的乐趣及工作中如何使用正则提高工作效率。 所以，在第二章 【整合】 中，jsliang 整合网上资源，记录了一些常用的正则工具，里面有很多东西，是在这篇文章中没有涉及的，有兴趣的小伙伴可以逐一尝试加深对正则的了解。  ————For the end———— 在编写这篇文章中，jsliang 玩性大发写下了下面的游戏（请用电脑查看）： 游戏地址：天下第一武道会 代码地址：https://github.com/LiangJunrong/regex 五 文章更正 目录 掘金反馈 2018-11-20 类型：内容错误 反馈用户：Kaelalv 反馈内容：3.2内容中对这段代码解析时：var str = 'abc-cba_abc'; var reg = /^[a-z0-9_-]{6,12}$/; console.log(reg.test(str)); // true  作者手误，打错：不符合则 返回 true；正确：不符合则 返回 false。 反馈处理：已更正，谢谢反馈  如果小伙伴们觉得本文还不错，记得 掘金 给个赞并去 GitHub 点个 star， 你们的 star 是我学习的动力！GitHub 地址 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/":{"url":"other-library/shortArticle/","title":"短杂文","keywords":"","body":"短杂文 Create by jsliang on 2018-12-23 21:09:19Recently revised in 2018-12-23 21:09:22  这里的文章， 有些是因为太短了，上不了台面； 有些是因为不常用，归纳到一块。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/agreement/agreement.html":{"url":"other-library/shortArticle/agreement/agreement.html","title":"✔ 关于协议","keywords":"","body":"关于协议 create by jsliang on 2018-8-22 17:58:56Recently revised in 2018-10-15 21:57:06 由于担心自己的知识产品被无良厂商/个人拿去非法盈利，所以jsliang特意去查了下关于协议的知识，下面是查询结果，分享给想了解协议的小伙伴们。 阮一峰关于协议的见解 查看详情 Phodal关于协议的见解 查看详情 事实上，我们大多数时候仅仅“了解”这些协议有大概有什么用，却很少把它使用到我们的项目中。就好比在这里我使用了一种保护markdown文档的许可证，但是，实际上我也不知道它究竟有没有作用。 GPL许可证： GPL协议的出发点是源代码的开源与免费使用，同时对其衍生代码进行引用、修改，但是引用、修改后代码必须开源与免费使用，即不允许修改后和衍生后的代码作为闭源的商业软件发布和销售。因此，有保密要求的部门不适合对具有GPL协议的开源代码进行集成、采用类库或者二次开发。 GPL协议具有“传染性”。当一个软件中使用（“使用”指类库引用，修改后的代码或衍生代码）GPL协议的产品，则该软件产品必须也采用GPL协议，即必须也是免费和开源，这就是它所谓的“传染性”。 GPL协议保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。所以有GPL协议的软件，在适用于大众去免费开发的同时，专利者也可以出售其版权获得利益。例如：甲骨文买走MySQL的版权，但是这个软件，它的使用权，免费权，开发权都在大众手里，甲骨文只有一个挂名权而已。 LGPL许可证： LGPL协议大部分等同于GPL协议，但它是基于GPL的，一个主要为类库使用设计的开源协议。 与GPL不同之处：允许商业软件通过类库引用（link）方式使用LGPL类库而不需要开源商业软件的代码，因此其可以被商业软件作为类库引用并发布和销售。 LGPL协议保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。 MPL许可证： MPL协议是The Mozilla Public License的简写，是1998年初Netscape的Mozilla小组为其开源软件项目设计的软件许可证。 MPL允许被许可人经过MPL许可证获得的源代码同其他类型的代码进行混合得到自己的软件程序。 BSD许可证： 给与使用者很大自由的协议，可以自由的使用或者修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此对商业集成很友好。 而很多的公司企业在选用开源产品的时候都首选BSD协议，因此可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。 MIT许可证： MIT协议中，作者只想保留版权，而不做任何其他限制。 使用者必须在使用的发行版里包含原许可协议的声明，无论是否以二进制发布还是以源代码发布。 Apache许可证： Apache协议是著名的非盈利开源组织Apache采用的协议。 Apache协议类似于BSD许可证，鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布。 Apache同样也对商业友好。使用者也可以在需要的时候修改代码来满足并作为开源或商业产品发布/销售。  这里仅进行简单介绍。如果你需要使用GPL、LGPL、MPL、BSD、MIT、Apache等协议，请认真百度/Chrome相关知识后再采用。如果你对上面说法持有异议，请联系上面的邮箱，督促jsliang进行修改。另：本文档采用 CC BY-NC-SC 4.0版本协议，该协议可以作用于markdown编写的电子文档，有兴趣的小伙伴可以点击前面链接去看看。 document library of jsliang by 梁峻荣 is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.Based on a work at https://github.com/LiangJunrong/document-library.Permissions beyond the scope of this license may be available at https://creativecommons.org/licenses/by-nc-sa/2.5/cn/. jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/crx/readMe.html":{"url":"other-library/shortArticle/crx/readMe.html","title":"✔ Chrome 插件","keywords":"","body":"Chrome 插件 create by jsliang on 2018-09-05 14:21:47Recently revised in 2018-10-15 14:17:55 Chrome 插件安装  首先，在 Chrome 浏览器中，点击右上角更多图标，点击 【更多工具】，再点击 【扩展程序】  然后，进入该界面，将 .crx 文件拖入：  最后，点击 【添加扩展程序】 即可： Angular  这款 Angular 开发插件叫 Augury，下载 id 为：elgalmkoelokbchhkhacckoklkejnhcd，在 这个地址 下输入该 id 并回车即可下载。  jsliang 这里提供的是 Angury_v1.19.1.crx 文件，地址为前往，或者找到该文件的同级目录，找到对应的插件即可。 开发的时候，打开 F12 控制台，点开 Augury 即可使用： jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/frontEnd/readMe.html":{"url":"other-library/shortArticle/frontEnd/readMe.html","title":"✔ 浅谈个人对前端历史的理解","keywords":"","body":"浅谈个人对前端历史的理解 create by jsliang on 2018-10-15 22:21:16Recently revised in 2018-10-15 22:21:23 奴隶社会  表现：HTML + CSS + JS 梭哈，直接干掉所有网页，实现各种动画，甚至兼容 ES6/7/8 等…… 优点：想到什么写什么，能写咋样是咋样。 缺点：太慢，太累。 石器时代  表现：使用 jQuery，做一些交互。 优点：命令式 DOM 操作，缩减了原生开发的时间，想怎么做就怎么做。 缺点，DOM 操作复杂的情况下，可能导致页面渲染卡慢 铁器时代  表现：Vue、React、Angular 优点；声明式操作，尤其是 Vue、React 这两种科技，使用了 VirtualDOM，通过映射关系，减少 DOM 的操作，只需关注状态的维护即可。 缺点：暂无发现 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/GitBook/":{"url":"other-library/shortArticle/GitBook/","title":"✔ GitBook","keywords":"","body":"GitBook Create by jsliang on 2019-05-20 14:43:41Recently revised in 2019-05-22 17:35:54 本文将介绍如何安装 GitBook、如何起 GitBook 服务、如何配置 GitBook，以及到最后的部署到 GitHub Pages 或者部署到个人云服务器。 小伙伴们如果觉得不错可以到 jsliang 的文档库 为 jsliang 点个 star，谢谢~ 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 GitBook 常用指令 四 GitBook 插件配置 五 GitBook 打包部署 六 总结 二 前言 返回目录 由于平时喜欢使用 MarkDown 编写文档，无意中在工作上暴露了自己会使用 MarkDown 的 “优点”，所以上周日（2019-05-19）被抓苦力，叫去将公司 WIKI 转成 GitBook。 后面回到租房自己又玩了下，表示深深被吸引了，这也太好用了吧！ 所以在这里安利给小伙伴们，大家一起 happy 下。 三 GitBook 常用指令 返回目录 安装 GitBook：npm i gitbook-cli -g 初始化 GitBook 项目：gitbook init 安装 GitBook 依赖：gitbook install 开启 GitBook 服务：gitbook serve 打包 GitBook 项目：gitbook build GitBook 命令行查看：gitbook -help GitBook 版本查看：gitbook -V 首先，我们为电脑配置 GitBook，在 终端 中直接敲：npm i gitbook-cli -g，电脑会配置好 GitBook。 由于 Mac 可能会有权限限制，所以需要执行 sudo npm i gitbook-cli -g 然后，我们找个空文件夹，初始化一个 GitBook 项目：gitbook init，目录会生成一个 README.md 内容文件和一个 SUMMARY.md 目录文件。 - GitBook - README.md - SUMMARY.md README.md# 表示一级标题，详情可自行查看 MarkDown 语法 # Introduction SUMMARY.md[链接](链接地址) 表示跳转链接，即 GitBook 会根据你的 SUMMARY 自动帮你生成左侧菜单栏的目录 # Summary * [Introduction](README.md) 最后，我们在 终端 输入 gitbook serve 即可开启一个 localhost:4000 的服务，请在浏览器中输入 http://localhost:4000 即可访问服务。 四 GitBook 插件配置 返回目录 下面我们开始配置 GitBook 插件。 首先，给目录中添加一个 book.json 文件 - GitBook - README.md - SUMMARY.md - book.json 然后，我们配置下 book.json： book.json { \"title\": \"jsliang 的文档库\", \"author\": \"梁峻荣 - jsliang\", \"description\": \"jsliang 的文档库. 里面包含了个人撰写的所有前端文章，例如 Vue、React,、ECharts、微信小程序等……\", \"language\": \"zh-hans\", \"styles\": { \"website\": \"./public-repertory/css/gitbook-configure.css\" }, \"plugins\": [ \"theme-comscore\", \"prism\", \"-highlight\", \"copy-code-button\", \"search-pro\", \"-search\", \"-lunr\", \"expandable-chapters\", \"splitter\", \"-sharing\", \"github-buttons\", \"donate\", \"tbfed-pagefooter\", \"baidu-tongji\", \"anchor-navigation-ex\" ], \"pluginsConfig\": { \"github-buttons\": { \"buttons\": [ { \"user\": \"LiangJunrong\", \"repo\": \"document-library\", \"type\": \"star\", \"count\": true, \"size\": \"small\" }, { \"user\": \"LiangJunrong\", \"width\": \"160\", \"type\": \"follow\", \"count\": true, \"size\": \"small\" } ] }, \"donate\": { \"button\": \"打赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\", \"alipay\": \"https://github.com/LiangJunrong/document-library/blob/master/public-repertory/img/seek-reward.jpg?raw=true\", \"wechat\": \"https://github.com/LiangJunrong/document-library/blob/master/public-repertory/img/seek-reward.png?raw=true\" }, \"prism\": { \"css\": [ \"prismjs/themes/prism-solarizedlight.css\" ], \"lang\": { \"shell\": \"bash\" } }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy jsliang.top 2019\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"baidu-tongji\": { \"token\": \"55e7dfe47f4dc1c018d4042fdfa62565\" }, \"anchor-navigation-ex\": { \"showLevel\": false } } } 最后，我们安装下 book.json 中配置的插件：gitbook install，并重新启动项目：gitbook serve。 当然，这需要你配置下 SUMMARY.md 文件，不过这应该对你来说不成问题。 4.1 book.json 返回目录 现在，我们讲解下 book.json 的意思： title：网站标题 author：网站作者 description：网站功能描述 language：网站使用语言 styles：网站额外配置的样式表 plugins：网站使用的插件 pluginsConfig：网站使用的插件的额外配置 下面主要讲解下 styles 和 plugins。 4.2 gitbook - styles 返回目录 有的时候，GitBook 会自带一些你不需要的样式，例如侧边栏的 由 GitBook 提供支持 等，我们可以通过设置 CSS 来让它隐藏掉： .gitbook-link { display: none !important; } .summary .divider { display: none !important; } 4.3 gitbook - plugins 返回目录 plugins 即插件的意思，有的 plugins 的配置，因为需要用户自行决定需要使用哪些功能，所以需要再额外配置下 pluginsConfig。 下面我们先列 plugins 清单，再逐个讲解功能实现： 插件 1 - theme-comscore theme-comscore：为 GitBook 添加好看的样式，它会使 Table 表单等变得更加好看。 配置方法 \"plugins\": [ \"theme-comscore\" ] 参考效果： 插件 2 - prism prism：为 GitBook 的 Code 添加更好看的样式，使用它的时候记得屏蔽 GitBook 默认的 highlight 插件，即通过 （-highlight 表示，下面出现 - 的插件也一样） 配置方法 \"plugins\": [ \"prism\", \"-highlight\" ], \"pluginsConfig\": { \"prism\": { \"css\": [ \"prismjs/themes/prism-solarizedlight.css\" ], \"lang\": { \"shell\": \"bash\" } } } 参考效果： 插件 3 - copy-code-button copy-code-button：给 GitBook 的 Code 添加复制功能，可以一键复制代码块的所有代码。 配置方法 \"plugins\": [ \"copy-code-button\" ] 参考效果： 插件 4 - search-pro search-pro：由于 GitBook 支持的搜索，对于中文不太好。添加该插件后，对搜索结果能用高亮来显示，非常强大。当然，由于取缔了默认的搜索功能，所以需要屏蔽 search 和 lunr 配置方法 \"plugins\": [ \"search-pro\", \"-search\", \"-lunr\" ] 参考效果： 插件 5 - expandable-chapters expandable-chapters：由于侧边栏标题是默认全部展开的，所以这个插件会让它具有展开收缩功能。 配置方法 \"plugins\": [ \"expandable-chapters\" ] 参考效果： 插件 6 - splitter splitter：让侧边栏的宽度可以自行拖动。 配置方法 \"plugins\": [ \"splitter\" ] 参考效果： 插件 7 - -sharing -sharing：去掉 GitBook 默认的分享功能。由于它默认的一些推特，脸书都需要翻墙，而我们做的是中文站点，所以将分享功能全部关闭掉。 配置方法 \"plugins\": [ \"-sharing\" ] 参考效果： 插件 8 - github-buttons github-buttons：给 GitBook 添加 GitHub 的图标，来显示 follow 和 stars。 配置方法 \"plugins\": [ \"github-buttons\" ], \"pluginsConfig\": { \"github-buttons\": { \"buttons\": [ { \"user\": \"LiangJunrong\", \"repo\": \"document-library\", \"type\": \"star\", \"count\": true, \"size\": \"small\" }, { \"user\": \"LiangJunrong\", \"width\": \"160\", \"type\": \"follow\", \"count\": true, \"size\": \"small\" } ] } } 参考效果： 插件 9 - donate donate：给底部配置一个打赏模块，用户可以点击进行支付宝、微信打赏等。 配置方法 \"plugins\": [ \"donate\" ], \"pluginsConfig\": { \"donate\": { \"button\": \"打赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\", \"alipay\": \"https://github.com/LiangJunrong/document-library/blob/master/public-repertory/img/seek-reward.jpg?raw=true\", \"wechat\": \"https://github.com/LiangJunrong/document-library/blob/master/public-repertory/img/seek-reward.png?raw=true\" } } 参考效果： 插件 10 - tbfed-pagefooter tbfed-pagefooter：给 GitBook 每个页面添加页脚，这样就可以知道这些文件的 copyright 以及修改时间等。 配置方法 \"plugins\": [ \"tbfed-pagefooter\" ], \"pluginsConfig\": { \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy jsliang.top 2019\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } } 参考效果： 插件 11 - baidu-tongji baidu-tongji：给 GitBook 的站点添加百度统计，这样用户的访问数量可以通过百度统计查看到。 配置方法 \"plugins\": [ \"baidu-tongji\" ], \"pluginsConfig\": { \"baidu-tongji\": { \"token\": \"55e7dfe47f4dc1c12345678fdfa62565\" } } 插件 12 - anchor-navigation-ex anchor-navigation-ex：根据 # ## ### 自动生成菜单，并添加跳转到顶部效果。 配置方法 \"plugins\": [ \"anchor-navigation-ex\" ], \"pluginsConfig\": { \"anchor-navigation-ex\": { \"showLevel\": false } } 参考效果： 插件 13 - gitalk gitalk：给页面添加评论功能，这些评论内容会添加到 GitHub 仓库的 Issue 上。 首先，这不是一个插件，Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。 然后，我们在 MessageBoard.md（即我们需要添加评论区的页面）中添加对应的代码： var gitalk = new Gitalk({ \"clientID\": \"需要补充的 clientID\", \"clientSecret\": \"需要补充的 clientSecret\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); 接着，我们大致讲讲上面那些字段： clientID：GitHub 开发者设置，客户端连接标识。下面有详细讲解。 clientSecret：GitHub 开发者设置，客户端秘钥。下面有详细讲解。 repo：GitHub 仓库名，我们的就是 document-library 啦。 owner：GitHub 仓库所有者，就是我 GitHub 账户：LiangJunrong。 admin：GitHub 仓库管理者，还是我的 GitHub 账户：LiangJunrong。（支持数组，多个管理者） id：页面的唯一标识，默认值: location.href distractionFreeMode：类似 Facebook 评论框的全屏遮罩效果,默认值: false 更多配置请看：Gitalk 再来，我们打开页面：GitHub 开放授权应用 创建后页面会显示： 最后，我们可以在 http://localhost:4000/MessageBoard.html 中查看到结果显示（最终需要放到 LiangJunrong.github.io 中）： 这样，我们就完成了单个页面添加 Gitalk，如果需要添加多个页面，那么可以参考下攻略（这里就不哆嗦了，jsliang 亲测有效）： gitbook 入门教程之实用插件(新增3个插件) - segmentfault - 雪之梦技术驿站 插件 14 - 参考文献 GitBook 插件 - GitHub - zhangjikai 插件功能定制，参数详解 - GitHub - zq99299 Gitbook 的使用和常用插件 - 赵达 【Gitbook】实用配置及插件介绍 - zhangjk 如何优雅地使用 Gitbook - 泫 gitbook 入门教程之实用插件(新增3个插件) - segmentfault - 雪之梦技术驿站 Gitbook模板 - GitHub - crifan 五 GitBook 打包部署 返回目录 现在，是时候打包并且发布项目，让其他小伙伴看到你的成果了。 首先，打包项目：gitbook build。 然后，部署到 GitHub Pages 或者个人云服务器。 GitHub Pages 教程 Nginx 配置 最后，我们查看下我们的部署页面： 部署在 GitHub Pages 中的页面：https://liangjunrong.github.io/ 六 总结 返回目录 OK，我们的 GitBook 教学到此结束啦。 如果小伙伴们在使用 GitBook 开发的时候碰到问题，可以联系我： 加 jsliang 的 QQ 资料群：798961601。 加 jsliang 的个人 QQ：1741020489 加 jsliang 的个人微信： 最后的最后，小伙伴们觉得不错的话，记得给 jsliang 点个 赞 或者 star 哦~ GitHub - jsliang 的文档库 掘金 - jsliang 的个人页面 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-22 17:35:55 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/JavaAbout/JSP/":{"url":"other-library/shortArticle/JavaAbout/JSP/","title":"✔ Java Server Pages","keywords":"","body":"Java Server Pages create by jsliang on 2018-9-12 11:37:01Recently revised in 2018-10-28 12:02:18 序  JSP全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计，它 [1] 是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML（标准通用标记语言的子集）文件(.htm,.html)中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。 由于最近工作可能涉及到 JSP 编写的页面，故在此简要学习下 JSP 语法。 本次学习主要参考有： 菜鸟教程 JSP 一、JSP 运行流程 浏览器发送 HTTP 请求给服务器 服务器根据请求调动 JSP 引擎，查找对应的 JSP 文件 JSP 引擎载入 JSP 文件，将其转为 Servlet (将 JSP 元素转化为 Java 代码)。 Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。 JSP 引擎将 Servlet 编译成可执行类，将原始请求传递给 Servlet 引擎。 服务器的对应组件会调用 Servlet 引擎，然后载入并执行 Servlet 类。在执行过程中， Servlet 产生 HTML 格式输出并将其内嵌于 HTTP response 中上交给 Web 服务器。 Web 服务器以 HTML 网页形式将 HTTP response 返回到浏览器中。 二、生命周期 编译阶段 ：servlet容器编译servlet源文件，生成servlet类 初始化阶段 ：加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法 执行阶段 ：调用与JSP对应的servlet实例的服务方法 销毁阶段 ：调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例 三、初试 JSP 输出：  例如： Hello World Hello World! 四、JSP 语法 4.1 声明  示例： 4.2 表达式  示例： 4.3 注释  上面两种注释中，一种是 JSP 注释，一种是 HTML 注释。 4.4 指令  @ page... 定义页面依赖属性，例如脚本、error页面，缓存需求等 @ include... 包含其他文件  @ taglib... 引入标签库的定义 4.5 行为  JSP 行为标签使用 XML 语法结构来控制 Servlet 引擎。它能够动态插入一个文件，重用 JavaBean 组件，引导用户去另一个页面，为 Java 插件产生相关的 HTML 等等。 语法 描述 jsp:include 用于在当前页面中包含静态或动态资源 jsp:useBean 寻找和初始化一个 JavaBean 组件 jsp:include 用于在当前页面中包含静态或动态资源 jsp:setProperty 设置 JavaBean 组件的值 jsp:getProperty 将 JavaBean 组件的值插入到 output中 jsp:forward 从一个JSP文件向另一个文件传递一个包含用户请求的request对象 jsp:plugin 用于在生成的HTML页面中包含Applet和JavaBean对象 jsp:element 动态创建一个XML元素 jsp:attribute 定义动态创建的XML元素的属性 jsp:body 定义动态创建的XML元素的主体 jsp:text 用于封装模板数据 4.6 隐含对象 语法 描述 request HttpServletRequest 类的实例 response HttpServletResponse 类的实例 out PrintWriter 类的实例，用于把结果输出至网页上 session HttpSession 类的实例 application ServletContext 类的实例，与应用上下文有关 config ServletConfig 类的实例 pageContext PageContext类 的实例，提供对 JSP 页面所有对象以及命名空间的访问 page 类似于 Java 类中的 this 关键字 Exception Exception 类的对象，代表发生错误的 JSP 页面中对应的异常对象 4.7 控制流语句 if...else... 今天是周末 今天不是周末 switch...case... for... \"> 菜鸟教程 至于while、do...while这些，在此就不提示了。 五、Study For Work 5.1 中文编码问题  在这里，${ctx} 有两种解读，一种是寻找文件：  另一种就是寻找对应的方法，这些是由后端管理的，例如： 成员管理 5.2 HTML 模板 data.jsp 今天的日期是: main.jsp 菜鸟教程(runoob.com) include 动作实例 5.3 JSTL 标准标签库  什么是JSTL：JSTL JSP 标准标签库（JSTL）是一个 JSP 标签集合，它封装了 JSP 应用的通用核心功能。 JSTL 支持通用的、结构化的任务，比如迭代，条件判断，XML 文档操作，国际化标签，SQL 标签。 除了这些，它还提供了一个框架来使用集成 JSTL 的自定义标签。 由于工作的代码中引用了 JSTL 核心标签库，所以接下来新开一篇文章，专门讲解 JSTL ： Go! jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/JavaAbout/JSTL/":{"url":"other-library/shortArticle/JavaAbout/JSTL/","title":"✘ JSTL 学习","keywords":"","body":"JSTL 学习 create by jsliang on 2018-9-12 11:37:01Recently revised in 2018-10-28 12:02:45 一、JSTL 简介  学习地址  结语：好的，我们的学习如上…… “读者：麻蛋，你没有学好不好！” “jsliang：麻蛋，让我去搞小程序了有木有！” “jsliang：有缘江湖再见！” jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/markdown/markdown.html":{"url":"other-library/shortArticle/markdown/markdown.html","title":"✔ Markdown","keywords":"","body":"Markdown 使用语法 create by jsliang on 2018-08-22 17:58:56Recently revised in 2018-11-14 21:40:54 什么事Markdown？Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本具有一定的格式。Markdown文件的后缀为 .md在jsliang看来，Markdown就是HTML的简化版、TXT文本的格式版。如果你在编写中存在难点，你可以直接在Markdown中使用HTML标记语言（包括使用行内样式）。 预览主题 在这里，介绍下VS Code的MarkDown预览如何更换为GitHub主题。 使用 Ctrl + Shift + P 打开设置面板，或者点 文件>首选项>设置 打开设置面板。 设置 \"markdown.styles\"为引用本地CSS（只能绝对路径），或者引用网上的第三方文件。这里引用了Public-Repertory\\/css下的markdown-github.css文件。 配置为： \"markdown.styles\": [ \"E:\\\\MyWeb\\\\jsliang-study\\\\Document-Library\\\\Public-Repertory\\\\css\\\\markdown-github.css\" ] PS：如果不满意加载本地的 Markdown Style，可以使用 VS Code 的插件：Markdown Preview Github Styling 下面介绍Markdown常用语法： 1. 标题 用法介绍：标题可以像HTML一样使用一级至六级标题，使用#即可，一级标题的使用方法为：# 一级标题，几级标题就使用几个#。 展示： 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 2. 无序列表 用法介绍：无序列表可以使用* + -这三种格式，这里推荐使用*：* 列表1 展示： 列表1 列表2 列表3 3. 有序列表 用法介绍：有序列表使用数字1. ***即可，如果开始数字是3，那这个列表就从3. ***开始，第二条是4. *** 展示： 列表1 列表2 列表3 4. 区块引用 用法介绍：区块引用使用>这个符号，空格后放文本即可：> 一级区块展示： 注意：区块引用的左边，有个竖线！ 注意：引用还可以嵌套使用，这是二级的引用，二级以上相信你也懂了 注意：这是三级嵌套，相信你知道怎么用了 5. 分割线 用法介绍：分割线使用三个及以上的*或者-或者_都可，这里使用三个*：*** 展示： * 6. 链接 链接分为行内式和参数式这两种方法 6.1 行内式 用法介绍：[jsliang的网站](http://www.jsliang.top) 展示： jsliang的网站 6.2 参数式 用法介绍： [site]:http://www.jsliang.top \"网站\" [网站]:http://www.jsliang.top \"网站\" 这里是[site],这里是[网站] 展示： 这里是site,这里是网站 7. 图片 用法介绍： 如果是本地图片，则支持绝对路径和相对路径 如果是网络图片，则可以使用http://**来引入 如果是base64，怎么使用参考markdown引用base64 展示： 8. 代码框 代码框分为单行用和多行用这两种方法： 8.1 单行用 用法介绍：`` 展示： 你好使用者，要看看jsliang的网站吗？点我跳转 8.2 多行用 用法介绍： \\`\\`\\` 注释 多行代码文本1 多行代码文本2 \\`\\`\\` 展示： 你好使用者，要看看jsliang的网站吗？点我跳转 你好使用者，要看看jsliang的网站吗？点我跳转 你好使用者，要看看jsliang的网站吗？点我跳转 9. 表格 表格有三种表示方法： 9.1 第一类表格 用法介绍： \\| name \\| age \\| sex \\| \\| :-----: \\| :--- \\| ---: \\| \\| jsliang \\| 23 \\| 男 \\| \\| 小梁 \\| 23 \\| 男 \\| 展示： name age sex jsliang 23 男 小梁 23 男 9.2 第二类表格 用法介绍： \\| name \\| age \\| sex \\| \\| ----- \\| ----- \\| \\| jsliang \\| 23 \\| 男 \\| \\| 小梁 \\| 23 \\| 男 \\| 展示： 表头1 表头2 内容1 内容2 内容3 内容4 9.3 第三类表格 用法介绍： 学号 \\| 姓名 \\| 分数 \\- \\| - \\| - 小明 \\| 男 \\| 75 小红 \\| 女 \\| 79 小陆 \\| 男 \\| 92 展示： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 10. 强调 10.1 字体倾斜 用法介绍：*字体倾斜*或者_字体倾斜_ 展示： 字体倾斜 字体倾斜 10.2 字体加粗 用法介绍：**字体加粗**或者__字体加粗__ 展示： 字体加粗 字体加粗 11. 转义 用法介绍：通过使用\\加上特殊字符，达到转义效果。 展示： \\ ` ~ * _ - + . ! …… 12. 删除线 用法介绍：~~请删除我吧~~ 展示： 请删除我吧！ 13. 功能实现 实现的功能：- [x] [x] 功能1 [x] 功能2 未实现的功能：- [ ] [ ] 功能3 [ ] 功能4 14. 结语 至此，Markdown语法介绍完毕，有兴趣的小伙伴继续去了解更深层次的Markdown语法吧！——2018年8月21日10:54:26 15 缩略标签 基础知识 被缩略 你还需要知道其他的吗？ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-21 10:34:08 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/":{"url":"other-library/shortArticle/oldWebArticle/","title":"✔ 旧网站 - ThinkPHP 建站的文章","keywords":"","body":"ThinkPHP 建站的文章 create by jsliang on 2018-9-18 20:37:30Recently revised in 2018-12-23 21:12:17  这里，存放了来自 http://www.liangjunrong.com 的文章，明天12点，它所在的服务器即将被回收，我使用过 ThinkPHP 建站的历史终将落幕，未来，我们 Node 再见！ 目录 标题 链接 整站感言 点击前往 HTML+CSS+JavaScript基础学习 点击前往 PHP基础学习 点击前往 Bootstrap学习 点击前往 ThinkPHP学习 点击前往 MySQL学习 点击前往 下一站：vue 点击前往 心有所动，路有所行 点击前往 vue第一站：从安装到打包 点击前往 给自己留一份感动 点击前往 4步搞定简易GIF图 点击前往 菜鸟：世界太大，给自己留50G空间 点击前往 5月心得 点击前往 pug模板引擎 点击前往 2017年10月10日 点击前往 gulpUncss清除样式 点击前往 vue基础 点击前往 学习旅途 时间 事件 2017年5月14日 第一次实现“整站”制作 2017年3月 【特训班】 蹭PHP课，自学基础php语法、接触ThinkPHP。 2016年11月14日 第一次实现较完整地在云服务器部署静态网站。注册域名、购买云服务器、配置IIS、域名备案、上传网站…… 2016年9月 必修【WEB系统与技术】 接触asp.net，各种蒙蔽，一无所成。 2016年3月 选修【移动互联网UI设计】 接触jQuery Mobile，“体验”写APP的感觉。 2015年3月 选修【网页设计基础】 首次接触HTML5+CSS3。各种自学：HTML5、CSS3、ECMAScript5、bootstrap…… 我的自学之路  你好，欢迎来到►飘飞的心灵。 ————2016年11月14日———— 想过很久，建一个网站对我的意义大不大。所以，这个网站，我也搞了很久：从一开始的时候，自己构建有语义化的html架构、搭配合理的样式、写js代码去让它炫酷，后来发觉还有好多东西要我去学去弄，前端这条路真的发展得好快、延伸得好漫长，渐渐地感觉时间好缺好缺，我学的还是好少好少，于是就想着套用bootstrap框架来弄吧，于是就有着现在的网站，目前来说还是静态的，但是我想随着了解点ASP.NET，学习下PHP，我可以把后台也搞搞，弄出一个真正意义上的整站。 一个人，大二开始，就慢慢地琢磨前端的东东，还ok，有时沉迷CSS样式中，学校没有很好的导师，但是网络上的各位前端前辈都是吾师；没有伙伴，但是每一次的自学都使我感到愉悦。从来，没想过后悔，既然做了，就干个漂亮！做最好的自己！ ————2017年5月14日———— 很高兴我能接上一次的自我介绍继续写下去。哈哈，是的，我这学期跑去学php了。 首先，从0基础开始（php的0基础。如果说后台的话不算，因为上学期我接触过asp.net了，虽然一塌糊涂），开始学php基础，照着书敲敲一些基本php语句（哈，现在也不知道敲了什么了，反正就是敲一遍，理解一遍，懂了，OK，下一份代码）。 然后，敲了下基于原生php的MVC框架。没敲完，卡住了（很有意思的，我卡在验证码上你信不？）。 再接着，学校特训班的项目老师要求我们小组成员都要投入到php的编写，快速写完项目的功能来。因为我们小组用的是ThinkPHP，所以我乘机跑去自学ThinkPHP咯，平时跟着项目敲敲。然后网上买了个10块钱的教程，照着敲了一遍。接着就是动手，把我原先的静态网站拿过来，分模块，修改。 最后，当当当当，我这个没有登录注册、不能留言、不能评论文章……只能后台管理添加文章的整站就出来啦！ ————tips———— 目前自学2年多了，如果你有兴趣，可以加下我的QQ或者微信，一起探讨前端（HTML5、CSS3、ECMAScript5）以及PHP（ThinkPHP）的神奇。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/01.html":{"url":"other-library/shortArticle/oldWebArticle/01.html","title":"✔ 旧网站 - 整站感言","keywords":"","body":"整站感言 create by jsliang on 2018-05-14Recently revised in 2018-12-23 21:13:30  首先感谢晓纯大大在筝韵项目中分配任务给我，让我在自学ThinkPHP基础上，进一步接触ThinkPHP，从而有更深层次的了解。 然后感谢舍友每周带我蹭PHP基础课、借书给我写那乱糟糟的笔记；还有杭锐大大的PHP技术探讨，不胜感激。 最后，奋战的我，辛苦了。  ——华丽分隔线——  也许，你会对你的愚笨感到羞耻：“哎呀，怎么这么简单你都想不到？” 也许，你会对你的贪玩感到厌恶：“哼哼，说好的周末学习，你又去玩游戏了！” …… 但，你终归有去学习。 你会对上下课路上偶然碰到的妹子眼熟。是因为，你学PHP基础语法的时候，经常跑去图书馆，然后每次去都能看到那个学霸妹子。或许你有感触，所以你不会沉迷游戏不知道做什么，因为你知道，你内心渴求什么。 你会对网上那10块钱的视频教程热衷不已，接连看完2遍。是因为，你很渴望能自己建一个属于自己的空间，即便只是一个小小的个人网站，你也能很开心，因为每一个角落都是你一下一下敲键盘、是你一点一点构思出来的。 你会疲惫地躺在床上痴痴傻笑。是因为，即便深夜1/2点，你都是在努力地为自己的小梦想前进，然后就算疲惫，也是很精神地，痴想着接下来的每一步。 …… 是的，这就是你。 无论，如何，记得高三的格言： ☆人生三愿：吃得下饭、睡得着急、笑得出来。 ☆人生四然：来是偶然、去是必然、尽其当然、顺其自然。  时光悄悄地飞，你苦苦地追，无论成功与否，你不曾后悔。 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/02.html":{"url":"other-library/shortArticle/oldWebArticle/02.html","title":"✔ 旧网站 - 基于 ThinkPHP 和 bootstrap 的整站开发","keywords":"","body":"基于 ThinkPHP 和 bootstrap 的整站开发 create by jsliang on 2017-05-14Recently revised in 2018-12-23 21:13:58  实现步骤： 了解HTML5、CSS3、简单JavaScript。》点击前往《 了解PHP基础语法，懂得MVC框架是怎么回事。》点击前往《 Bootstrap的学习。》点击前往《 ThinkPHP的学习。》点击前往《  自学指导： 你按照我给的步骤，学习完步骤1-4，那么基本可以做一个整站（前端+后台+数据库），在ThinkPHP的学习中你可以找到做整站的链接，在这里我就不重复写了，下面给出最终成品和参考资料。  最终成品（仅供参考）： 1、意空间仿站源码：ykj.zip 2、我的网站源码：myWeb.zip  参考资料： 网站模板参考寻找：模板王、模板之家 在线制作ico：ICO 在线压缩图片：图好快 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/03.html":{"url":"other-library/shortArticle/oldWebArticle/03.html","title":"✔ 旧网站 - HTML + CSS + JavaScript 基础学习","keywords":"","body":"HTML + CSS + JavaScript 基础学习 create by jsliang on 2017-05-14Recently revised in 2018-12-23 21:14:40  学习路径：给出视频和文档学习两个途径，可按照自己的习惯学习，至于较好的书籍推荐，目前就不写进来了，如果需要，去“自学旅途”找到我的个人联系方式问吧。 视频学习： HTML+CSS基础课程：》点击前往《 JavaScript基础课程：》点击前往《 JavaScript进阶教程：》点击前往《  文档参考： HTML5学习：》点击前往《 CSS3学习：》点击前往《 已失效 JavaScript学习：》点击前往《 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/04.html":{"url":"other-library/shortArticle/oldWebArticle/04.html","title":"✔ 旧网站 - PHP 基础学习","keywords":"","body":"PHP 基础学习 create by jsliang on 2017-05-14Recently revised in 2018-12-23 21:15:04  学习途径：这里提供视频和文档这两种学习途径，至于推荐书籍，暂时没整理出来，如果有需要，请点击“自学旅途”找到我的个人联系方式联系我。  视频： PHP基础：》点击前往《 PHP进阶：》点击前往《 PHP之MVC框架：》点击前往《  文档： PHP教程：》点击前往《 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/05.html":{"url":"other-library/shortArticle/oldWebArticle/05.html","title":"✔ 旧网站 - Bootstrap 学习","keywords":"","body":"Bootstrap 学习 create by jsliang on 2017-05-14Recently revised in 2018-12-23 21:15:35  学习途径：在这里，只需要参照文档，在可视化布局系统进行拖拉，然后部署到自己的机子尝试就OK了。 Bootstrap文档学习：》点击前往《 Bootstrap可视化布局：》点击前往《 Bootstrap文档下载（楼主目前使用版本）》bootstrap.zip《 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/06.html":{"url":"other-library/shortArticle/oldWebArticle/06.html","title":"✔ 旧网站 - ThinkPHP 学习","keywords":"","body":"ThinkPHP 学习 create by jsliang on 2017-05-14Recently revised in 2018-12-23 21:16:00  学习推荐；通过下面3个链接，你基本可以开发属于自己的网站咯。 ThinkPHP在线文章：》点击前往《 ThinkPHP PDF文档：》点击前往《 ThinkPHP 个人博客实战：》点击前往《 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/07.html":{"url":"other-library/shortArticle/oldWebArticle/07.html","title":"✔ 旧网站 - MySQL 学习","keywords":"","body":"MySQL 学习 create by jsliang on 2017-05-14Recently revised in 2018-12-23 21:16:30  推荐学习：MySQL的学习我是照着书来学习的，暂时没有更好的推荐，所以先给个在线文档学习的网站吧，祝你学习愉快~ MySQL在线教程：》点击前往《 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/08.html":{"url":"other-library/shortArticle/oldWebArticle/08.html","title":"✔ 旧网站 - 下一站：vue","keywords":"","body":"下一站：vue create by jsliang on 2017-05-14Recently revised in 2018-12-23 21:16:51  5月中旬，继续接力！vue的学习，你准备好了吗？跟我一起来吧！ vue在线文档学习：》点击前往《 vue在线视频学习：》点击前往《 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/09.html":{"url":"other-library/shortArticle/oldWebArticle/09.html","title":"✔ 旧网站 - 心有所动，路有所行","keywords":"","body":"心有所动，路有所行 create by jsliang on 2017-05-18Recently revised in 2018-12-23 21:17:11  尤记得一记亮光，照进的不止是心房，更清除了心中的迷茫。 从高三毕业，到大三准就业:高三为着不知道能不能考上“好”大学而迷茫，大三为着毕业能不能找到工作而迷茫。 有的时候，心酸，烦躁，不安……真的不知道自己在做什么，觉得好像被人堵在了漆黑木桶，两眼发黑。你想找着一丝亮光，但你却怕那丝亮光会瞬间丢失，让你陷入更深的恐慌。于是，你漫无目的闲逛，但，只能毫无意义。 你不是个情商很高的人，但你是个单纯又复杂的人，你所了解的不多，但一件小事你又可以把它无限延伸，搞得天都要为之“下凡”（天塌）。 好吧，你的确不知道自己在写着什么，但写完了总有写完的舒服。 天不眷我，吾自惜己。 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/10.html":{"url":"other-library/shortArticle/oldWebArticle/10.html","title":"✔ 旧网站 - Vue 第一站：从安装到打包","keywords":"","body":"Vue 第一站：从安装到打包 create by jsliang on 2017-05-19Recently revised in 2018-12-23 21:17:34  大家好，不知不觉又是周五，这周你都做了啥？都学到了啥？尝试让自己更好吧！ OK，直奔主题,这周我们讲讲vue从安装到构建项目： 1、下载安装Visual Studio Code，这里提供的是官网下载（英文网站，点击右手边的download即可） 》VS Code官网《 2、安装node.js并配置环境： 》Node.js安装及环境配置之Windows篇《已失效 》Node.js下载《 》淘宝NPM镜像《 3、安装vue 方法一：使用cmd的命令行安装（Node.js安装文章教过你怎么打开了）。 方法二：使用VS Code的集成终端（道理和cmd一样，就是界面比cmd好看了点）：  下面一步一步讲解如何安装： 1、全局安装vue-cli：npm install --global vue-cli  安装完成后可以在C:\\Users\\Administrator\\AppData\\Roaming\\npm目录下（如果你配置了node的文件存放位置，请到node安装目录中找文件）找到安装的文件：  2、创建一个基于webpack模板的新项目：先用命令行cd /d D:\\Node\\node_global，切换到你要存放项目的工作空间，然后使用命令行 vue init webpack vueobject创建项目，vueobject就是你的名字，下面通过图文讲解我怎么创建一个新的项目的：      （给项目找个存放位置）  （询问你项目名称，默认为（）里面的my_vue_object，我直接回车）  （询问你项目描述，默认为（）里面的A Vue.js project，没啥描述，直接回车）  （询问你作者，嗯，梁渣渣）  （询问你使用哪个？可以使用↑↓来选择，它说大多数人用第一个，那就enter第一个吧）  （是否安装vue-router，这是官方的路由，大多数情况下都使用，就y然后enter吧）  （是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，并不会影响整体的运行，这也是为了多人协作，新手就不用了，一般项目中都会使用。所以选n并enter吧）  （是否安装单元测试，Karma和Mocha，详细你们去了解吧，这里选择n）  （是否安装e2e测试，这里我还是选择n）  至此，我们的安装就完成了，打开文件查看下确认是否安装：  接下来我们将cmd切换到我们项目所在的位置，或者你将my_vue_object文件夹拖到Visio Studio Code（由于楼主没有安装好，没法直接用右键文件夹用Visio Studio Code打开，所以一般都是把文件拖入到VS ），并打开集成终端，就可以直接切换到项目所在位置了：  然后我们安装所有的依赖：npm install  （正在安装）  （安装完毕）  可以看到我们的my_vue_object文件夹中多了个依赖文件了：  接下来就是打开项目了，你可以使用VS Code：  或者使用命令行：npm run dev  最终网页展示，至此，我们的项目搭建完成啦！  接下来大致说下打包，打包的命令是：npm run build 。当然打包不是直接敲这个命令行就OK了。 首先我们需要找到config/index.js，修改下路径：  然后找到build/build.js，注释掉两句话：  最后我们在集成终端/cmd输入npm run build，它运行后：  可以看到我们的项目文件夹中多了个dist，说明我们成功了，平时我们需要打开环境才能运行的项目，在这里打包成功了，我们可以直接用浏览器打开了（你可以试下把编辑器关了），在这里我就不演示了。  因为我也是新手，如果你觉得我说得不够透彻，可以看看其他人写的怎么安装vue：》点击前往《  最后我们来个小总结： 在这篇文章中，一些新词我会尽量给你我找到的解释，如果你看到自己不懂的，OK，百度，如果还不懂，OK，再百度。意思就是：没有百度一遍搞不定的，如果有，那就百度两遍！谁都是这么过来的。我写这篇文章，只是给你一个我认为还OK的“捷径”，并不是说，手把手教你从头到尾。 在这里vue的从安装到运行就结束了，如果操作过程有疑惑，然后你百度后还不懂，可以加我QQ或者微信询问（我不一定能帮你解决，但我一定是搜索过我的小脑袋瓜帮你解决了）。  谢谢你的阅读，希望你的前端之路更进一步。 ——梁^_^飘 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/11.html":{"url":"other-library/shortArticle/oldWebArticle/11.html","title":"✔ 旧网站 - 给自己留一份感动","keywords":"","body":"给自己留一份感动 create by jsliang on 2017-05-21Recently revised in 2018-12-23 21:17:55  最可悲的人，心有猛虎行若老鼠。即使你精打细算，把你未来几天、一周，甚至是半年的时间规划好，但是，如果你的行动仅限于开始的完美起步，那么，你终归还是失败了。最终的最终，你只能抱着“楚楚可怜”的自己，为自己的“不执行”而后悔，然后规划下一次的“斩首”行动，最后死在自己的梦中。 最彷徨的人，三天打鱼两天晒网。如果你有计划，OK，那么请你一步一步走踏实了，别想着大鱼买了小钓竿，美味不是想出来的，没有你的激情燃烧，没有你的汗血挥洒，你终归享受不到最后的那份美味。 …… 也许你会问，为什么提这个？因为前面两个我都经历过啊！每一次对自己的鼓舞，总是那么让人激情澎湃，总是想着结果的幸福美好，然后，每一次，换来对自己深深的失望：有时候是计划好了，然后做了几天，就腻了，倦了，三天打鱼两天晒网，最终也不知道自己收获了什么，成就了什么；有时候是觉得，仿佛整个世界都是自己的，自己能改变自己，改变周遭，能做地更好，结果，在行动上，寸步“不”行。 仿若上苍终归有点人性，异或自己有点想法。从5月1号开始，就草草地订了两个计划：在6月1日前，用ThinkPHP搭建我的网站，用vue.js做个静态整站。然后，就是我的“傻傻”学习，我花了两周（15天），看了两遍一个ThinkPHP的初级博客建站教学视频，对，很感兴趣那种，我都不知道哪来的激情，心中还在想着那天12点断网后，凭着视频缓存看完第一遍的那种感动，那一刻，仿佛我站在了世界之巅！那15天怎么过来的我不知道，但是我清楚地记得每天学习到晚上1点睡觉的时候，躺在床上的那种感动。 今天，5月21日了。虽然我的vue.js还在入门阶段，但是，我对接下来9天仍充满期待，也许，这将可能是我大学中，过得印象最深的一个月吧。加油，梁峻荣！ jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/12.html":{"url":"other-library/shortArticle/oldWebArticle/12.html","title":"✔ 旧网站 - 4 步搞定简易 GIF 图","keywords":"","body":"4 步搞定简易 GIF 图 create by jsliang on 2017-05-22Recently revised in 2018-12-23 21:18:21  话不多说先上图！  然后提供下网址，想自己探索的可以先去看看：》美图制作GIF《  最后提供下教程，本人亲自编写，不服不懂不会去“自学旅途”找我联系方式，包教包会！！！ 教程：4步搞定GIF图.doc jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/13.html":{"url":"other-library/shortArticle/oldWebArticle/13.html","title":"✔ 旧网站 - 菜鸟：世界太大，给自己留 50G 空间","keywords":"","body":"菜鸟：世界太大，给自己留 50G 空间 create by jsliang on 2017-05-24Recently revised in 2018-12-23 21:18:42  你是不是还在编程中不断排坑，步步向前？ 你是否为了自己的未来，在努力构建自己的知识体系？ 你有过自己的梦想吗？ 为了梦想你是否有去熬夜通宵？是否端坐在电脑前十几小时如一秒？是否曾经觉得饭菜也不过只是填饱你的肚子，还不如我的编程有滋味？ 无论你怎么想的，如何过的，但今天我只想说：以上的？号，我都经历过，但是，我心无悔。 …… …… …… 有多少次，想要一个属于自己的编程空间，自己就是那个世界的王。你说让它变漂亮，它就漂亮；你说我想简洁点，那么，它就简洁！是的，我在说着我的网站，那个经过我购买域名、购买云服务器、配置云服务器设置、申请域名备案、学前端、学后台、搞数据库……最后发布出来的网站：“飘飞的心灵”。 我不知道我曾经熬夜几次，我不记得我辗转反侧地在床上构思过几次，我忘乎所以地在路上思考过出现的bug几次，但每一次的编程，我都知道自己离成功更近了一步。直到我在自己那部用了3年多的手提，部署出一个小小的，只有少少功能的网站，然后远程登录云服务器，复制、粘贴、建数据库，最后用自己手提访问：“欢迎来到梁峻荣的网站！”。那一刻，我兴高采烈！ 是的我是一个菜鸟，我见过别人的个人博客，用的技术是那么高大上，写的界面是那么华丽，加载的时间是那么迅速。但，我仍觉得我为自己骄傲，因为，我也有！也许别人会嘲笑：“吖！这东东，不是老早老早以前就有的么？”。是啊是啊，不过我做出来我自己的博客了。“啧啧，这技术，都快淘汰啦，看别人都是用最新的技术做的~”。是啊是啊，不过我做出来了。 也许你会说，你是不是活在自己的世界里了？ 但是我想说，你有过梦想并且不断努力地去实现吗？ …… …… …… 菜鸟，不要为自己的低级感到自卑！不要因为自己写的那些不堪入目的代码感到羞耻！我们能创新，我们有属于自己的想法！看到那些新技术，我两眼发光，恨不得把它源码搜刮一遍，去杂重构，变成自己知识体系的一部分。在编程世界里挣扎吧！ 我还记得，每次去上课的路上，会看到那颗高高在上，生长扎根在楼顶的树苗，也许它就像那些有很好的背景，出身显贵的人，一开始就能站在很高的角度。但是，或许它也会经历风雨，也懂得深扎根，可如果他们想更进一步，势必只能破楼而起，也终比不过那些土生土长的，生长在大地上，与众多竞争对手抢着那一块小小的地盘的那些树苗，因为他们的未来，充满着无限可能！ jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/14.html":{"url":"other-library/shortArticle/oldWebArticle/14.html","title":"✔ 旧网站 - 5 月心得","keywords":"","body":"5 月心得 create by jsliang on 2017-05-31Recently revised in 2018-12-23 21:19:09  5/31 接触新技术的猎奇，想早点开发demo，却感觉一无所知的那种烦躁与不安，带着这种动力，奔赴6.1。 5/30 学会控制自己的情绪，你就赢了一半了。 5/29 欠，再小的人情你也得记着，你当渣人当沙；给，再大的人情你也不必太过当回事，有回那就好好相处，没回就当没这个人。 5/28 别后悔就行。 5/27 未来描述的很美好，但远处的你没去找，近处的你懒得建，高处的你没去爬。 5/27 出门就能搬凳子晒太阳，不是对爸妈的辛苦视而不见，只是我有更高的追求，加油！ 5/26 偶尔来一次久违的运动，累得瘫痪，开心无比。 5/25 你和别人谈笑风生，似乎对什么都不在意。然后你回去后暗下决心，要改变自己。最后你做不所做，无果而终。 5/24 没有完美，接受bug人生。 5/23 充满期盼，激情澎湃。 5/22 很多有趣好玩的东西等着你，但是不要贪心，先做好现在需要做的，例如:先用vue做出个静态整站？ 5/21 生活总是充满隐藏彩蛋，只要你去寻觅，总有一堆惊喜等着你。 5/20 也许别人现在过得有滋有味，你却通宵达旦做一些“低级”的事，但请相信，你的心情不比那些人差，因为你为自己而高兴。 5/19 也许有时候要学会释放，而不仅仅靠一股热情。 5/18 很好，够充实！我喜欢~ლ(╹◡╹ლ) 5/17 最大的敌人不是迷茫，是察觉不到迷茫，迷茫后不知要怎么办。 5/16 不以做demo为目的的学习，都是耍流氓。 5/15 有时候有些事也许你都不知道你做了啥，但一定有它所存在的意义。若没有，请反思。 5/14 沉迷的人无法感知时间，但沉迷游戏的人醒来后发现的是后悔，沉迷学习的人醒来后发现的是幸福。 5/13 人生一是:糊涂一时，豁达一世。 人生二是:心不二用，才贯二酉。 人生三是:得其三昧，连中三元。 祝:眼观六路，四清六活，才绝六艺。 5/12 各种忙活，但是很充实很开心。有的时候写的是一份不知所谓感觉一无所用的说明书；有的时候是为了自己心中那点小心愿写写写画画画自己的网站。ლ(╹◡╹ლ)但是，只要我内心不疲惫，就没有不能坚持的。 5/11 也就那杆标尺，也就那个准则。不管有理没理，但还是觉得，日子过得再快点吧，到周五六就没那家伙了。 5/10 忙碌，也许忙的不是自己想做的，但却是被迫的。疲惫，虽然让人感到无法坚持，但坚持下来，却是让人欣慰。 5/9 也许真的有份工作，让人越干越精神，如果你找的工作只是为了赚钱，为了养家糊口，那么有什么意思？单纯为了麻木得活下去，亦或者说你觉得过段时间就好了？ 5/9 过了会争辩的时代。周围人都觉得它懂，它会去改的，都不曾想着“推”它一把，只是“静静地”看着。但它终究因为不懂犯下了错，进不了新的环境，而你终究在想:它知道的，它会去改的。 5/8 精，气，神。或许做不到每天充实，但至少让你感觉良好，不会太伤感，也不会太懊悔，这才是我想要的每天的状态。 5/7 我也只是个普通人，一生可能不会创造什么奇迹，但这个世界，却给了我最大的惊喜。 5/4 没有比今天更好的状态了！(,,・ω・,,)加油！ 5/3 6.1前，用TP搭建我的网站，用vue.js写个静态网站，加油！ 5/2 高考前你为自己各科目的这不懂那不会感到惊慌，实习前你为自己这不通那不顺感到迷茫。也许人生就是这样，别灰心，试着攀向更高！ 5/1 也许人家花两周都搞不好的静态网页，你一晚上功夫就可以搞定了；也许你花7个钟才搞定的后台代码，人家花半个钟就弄完了。别得意，生活总是这样，每个人都有自己擅长的部分，你所要做的，是不断提升自己。 5/1 致不知道什么时候会看到这句话的自己:你恨过自己的无能为力，骄傲过自己的刻苦铭心，无论你过得如何，但是请记住，你过得不后悔。 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/15.html":{"url":"other-library/shortArticle/oldWebArticle/15.html","title":"✔ 旧网站 - pug 模板引擎","keywords":"","body":"pug 模板引擎 create by jsliang on 2017-06-08Recently revised in 2018-12-23 21:19:30 目录 一、介绍 二、安装 三、建立项目 四、标签 五、id与class 六、属性 七、多行文本 八、注释 九、style与script 十、变量 十一、for、each、while 十二、if、else、unless 十三、mixins 十四、结语 一、介绍  返回目录  首先，我们得知道，什么是模板引擎？ 模板引擎（这里特指用于 Web 开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。->详情参考百度 然后，为什么使用 pug ？pug 的前身是 jade ，因为涉及商标原因改名 pug。pug 是一个高性能的模板引擎，它深受 Haml 影响，它是用 JavaScript 实现的，使用空白与缩进敏感的代码格式编写HTML页面，并且可以供 Node 使用。->pug官网 缺点：1、可移植性差；2、调试困难；3、性能不是很出色。 优点：1、初始阶段开发效率快；2、稳定阶段性能和协作成本低。  举个例子： 传统HTML代码： hello pug pug pug  pug 代码： doctype html html head title hello pug body h1 pug pug 二、安装  返回目录  npm install pug npm install -g pug-cli 三、建立项目  返回目录  新建文件夹 pug，然后添加文件 index.pug ，往 index.pug 添加下面内容（注意，pug 的书写格式是空2格，如果用 tab 缩进会报错） doctype html html head title pug study body  然后在该文件夹的位置，使用终端运行 pug -P -w index.pug（如何使用命令行我vue有讲，这里就不累叙了），就会获得一个可读性较好的 index.html （如果想要压缩的 html，使用 pug index.pug 就OK了）： pug study  此刻文档目录如下： 四、标签  返回目录  标签写法非常简单，这里就不哆嗦了。 doctype html html head title pug study body  使用 pug -P -w index.pug 命令编译后查看 index.html 文件（为简略下面只写“编译后”）： pug study 五、id与class  返回目录 doctype html html head title pug study body p.bg_color1 hello pug class1 p(class=\"bg_color2\") hello pug class2 p#title1 hello pug id1 p(id=\"title2\") hello pug id2 p.bg_color1#title1 hello pug class+id  编译后： pug study hello pug class1 hello pug class2 hello pug id1 hello pug id2 hello pug class+id 六、属性  返回目录 doctype html html head title pug study body a(href=\"http://www.liangjunrong.com\", target=\"_blank\") 梁峻荣的网站 input(name='study',type='button',value='pug学习') input(name='like',type='checkbox',checked) span 吃喝拉撒睡  编译后： pug study 梁峻荣的网站 吃喝拉撒睡 七、多行文本  返回目录 doctype html html head title pug study body p | 1. hello span /hi | 2. liang p. 1. hello/hi 2. liang  编译后： pug study 1. hello/hi2. liang 1. hello/hi 2. liang 八、注释  返回目录 doctype html html head title pug study body h3 单行注释，该注释会显示到编译后的HTML中 // h3 hello world! h3 非缓冲注释，不会显示到编译后的HTML中 //- h3 hello world! h3 多行注释 //- h3 hello span hello h4 hi  编译后： pug study 单行注释，该注释会显示到编译后的HTML中 非缓冲注释，不会显示到编译后的HTML中 多行注释 九、style与script  返回目录 doctype html html head title pug study style. p{ color: red; } body p hello world! script. var name = 'liang'; var title = 'pugStudy';  编译后： pug study p{ color: red; } hello world! var name = 'liang'; var title = 'pugStudy'; 十、变量  返回目录 doctype html html head title pug study body h3 变量定义与使用 - var name = 'liang' p #{name} - var nameScript = 'alert(hello);' h3 转义 div #{nameScript} div= nameScript h3 非转义 div !{nameScript} div!= nameScript h3 单纯输出文本 div \\#{name} div \\!{name} h3 input value默认值 input(value=name) input(value=myName) 十一、for、each、while  返回目录 doctype html html head title pug study body - var liang = {name1: '梁峻荣', name2: '梁渣渣'} h3 for - for (var k in liang) p= liang[k] h3 each each value, key in liang p #{key}: #{value} h3 while - var n = 0 ul while n  编译后： pug study for 梁峻荣 梁渣渣 each name1: 梁峻荣 name2: 梁渣渣 while 0 1 2 3 4 十二、if、else、unless  返回目录 doctype html html head title pug study body h3 if...else... - var number = 1 if number != 0 p number!=0 else p number=0 h3 unless - var myNumber = true unless !myNumber p false h3 case - var caseNumber = 3 case caseNumber when 1 p caseNumber=1 when 2 p caseNumber=2 when 3: p caseNumber=3 default p caseNumber undefined  编译后： pug study if...else... number!=0 unless false case caseNumber=3 十三、mixins  返回目录 1. mixin初认识 2. mixin循环 3. mixin嵌套 4. 传递标签 5. 传递class 6. 传递class和id 7. 不确定传参 mixin初认识  返回第十三章目录 doctype html html head title pug study body mixin lesson p pug study +lesson  编译后： pug study 1、mixin初认识 pug study mixin循环  返回第十三章目录 doctype html html head title pug study body mixin study(name, courses) p #{name} ul courses each course in courses li= course +study('tom', ['jade', 'pug'])  编译后： pug study tom courses jade pug mixin嵌套  返回第十三章目录 doctype html html head title pug study body mixin study(name, courses) p #{name} ul courses each course in courses li= course mixin group(student) h4 #{student.name} +study(student.name, student.courses) +group({name:'liang',courses:['jade','pug']})  编译后： pug study liang liang courses jade pug 传递标签  返回第十三章目录 doctype html html head title pug study body mixin team(slogan) h4 #{slogon} //- 如果存在附带标签，则传递过来 if block block else p no team +team('slogon') p Good job!  编译后： pug study Good job! 传递class  返回第十三章目录 doctype html html head title pug study body mixin attr(name) p(class != attributes.class) #{name} +attr('attr')(class='magic')  编译后： pug study attr 传递class和id  返回第十三章目录 doctype html html head title pug study body mixin attrs(name) p&attributes(attributes) #{name} +attrs('attrs')(class='magic', id='attrid')  编译后： pug study attrs 不确定传参  返回第十三章目录 doctype html html head title pug study body mixin magic(name, ...items) ul(class=name) each item in items li = item +magic('magic', 'node', 'jade', '...')  编译后 pug study = item = item = item 十四、结语  返回目录  pug是我在学node.js的课程中，老师要求使用node写一个项目，然后我在项目中负责前端，而小伙伴想我使用pug写个静态界面给他，所以才有了我学习pug的文档。 参考资料： 慕课jade模板视频讲解 ->点击前往 segmentfault论坛pug模板（一） ->点击前往 pug npm网址 ->点击前往 pug的GitHub网址 ->点击前往  到此我们的pug学习结束。 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/16.html":{"url":"other-library/shortArticle/oldWebArticle/16.html","title":"✔ 旧网站 - 2017年10月10日","keywords":"","body":"2017年10月10日 create by jsliang on 2017-10-10Recently revised in 2018-12-23 21:19:59  7月，放假，回家，学车……一次，无奈、无语却无悔的暑假经历。 9月，开学，回校，学习……一个，心酸、迷茫且悲哀的大四开局。 至今，10月10日，幡然醒悟，回首一季，悄然已逝，追悔莫及。 没有人比自己更清楚自己。我想要的，简简单单；我要做的，却沉闷繁杂。我不知道，是不是想要达成一个目标，总得曲折辗转……但，我想做的，那我就去做吧！ ☆12.1前做完毕业设计 ☆毕业后买部新手机去张家界旅游。 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/17.html":{"url":"other-library/shortArticle/oldWebArticle/17.html","title":"✔ 旧网站 - gulpUncss 清除样式","keywords":"","body":"gulpUncss 清除样式 create by jsliang on 2017-10-24Recently revised in 2018-12-23 21:20:16  套用模板、编写大型网站的时候，经常会写了很多没用的CSS代码，尤其是没有分好类、写好备注的时候，就会感觉很麻烦，这时候就可以使用gulp-uncss来精简样式，去掉没用的css代码。 首先找到你要精简样式的目录：  然后安装node：http://nodejs.cn/ 接着新建一个目录放gulp项目：npm init  再接着安装gulp：cnpm install gulp -g  然后安装gulp-uncss：cnpm install gulp-uncss --save-dev  再然后在项目中新建一个gulpfile.js：  代码如下： var gulp = require('gulp'), //加载gulp uncss = require('gulp-uncss'); //加载gulp-uncss gulp.task('uncss', function() { //冗余css文件 return gulp.src('./App/css/style.css') //清除APP/css下的style.css .pipe(uncss({ //使用该css的html页面，可多个（这里我们只清除一个试试） html: ['./App/index.html'], })) //输出目录 .pipe(gulp.dest('./dist/css')); });  接着新建好输出目录的文件夹：  最后执行gulp uncss：  这样，就可以看到，原本1300行的CSS清除到630行了，我们使用gulp-uncss清除样式成功啦~。 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/oldWebArticle/18.html":{"url":"other-library/shortArticle/oldWebArticle/18.html","title":"✔ 旧网站 - Vue 基础","keywords":"","body":"Vue 基础 create by jsliang on 2017-06-12Recently revised in 2019-05-21 09:55:168 第一季 vue基础  前提：安装VSCode、下载vue.js、vue.min.js 推荐：Vue教程：https://cn.vuejs.org/v2/guide/ 参考：技术胖博客：http://jspang.com 第一节 Hello World 拖拽文件作为项目目录 项目目录为： 安装live-server：npm install -g live-server（终端安装，下同） 启动项目：live-server（cd到该项目，输入命令行并启动） 初始化项目，获取package.json：npm init 6.代码 index.html Vue.js实例 Vue2.0实例 Hello World实例 v-if&else&show v-for v-text&v-html v-on v-model v-bind v-pre & v-cloak & v-once 第二节 v-if、v-else、v-show  讲解：v-if与v-else经常搭配，v-show是另一种显示隐藏的手段： v-if：判断是否加载，可以减轻服务器的压力，在需要时加载。 v-show：调整css display属性，可以使客户端操作更加流畅。 v-if&else&show.html v-if HelloWorld 你登录了！ 抱歉，还没有登录！ 你注册了！ var app = new Vue({ el:'#app', data:{ isLogin:true, isRegister:true } }) 第三节 v-for v-for.html  第一部分 v-for 实例 v-for 实例 {{item}} var app = new Vue({ el:\"#app\", data:{ ///1、需要循环的数据 items:[1, 33, 22, 55, 44, 6, 8] } })  第二部分 v-for 实例 v-for 实例 {{item}} var app = new Vue({ el:\"#app\", data:{ // 1、需要循环的数据 items:[1, 33, 22, 55, 44, 6, 8] }, computed:{ // 3、重新定义一个数组，接收items并对其进行排序 newItems:function(){ return this.items.sort(sortNumber); } } }); function sortNumber(a, b){ return a-b; }  第三部分 v-for 实例 v-for 实例 {{item}} {{index+1}}:{{item.name}}--{{item.age}} var app = new Vue({ el:\"#app\", data:{ // 1、需要循环的数据 items:[1, 33, 22, 55, 44, 6, 8], // 4、数组中存放对象 students:[ {name:\"梁峻荣\", age:11}, {name:\"梁渣渣\", age:33}, {name:\"梁^_^飘\", age:22}, ] }, computed:{ // 3、重新定义一个数组，接收items并对其进行排序 newItems:function(){ return this.items.sort(sortNumber); }, newStudents:function(){ return sortByKey(this.students, 'age'); } } }); function sortNumber(a, b){ return a-b; }; // 6、数组对象方法排序 function sortByKey(array,key){ return array.sort(function(a, b){ var x = a[key]; var y = b[key]; return ((xy) ? 1 : 0)); }); }; 第四节 v-text、v-html （见第一季 vue基础（二）） v-text&html.html v-text&html 实例 v-text&html 实例 v-text比{{message}}更友好在于，没加载出来时不显示乱码给客户看 {{message}} = 3、请注意尽量别用<>标签输出，因为黑客可以利用xss攻击 var app = new Vue({ el:\"#app\", data:{ message: \"Hello World!\", htmlMessage: 'Hello World!' } }) 第五节 v-on （见第一季 vue基础（二）） v-on.html v-on 实例 v-on 实例 加分 减分 var app = new Vue({ el:\"#app\", data:{ score:0, score2:1 }, methods:{ addScore:function(){ this.score++; }, reduceScore:function(){ this.score--; }, onEnter:function(){ this.score = this.score + parseInt(this.score2); } } }) 第六节 v-model （见第一季 vue基础（二）） v-model.html v-model 实例 v-model 实例 一、双向数据绑定 一、双向数据绑定-懒加载 一、双向数据绑定-前数字去尾部非数字 一、双向数据绑定-去尾部空格 二、双向数据绑定-文本域 三、多选框 三、多选框-数组绑定 梁峻荣 梁渣渣 梁大傻 四、单选框 男 女 你选择的是：{{sex}} var app = new Vue({ el:\"#app\", data:{ message: '我会跟着你输入的数据变喔~', message2: '完成输入数据并失去焦点时改变', message3: '我只搞数字，其他别放我这', message4: 'Hello World!', message5: '文本域双向数据绑定', isTrue: true, webName: [], sex: '', } }) 第七节 v-bind （见第一季 vue基础（二）） v-bind: v-bind 实例 .bg_red{ background: red; } .font_big{ font-size: 150%; } v-bind 实例 梁峻荣的网站 我是要被改变的文本。 选中状态：{{isOK}} 绑定数组 绑定class的三元运算符 绑定class对象 var app = new Vue({ el:\"#app\", data:{ imgSrc: 'http://img3.imgtn.bdimg.com/it/u=1504668356,1647420697&fm=26&gp=0.jpg', webSrc: 'http://www.liangjunrong.com', isOK: false, bgRed: 'bg_red', fontBig: 'font_big', styleObject:{ color: 'green', fontSize: '20px' } } }) jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-21 09:56:21 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/share/FrontEndSolution.html":{"url":"other-library/shortArticle/share/FrontEndSolution.html","title":"分享 - 前端解疑","keywords":"","body":"前端解疑 Create by jsliang on 2018-11-28 22:03:53Recently revised in 2018-11-28 22:11:09  学前端的总会有这样那样的困扰，下面的谈话分析可能对你有所帮助： (1) 问：  你好，我觉得很困惑，我只会点 HTML5、CSS3，大学期间学过点防火墙、HTML5、CSS3、SQL、Java……但是我担心我的技术可能连毕业设计都解决不了，我的题目是基于 Node.js 的动漫资源管理的实现与开发，而且我剩下一个月了，能不能搞定啊？ 答：自信还是要有的。建议使用 jQuery + Bootstrap + Express + MySQL。  首先，为什么使用 Bootstrap 呢？因为它布局简单，容易上手，基本看个 2/3 天就能了解一些简单的使用。 然后，为什么推荐使用 jQuery 呢？因为它精简了 JavaScript 操作 DOM 的部分，容易上手，同时可以做一些好看的动画，而且它的延伸很多，拿来就用。 接着，为什么推荐 Node 的 Express 框架呢？因为它已经封装好了，你老实拿来用就行了，不用费太大功夫折腾。 最后，为什么推荐 MySQL 呢？因为你学过它，你要做的就是，将 Node 与 MySQL 连接起来，至于数据库的设计，还不简单么，至少你懂啊！ 综上，如果你们的技术要求不高的话，完全可以在一个月内用这个搞定。  那么，第一步你要做什么？加 QQ 群，尽可能地加很多的技术 QQ 群：jQuery 群、 Node 群、MySQL 群……因为，当你产生问题的时候，你要多个 QQ 群问，才有可能收到回答。当然，首先是你百度找不到答案的前提下，因为有些 QQ 群看你不百度就问，下次再也不会回复你的。 第二步，你要学会灵活使用 百度 和 google，只有大量的资料，才能让你更稳健地进行开发。 第三步，你要学会跟你的指导老师沟通，因为你写的，有可能不符合规定，只有让老师看到你写了什么，这些模块够不够达到毕业标准……只有在沟通下，你才能更加明确地知道，自己应该怎么开发。  综上，你的路就是：先学 Bootstrap，将页面搭起来。再学 Express ，通过它连接 MySQL，知道怎么提供接口后，再用 jQuery 调接口渲染数据。注意时间的安排，每门技术花费多少时间。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/share/November2018.html":{"url":"other-library/shortArticle/share/November2018.html","title":"分享 - 2018 前端开发分享","keywords":"","body":"2018 前端开发分享 Create by jsliang on 2018-11-26 08:10:27Recently revised in 2018-11-29 22:05:14  Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更丰富文章的动力！GitHub 地址  查阅网上诸多资料，并结合自己的实际开发经验，进行的一次前端技术分享。 一 目录  不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 发展历史  3.1 原始社会  3.2 石器时代  3.3 铁器时代  3.4 工业时代 四 技术比较  4.1 JSP 与 jQuery  4.2 jQuery 与 Vue  4.3 Vue 与 小程序 五 思考总结 六 解疑释惑 二 前言 返回目录  于 2018年12月 做个小小的前端技术分享，分享包括但不限于：Web 前端发展史、JQuery 与 Vue 的比较、Vue/React/Angular 的比较、前端开发经验的分享与总结等……  参考文献： 前端发展史 | 博客园 - kidney 前端发展史 | 简书 - 迷缘火叶 前端开发的历史和趋势 | CSDN - 红豆灬 前端基础历史 | 百度前端技术学院 - 刘文超 JSP、JavaScript、jQuery、jQuery Easy UI、Ajax、JSON各自是什么、区别、联系 | CSDN - 南下Debugging jquery 和 jsp常用功能点汇总 | CSDN - toMatser jquery 和 vue对比 | 博客园 - 绿茶/ 浅析 Vue 和微信小程序的区别、比较 | 脚本之家 - 卖女孩的小火柴 怎样在 vue，angular，react 快速选择一个合适的框架 | CSDN - 猛码象 vue.js适合开发大的网站吗？ | 百度贴吧 - 醉红尘 前端工程师的未来在哪里？ | 微信公众号 - 阿里技术  参与协助： 深圳大学 - 陈建光 杭州店家科技 智慧财务线 - 靳宗楠 三 发展历史 返回目录  以铜为镜，可以正衣冠； 以古为镜，可以知兴替； 以人为镜，可以明得失。  了解一门技术的历史，可以帮助我们更清晰地了解这个行业的动态。 3.1 原始社会 返回目录  很久很久很久以前，在 jsliang 出生的前一年，即 1994 年的时候，网景公司 (Netscape Communications) 推出了第一款浏览器：NCSAMosaic，但是它只有少数的幸运儿才能使用。  它的初始作用，是为了方便科学家看文档、传论文。所以，到今天为止，学习前端的人在接触 HTML 的时候，都会记得它的第一句有个词是 Document。 这时候的互联网，无疑是处于原始社会的文明初创时期。  你的标点符号变了？OK，浏览器下载过一个新的页面； 你提交了一个表单？OK，浏览器白屏等待许久，最后返回给你个 “用户名错误”； 你电商网站有一千种商品？OK，那你写一千个页面吧……  这时候的互联网，它的开发者统称为程序员。因为前后端开发是一体的，前端代码是后端代码的一部分：后端收到浏览器的请求 ---> 发送静态页面 ---> 发送到浏览器。 3.2 石器时代 返回目录  就在同一年(1994 年)，PHP 出现了，有了将数据嵌入到 HTML 中的形式，这意味着互联网行业出现了钻木取火，不断朝石器时代发展。  这时候的互联网，兴起了数据嵌入模板，模板直接写样式的开发模式，例如 MVC 模式： Model（模型层）：提供/保存数据。 Controller（控制层）：数据处理，实现业务逻辑。 View（视图层）：展示数据，提供用户界面。  在此时，前端只是后端 MVC 中的 V，所以那时候的所谓 “前端工程师” 还没有对应的概念，前端开发人员都喜欢自称 “切图仔”。 后来，因为后端太忙，没空写页面样式让它长得更好看些，于是才有了前端编写页面模板后，让后端代码读取模板，替换变量，渲染出页面。  以 PHP 框架的 Laravel 为例： 用户提交请求 根据路由不同请求对应的 Laravel 控制器 控制器与模型交互 控制器调用结果页面 在用户浏览器上渲染页面  PHP 内嵌 HTML 代码片段： Car {{ $car->id }} Car {{ $car->id }} >Make: {{ $car->make }} Model: {{ $car->model }} Produced on: {{ $car->produced_on }} 相似的：PHP 直接将数据内嵌到 HTML 中。ASP 的 ASPX，在 HTML 中嵌入 C# 代码。Java 的 JSP 直接将数据嵌入到网页中。 3.3 铁器时代 返回目录  1995 年，网景推出了 JavaScript，形成了前端的雏形：HTML 为骨架，CSS 为外貌，JavaScript 为交互。 而到了 1998 年前后，Ajax（Asynchronous Javascript And XML：异步的 JavaScript 和 XML）得到了相对的应用，并且在之后逐渐被使用到各个页面上，从而促进了 Web 从 1.0 的静态网页，纯内容展示向 Web 2.0 模式迈进：  Web 2.0 时代：动态网页，富交互，前端数据处理  在 Ajax 的普及中，有三件事是值得一提的： 2004 年：Gmail 2005 年：Google 地图 2006 年：Ajax 被 W3C 正式纳入标准  这时候，前端不再是后端的模板，它可以独立得到各种数据。相对于 Web 1.0 的时代，Web 2.0 由石器时代迈向了铁器时代！  在 Web 2.0 的时代中，在 2006 年的时候，用于操作 DOM 的 jQuery 出现了，它快速地风靡了全球。大量的基于 jQuery 的插件构成了一个庞大的生态系统，从而稳固了 jQuery 作为 JS 库一哥的地位。 jQuery 的影响是源远流长的。即时到了今天，还是会有用 jQuery 一把梭、jQuery + gulp 的前端工程化的项目等……无它，唯方便而。 3.4 工业时代 返回目录  伴随着信息时代、大数据时代的到来，jQuery 在大量的数据操作中的弊端体现出来了，它在对 DOM 进行大量的操作中，会导致页面的加载缓慢等问题，这时，有些前端开发人员逐渐觉得力不从心了…… 2008 年，谷歌 V8 引擎发布，终结微软 IE 时代。 2009 年 AngularJS 诞生、Node诞生。 2011 年 React 诞生。 2014 年 Vue.js 诞生。  如果说，Angular、React、Vue 等 MVVM 模式的出现，以及 Webpack 的前端工程化构建，加速了数据驱动前端工程化的发展。那么，Node 这个基于 V8 引擎的服务端 JavaScript 运行环境的诞生，可媲美 Ajax 对于前端的贡献。  Node 是前端的第二次飞跃，它使 JS 在服务端语言中也有了一席之地。 何为 MVVM 模式？ Model：提供/保存数据。 View：视图 View-Model：简化的 Controller，唯一的作用就是为 View 提供处理好的数据，不含其它逻辑。  如今，后端负责数据，前端负责其余工作越发明显化。它们之间的通讯，只需要后端暴露 RESTful 接口，前端通过 Ajax，以 HTTP 协议与后端通信即可：  在这个前端的工业时代中，Vue、React、Angular 三大框架并驾齐驱。其他框架虽然也有在陆续发布，但是脱离不了这三大框架的魔爪。而这三大框架的 UI 框架来说，也涌现了不少地技术，例如桌面端的 Electron、NW.js；移动端的React Native、Weex 等。  以此同时，手机端的发展也是不可小觑的： 2007 年第一代 iPhone 发布。 2008 年第一台安卓手机发布。 ...... 2018 年 iPhone Xs Max 发布。  虽然，一开始的手机应用，是基于手机本地系统如 IOS、Android、WP，使用其原生程序进行编写的第三方应用程序 —— Native App 的天下。但是，随着 React Native、微信小程序等这类技术的发展，以及网速等的不断提升，Native App 逐渐被 Web App 所取代。  如今，多元化的前端框架使这门行业兴起了其独特的工业时代，诸多科技百花争放、百家争鸣。 四 技术比较 返回目录  没有最好的框架，只有最合适的应用场景。 在前端的开发工作开始之前，我们应该就不同的前端技术进行分析比较，从而更好、更流畅地进行编程开发。 4.1 JSP 与 jQuery 返回目录  就技术而言，JSP 与 jQuery 是天南地北的。但是，jsliang 个人觉得可以就内嵌 HTML 的形式与前后端分离的形式，对 JSP 与 jQuery 进行简要比较。这里的比较，仅仅因为工作中同时有涉及 JSP 与 jQuery，如有不实，望海纳指正。  关于 JSP 与 jQuery 的学习记录： Java Server Pages jQuery  何为 JSP？ JSP 全称 Java Server Page，是 Java 企业应用的一种动态技术。Java 和 JSP 是运行在服务器端的，也就是说他两运行的结果生成 HTML，HTML 是静态页面，而 JSP 是动态页面。  何为 jQuery？ jQuery 是一个轻量级的 JavaScript 库。jQuery 能够使用户的 HTML 页面 和 JS 内容分离，也就是说，jQuery 的使用，更有利于 HTML、CSS、JavaScript 三者的分离，使得前端代码得到更好的维护。  现在就相同功能进行 JSP 与 jQuery 代码比较： JSP 代码片段 ${user.userName} jQuery 代码片段 $(function() { // 通过 ajax 从 Java 接口获取数据 var data; $.ajax({ // ...请求地址、请求头及传参等 success: function(res){ data = res.data; // 拼接字符串，并渲染页面 var html = ''; $.each(data, function(index, item) { var html='' + item.userName + ''; html += html; }) html = '' + html + ''; } }) })  咋看之下，你会觉得：“啊，JSP 那么简单，用 JSP 好啊！” 是的，JSP 几行代码就能解决 jQuery 十几行代码才能解决的事，而且运行速度也快过 jQuery，为啥不一直用它呢？ 就项目发展而言。公司初创的时候，项目初期结构不繁杂的情况下，使用 JSP 无可厚非，因为它快、省事，而且还能节省人力（前后端让一个 Java 写就可以搞定了）。 但是，在项目越来越繁杂、庞大的情况下，一个 Java 已经维护不过来了，企业必须不停地增加 Java 开发人手。 同时，JSP 页面的增多，使得服务器渲染的工作量增加，对企业的服务器造成的压力也越来越大，而使用 Ajax 来渲染却可以将渲染的压力分摊到每个用户上……但是 Java 人员决定不了公司的技术决策，因此深陷技术债中……  然而，就好比喜欢锻炼的不全都喜欢跑步一样，并不是所有操作数据的 Java 都喜欢写页面的，这时候就凸显了几个问题： 项目越来越大，模块越来越多，需要投入的人手也越来越多，这时候需要分模块分人手地去维护。而且这些 Java 开发人员必须喜欢操作数据也喜欢编写页面，要不然企业将面临员工频繁流动的困扰。 用户开始对界面操作提更高的要求，需要增加更多的 JavaScript 互动和特效，无形中增加 Java 开发人员的工作量。 当有员工辞职后，下一名员工接手熟悉项目的时间将逐渐增加，由 1 天增长为 1 周甚至 1 个月。因为他不仅要熟悉数据的操作部分，更需要去维护 JavaScript 的页面互动。而这段时间，辞职员工的工作将施压到其他 Java 开发人员身上。  综上，这时候企业不得不考虑了：能不能帮 Java 开发人员减轻负担，更好地维护发展项目。 以此同时，JavaScript 经过时间的沉淀，越发凸显了它的强大。所以，在诸多因素之下，就有了前后端的分离：  后端人员提供接口，前端人员使用 jQuery 中封装好的 Ajax 调取接口获取数据，渲染到页面上。 4.2 jQuery 与 Vue 返回目录  在上面的 JSP 与 jQuery 的比较中，我们会发现一个问题，就是 jQuery 在数据操作上，它需要操作的步骤太多了。而且，频繁地操作 DOM。在数据量比较大的情况下，还会造成页面卡慢。 而这时候，就有了 MVVM 等 MV* 概念的提出： 何为 MVVM 模式？ Model：提供/保存数据。 View：视图。 View-Model：简化的 Controller，唯一的作用就是为 View 提供处理好的数据，不含其它逻辑。  简单来说，就是 MV 模式，将对数据的操作提升上去了。在 Vue、React、Angular 等 MV 框架中，可以通过对数据的操作，从而完成对页面数据的渲染。这里我们挑选简单、快速、紧凑而强大的 Vue，与 jQuery 进行比较。 index.html - jQuery jQuery 代码演示 第1条数据 第2条数据 添加数据 $(document).ready(function() { var i = 2; $('#add').click(function() { i++; //通过 DOM 操作在最后一个li元素后手动添加一个标签 $(\"#list\").children(\"li\").last().append(\"第\" + i + \"条数据\"); }); }); index.html - Vue Vue 代码演示 {{item}} 添加数据 new Vue({ el: \"#app\", data: { message: [\"第1条数据\", \"第2条数据\"], i: 2 }, methods:{ //向数组添加一条数据即可 add:function(){ this.i++; this.message.push(\"第\" + this.i + \"条数据\"); } } })  上面的例子，对这两者进行了简单的比较与区分。虽然只是一个简单的说明，但是在实际中，Vue 能解决的问题远比上面的要多的多，复杂的多。 但是，对 jQuery 与 Vue 进行比较，是推崇 Vue，建议全面废弃 jQuery 吗？并不是。 Vue 适用的场景：复杂数据操作的后台页面，表单填写页面。 jQuery 适用的场景：比如说一些 HTML5 的动画页面，一些需要 JavaScript 来操作页面样式的页面。  正应了那句话：“没有最好的框架，只有更适合的应用”。 我们应该根据项目的需求，对技术进行不同的选取。就好比在公众号的 H5 页面上，jsliang 就很喜欢用 jQuery 进行操作，因为它简单粗暴好操作，在动画效果的编写上也不错；而在使用 Echarts 进行报表演示的开发中，我更喜欢使用 Vue，因为它能很简易地对后端传回的大量数据进行操作。 4.3 Vue 与 小程序 返回目录  开篇点题；深入学习过 Vue 开发的，那么在微信小程序、React、Angular 等框架的开发上也不会太差。  为什么这么说呢？因为它们都是基于 MV* 模式的一些现代前端框架。拿其中的 Vue 与 微信小程序 进行一些简单区别： 生命周期/钩子函数不同，微信小程序的钩子函数要简单地多。 请求数据方面，Vue 会在 created 或者 mounted 中请求数据，而微信小程序会在 onLoad 和 onSow 中请求数据。 等等……  往往很多时候，我们会觉得它们是有很多地方是相同的。 所以，对于 Vue、React、Angular、微信小程序等 MV* 模式的前端框架，如果非得进行区分比较的话，我们应该就框架的使用场景、团队技术能力、框架优劣势、生态系统等方面去分析它们，并区分它们的适用场景： Vue：简单易学，灵活轻便。相对于 React 和 Angular 来说，它的学习成本低，适合快速上手，且学习曲线比较平缓。 React：灵活性很高，生态圈强大。相对于 Vue 来说，React 在数据操作方面更灵动；相对于 Angular 来说，它的学习成本更低。 Angular：完整的框架体系。相对于 React 和 Vue，它是一个成熟完善的框架。 微信小程序：简单轻便。相对于 Vue 来说，它更加便捷了，而且微信小程序有上传的代码大小限制，使得微信小程序是真的 “小”。而且微信小程序结合微信，提供了很多 API 供开发人员使用。  因此，前端团队在项目开发前，可以就项目涉及领域进行探讨： 假如你想快速开发一个成本低的小应用，可以考虑 Vue。 假如你想开发一个大型应用，可以考虑 Angular。 假如你想开发一个跨平台应用，可以考虑 React。  事无绝对，这里仅为本人观点，实际技术选用应结合团队意见，从而找到最适合该项目的技术。 就 jsliang 本人的开发体验来说：2018 年 4 月份的毕业设计使用了 Vue 进行开发，然后相隔半年进行了微信小程序开发，发觉小程序开发比起 Vue 而言是更轻松便捷的，因为它封装了很多 API 供开发人员使用，并且它有专门的提 Bug 社区。 五 思考总结 返回目录  没有最好的框架，只有最合适的应用场景。  希望小伙伴们在面临不同的项目时，可以选择到最合适的框架，从而减少开发工作量，降低开发难度。  最后的最后，我们再谈谈前端的未来发展及前端职业未来： 前端会继续分化。例如，喜欢 CSS 图形化的，将更深入地学习 UI 与 CSS 3D 等，进行更炫酷的布局；喜欢 JavaScript 的，将更深入地学习数据的操作，实现更复杂地业务、更有趣的用户体验。 前端会继续融合。例如，Vue、React、Angular 合并，实现大一统，结束三分天下的局面。 前端将更加丰富。例如，PC、Mobile、IPad 等的体验更加丰富，不同的平台实现不同的功能。  所以，抓住机遇，不断折腾，创造更好的前端吧！ 六 解疑释惑 返回目录 quesiton 1 问：为什么 Vue 不建议用于开发大型项目？ 答：  首先，这里讨论的 Vue，建议用于开发中小型页面，但是 Vue 是可以开发大型项目的。 然后，Vue 本身是个轻量级框架，开发中小页面应用是挺好的，但是开发大型应用尤其是涉及大量表单交互的地方，React 和 Angular 就比较合适了。 最后，大型项目的配置较多，而 React 相对于 Vue 来说更加灵活，所以在有对比的情况下，不推荐你使用 Vue 开发大型项目。  Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更丰富文章的动力！GitHub 地址 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/shortArticle/VisualStudioCode/vscode.html":{"url":"other-library/shortArticle/VisualStudioCode/vscode.html","title":"VSCode 常用操作和配置","keywords":"","body":"VSCode 常用操作和配置 create by jsliang on 2018-09-04 11:26:11Recently revised in 2018-11-30 10:01:01 第一节 VSCode配置  配置方式： 主菜单 -> 文件 -> 首选项 -> 用户设置： { \"editor.wordSeparators\": \"./\\\\()\\\"':,.;<>~!@#$%^&*|+=[]{}`~?\", \"git.autofetch\": true, \"markdown.styles\": [ \"E:\\\\MyWeb\\\\jsliang-study\\\\Document-Library\\\\public-repertory\\\\css\\\\markdown-github.css\" ], \"file.exclude\": { \"node_modules/\": true } } 1.1 下划线选中  设置不仅可以下划线选中，而且可以横杠选中，主要应用于同事写 class 名或者 id 名或者写 js 起名的时候，有可能用 - 或者 _ 。 { \"editor.wordSeparators\": \"./\\\\()\\\"':,.;<>~!@#$%^&*|+=[]{}`~?\" } 1.2 监听 git fetch  git fetch 命令用于从另一个存储库下载对象和引用，在 vs code 中配置 git.fetch 功能，从而启动自动提取。当然一般不会有问题，但是在环境中使用tar压缩源码时，vs code后台会来 git fetch 导致压缩失败，可以视情况关闭 { \"git.autofetch\": true, } 1.3 配置 Markdown 预览的样式  如果是VS Code默认的配置，Markdown 文件是乌漆嘛黑的，这时候可以给它设置个 GitHub 样式，这样子预览看到的就是 GitHub 中的样式，详情可看：点击跳往 { \"markdown.styles\": [ \"E:\\\\MyWeb\\\\jsliang-study\\\\Document-Library\\\\public-repertory\\\\css\\\\markdown-github.css\" ], } 1.4 忽略 node_modules 文件夹  设置这个，vs code 就不会理会 node_modules 文件夹了。详情可看：点击跳往 { \"file.exclude\": { \"node_modules/\": true } } 1.5 VS Code 设置模板页 安装插件 HTML Snippets 文件-首选项-用户代码片段-HTML 修改文件内容为： { // Place your snippets for html here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the // same ids are connected. // Example: // \"Print to console\": { // \"prefix\": \"log\", // \"body\": [ // \"console.log('$1');\", // \"$2\" // ], // \"description\": \"Log output to console\" // } \"!!\": { \"prefix\": \"!!\", \"body\": [ \"\", \"\", \"\", \"\\t\", \"\\t\", \"\\t\", \"\\tHelloWorld\", \"\", \"\", \"\\t$1\", \"\\t\", \"\\t\", \"\", \"\" ], \"description\": \"!! - Defines a template for a html5 document\" } } 在HTML页面输入!!然后回车，即可看到新效果 第二节 插件推荐 Prettier - Code formatter：格式化代码 Vetur - 管理好你的 Vue 代码 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/SQL/MySQL.html":{"url":"other-library/SQL/MySQL.html","title":"MySQL","keywords":"","body":"MySQL Create by jsliang on 2018-12-13 08:49:41Recently revised in 2018-12-14 08:45:24  一切的折腾，均要有个度。并且，明白自己折腾的目的。 一 目录  不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 下载 四 安装 五 总结 二 前言 返回目录  MySQL 是什么呢？MySQL 是最流行的关系数据库管理系统之一，体积小、速度快、总体成本低的缘故导致中小型网站的开发都乐意选用 MySQL。 Long long ago，jsliang 曾跟随大学老师，学习过 SQLserver，那时候的 SQL，纯粹是用 SQL 语句建表，各种秀……后来，为了应付毕设，囫囵吞枣，学习了 MongoDB，用 Express 连接它进行各种操作。当然，关系型数据库和非关系型数据库的区别将我折腾地体无完肤。 最近要学习 Node 基础，思来想去考虑一番，还是打算连接 MySQL，无他，因为正经学过关系型数据库而已。 三 下载 返回目录  在这里，咱是用 Window 系统进行的下载安装，各位看官如果是用 Mac 或者其他，请看： Window 安装 MySQL 全攻略 | 博客园 - Smile_Coding Linux 安装 MySQL | 百度经验  如果上面两篇都无法满足大佬需求，请自行百度或者 google。  那么下面开始安装： 直接打开 MySQL 下载页面：地址 选择系统 Windows 点击下载 MSI 安装包  然后，它会弹出窗口告诉你，需要登录或者注册：  jsliang 没有自己的账号，所以需要注册，但是点开注册页面，发现自己又不想注册了（太多账号了！不想再搞事情了），所以咱直接下载比较旧的版本吧： MySQL 版本5.7 MSI 安装包 最新版本是 8.0.13  双击打开，点击一系列确认后（Windows 10 安全机制会弹窗），弹出安装界面： 四 安装 返回目录  那么现在开始正式安装，除了这里贴出的需要注意的地方，大致一路 Next 下去就 OK 了。 主要安装需要注意的地方为前 4 个步骤，请小伙伴们注意。 在 Account and Roles 这块地方，它会询问到 MySQL Root Password 以及 Repeat Password，就是让你设置根数据库的登录密码，所以设置个比较容易记的密码并记到手机或者笔记吧。 比较容易记是怕小伙伴忘记，如果你的数据库非常值钱，还是搞个复杂的吧~ 在 Connect To Server 这部分，它会提示你设置用户和密码，这里的 User：root 是它默认给的，如果没其他需要，那就按它这个不动就行了，然后输入第 1 步中的密码，点击 Next 即可。 这一步需要重新输入一次账号密码，然后点击红框中的 Check，报绿了点 Next 即可。 到了 Install Complete 这一步，表明你已经搞定地 7788 了，点 Finish 结束安装。 在第 4 步点击 Finish 后，它会弹出一个窗口，这里还不需要管它是啥，点击 × 关闭即可。 键盘按 Win 键或者直接用鼠标点开 开始菜单，会看到它提示我们最近安装了个 MySQL，如果是 win7，应该也可以找到下面这个，点击打开它。 在第 6 步点击后，它会弹个小黑框，让你先输入密码，密码正确后，你就可以使用 MySQL 了。如果是初次学习的 SQL，推荐去学习下 SQL 命令，照着黑窗口多敲两句 SQL 语句。 MySQL 的小黑框虽然有些装逼，但是现在是什么年代，操作个数据库还要敲大量 SQL 语句，对 jsliang 这前端人员来说，这太难以接受了，还是安装个 图形化工具 吧： navicat premium 64位 v12 特别版  首先，打开上面的网址。  然后，将页面拉到下面，选择下图红框中的任一地址下载。  接着，进行安装破解： 解压文件夹，安装原版程序。 不要运行程序！！！不要运行程序！！！不要运行程序！！！重要的事情说三遍，因为破解前运行了程序会导致破解冲突。 根据 txt 的解说，将补丁安装到对应目录。 运行补丁程序，打补丁 操作成功！ 打开这个图形化工具，点击 文件 -> 新建连接 -> MySQL： 输入前面步骤提到的账号密码，点击 确定： 这时候可以看到我们的 root 数据库打开了，大功告成： 五 总结 返回目录  在这篇文章中，我们提到了 MySQL 的下载、安装以及图形化工具的安装。 有些小伙伴对这些安装的感到最烦躁，因为这也要安装，那也要安装的，实在太烦了。 但是这又是必要的步骤，只有前面的搭建好了，后面我们进行 Node 连接 MySQL 数据库就轻便多了。 不折腾的前端，和咸鱼有什么区别！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Website/":{"url":"other-library/Website/","title":"网站","keywords":"","body":"个人网站 Create by jsliang on 2018-10-25 15:13:31Recently revised in 2018-12-22 18:10:44 目录 目录 介绍 Blog 打造个人博客 BuildStation 使用云服务器搭建自己的网站 GitHubPages 快速打造一个静态网站 ShoppingMall 打造一个商城 jsliang.top 目录 介绍 jsliang.top jsliang 的网站列表 cv.jsliang.top 通过 ECharts + Vue 打造个人线上简历 playregex.jsliang.top 通过游戏来了解正则表达式 lucky.jsliang.top 悠闲刮刮乐，仅供娱乐 deadline.jsliang.top jsliang 的工作时间轴 webpack.jsliang.top Webpack 学习成果，Webpack 多页面配置 game.jsliang.top 一个小游戏，只兼容 PC，适配移动端失败 company.jsliang.top Node 打造企业网站，支持注册、登录及留言 work.jsliang.top jsliang 工作成果，给领导或者工作小伙伴查看 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Website/Blog/":{"url":"other-library/Website/Blog/","title":"网站 - Vue + Node + MongoDB 演练","keywords":"","body":"Vue + Node + MongoDB 演练 create by jsliang on 2018-10-16 21:26:19Recently revised in 2018-10-28 12:05:43 目录 目录名 链接 笔记 链接 写在前面  为什么会写这个？ jQuery 写腻了，小程序实操过一遍了。公司追求效益，前端没时间学习新技术跟潮流。最重要的是，上头太难相处，工资太低了( 5.5K )，想挪窝了。咳咳，前面的你们看错了，它的意思是：不折腾的前端不是好前端~ 想看看自己是否退步了，毕业设计就是用 Vue + Node + MongoDB 走了一遍。六个月过了，尚能码否？ 想更进一步，通过研究 Vue 源码，再转战 React，来日获得更高的技术栈。 计划  在 2019/02/05 (春节)前： get 到三套 Vue + Node + MongoDB 的技术点，并仿出三个类似于其视频内容的 Demo。 看两遍 Vue 源码，写一篇自己通彻的文章(不追求其他人是否能懂，首先要自己能清楚)。 再研究一下设计模式( es6 版 )。 准备面试技巧。 寄语  成功了，这就是个故事； 失败了，这就是个笑话。 打卡  每天打卡，剩余 112 天： 2018-10-16 21:37:48 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Website/Blog/note.html":{"url":"other-library/Website/Blog/note.html","title":"网站 - Vue + Node + MongoDB 学习笔记","keywords":"","body":"Vue + Node + MongoDB 学习笔记 create by jsliang on 2018-10-16 21:48:25Recently revised in 2018-10-28 12:05:20 目录 章节 第一章 印象 第二章 基础语法 第三章 路由 第四章 Axios 第五章 ES6 奇技淫巧 第六章 杂碎 第一章 印象 返回目录 Vue 是一个灵活的、渐进式框架：声明式渲染 -> 组件系统 -> 客户端路由 -> 大规模状态管理 -> 构建工具 Vue 区别于 jQuery： 数据驱动。不同于 jQuery 的命令式操作，不需要大规模对 DOM 节点的更新替换，Vue 更专注于数据层，通过数据层的改变，来渲染页面。   View(DOM) ViewModule(Vue) Model(POJO - 原生JS对象) 组件化。在 jQuery 中，一些业务逻辑不能更好的提取出来。而 Vue 可以对一些常用的功能模块进行抽取，形成组件：例如购物车、登录。 Vue 如何实现双向数据绑定的关键： Object.defineProperty 的 get 和 set 方法。案例可以找： E:\\学习资料\\实战\\Vue+Node+Mongodb\\第1章课程介绍\\1.3vue概括核心思想.wmv Vue 双向数据绑定实现 var obj = {}; Object.defineProperty(obj, \"userName\", { get: function() { console.log(\"get init\"); }, set: function(val) { console.log(\"set init\"); document.getElementById(\"uName\").innerText = val; document.getElementById(\"userName\").value = val; } }); document.getElementById(\"userName\").addEventListener(\"keyup\", function(event){ obj.userName = event.target.value; }) 通过 vue-cli 搭建的环境，是 SPA 单页应用。 如果需要使用 Vue 搭建多页面应用，需要通过 标签引用 Vue，或者配置 Webpack 来开发 Vue 的多页面应用。 通过 vue-cli 构建 SPA 应用： 全局安装 vue-cli ：npm i vue-cli -g 简洁生成：vue init webpack-simple demo || 完整生成：vue init webpack demo2 安装依赖：cnpm i 第二章 基础语法 返回目录 模板语法 Mustache 语法： {{ msg }} HTML 赋值：v-html = \"\" 绑定属性：v-bind:id= \"\" 使用表达式：{{ ok ? 'yes' : 'no' }} 文本赋值：v-text = \"\" 指令：v-if = \"\" 过滤器： {{ message || capitalize }} 和 v-bind:id = \" rawId | fromatId \" Class 和 Style 绑定 对象语法：v-bind:class=\"{ 'active':isActive, 'text-danger':hasError }\" 数组语法： data: { activeClass: 'active', errorClass: 'text-danger' } style 绑定-对象语法：v-bind:style = \"{ color: activeColor, fontSize: fontSize + 'px' }\" 条件渲染 v-if：v-if 判断，如果否，则连 DOM 节点都不产出。 v-else：相反于 v-if。 v-else-if：v-if 的多种判断情况。 v-show：不同于 v-if，该条件渲染产生了 DOM 节点，它只是控制 DOM 的显示隐藏，有则 display: block，无则 display: none。 v-cloak： Vue 事件处理器 v-on:click = \"greet\" 或者 @click = \"greet\" v-on:click.stop、v-on:click.stop.prevent、v-on:click.self、v-on:click.once v-on:keyup.enter Vue 组件 全局组件和局部组件 父子组件通讯-数据传递 Slot 第三章 路由 返回目录 什么是前端路由？它有什么作用？  路由时根据不同 url 地址 展示不同的内容或页面。 前端路由就是把不同路由对应的不同内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。 什么时候使用前端路由？  在单页面应用，大部分页面结构不变，只改变部分内容的使用。 前端路由有什么优缺点？  优点： 用户体验好，不需要每次都从服务器全部获取，可以快速展现给用户  缺点： 不利于 SEO 使用浏览器的前进，后退键会重新发送请求，没有合理地利用缓存 单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置 vue 使用 vue-router 来构建 SPA 使用 或者 this.$router.push({path: ''}) 使用 什么是动态路由？ 模式 匹配路径 $route.params /user/:username /user/evan { username: 'evan' } /user/:username/post/:post_id /user/evan/post/123 { username: 'evan', post_id: 123 } 什么是嵌套路由？  一级路由下还有二级路由，通过 children 来定义。 什么是编程式路由？  通过 js 来实现页面的跳转。 $router.push(\"name\") $router.push({path: \"name\"}) $router.push({path: \"name?a=123\"}) 或者 $router.push({path: \"name\", query: {a:123}}) $router.go(-1) 什么是命名路由和命名视图  给路由定义不同的名字，根据名字进行匹配。 给不同的 router-view 定义名字，通过名字进行对应组件的渲染。 第四章 Axios 返回目录  安装方式： npm i axios  方法： axios.request(config) axios.get(url[,config]) axios.delete(url[,config]) axios.head(url[,config]) axios.options(url[,config]) axios.post(url[,config]) axios.put(url[,config]) axios.patch(url[,config]) 第五章 ES6 奇技淫巧 返回目录 函数与循环  旧姿势 function sum(x, y, z) { var total = 0; if(x) { total += x; } if(y) { total += y; } if(z) { total += z; } console.log(total); } sum(1, 3, 5);  新姿势 function sum(...m) { let total = 0; for(var i of m) { total += i; } console.log(total); } sum(4, 8, 9, 10);  更新姿势 let sum = (...m) => { let total = 0; for(var i of m) { total += i; } console.log(total); } sum(1, 3, 5, 7); 数组  数组添加数组  旧姿势 let arr1 = [4, 8]; let arr2 = [1, 3]; arr1.concat(...arr2); console.log(arr1);  新姿势 let arr1 = [{ name: jsliang, age: 23 }, { name: JavaScriptLiang, age: 23 }]; let arr2 = [{ name: JavaLiang, age: 23 }, { name: LiangJs, age: 23 }]; arr1.push(...arr2); console.log(arr1);  更新姿势 let arr1 = [{ name: jsliang, age: 23 }, { name: JavaScriptLiang, age: 23 }]; let arr2 = [{ name: JavaLiang, age: 23 }, { name: LiangJs, age: 23 }]; let arr3 = [...arr1, ...arr2]; console.log(arr3); 数组  如果有一个数组，开头固定，其他不固定： var [x, ...y] = [4, 5, 6, 7]; console.log(y); // 5, 6, 7 let [a, b, c] = \"ES6\"; // a=E, b=S, c=6 let xyz = [...'es6']; // xyz=['e', 's', '6'] Promise // api.js const fetch = ({ url, data, header }) => { return new Promise((resolve, reject) => { axios.post({ ... success: res => { }, error: res => { } }) }) }; export const login = data => { return fetch({ url: '...', data: data }) }; // 调用 api.js import { login } from './api.js'; login({ userName: '', userPhone: '' }).then( (res) => { })  如果有多个 Promise ，则： Promise.all([checkLogin(), getUserInfo()]).then( ([loginres, getinfores]) => { }) export 与 import a.js export let sum1 = (x, y) => { return x + y; } export let sum2 = (x, y, z) => { return x + y + z; } b.js import { sum1, sum2 } from './a.js'; console.log(sum1(1, 2)); console.log(sum2(1, 2, 3)); // 或者 import * as a from './a.js'; console.log(a.sum1); console.log(a.sum2); 第六章 杂碎 返回目录  npm 工具 vue-lazyload jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-21 10:29:27 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Website/BuildStation/":{"url":"other-library/Website/BuildStation/","title":"云服务器建站","keywords":"","body":"云服务器建站 Create by jsliang on 2018-12-21 13:34:13Recently revised in 2018-12-23 11:59:40  Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更精彩文章的动力！GitHub 地址  本篇文章重点： 云服务器购买及使用 域名购买、备案及解析 Nginx 配置多个二级域名及解析网页 Node 服务端的部署及 MySQL 的安装  最终效果： 目录 介绍 jsliang.top jsliang 的网站列表 cv.jsliang.top 通过 ECharts + Vue 打造个人线上简历 playregex.jsliang.top 通过游戏来了解正则表达式 lucky.jsliang.top 悠闲刮刮乐，仅供娱乐 deadline.jsliang.top jsliang 的工作时间轴 webpack.jsliang.top Webpack 学习成果，Webpack 多页面配置 game.jsliang.top 一个小游戏，只兼容 PC，适配移动端失败 company.jsliang.top Node 打造企业网站，支持注册、登录及留言 work.jsliang.top jsliang 工作成果，给领导或者工作小伙伴查看 一 目录  不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 云服务器及域名  3.1 云服务器  3.2 域名 四 Nginx 代理前端页面 五 MySQL 安装及部署 六 Node 提供接口服务 七 总结 二 前言 返回目录  作为一枚程序猿， 第一句编程必须是 Hello World!， 第一个愿望必须是 My Blog， 如果不是，当我没说。  关于云服务器： 作为一枚能 “折腾” (能作死) 的人，jsliang 玩过腾讯云服务器和阿里云服务器。 腾讯云服务器。如果你是大学生，那么腾讯云不可错过，[云+校园]学生云服务器体验套餐 10 元/月。这个活动，其实一开始的价格是 1元/月，1 年也就 12 元，一餐饭的价格都不到，jsliang 用了两年，直至 jsliang 毕业。后来，enm... 你知道的，变成了 10 元/月，腾讯云的意图我就不猜了，一年就是 120 元，云服务器配置是 1 核 2 G + 1 M带宽，对于初学者来说，完全够用了。 阿里云服务器。jsliang 目前正在使用的服务器就是云服务器。也许有的小伙伴们应该了解过云服务器，也知道在双 11 双 12 的时候，不仅有疯狂的淘宝购物，还有阿里云服务器的推送，说不定小伙伴已经买了一台给自己了，但是一直没用上。  如果小伙伴需要订购云服务器来存放像 jsliang 个人网站类的静态或者有 Node 后端的网页，但却不知道怎么选择，可以加 jsliang QQ：1741020489 咨询，下面是一些优惠推广：  腾讯云推广：  新用户点这里： 新客户无门槛 2775 元代金券  购买云服务器： 12 月优惠低至 168 元/年  阿里云推广：  新用户点这里： 新用户云产品 1888 通用代金券  购买云服务器： 高性能云服务器 - 低至 293元/年  购买企业级云服务器： 企业级高性能云服务器 三 云服务器及域名 返回目录  云服务器和域名都是需要备案的：阿里云备案管理 小伙伴可以通过上面链接了解下备案相关知识。 3.1 云服务器 返回目录  如果你已经通过上面推送购买了云服务器，或者你本身就有云服务器，那么我们开始讲解下 jsliang 对云服务器的使用：  我们了解下在哪里可以看到自己的云服务器： 在阿里云首页点击控制台。 点击左侧展开侧边栏，点击云服务器 ECS。 点击实例，选择云服务器所在地区，便出现了自己买的云服务器实例。  我们需要记住有五大块： IP 地址。IP 地址 可以让你通过 Win + R，输入 mstsc 后，在远程桌面中，通过输入公网地址以及密码，访问你的云服务器，方法详情。 远程连接。远程连接 可以直接通过网页的形式连接云服务器，对它进行操作。 实例状态。更多 -> 实例状态 可以停止、开启、重启云服务器。 磁盘和镜像。 如果你感觉 Windows 云服务器满足不了你了，或者你想更换 Windows 系统的其他版本，那么你可以通过 更多 -> 磁盘和镜像 -> 更换系统盘 来更换系统（请先在实例状态中停止云服务器）。方法详情 如果你觉得你的云服务器爆满了，想重新折腾过，那么可以通过 更多 -> 磁盘和镜像 -> 重新初始化磁盘 进行服务器的重置。方法详情 网路和安全组。点击 更多 -> 网路和安全组 -> 安全组配置 -> 配置规则 -> 添加安全组规则，从而添加 80 端口的安全组。方法详情 这里我们讲解的是 Windows 系统对 Windows 云服务器的操作，因为 Windows 系统方便操作，所以有着其他系统的云服务器的小伙伴，可以考虑将云服务器改成 Windows 系统，或者百度、google 查找其他云服务器的部署方式。  现在，我们讲解了云服务器的基本操作，我们暂且将云服务器这块内容先放一边，讲解下域名部分。 3.2 域名 返回目录  在你使用域名之前，记得给域名备个案；阿里云备案管理 如果你没有域名，可自行购买：万网域名注册  现在我们进入域名控制台：  除了备案，其他的都不用理会了，我们直接点击解析：  上面的图片中显示的，都是 jsliang 在 jsliang.top 进行的解析记录。其中： 主机记录：二级域名开头，例如 company 对应的就是 http://company.jsliang.top 这个二级域名。 记录值：就是小伙伴云服务器的公网地址，在上面章节中提到过云服务器的 IP 地址。这是个很重要的玩意，请勿泄露。  很好，现在我们点击 添加记录：  我们只需要填上 主机记录 以及 记录值，然后点击 确定 就可以完成一条二级域名的添加了。 下面会讲解到如何通过云服务器的 Nginx 配置，使二级域名导向服务器中的指定目录。 四 Nginx 代理前端页面 返回目录 为了保证小伙伴们尽可能地实施顺利，jsliang 对自己的云服务器进行了 重新磁盘化磁盘 的操作，从而减少中间出篓子的可能。  现在我们开始配置 Nginx。 首先，远程连接我们的云服务器。操作方法 云服务器配置：云服务器操作系统：Windows Server 2008 R2 企业版 64位中文版开放端口：80、-1、22、3389  然后，我们打开 C 盘，创建这几个目录： WebFrontEnd：存放前端文件位置 WebBackEnd：存放后端文件位置 Nginx：存放 Nginx 安装目录以及配置 Node：存放 Node 安装位置 MySQL：存放 MySQL 安装位置  然后，我们进行 Nginx 的安装及配置： Nginx 下载 由于云服务器浏览器时 IE，enm...所以我们本地直接下载吧！PS：可能这也是我为什么用 Windows 的原因，因为方便复制本机内容粘贴到云服务器上去。  我们下载稳定版本，即 nginx/Windows-1.42.2，它会弹窗让你下载 zip 包，我们先在本机解压配置好，最后再复制到云服务器上的 Nginx 文件目录中。  接着，我们进行 Nginx 的配置解析，先在本地熟悉下目录。  在这里，我们要先了解到：Nginx/conf/nginx.conf 是我们要修改的配置，而 vhost 是我们要新建的目录，目录下就是我们二级域名配置文件，例如 compony.jsliang.top 对应的就是 company_jsliang.conf 文件。  然后，我们打开文件 Nginx/conf/nginx.conf 进行配置，配置的文件已有注释，故这里不再哆嗦： Nginx/conf/nginx.conf #user nobody; # 跟 CPU 有关，不用修改 worker_processes 1; events { # nginx 最大负载量 worker_connections 1024; } http { # mime type 映射 include mime.types; default_type application/octet-stream; # 启动高效传输文件的模式 sendfile on; # 长连接 timeout keepalive_timeout 65; # http 结构下可以有多个 server。请求进来后，确定哪一个 server 由server_name 决定，这里我们通过 include **文件 来进行多网址配置 server { # 监听端口 listen 80 default_server; # 识别的域名 server_name localhost default_server; # 一个关键配置，与 URL 参数乱码问题有关 #charset utf-8; root html; # 监听的文件 location / { index index.html index.htm; } # 404页面 # error_page 404 /404.html; # 重定向端口错误页面到50*.html页面 error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } # 把其他 server 配置写到其他文件，方便管理 include ../vhost/*.conf; }  在上面，我们通过最后一句话 include ../vhost/*.conf 可以知道，我们将配置文件放到了 vhost 目录中，从而方便我们下次新增二级域名。  如果小伙伴希望多了解点 Nginx 的知识，可以看下下面的文章。 如果小伙伴们单纯就想快点部署完，请跳过这段话。 Nginx 多域名配置 worker_processes：进程数（1） worker_connections：最大负载量（1024） sendfile：启动高效传输文件的模式（on） keepalive_timeout：长连接（65） include：（mime.types） proxy_pass：要转发的地址（http://www.a.com:3000）  再接着，我们在 Nginx 目录下新建 vhost 目录，然后新增 company_jsliang.conf、work_jsliang.conf ……等目录，命名不重要，好记且它是 *.conf 就行。 *.conf server { # 监听的端口，80 即可 listen 80; # 监听的网址，这里填写你的网址，我的就有 company.jsliang.top 等……请确保该域名已经在阿里云、腾讯云、百度云等进行了域名解析。 server_name company.jsliang.top; # 监听的目录 root C:\\WebFrontEnd\\company; # 监听的文件 location / { index index.html index.htm; } }  看到这个，小伙伴们可能就明白了：当我们访问 company.jsliang.top 时，Nginx 就会监听我们在 C 盘下 C:\\WebFrontEnd\\company 目录下的 index 或者 index.html 或者 index.htm。 当小伙伴们回想起我们在域名解析时的操作时，会更加清晰： 域名解析到公网 IP -> Nginx 监听到了来自浏览器的请求 -> Nginx 查找关于这个请求的配置 -> Nginx 找到这个配置，发现应该定位到 ** 目录 -> Nginx 将信息返回给浏览器。  配置完成后，我们将文件复制并替换到云服务器上去。 记得在 WebFrontEnd 上存放你的前端网页文件喔，要不然最后运行 Nginx 你会发现好像没成功一样~  再然后，我们进入目录 C:\\Windows\\System32\\drivers\\etc，修改下 hosts 配置并保存： hosts # Copyright (c) 1993-2009 Microsoft Corp. # # This is a sample HOSTS file used by Microsoft TCP/IP for Windows. # # This file contains the mappings of IP addresses to host names. Each # entry should be kept on an individual line. The IP address should # be placed in the first column followed by the corresponding host name. # The IP address and the host name should be separated by at least one # space. # # Additionally, comments (such as these) may be inserted on individual # lines or following the machine name denoted by a '#' symbol. # # For example: # # 102.54.94.97 rhino.acme.com # source server # 38.25.63.10 x.acme.com # x client host # localhost name resolution is handled within DNS itself. # 127.0.0.1 localhost # ::1 localhost 127.0.0.1 jsliang.top 127.0.0.1 company.jsliang.top 127.0.0.1 cv.jsliang.top 127.0.0.1 deadline.jsliang.top 127.0.0.1 game.jsliang.top 127.0.0.1 lucky.jsliang.top 127.0.0.1 playregex.top 127.0.0.1 webpack.jsliang.top 127.0.0.1 work.jsliang.top  最后，我们再双击 Nginx 目录中的 nginx.exe，运行 Nginx。 这时候，有的小伙伴可能发现有一个小框一闪而过，然后以为没打开成功？别急，打开 Windows 任务管理器你会发现它已成功运行了。 如果小伙伴要新增一个二级域名，那就需要去 Windows 任务管理器将 Nginx 的两个进程结束，新增完毕后再重启 Nginx。  这时候，我们打开 company.jsliang.top 进行查看，发现它已成功部署啦：  后记，附上我学习 Nginx 时的其他参考： Nginx中文文档 Nginx 在 Windows 上安装及 Nginx 的配置及优化 Nginx 基本配置与参数说明 五 MySQL 安装及部署 返回目录  关于 MySQL 的安装，我在另一篇文章中有记录： MySQL 的安装及配置  现在，我们直接在本地下载安装包，下载完后直接复制到云服务器上，按照教程一步一步配置即可。 六 Node 提供接口服务 返回目录  首先，我们下载 Node 的 msi 安装包，并复制到云服务器上：下载地址  在这里要注意的是，我们下载的是 64 位的 msi 安装包，因为在上面的 Nginx 配置的时候，我们讲过我们的云服务器是 Windows Server 2008 R2 企业版 64位中文版。  我们只需要一路 Next，在配置安装位置的时候，将位置放在我们建好的 Node 目录中即可。  然后，我们通过 win + r -> cmd -> cd C:\\WebBackEnd -> node -v 查看我们的 Node 版本，jsliang 这里显示的是 v10.14.2，表明我们安装成功了。。  接着，我们将我们的 Node 代码复制到 WebBackEnd/NodeBase 目录中，同时控制台 cd 到这个目录：cd NodeBase，然后 npm i 安装依赖包，并 node index.js 从而开启项目。  最后，因为我们 Node 项目开启的是 8888 端口，所以我们需要在云服务器的配置规则上配置好 8888 端口：方法详情  至此，我们的 Node 配置完毕并成功开启，如果小伙伴们想知道 Node 如何连接 MySQL、Node 如何使用、cnpm 以及 pm2 是什么，请查看 Node 基础。 记得 npm i 安装项目依赖包以及配置云服务器中相关的端口喔~ 七 总结 返回目录  经过一系列的折腾，我们的云服务器终于配置完毕了，接下来就可以愉快玩耍啦~ 当然，如果小伙伴嫌自己配置麻烦，可以去阿里云的云服务器市场看看有没有装好的 Node + MySQL 环境喔~  最后叨一句：需要购买云服务器的小伙伴可以咨询我 QQ 1741020489 哈~ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Website/GithubPages/DocumentLibrary.html":{"url":"other-library/Website/GithubPages/DocumentLibrary.html","title":"使用 GitHub Pages 和 VuePress 搭建网站","keywords":"","body":"使用 GitHub Pages 和 VuePress 搭建网站 Create by jsliang on 2018-10-20 10:34:39Recently revised in 2018-10-24 13:54:52  Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址  本文教你如何利用 GitHub 平台搭建自己的博客/文档库。 如果，你的目的仅仅是想了解如何配置。那么，你应该在看完 第三章 基础配置 后，就可以自己去写自己的博客/文档库，遇到不懂的问题，可以自己翻阅 VuePress 文档，解决你所需要解决的问题。 如果，你的目的是具体查找某组件：例如导航条、例如侧边栏的配置。那么，你可以直接查找目录，跳到对应章节进行阅读。  参考文档： 参考地址：GitHub Pages 参考地址：VuePress 中文网  目前效果： 一 目录 目录名 一 目录 二 前言 三 基础配置  3.1 搭建 GitHub Pages  3.2 搭建 VuePress   3.2.1 目录讲解   3.2.2 导航栏   3.2.3 侧边栏   3.2.4 默认首页 四 VuePress 进阶  4.1 修改样式 二 前言 返回目录  一般的网站，大体由三部分组成：域名、服务器部署环境以及部署代码。 GitHub Pages，由 GitHub 网站服务，为众多 GitHub 用户提供了良好的服务器部署环境以及域名的好工具。【Github Pages 官网】 VuePress，是以 Vue 为驱动的主题系统的简约静态网站生成工具 balabala……它是咱尤雨溪大神折腾出来的一个工具，初始目的是为了方便他使用 Markdown 语法来写文档，然后生成 HTML 代码，部署到服务器上即可。在众多网友的修改下，它可以拿来写静态网站，也就是可以拿来发布我们编写的博文。【VuePress 官网】  说到这里，小伙伴们大概懂了我们要讲什么了~ 但是，如果这只是一篇关于如何入门 GitHub Pages 和 VuePress 的文档，我会觉得毫无意义。所以，jsliang 希望这篇文章能够整合网上的 GitHub Pages 和 VuePress 资料，并且比它们丰富一丢丢，加入 jsliang 使用心得，让小伙伴们看完无需翻阅大量文章也能快速做好自己的个人文档库/博客。那样，我就心满意足了。因为……  不折腾的前端，跟咸鱼有什么区别！  本文涉及的技术点： GitHub Git Markdown  如果你不是很熟悉上面的技术，jsliang 推荐你去百度下资料，先学习下这些技术，再回来继续学习。其中 GitHub 和 Git 的文章 jsliang 尚未整理，小伙伴只能去百度获取资料了，这里我提供一篇自己写的 Markdown文章：地址。 如果你熟悉且了解上面的技术，那么，让我们愉快地继续往下去折腾吧！ 三 基础配置 3.1 搭建 GitHub Pages 返回目录 新建仓库( New repository )，在仓库名( Repository name )中输入 用户名.github.io，例如我的就是：LiangJunrong.github.io，然后点击 Create repository 即可创建一个部署好的环境。 Clone 项目至电脑，并新增 README.md 和 index.html： README.md Hello Github Pages === &emsp;这是我的 GitHub Pages 初始目录 index.html Hello Github Pages .container { margin-top: 300px; text-align: center; } Hello Github Pages 上传到 GitHub： git add . git commit -m \"Github Pages\" git push 打开 用户名.github.io：  如上，完成 GitHub Pages 的搭建，现在我们已经拥有了一个免费部署静态页面的平台了。那么，下面我们将讲解如何通过 Markdown + VuePress 来编写博客。 3.2 搭建 VuePress 返回目录 安装 VuePress  在你需要存放的目录中，通过终端命令行安装 VuePress：npm i vuepress -D 创建目录及部署代码  编辑 package.json： package.json { \"scripts\": { \"dev\": \"vuepress dev docs\", \"build\": \"vuepress build docs\" }, \"devDependencies\": { \"vuepress\": \"^0.14.4\" } } 注： npm run dev 即可开始实时编辑模式 npm run build 即可对代码进行压缩打包，打包后的文件夹在 .vuepress/dist 上。  然后创建 docs 文件夹，并在 docs 文件夹下创建 README.md 文件 README.md Hello VuePress ===  最后在终端执行命令 npm run dev，并打开 http://localhost:8080，得到初步配置界面如下：  值得注意的是。在这里，我们是通过 npm run dev 即时获取我们修改的页面显示。 然后，我们可以通过 npm run build 打包我们的代码，你可以在 .vuepress 中找到一个 dist 文件夹，然后将 dist 中的文件夹上传至 用户名.github.io，即可完成 VuePress 的部署。 3.2.1 目录讲解 返回目录  在前面，我们讲解了如何设置 VuePress 并启动  现在，我们来个基配的目录，进行讲解： - docs - VuePress 存放目录 - .vuepress - VuePress 配置目录 - public - 共用文件存储目录 - img - 共用图片目录 - banner.png - 图片-首页 banner - logo.ico - 图片-网站右上角小图标 - config.js - VuePress 的 js 配置文件 - listOne - 侧边栏项目组1 - pageOne.md - 项目组1页面1 - README.md - 项目组1默认页面 - listTwo - 侧边栏项目组2 - pageThree.md - 项目组2页面3 - pageTwo.md - 项目组2页面2 - README.md - 项目组2默认页面 - README.md - 网站默认首页 + node_modules - node 依赖包 - package.json - webpack 配置文件  其中，.vuepress 存放 VuePress 的配置目录，public 中存放共有的文件，config.js 为 VuePress 的配置文件，listOne、listTwo 是侧边栏组，对页面进行个分类。 3.2.2 导航栏 返回目录  在这里，我们开始进行顶部导航栏的配置。 首先，我们填写下 config.js 中的配置代码： config.js module.exports = { // 左上角标题 title: 'jsliang 的文档库', // 描述 description: '前端工程师 jsliang 的文档库', // 头部部署，右上角小图标 head: [ // ico 配置 ['link', { rel: 'icon', href: '/img/logo.ico' }] ], // 主题部署 themeConfig: { /** * 右侧导航条 * text - 显示字段 * link - 链接：注意前后带 / 符号 */ nav: [ { text: '主页', link: '/' }, /** * 多级菜单 * 开头 text 为一级标题 * 数组内 text 为二级标题 * link 为链接，注意带 / */ { text: '博文', items: [ { text: '微信小程序 bug 集中营', link: 'https://github.com/LiangJunrong/document-library/blob/master/other-library/WeChatApplet/WeChatAppletBug.md' }, { text: '使用 GitHub Pages 和 VuePress 搭建网站', link: 'https://github.com/LiangJunrong/document-library/blob/master/other-library/GithubPages/GithubPages.md' } ] }, { text: '关于', link: '/about/' }, // 链接到网站 { text: 'Github', link: 'https://www.github.com/LiangJunrong' }, ] } }  然后，启动 npm run dev，打开 http://localhost:8080，你可以看到导航栏部署完毕了。 3.2.3 侧边栏 返回目录  VuePress 中的侧边栏配置，一共有三种方式：简单配置，按组配置，分页配置，有兴趣的小伙伴可以去：地址 直接查看，这里我们单纯讲下我们部署我们的文档库用到的分页配置。  目录如下：  然后，我们修改下 config.js： config.js module.exports = { title: 'jsliang 的文档库', description: '前端工程师 jsliang 的文档库', head: [ // ...省略，配置代码同 3.2.2 ], themeConfig: { nav: [ // ...省略，配置代码同 3.2.2 ], /** * 侧边栏配置：侧边栏组 */ sidebar: { // 侧边栏在 /index/ 目录上 '/index/': [ ['', 'README'], ['indexTwo', '导航第二页'] ], // 侧边栏在 /about/ 目录上 '/about/': [ ['', 'README'], ['GithubPages', 'GithubPages'], ['VuePress', 'VuePress'] ] } } }  最后，我们运行 npm run dev，查看 http://localhost:8080 所示如下：  可以看出，我们已经成功配置了分页形式的侧边栏。 3.2.4 默认首页 返回目录  VuePress 为我们设置了一套默认的首页，我们直接拿来用，看看它长什么样子吧！  首先，我们找一张 banner.png 图，放到 public/img/banner.png 上。 然后，我们修改下 docs/README.md 文件： docs/README.md --- home: true heroImage: ./img/banner.png actionText: 皮皮虾 我们走 → actionLink: /index/ features: - title: 装逼 details: 在这里，你可以看到 jsliang 在这里无限装逼，所以你可以尽情打脸。就算你懂，没关系，打了脸再说~ - title: 搞笑 details: 在这里，你可以获得各种学习欢乐，轻松进击前端编程。点滴进步，成就不一样的你。 - title: 深沉 details: 在这里，你可以收获一个广州自身漂泊的人的情怀，感受在这个烦躁的社会 jsliang 如何安身立命。 footer: jsliang 的文档库 | Copyright © 2018 不折腾的前端，和咸鱼有什么区别 ---  OK，由于我们重新修改了首页（即 docs/README.md），所以我们重新重启下，Ctrl+C -> y -> npm run dev，重新打开 http://localhost:8080：  完美！这样，我们就完成了基础的配置了！！！ 四 VuePress 进阶 4.1 修改样式 返回目录  正在逐步完善。  如果你觉得该篇文章对你非常有用，请给我在 GitHub 上的文档库一个 star，你的 star 是我不断折腾的动力~ 【Github 地址】 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/Website/ShoppingMall/ShoppingMall.html":{"url":"other-library/Website/ShoppingMall/ShoppingMall.html","title":"Vue + Koa2 + MongoDB 搭建商城","keywords":"","body":"Vue + Koa2 + MongoDB 搭建商城 Create by jsliang on 2018-10-25 15:14:00Recently revised in 2018-10-28 18:58:21  Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址  本文通过 Vue + Koa2 + MongoDB 搭建一个春节/新年皮肤的商城。  本文参考教程：Vue.js+Koa2移动电商实战视频教程(文字版)  涉及技术点： Vue - 2.5.2 Vant - 1.3.8 Node - 8.11.2 Koa2 - MongoDB -  值得注意的是，你在这里看到的，不是从无到有的开发过程，即：这不是一篇手把手带你 0 基础搞定一切的文章。 细瞧代码片刻，竟无语凝噎，唯有泪千行，妈妈我不知道怎么跟小伙伴们讲啊！前端代码涉及知识点太多了~ 但，文章篇幅会非常详细，jsliang 会尽可能地提供相应的开发思路，如果你在阅读这篇文章的过程中，发现某些无法看懂，请自行 百度 或者 Google 或者在 QQ 群 @ 我。这就好比咱要做一件坏事，jsliang 为你提供了作案思路和作案工具，还有外援(QQ 群 798961601)，相信小伙伴们在自己的努力下，会收获不一样的精彩。  推荐通过 目录 以及使用 返回目录 按钮，获得更好的阅读体验。  如果你对文章的一些章节存在疑惑，请留言或者私聊 jsliang 提出来，jsliang 在自己理解的基础上尽可能为你解答，因为 jsliang 在 Vue 某些方面的理解，是远远不及一些有丰富开发经验的 Vuer 的。 一 目录  我不是想犯罪，只是，似乎证据确凿？…… 目录名 一 目录：你一定会回来的 二 自白：我想做个好人 三 犯罪商城：奇技淫巧  3.1 VS Code 插件  3.2 Iconfont-阿里巴巴矢量图标库  3.3 Vant——Vue的组件库   3.3.1 引用 Vant 组件库   3.3.2 Button 按钮   3.3.3 Layout 布局  3.4 模拟网速缓慢 - Slow 3G  3.5 mock 数据 - Easy Mock  3.6 Chrome 插件 - Vue Devtool  3.7 Swiper 组件 - vue-awesome-swiper 四 犯罪前奏：前端基础  4.1 vue-cli 的安装及使用  4.2 引用图片  4.3 引用 Axios 获取 API  4.4 API 接口文件配置  4.5 Filter 过滤器  4.6 Sass 的安装 五 犯罪经过：页面布局 六 牢狱之灾：初识数据 七 作案新招：后端基础 八 卷土重来：项目部署 九 枪决前刻：我真的是个好人 二 前言 返回目录  商城思路：  规则： 用户有 10000 初始金币 用户可以向系统商城购买商品 用户可以购买店铺皮肤 用户可以修改商品标题、介绍、图片、详情 用户通过售卖商品、商铺点赞、商品点赞获得金币 用户可以参与销售比赛。比赛规则：假如有 10 个用户参与商户竞赛，总共有 1000 个用户参与其中。那么，比赛主持人（我）将投入 100 块钱，假如其中一个用户最后获得 100 * 10000 金币，那么，它将得到 10 块钱……以此类推  页面： 注册/登录 商城首页-商品推荐页 商家首页-商品列表页 购物车页 新增收获地址页 订单/付款页 销售排行榜页 个人中心页 道具页 打卡日历页  下载代码：代码目前在 jsliang 的 unfineshed-code 仓库中，等这篇文章完结了会单独开一个仓库以供下载，如果你想即刻拥有原始资料，那就点击链接加 QQ 群拿资料吧：798961601。 我是 jsliang，我在天书世界等你，噢，不是…… 我是 jsliang，想要资料就来砍我，哦，不是…… 我是 jsliang，我在 jsliang 资料群等你~  运行代码： # 安装依赖 npm i # 在 localhost:8080 运行 npm run dev # 打包部署到服务器 npm run build 三 奇技淫巧 返回目录  在这个章节中，你可以看到 VS Code 的一些插件的妙用；可以看到 Iconfont 这个图标库的使用；可以看到一些比较实用的组件库例如 Vant 的介绍…… 通过这些小技巧，提高你的开发效率。 如果这些小技巧你都用得非常熟练了，请通过目录跳转至第四章或者直接前往第五章，学习其他的开发技巧。 3.1 VS Code 插件 返回目录  使用方法：Visio Studio Code 软件 -> 扩展 -> 搜索关键字 -> 安装 -> 重启 VS Code Vetur：该插件可以使得 VS Code 能识别 .vue 文件，并支持 .vue 文件的语法高亮显示，同时，还兼顾大多数主流的前端开发和插件，例如 Sass 和 TypeScript。 Vue VSCode Snippets：该插件可以方便编写 Vue 代码。通过安装后，在页面中敲 vbase 并回车可以得到一个空模板，敲 vdata 可以获得一个 data() 方法。 3.2 Iconfont-阿里巴巴矢量图标库 返回目录  在阿里巴巴图标库，设计师将图标上传到 Iconfont 平台，用户可以自定义下载多种格式的 icon，平台也可将图标转换为字体，便于前端工程师自由调整与调用。  地址：阿里巴巴图标库  使用方法，通过加入购物车的形式，将需要的图标一起打包下载。如果实在是不看攻略就搞不懂，可参考文档：链接-如何使用 iconfont 下载图标？ 3.3 Vant——Vue的组件库 返回目录  Vant 是轻量、可靠的移动端 Vue 组件库：Vant 官网  这里我们讲一下 Vant 的基础引用，下面章节涉及到 Vant 的代码时，请小伙伴们直接查看上面的 Vant 官网。因为组件库的使用，只有自己去折腾几遍，才能玩得溜。 3.3.1 引用 Vant 组件库 返回目录  在通过 Vue-cli 安装了 Vue 项目的情况下，Vant 的安装及配置： 安装 Vant：npm i vant -S 通过安装 babel-plugin-import 按需引用组件模块：npm i babel-plugin-import -D 在 .babelrc 文件中配置 plugins： .babelrc { \"presets\": [ ... 省略，详情在 .babelrc 中有，复制下面的 plugins 至代码中即可 ], \"plugins\": [ \"transform-vue-jsx\", \"transform-runtime\", [ \"import\", { \"libraryName\": \"vant\", \"style\": true } ] ] } 3.3.2 Button 按钮 返回目录  这里讲解下页面中引用 Vant 的 Button 组件： src/main.js import { Button } from 'vant' Vue.use(Button) src/App.vue 主要按钮  这样，我们可以通过引用组件的形式，引用 Vant，做到按需引用，对我们的项目是比较友好的。如果你想采用其他的引用技巧或者更进一步了解 Vant，请点击上面提及的 Vant 链接，直接访问即可。 3.3.3 Layout 布局 返回目录  如果你使用过 bootstrap，你可能还记得它的 12 格栅格化布局，在 Vant 中，它不同于 bootstrap，它使用了 24 格布局：Vant Layout 布局。  下面我们讲解它的使用：  我们在 src/main.js 中引用 Vant 的 Row 和 Col 组件： src/main.js // The Vue build version to load with the `import` command // (runtime-only or standalone) has been set in webpack.base.conf with an alias. import Vue from 'vue' import App from './App' import router from './router' import { Button, Row, Col } from 'vant' Vue .use(Button) .use(Row) .use(Col) Vue.config.productionTip = false /* eslint-disable no-new */ new Vue({ el: '#app', router, components: { App }, template: '' })  然后，我们在 ShopingMall.vue 中使用布局 ShoppingMall.vue 主要按钮 span: 8 span: 8 span: 8 export default { }  这样，我们就搞定了 Vant Layout 布局的引用。 3.4 模拟网速缓慢 - Slow 3G 返回目录  由于我们制作的是商城，到时候可能加载大量的图片。 所以，我们不仅需要考虑用户在 WiFi 下的愉快体验，更需要考虑在野外等手机信号差的 3G，甚至 2G 信号下商城的加载速度，从而优化用户的浏览体验。 因为我们平时在公司或者家里开发，都是 WiFi 网络。所以，在这里，我们使用 Chrome 控制台的 Slow 3G，通过加载PC端淘宝，进行网速慢的模拟。  首先，我们通过 Chrome 打开淘宝首页，通过 F12 打开控制台，点开 Network 并通过按 Ctrl + F5 进行强制刷新，得到下面这个图：  可以看到，我们 WiFi 情况下，DOM 节点的内容加载为 1.02s。然后，我们按下面的图点开下拉菜单，选择 Slow 3G：  再通过 Ctrl + F5 进行强制刷新，模拟网速缓慢的情况：  可以看出，在网速缓慢的情况下，我们加载 DOM 节点的内容，加载了 10.43s。无疑，假设我们开发的商城在上线后变成这样，当用户在网速更差的情况下，可能会选择直接关闭网站。 所以，通过网络缓慢的情景模拟，可以对网站做一些性能优化，从而减少我们的用户量。 3.5 mock 数据 - Easy Mock 返回目录  对于页面中最后需要调用接口渲染的数据，我们大概会使用两种方法： 直接在 data 中使用假数据，读取接口后再进行更新； 根据接口文档，进行 mock，获取 mock 数据。  在这里，我们介绍一种比较便捷的方式：Easy Mock Easy Mock 是一个比较好用的图形化网站，小伙伴们点击进去会立刻 get 到它的设计意图，我们可以直接在项目中通过 Axios 直接调用它的链接，获取到数据。 3.6 Vue 的 Chrome 插件 - Vue Devtool 返回目录  如果你是 Vue 新手，那么，当你第一次运行 npm run dev，在 localhost:8080 中打开控制台会发现：  它提示我们安装个 Vue Devtools 的插件，来获得更好的开发体验： Download the Vue Devtools extension for a better development experience: https://github.com/vuejs/vue-devtools  所以，我们下载了个 Vue Devtools 的插件，并进行了安装。插件安装包和安装方式： 参考地址1-安装方式 参考地址2-安装包（加入公众号 -> 获取验证码 -> 下载资料 -> 取消关注）  安装完成后，我们可以刷新页面，可以在 Vue 项目的控制台中看到：  由于插件非常简洁，一看就懂，所以这里就不讲解了，这样我们又可以愉快地玩耍啦~ 3.7 Swiper 组件 - vue-awesome-swiper 返回目录  vue-awesome-swiper 是关于 Vue 的一个 Swiper 组件，它实现了轮播图、滑动、内容滚动等功能，GitHub 地址：vue-awesome-swiper  它适合 PC 或者 Mobile 端，可用于 SPA 或者 SSR 页面。  它的使用技巧及 Example 在上面的 GitHub 地址存在，如果你想先了解它的作用，可以点击这里：展示地址  然后，上面的演示对应的代码为：代码地址。在安装了 vue-awesome-swiper 的情况下，将代码地址中的任意一个 .vue 文件复制到我们的项目，进行稍微修改即可。 全局引用： main.js // import 依赖 import Vue from 'vue' import VueAwesomeSwiper from 'vue-awesome-swiper' // 加载样式 import 'swiper/dist/css/swiper.css' // 全局使用 Vue.use( VueAwesomeSwiper, ) // ... 页面中组件形式引用 *.vue // 以组件方式引用 import { swiper, swiperSlide } from 'vue-awesome-swiper' // 加载样式 import 'swiper/dist/css/swiper.css' // 引用组件 export default { components: { swiper, swiperSlide } }  如果你需要更多的技巧，请直接翻阅它的 Github。 四 前端开发 返回目录  在这个章节，我们开始部署前端基础环境，为后续的连贯操作做基础准备。 4.1 vue-cli 的安装及使用 返回目录  步骤： 安装 vue-cli：npm i vue-cli -g 初始化 Vue 项目：vue init webpack 开启开发模式：npm run dev 打开浏览器，查看网页： http://localhost:8080 4.2 引用图片 返回目录  如果你没用过 Vue-cli，那么，你可能会对它的图片存放路径存在问题，因为它可以存放在 src/assets 及 static 这两个目录中。你可能对此感到疑惑，为什么它会有两个文件夹来进行存放呢？ 讲个大白话：src/assets 目录中的图片是会被 webpack 打包成 base64 的，static 目录中的图片是不会被打包的。 那么，为什么会存在打包成 base64 的区别呢？因为当浏览器加载你的图片的时候，每一张图片就相当于一次 http 请求，当图片多了的时候，它就会损耗你的性能。所以，就像 雪碧图 的引用一样，在 vue-cli 的配置上： { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') } },  可以看出，它对于小于 10K(10000/1024) 的图片，会打包成 base64，从而减少了我们在浏览器加载时的性能损耗。  讲解完 src/assets 及 static 的区别后，我们继续讲在这两个文件夹中图片的引用。 由于 src/assets 目录中，我们存放一些比较小的，需要打包的图片，所以我们应该通过 require 的方式，将它当成模块进行引用。 而在 static 目录的图片，vue-cli 已经对其进行了个解析： config/index/js 'use strict' const path = require('path') module.exports = { dev: { assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: {}, //... 省略剩下的代码 }, build: { index: path.resolve(__dirname, '../dist/index.html'), assetsRoot: path.resolve(__dirname, '../dist'), assetsSubDirectory: 'static', assetsPublicPath: '/', // ...省略剩下的代码 } }  从中，可以看出，对于 static 的资源，vue-cli 在开发模式 dev 以及打包模式 build 中都进行了配置，它不会被 webpack 进行打包，属于 “静态资源”。所以，在项目中引用 src/assets 及 static 下的图片资源，我们可以： src/components/pages/ShoppingMall.vue export default { data() { return { icon1: require('../../assets/img/emoticon_cool.png'), // 引用 assets 下的图片 icon2: '/static/img/emoticon_cute.png' // 引用 static 下的图片 } } }  通过 npm run dev 编译后，浏览器 localhost:8080 展示为： 4.3 引用 Axios 获取 API 返回目录  步骤： 安装 axios：npm i axios -S 在 src/components/pages/ShoppingMall.vue 的 标签中引用并使用 axios： import axios from 'axios'; export default { data() { return { icon1: require('../../assets/img/emoticon_cool.png'), // 引用 assets 下的图片 icon2: '/static/img/emoticon_cute.png' // 引用 static 下的图片 } }, created() { axios({ url: 'https://www.easy-mock.com/mock/5bd2b50e6388c25a14965a22/index', method: 'get' }).then(res => { console.log(res.data.data); }).catch(err => { console.log(err); }) } }  然后，我们打开 localhost:8080，查看控制台，可以看到它进行了正常的输出。 4.4 API 接口文件配置 返回目录  在 4.3 章节中，我们提及到了 Axios 对接口的调用。 但是，小伙伴们有没有想到，如果某天，后端大大对你说，某台服务器过期了，你将接口地址更改一下。听到这话，你乖乖地一个一个 .vue 文件改一遍，当你还没有改完时，后端大大又发你一个接口地址：“确定了，咱还是用这个。”…… 不知道小伙伴会是什么心情吧……所以，为了预防万一，我们将 API 地址统一抽取到一个文件，到时候修改起来也方便。 我们在 src 目录下新建一个 serviceAPI.config.js 配置文件，用来存放 API 接口地址： src/serviceAPI.config.js const BASEURL = \"https://www.easy-mock.com/mock/5bd2b50e6388c25a14965a22/ShoppingMall/\" const URL = { getGoodsInfo: BASEURL + 'getGoodsInfo', getUserInfo: BASEURL + 'getUserInfo', } module.exports = URL  然后，我们在 Vue 文件中获取该数据： *.vue import axios from 'axios'; import url from '@/serviceAPI.config.js'; export default { created() { axios({ url: url.getGoodsInfo, method: 'get' }).then(res => { console.log(res.data.data); }).catch(err => { console.log(err); }); axios({ url: url.getUserInfo, method: 'get' }).then(res => { console.log(res.data.data); }).catch(err => { console.log(err); }) } }  最后，我们打开 localhost:8080 的控制台，就可以看到这两个接口都能获取到数据了。 4.5 Filter 过滤器 返回目录  在 Vue 中，可能经常对一些数据进行处理。例如：对后台返回的时间进行处理，对后台返回的金钱进行处理……在这里，我们就需要写过滤器，完成对这些数据的处理。 下面讲解一个金钱格式过滤器。现在 src 文件下建立一个 filter 文件夹，然后 filter 文件夹下建立一个 moneyFilter.js 文件，我们用它来进行金钱格式的过滤： src/filter/moneyFilter.js export function toMoney(money = 0){ return money.toFixed(2) }  然后，我们在页面中引入并使用这个金钱过滤器： *.vue import axios from 'axios'; import { toMoney } from '@/filter/moneyFilter.js' export default { filters: { moneyFilter(money) { return toMoney(money); } }, // ...省略下面代码 }  最后，我们在 template 中实现简单过滤： {{112 | moneyFilter}}  在 localhost:8080 页面中可以看到，数字变成了 112.00 4.6 Sass 的安装 返回目录  在代码中，如果我们需要在页面中使用 sass：  如果你在你的 build/webpack.base.config.js 中没找到这四行，那就证明你没有安装 sass 处理器： { test: /\\.scss$/, loaders: [\"style\", \"css\", \"sass\"] },  所以，在这里，我们讲一下在 Vue 项目中，sass 的安装： 安装对应的依赖： npm i node-sass -D npm i sass-loader -D 在 build/webpack.base.config.js 的 rules 中加上： { // ...上一个 test:...loader:...复制下面的 {} 即可 } { test: /\\.scss$/, loaders: [\"style\", \"css\", \"sass\"] },  如此，你在加载下 Vue 项目，会发现它能正常运行了。 未完待续  如果小伙伴们觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-21 10:05:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/WeChatApplet/":{"url":"other-library/WeChatApplet/","title":"微信小程序","keywords":"","body":"微信小程序 create by jsliang on 2018-9-13 09:04:41Recently revised in 2018-12-23 21:22:46  应产品所需，用技术去折服他~ 微信小程序开发，走你！ 一、环境准备 1.1 下载安装 ---地址--- 1.2 授权登录 ---地址--- 按上面地址配置，然后扫码登录进小程序。 二、环境介绍 2.1 文件类型 文件类型 作用 .json JSON 配置文件 .wxml WXML 模板文件 .wxss WXSS 样式文件 .js JS 脚本逻辑文件 2.2 .json 文件 app.json：小程序的全局配置。 详情 project.config.json：工具的个性化配置，例如界面颜色、编译配置等。 详情 page.json：页面配置，用来设置页面的整体样式等。 详情 2.3 WXML 模板  WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。详情 2.4 WXSS 样式  WXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。详情 2.5 事件 事件是视图层到逻辑层的通讯方式。 事件可以将用户的行为反馈到逻辑层进行处理。 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。 事件对象可以携带额外信息，如 id, dataset, touches。 2.6 API  小程序开发框架提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。 2.7 审核发布  微信公众平台 -> 小程序管理后台 -> 开发管理 -> 开发版本 -> 提交审核 三、友情链接 作者 链接 小程序官网 小程序组件 jsliang 微信小程序 bug 集中营 jsliang 微信小程序通讯录 jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/WeChatApplet/WeChatAppleProcess.html":{"url":"other-library/WeChatApplet/WeChatAppleProcess.html","title":"微信小程序开发流程","keywords":"","body":"微信小程序开发流程 Create by jsliang on 2018-12-28 17:27:41Recently revised in 2018-12-28 17:36:43 邮箱。可以考虑网易邮箱，1 个手机号 = 15 个邮箱。 名称和头像。随意。 注册：名字（一年仅能修改两次）、头像（一个月修改五次）、实名认证。 注意事项： 个人小程序没有支付功能，需要注册公司并开通银行账号。 小程序 API 地址必须是 https，所以需要配置 https 服务。 服务器地址不支持 ip 地址，且使用域名的时候必须是备案过的域名。 前端下载开发者工具开始开发。前端需要小程序 APPID以及小程序名。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议 进行许可。基于 https://github.om/LiangJunrong/document-library 上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/WeChatApplet/WeChatAppletBug.html":{"url":"other-library/WeChatApplet/WeChatAppletBug.html","title":"微信小程序 bug 集中营","keywords":"","body":"微信小程序 bug 集中营 Create by jsliang on 2018-9-17 17:58:56Recently revised in 2018-11-21 11:40:01  Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址 写在前面  首个微信小程序实践记录: 工作量: PSD 18 张 (导出的 JPG 30 张) 耗时：12 个工作日 总结1: 在页面制作商，需要 3 周工作日（工作 15 天）搞定，前后端对接口另计。实际上，12 个工作日可以搞定所有页面，但是应该往前铺 1.5D 熟悉框架，往后铺 1.5D 整理代码。当然每个人的耗时可能不同，可根据个人实际情况进行调整。 总结2：在 API 调用上，根据接口数量可能需要 7-12 个工作日进行 API 调用，难点表现在： 接口不够丰富，数据量不足； 接口数据不够正式真实，跟前面的假数据相差太大； 接口可能没法正常调用 等原因。故因根据小程序业务逻辑进行工作时长的报备。  这里有 jsliang 微信小程序开发中遇到的所有坑，以及在填坑过程中的一些个人经验。jsliang 利用这篇教程存储一些常用的微信小程序开发技巧，方便查找。它可能教不了你什么，但至少能省下你百度的功夫。  请结合 《目录》 和 《返回目录》 来进行跳转，获得更好的阅读体验。  本文技术支持：Ansen江  注1：由于更新频繁，有时候平台上的文章版本可能没有图片或者目录无法跳转，所以小伙伴需要获取最新资料的，请前往 GitHub：地址  注2：如果小伙伴使用的是手机版打开，那么推荐小伙伴使用电脑打开，因为各平台的手机端大都不支持页内跳转，看起来比较费劲。 一 目录  目前已有 48 个坑。 请各位按目录检索时注意：3.1、3.2、3.3…… 等二级目录对应着一个章节。3.1.1、3.1.2、3.1.3…… 等三级目录将该二级目录这个大章节详细拆分成诸多小坑，方便查看。 目录 坑 一 目录 二 前言 三 填坑实战  3.1 swiper 轮播图 5   3.1.1 行内样式无效   3.1.2 图片样式修改不了   3.1.3 swiper 属性值设置   3.1.4 轮播图图片跳转   3.1.5 wx:key   3.1.6 实战代码  3.2 tabBar 与 switchTab 3   3.2.1 底部导航跳转   3.2.2 自定义底部导航   3.2.3 自定义组件  3.3 px、rem 与 rpx 1  3.4 微信 web 开发者工具 2   3.4.1 无法输入中文   3.4.2 无法滑动滚轮  3.5 组件与 API 2   3.5.1 概念混淆：组件 VS API   3.5.2 API 查询不到对应的方法  3.6 flex 布局 2   3.6.1 基础概念   3.6.2 左右布局   3.6.3 混合布局  3.7 background-image 套用本地图片无效 1  3.8 \\ 与 \\ 1  3.9 搜索框 2   3.9.1 margin-top 无法上浮   3.9.2 改造 WeUI 搜索框  3.10 微信小程序分享 1  3.11 border-box 设置 1  3.12 自定义导航条 6   3.12.1 WeUI 选项卡   3.12.2 自定义选项卡效果与实现   3.12.3 绑定事件如何传递数据   3.12.4 不允许驼峰   3.12.5 获取 data 数据   3.12.6 实现文字省略  3.13 黑科技：\\ 2   3.13.1 被遗弃的 \\   3.13.2 四种弹窗写法  3.14 小程序解析 HTML 6   3.14.1 解析 HTML 的三种方法   3.14.2 wxParse   3.14.3 rich-text   3.14.4 web-view  3.15 诡异的 open-type 1  3.16 \\去样式及其内嵌\\ 1  3.17 下拉刷新和上拉加载 2  3.18 获取 input 的值 1  3.19 onLaunch 加载问题 2   3.19.1 小程序执行顺序   3.19.2 路由守卫  3.20 request 封装与 api 抽离 1  3.21 判断数据是否读取完 1  3.22 客服系统研究 1  3.23 文件在线预览 2  3.24 尽量使用 ES6 1  3.25 视频功能实现 1  3.26 多层 for 循环 1  3.27 拼音导航 1 四 网友补充  4.1 文件夹读取报错 1  4.2 textarea问题多多 1 二 前言  返回目录 本文章原名【微信小程序 100 坑】  微信小程序的开发教程，或许写出来是非常受欢迎的。 但是： 第一，微信小程序是国内的，有中文文档，虽然它的文档说明有点坑，但好歹有文档，阅读理解对小伙伴们来说不是问题。 第二， jsliang 的文笔并没有想象中的那么好，想想如果我带你们走了一遍小程序开发，然后你们以为是一条平坦路，结果碰到一堆坑坑洼洼，咋办？最后的锅，会不会到我背啊，可怕！  所以，在这里， jsliang 结合 “日常躺坑” ，先为你解决小程序的 100 个坑！虽然现在可能还不够，但是第一天我就碰到 4/5 个了，我想我可以帮你们躺完 100 个的！！！ 现在的微信开发者工具显示的开发版本是：\"libVersion\": \"2.0.4\" 如果你开发的版本已经解决了这个 bug ，或者你觉得这个 bug 还有其他解决方法，或者你觉得这个玩意还有其他 bug ，请告诉我，我会补充到这篇文档上，顺带记上您的大名，谢谢！ QQ： 1741020489 三 填坑实战  返回目录  这里的坑： 有的来源于微信自带的开发文档：小程序开发文档。在文档中，你会发现很多的乐趣！毕竟，你不知道什么时候中文成为了你的语言障碍~ 有的是开发中遇到的，然后结合大量的百度结果，进行的有效性总结。  希望小伙伴在百度中或者无意看到这篇文章，请熟练使用浏览器的 Ctrl + F，查找需要的问题答案。 3.1 swiper 轮播图  返回目录 本组件目前已有 5 个坑，有兴趣的小伙伴可以详看。   代码来源于该地址：微信组件 swiper 。  为方便小伙伴查看，下面贴出原版代码： demo.wxml indicator-dots autoplay interval duration demo.js Page({ data: { imgUrls: [ 'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg', 'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg', 'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg' ], indicatorDots: false, autoplay: false, interval: 5000, duration: 1000 }, changeIndicatorDots: function(e) { this.setData({ indicatorDots: !this.data.indicatorDots }) }, changeAutoplay: function(e) { this.setData({ autoplay: !this.data.autoplay }) }, intervalChange: function(e) { this.setData({ interval: e.detail.value }) }, durationChange: function(e) { this.setData({ duration: e.detail.value }) } })  好的，上面就是微信官方文档的演示代码，如果你跟着演示代码走了一遍碰到疑问的话，看看这里我挖的土是不是能填好你的坑： 3.1.1 行内样式无效  返回目录  demo.wxml 中出现的 这行， width 和 height 的行内属性是忽悠老百姓的，它并没卵用 ！我们需要在 slide-image 这个 class 类中修改 width 和 height。简而言之，行内样式都是骗人的，乖，我们还是去 demo.wxss 写样式吧~ 3.1.2 图片样式修改不了  返回目录  在任何出现图片的地方（包括但不限于轮播图），如果你发现不仅行内写法无效之外，还发现单纯地给图片加 class，去 *.wxss 写样式也无效的话。那么，我建议小伙伴最好采用样式加重法，即 .image-wrap .image 这种写法格式，来确保图片样式能进行修改。详细用法可看下文。 3.1.3 swiper 属性值设置  返回目录  swiper 属性值。官方文档说明：  虽然，它的属性名和属性值是这么说的。但是，用的时候，首先你需要在 demo.wxml 中的 swiper 绑定这个属性名，然后在 demo.js 中设置其属性值。值得注意的是，它的绑定值，稍微不同于 Vue， 需要设置 {{}} 形式。如果文字描述你看得不是很清楚，可以参照下面的代码进行理解。 3.1.4 轮播图图片跳转  返回目录  关于轮播图的地址跳转，在微信小程序的官网是没用提及的，也是 jsliang 去百度查看了下，才知道怎么设置（可能是我一开始就挑战的难度太高了么 -_-|| ），在下面 jsliang 贴出来代码~想知道怎么解决的可以去看看：首先，在 data 中设置 link ；然后，设置 navigator 导航遍历 item.link 。 3.1.5 wx:key  返回目录  关于 wx:key ， wx:key 的作用是：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。但是，在其 swiper 中，小程序本身是没有写的，所以它会带有 warning ，这里也是个小坑， jsliang 也是百度了下也知道这件事：点我了解。 3.1.6 实战代码  返回目录  下面给出这 5 个坑的解决代码，如有不对，尽情指出： index.wxml index.wxss .carousel .slide-image { width: 100%; height: 420rpx; } index.js Page({ data: { imgUrls: [ { link: '../index/index', url: 'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg', }, { link: '../demo/demo', url: 'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg', }, { link: '../logs/logs', url: 'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg' } ], indicatorDots: true, autoplay: true, interval: 5000, duration: 1000 } }) 3.2 tabBar 与 switchTab  返回目录 本组件目前已有 3 个坑，有兴趣的小伙伴可以详看。  tabBar ：底部菜单栏，需要在 app.json 中设置。使用方法：见下文。 navigator ：导航切换。使用方法：地址 switchTab ：控制 tabBar 的切换。使用方法：地址 3.2.1 底部导航跳转  返回目录  在这里，我们讲下 tabBar 的坑，如果你在 app.json 中设置了 tabBar ： app.json \"tabBar\": { \"list\": [{ \"pagePath\": \"pages/index/index\", \"text\": \"首页\", \"iconPath\": \"./public/index_tabBar1_nor.png\", \"selectedIconPath\": \"./public/index_tabBar1.png\" }, { \"pagePath\": \"pages/demo/demo\", \"text\": \"发现\", \"iconPath\": \"./public/index_tabBar2_nor.png\", \"selectedIconPath\": \"./public/index_tabBar2.png\" }, { \"pagePath\": \"pages/logs/logs\", \"text\": \"我的\", \"iconPath\": \"./public/index_tabBar3_nor.png\", \"selectedIconPath\": \"./public/index_tabBar3.png\" }] }  那么，我们就需要通过设置 switchTab 来控制底部导航的跳转，而不能通过 navigator 来跳转： demo.wxml Hello demo.js linkTo: function () { wx.switchTab({ url: '../index/index' }); }, 3.2.2 自定义底部导航  返回目录  那么问题又来了，当我们切换到子页面的时候，我们发现 tabBar 这个底部导航栏不见了，然后问了下 Ansen江 ，他说之前是整个小程序都有的，有些页面还要想方设法去隐藏。 但是现在嘛……它没了！没了啊！！！在微信小程序的文档没看到有唤起底部导航条的方法，难道我要做一个导航条了么 -_-|| 回答是：yes！ 所以，下面给出该底部导航条 tabBar 的实现情况和代码片段： 注：图片宽高均为 54rpx *.wxml 首页 在线咨询 电话咨询 立即订购 *.wxss .nav { display: flex; justify-content: space-around; font-size: 20rpx; border: 1px solid #ccc; position: fixed; bottom: 0; background: #fff; } .nav view { display: flex; flex-direction: column; align-items: center; } .nav image { width: 54rpx; height: 54rpx; } .nav text { margin-top: 7rpx; } .nav-home { border-right: 1px solid #ccc; width: 130rpx; padding-top: 5rpx; } .nav-service { border-right: 1px solid #ccc; width: 130rpx; padding-top: 5rpx; } .nav-phone { width: 130rpx; padding-top: 5rpx; } .nav-buy { background: #eb333e; color: #fff; width: 360rpx; height: 98rpx; line-height: 80rpx; font-size: 34rpx; } *.js callWaiter: function(res) { wx.makePhoneCall({ phoneNumber: '13264862250', success: function(res) { console.log(\"拨打成功\"); console.log(res); }, fail: function(res) { console.log(\"拨打失败\"); console.log(res); }, complete: function(res) { console.log(\"拨打完成\"); console.log(res); } }) }, goHome: function() { wx.switchTab({ url: '../index/index' }) }, 3.2.3 自定义组件  返回目录  在最近的工作中，又发现一个小问题：  像这个导航条，它需要根据页面所在的模块，动态地展示不同位置的状态为活跃，而且它是需要在多个页面重复出现的，如果每个页面我都要复制粘贴一遍，到时候要修改起来的时候，麻烦不说，最重要的是，它可能影响我前端的性能了，能不能直接将其封装起来呢？  自定义组件：链接  是的，发现在小程序文档中是存在这个东西的。当然，至于过程中我百度了几篇文章来辅助写出下面的代码，你猜？  子组件写法 navBar.wxml 首页 发现 我的 navBar.wxss .navBar { width: 100%; padding: 18rpx 0; border-top: 1rpx solid #cccccc; display: flex; justify-content: space-around; position: fixed; bottom: 0; background: #fff; } .navBar image { width: 55rpx; height: 55rpx; } .navBar view { display: flex; flex-direction: column; align-items: center; font-size: 20rpx; color: #999999; } .navBar-user text { color: #d0a763; } navBar.js // pages/componentNavBar/navBar.js Component({ /** * 组件的属性列表 */ properties: { homeActive: { type: Boolean, value: false }, exploreActive: { type: Boolean, value: false }, userActive: { type: Boolean, value: false } }, /** * 组件的初始数据 */ data: { }, /** * 组件的方法列表 */ methods: { // 返回首页 goHome: function (e) { wx.switchTab({ url: '../index/index', }) }, // 返回发现页 goExplore: function (e) { wx.switchTab({ url: '../explore/explore', }) }, // 返回我的页面 goUser: function (e) { wx.switchTab({ url: '../user/user', }) }, showCode: function(e) { console.log(e); let that = this; console.log(that.data); } } }) navBar.json { \"component\": true, \"usingComponents\": {} }  然后，在父组件的使用，只需要： *.wxml *.json { \"usingComponents\": { \"navBar\": \"../componentNavBar/navBar\" } } *.js data: { userActive: true },  怎样？这就是自定义组件的写法，是不是觉得特好用涅，一次写完，终身受用。 3.3 px、rem 与 rpx  返回目录 本节目前已有1个坑，有兴趣的小伙伴可以详看。  在微信中，它自带了一套属于自己的单位：rpx ， rpx 不同于之前我们认识的 px 、 rem 、 em ，如果你的设计稿是 750 px 的，那么很容易的， 1px = 1rpx ，但是，如果设计稿不是 750 px ，那么将造成一个 bug ，至于这个 bug 如何解决…… -_-|| 谁知道呢……要不先把UI设计师宰了？ 知识补充：关于 rpx 。 3.4 微信 web 开发者工具  返回目录 本节目前已有 2 个坑，有兴趣的小伙伴可以详看。 3.4.1 无法输入中文  返回目录  如果你在开发过程中，发现只能写英文了，而中文无法输入了，千万别急，也别怪输入法出 bug 了，你只需要：重启开发工具。 3.4.2 无法滑动滚轮  返回目录  如果你某时刻，突然发现你没法滚动代码进行查看，而是需要拖动滚动条才行，请别怪你的鼠标，你可以去浏览器打开一篇文章看看，enm...你的鼠标还是好的~所以，请：重启开发工具。 3.5 组件与 API  返回目录 本节目前已有 2 个坑，有兴趣的小伙伴可以详看。 3.5.1 概念混淆：组件 VS API  返回目录  首先，科普下 组件 与 API 是什么： 组件：对数据和方法的封装，使用组件可以实现拖放式编程、快速的属性处理以及真正的面向对象的设计【百度百科】。那么，可以理解为：开发中常用的一些部件，我们都可以封装起来，然后在需要的时候拿来用，即为组件。 API：预先定义的函数，提供应用程序与开发人员无需访问源码，基于某软件或硬件得以访问一组例程的能力【百度百科】。就是说已经写好的一些 Function 或者后端接口，前端直接调用就行了。  但是，在微信小程序官方文档中，组件与API，拆分地有点不科学。 例如：轮播图与底部导航条 一个在组件中，一个在 API 中； 一个在 wxml 、 wxss 、 js 中要设置对应的参数，一个只需要在 app.json 中设置就行。  可能微信小程序考虑到底部导航条不应该有太大的变化（例如让你修改太多样式或者 js ），所以将导航条内嵌至源码中了。 但是，这可能导致什么重要影响吗？是的，如果底部导航条需要进行修改呢？例如：3.2.3 自定义组件。这样的情况下，我们的开发时间就有所增加了。 3.5.2 API 查询不到对应的方法  返回目录  如果小伙伴你经常有去看微信小程序官方文档的话，那么你一定会有一件事需要吐槽，那就是： 明明上次我见到过某个 API 实现了我需要做的功能，但是改天我回去查找的时候，它却提示我没有这个玩意，这是什么鬼？！ 是的，跟我们 3.13 黑科技：\\ 这一章中讲到的 这个黑科技一样，有时候官方文档也不是万能的，它总会有这样那样的毛病，导致我们找不到需要的东西，只能去百度了 -_-|| 3.6 flex 布局  返回目录 本节目前已有 3 个坑，有兴趣的小伙伴可以详看。  Flex布局又称弹性布局，在小程序开发中比较适用。但是由于 jsliang 之前没怎么用过 Flex 布局，所以在这里咱们特意去踩下坑，充实下自己。【小程序开发之页面布局】【阮一峰-Flex 布局教程】 在我们布局页面的时候，最好看看 阮一峰 的教程，平时遇到布局的问题的时候，我都习惯去上面 阮一峰 的文章看看： 3.6.1 基础概念  返回目录  基础概念：地址 display: flex; flex-direction: row | row-reverse | column | column-reverse; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow: || ; justify-content: flex-start | flex-end | center | space-between | space-around; align-items: flex-start | flex-end | center | stretch | baseline; align-content: flex-start | flex-end | center | space-between | space-around | stretch; 3.6.2 左右布局  返回目录  实现效果如下：  如图，这是我们要实现的左右布局效果。那么，在微信小程序要怎么做呢？ *.wxml 热门推荐 查看全部 > *.wxss .top-recommended-headlines { display: flex; align-items: flex-end; height: 31rpx; line-height: 31rpx; margin-bottom: 10rpx; } .top-recommended-headlines-left text { font-size: 32rpx; font-weight: bold; } .top-recommended-headlines image { width: 366rpx; height: 31rpx; margin-left: 10rpx; } .top-recommended-headlines-right navigator { font-size: 26rpx; color: #a9a9a9; margin-left: 50rpx; } 3.6.3 混合布局  返回目录  实现效果如下：  如图，这是我们要实现的左右布局效果。那么，在微信小程序要怎么做呢？ *.wxml {{item.title}} {{item.content}} {{item.datatime}} {{item.reader}}阅读 #{{item.label}}# *.wxss .weui-tab__content-item3 { padding-left: 30rpx; padding-right: 30rpx; margin-top: -10rpx; margin-bottom: 10rpx; } .weui-tab__content-item3:first-child { padding: 40rpx 30rpx 0; } .weui-tab__content-item3-question image { width: 30rpx; height: 30rpx; } .weui-tab__content-item3-question text { font-size: 30rpx; line-height: 46rpx; font-weight: bold; color: #333; margin-left: 10rpx; } .weui-tab__content-item3-answer image { width: 30rpx; height: 30rpx; } .weui-tab__content-item3-answer text { font-size: 26rpx; line-height: 42rpx; color: #a9a9a9; margin-left: 10rpx; } .weui-tab__content-item3-detail { display: flex; justify-content: space-between; font-size: 26rpx; color: #a9a9a9; } .weui-tab__content-item3-detail-label { color: #d0a763; } .weui-tab__content-item3-gap image { width: 100%; height: 30rpx; } *.js tabs3Content: [ { title: '员工发明创造是否属于职务发明的认证标准?', content: '随着企业对知识产权在企业发展中核心竞争力的认识力提高，企业保护自身知识产权的意识不断增强，使其技术得......', datatime: '2018-03-05', reader: '2081', label: '知识产权' } ] 3.7 background-image 套用本地图片无效  返回目录 本节目前已有 1 个坑，有兴趣的小伙伴可以详看。  在小程序中，如果你使用 wxss，你是可以发现有 background-image 的提示的。但是，如果你设置它的背景图是本地图片，你会发现，它是不生效的。 解决方案： 在使用背景图片的时候用网络图片，就是用外链的形式，比如你将这张图片放到你的服务器，如：https://xxxx/xxx.jpg； 将背景图片使用编码base64进行转换，可以在这个网址进行 点我前往 转换，如：background-image: url(\"转换后得到的编码文本\")，如果多次使用的话可以将该值设置为全局变量，再在js文件进行引用即可。 使用 image 组件 + position 定位而不是使用 background-image 。 3.8 \\ 与 \\  返回目录 本节目前已有 1 个坑，有兴趣的小伙伴可以详看。  两者的区别是， 是一个组件，会在页面上做渲染； 不是一个组件，它仅仅是一个包装元素，只接受控制属性，不会在页面中做任何渲染。 所以，如果你仅仅是需要包裹，而不是渲染一个层，可以使用 提升性能。 3.9 搜索框  返回目录 本节目前已有 2 个坑，有兴趣的小伙伴可以详看。 3.9.1 margin-top 无法上浮  返回目录  首先，我们要实现的效果是：  然后， jsliang 的想法是： *.wxml 搜索产品 *.wxss .search { height: 100rpx; display: flex; flex-direction: column; justify-content: space-between; align-items: center; position: relative; } .search-product-input { background: #f5f5f5; width: 650rpx; height: 65rpx; border-radius: 30rpx; font-size: 30rpx; padding-left: 20rpx; } .search-placeholder { font-size: 26rpx; text-align: center; margin-top: -65rpx; z-index: 2; } .search-placeholder-icon { width: 24rpx; height: 24rpx; } .search-placeholder-text { margin-left: 10rpx; }  你注意到了吗？在 *.wxml 中， jsliang 设置了个空的 ，如果你把这个 去掉，你会惊奇地发现，它……下来了……  好吧，可能有其他的实现方式，但是如果你下次使用这种方式，注意上面这个坑~ 3.9.2 改造 WeUI 搜索框  返回目录  回头看了下 WeUI 的实现方式，发现跟我的思路是挺像的，关于 input 的实现方式，现在依据 WeUI ，成功实现了输入框：  源码奉上： *.wxml 0}}\" bindtap=\"clearInput\"> 搜索 取消 0}}\" class=\"weui-search-bar__submit-btn\" hidden=\"{{!inputShowed}}\" bindtap=\"searchInput\">搜索 *.js Page({ data: { inputShowed: false, inputVal: \"\" }, showInput: function () { this.setData({ inputShowed: true }); }, hideInput: function () { this.setData({ inputVal: \"\", inputShowed: false }); }, clearInput: function () { this.setData({ inputVal: \"\" }); }, inputTyping: function (e) { this.setData({ inputVal: e.detail.value }); } }) *.wxss .search { height: 100rpx; padding: 18rpx 30rpx; } .weui-search-bar { padding: 0; background-color: #fff; border-top: none; border-bottom: none; height: 64rpx; } .weui-search-bar__form { border: none; } .form-border { border: 1rpx solid #f5f5f5; background: #f5f5f5; } .weui-search-bar__label { background: #f5f5f5; border-radius: 30rpx; } .weui-search-bar__cancel-btn { font-size: 26rpx; background: rgb(8, 202, 186); color: #fff; padding: 2rpx 20rpx 0 20rpx; border-radius: 10rpx; } .weui-search-bar__submit-btn { font-size: 26rpx; background: rgb(8, 200, 248); color: #fff; padding: 10rpx 20rpx 0 20rpx; border-radius: 10rpx; } 3.10 微信小程序分享  返回目录 本节目前已有 1 个坑，有兴趣的小伙伴可以详看。  官方文档：地址 在这里，提醒广大小伙伴注意了，注意了，注意了！重要的事说三遍。 当你新建 page 的时候，微信 web 开发者工具会自动帮你添加分享事件: /** * 用户点击右上角分享 */ onShareAppMessage: function (res) { // 实现分享功能 return { title: this.data.productName, path: '/pages/indexProductDetail.js?productId=' + this.data.productId, imageUrl: this.data.videoImageSrc, success: (res) => { console.log(\"分享成功~\"); }, fail: (res) => { console.log(\"分享失败~\"); } } }  所以，如果你在前面定义了，它会在最下面偷偷帮你清空，然后你就觉得无法自定义分享事件…… 是的，jsliang 打死都不承认这是我自己的锅，新手注意！新手注意！！新手注意！！！ 3.11 border-box 设置  返回目录 本节目前已有 1 个坑，有兴趣的小伙伴可以详看。  熟知盒模型的小伙伴应该知道，盒模型有两种计算方式： box-sizing: border-box; box-sizing: content-box;  在 border-box 中，整个 view 的宽、高，包括 margin、padding、border。 而在 content-box 中，整个 view 的宽、高，则不包括上面元素。  如上图，如果一个 view ，你的代码如下： view { box-sizing: border-box; margin: 10rpx; width: 100rpx; height: 100rpx; padding: 10rpx; }  那么，你的整个宽高还是 100rpx。 但是，如果你的代码如下： view { box-sizing: content-box; margin: 10rpx; width: 100rpx; height: 100rpx; padding: 10rpx; }  那么，你的整个盒子宽高是 120rpx。  如果你在设计页面中，发现内容区被撑爆了，那么，请检查下现在的 border-box 是什么。 3.12 自定义选项卡  返回目录 本节目前已有 6 个坑，有兴趣的小伙伴可以详看。 3.12.1 WeUI 选项卡  返回目录  使用 WeUI 的导航条，首先需要引用 WeUI 的 CSS 样式：地址  下载 weui.wxss 并在 app.wxss 中引用即可 app.wxss /* 引用WeUI */ @import 'weui.wxss';  然后，我们直接往页面加入它的选项卡并根据项目需求修改其样式： *.wxml {{item}} 全部 已付款 待付款 *.wxss .tab { font-size: 26rpx; } .tab image { width: 173rpx; height: 29rpx; } .weui-navbar { border-top: 1rpx solid #efefef; border-bottom: 1rpx solid #efefef; } .weui-navbar__slider { background: #d0a763; width: 4em; } .weui-navbar__item.weui-bar__item_on { color: #d0a763; } .weui-tab__content { margin-bottom: 100rpx; } *.js var sliderWidth = 52; // 需要设置slider的宽度，用于计算中间位置 Page({ /** * 页面的初始数据 */ data: { // 选项卡导航 tabs: [\"全部\", \"已付款\", \"待付款\"], activeIndex: 1, sliderOffset: 0, sliderLeft: 0, }, // 选项卡切换 tabClick: function (e) { this.setData({ sliderOffset: e.currentTarget.offsetLeft, activeIndex: e.currentTarget.id }); }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { // 计算搜索框活跃条 var that = this; wx.getSystemInfo({ success: function (res) { that.setData({ sliderLeft: (res.windowWidth / that.data.tabs.length - sliderWidth) / 2, sliderOffset: res.windowWidth / that.data.tabs.length * that.data.activeIndex }); } }); } })  2018-11-15：新增一个 bug 修复，就是在第一个 tab 能流畅切换的情况下，第二个及其他的 tab，需要多次滑动才能上拉加载。这时候，只需要在 weui-tab__content 这个类新增三行代码就可以解决该问题： *.css .weui-tab__content { padding: 30rpx 30rpx 0; box-sizing: border-box; height: 100%; overflow: hidden; } 3.12.2 自定义选项卡效果与实现  返回目录  自定义选项卡的代码实现：  实现效果图如下：  实现代码如下： *.wxml {{item.label}} {{item.title}} 发布时间：{{item.datatime}} 生效时间：{{item.effectiveTime}} *.wxss .weui-tab__nav { background: #f5f5f5; border: 1rpx 0rpx solid #e6e6e6; height: 90rpx; padding: 17rpx 41rpx; display: flex; justify-content: space-between; } .weui-tab__nav text { border-radius: 56rpx; height: 56rpx; line-height: 56rpx; padding: 15rpx 23rpx; font-size: 26rpx; font-weight: bold; } .weui-tab__nav-active { color: #fefefe; background: #d0a763; } .weui-tab__content-item2 { display: flex; justify-content: space-between; padding: 25rpx 30rpx; } .weui-tab__content-item-descritpion { display: flex; justify-content: space-between; } .weui-tab__content-item-descritpion image { width: 60rpx; height: 70rpx; } .hide { display: none; } .weui-tab__content-item-descritpion-content { margin-left: 26rpx; } .weui-tab__content-item-descritpion-content-title { font-size: 28rpx; font-weight: bold; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 1; -webkit-box-orient: vertical; } .weui-tab__content-item-descritpion-content-datatime { font-size: 22rpx; color: #bbb; } .weui-tab__content-item-descritpion-content-datatime1 { margin-right: 35rpx; } .weui-tab__content-item-download-state image { width: 64rpx; height: 64rpx; } *.js data: { tabs2Nav: [ { id: '1', label: '法律大全', state: 1 }, { id: '2', label: '合同模板', state: 0 }, { id: '3', label: '民事', state: 0 }, { id: '4', label: '行政', state: 0 }, { id: '5', label: '执行', state: 0 } ], tabs2Content: [ { title: '中华人名共和国民用航空法(2015年...).doc', url: 'https://wxmcard.imusic.cn/testfordocdownload.doc', datatime: '2018-01-26', effectiveTime: '2018-01-26', type: '1' }, { title: '原生申诉表格.xls', url: 'https://wxmcard.imusic.cn/testfordocdownload.doc', datatime: '2018-01-26', type: '2' }, { title: '法律常识大汇集及范例.ppt', url: 'https://wxmcard.imusic.cn/testforpptdownload.pptx', datatime: '2018-01-26', effectiveTime: '2018-01-26', type: '3' }, { title: '事业单位法律基础知识总结.pdf', url: 'https://wxmcard.imusic.cn/testforpdfdownload.pdf', datatime: '2018-01-26', effectiveTime: '2018-01-26', type: '4' } ], // 选项卡第二屏分组 tabs2Content1: [ { title: '中华人名共和国民用航空法(2015年...).doc', datatime: '2018-01-26', effectiveTime: '2018-01-26', type: '1' }, { title: '原生申诉表格.xls', datatime: '2018-01-26', type: '2' }, { title: '法律常识大汇集及范例.ppt', datatime: '2018-01-26', effectiveTime: '2018-01-26', type: '3' }, { title: '事业单位法律基础知识总结.pdf', datatime: '2018-01-26', effectiveTime: '2018-01-26', type: '4' } ], tabs2Content2: [ { title: '合同模板.doc', datatime: '2018-01-26', effectiveTime: '2018-01-26', type: '1' } ], tabs2Content3: [ { title: '民事合同模板.doc', datatime: '2018-01-26', effectiveTime: '2018-01-26', type: '1' } ], tabs2Content4: [ { title: '行政合同模板.doc', datatime: '2018-01-26', effectiveTime: '2018-01-26', type: '1' } ], tabs2Content5: [ { title: '执行合同模板.doc', datatime: '2018-01-26', effectiveTime: '2018-01-26', type: '1' } ] }, // 选项卡2切换 tabs2NavClick: function(e) { var that = this; console.log(\"完整的数据是：\"); console.log(that.data.tabs2Nav); console.log(\"点击的标签是：\"); console.log(e.currentTarget.dataset.labelid); var newTabs2Content; console.log(\"正在经历的标签是：\"); for(var i=0; i 3.12.3 绑定事件如何传递数据  返回目录  绑定事件如何传递数据： 如果学过 Vue 的同学，应该知道 Vue 的数据传递形式是： @click='tabs2NavClick(item.id)' 那么，在微信小程序中，你千万记得，绑定时间的传递参数的方式不是这样子的，而是： {{item.label}}  通过 data-*=\"{{item}}\" 的形式传递的~然后你需要在 js 中，通过 e.currentTarget.dataset.labelid 来获取。 3.12.4 不允许驼峰  返回目录  然后，注意了，这里还有个小 bug。在代码中，我们使用的是 data-labelId=\"{{item.id}}\"，而获取数据的时候，我们获取的是 labelid，是的，驼峰不见了~  参考链接：链接 3.12.5 获取 data 数据  返回目录  如何在方法中获取 data 中定义的数据： 如果我想在选项卡切换的方法 tabs2NavClick 中获取 data 里面的数据，那么我应该怎么做呢？ 是的，通过: tabs2NavClick: function(e) { var that = this; console.log(that.data.tabs2Nav); }  这种形式，我们就可以获取到 data 中的数据。 参考链接：链接 3.12.6 实现文字省略  返回目录  如何实现文字省略： 加入你有一段文本，你想让页面根据自身宽度，自动省略多余长度，那么，我们可以设置下面的 css 代码，从而实现文字省略效果（不使用 js 的原因，是因为 js 没有 css 那么灵活） text { overflow:hidden; text-overflow:ellipsis; display:-webkit-box; -webkit-line-clamp:1; -webkit-box-orient:vertical; }  参考链接：链接 3.13 黑科技：\\  返回目录 本节目前已有 2 个坑，有兴趣的小伙伴可以详看。 3.13.1 被遗弃的 \\  返回目录  一个坑就是一个故事。 故事都有四元素：时间，地点，人物，事情。 前三个自不必说，我们直接讲事情经过：我们项目的负责人需要一个留言弹窗，然后里面有个文本框可以填信息，最后点击【留言】按钮将数据传到后端，点击【取消】按钮关闭弹窗。 需求是不是很简单~既然微信小程序有自己的官方文档。那么，怎么方便怎么来吧，于是 jsliang 在微信小程序中搜索关键字 弹窗：  看了下搜索记录，最匹配的就是上面这个了。enm...好像没看到放文本框的？先试试：  额(⊙o⊙)…  不好意思打扰了，我去百度看看：链接  咦~ 它这里好像有个 标签？Ctrl+C、Ctrl+V 试试先~  Duang~~~这不就是我要的效果么，挖槽，黑科技？于是 jsliang 去小程序那里搜了下 modal ……enm...蜜汁尴尬，好像只有上面的 wx.showModal() 方法……于是 jsliang 满头黑线……好嘛，黑科技黑科技！！！ 下面贴出实现代码： *.wxml 写留言 *.js Page({ data: { // 弹窗 hiddenmodalput: true, //可以通过hidden是否掩藏弹出框的属性，来指定那个弹出框 }, //点击按钮指定的hiddenmodalput弹出框 modalinput: function () { this.setData({ hiddenmodalput: !this.data.hiddenmodalput }) }, //取消按钮 cancel: function () { this.setData({ hiddenmodalput: true }); }, //确认 confirm: function () { wx.showToast({ title: '留言成功！', }) this.setData({ hiddenmodalput: true }) } })  好的，上面就实现了一个简单的可填写文本的弹窗了。 3.13.2 四种弹窗写法  返回目录  作为一枚职业填坑人，怎么能满足于上面的两种弹窗形式呢！于是，使用百度大法又找到了一篇填坑文：链接  所以，总结下就有了四种弹窗写法： 类型 说明 地址 模态弹窗 wx.showModal(Object) - 模态弹窗就是上面的第一种弹窗，它可以给你选择【取消】或者【确定】 链接 \\ \\是上面的第二种弹窗，可以提供用户填写 链接 消息弹窗 wx.showToast(Object) - 消息弹窗就是操作成功或者操作失败的那一刻，系统的提示弹窗，无需用户操作，可设定几秒自动关闭 链接 操作菜单 wx.showActionSheet(Object) - 操作菜单类似于弹出的下拉菜单，提供你选择其中某项或者【取消】 链接  在这里，就讲完了微信小程序的四种弹窗形式了。如果你改样式改的烦啊烦的，可能你需要封装一个属于自己的弹窗？嘿嘿，说不定你的产品经理会有兴趣让你开发一个 beautiful 弹窗的~ 这坑我不填，我没碰到~碰到了再说！在这里预留下这个坑，哈哈。 3.14 小程序解析 HTML  返回目录 本节目前已有 6 个坑，有兴趣的小伙伴可以详看。 3.14.1 解析 HTML 的三种方法  返回目录  在小程序的文章处理中，文章的主体内容，一般来说，后端会采用富文本的形式存储数据到数据库。就是说，你要在 view 中展示 html 变迁。但是，你知道的，小程序不采用浏览器的那一套，所以，你可能需要兜圈子了：链接  在上面这篇文章中，讲述了三种解析富文本的方法： wxParse 解析富文本 rich-text 解析富文本 web-view 解析富文本 3.14.2 wxParse  返回目录  在百度大法的渲染下，jsliang 采用了 wxParse。  Github 的 wxParse 地址：链接  使用方法很简单，照着它 GitHub 地址去撸就是了。然而，坑不是那么容易填的 o(╥﹏╥)o  （ bug1 ）wxParse 在其神秘源码中，会将你的 html+css 样式弄乱，例如：px 要转成 rpx，才能在小程序中正常显示，如果你不处理……enm...你试试~  （ bug2 ）然后，如果你突然发现，内容无法显示，那么，恭喜你又触发了 bug，这个是 wxParse 代码的一个 bug,在一些特殊的手机里面，在 wxparse/html2json.js 中的第 112 和 119行，都有一个 console.dir() 这个函数的使用，它使你的内容不能正常显示了。把这个函数注释掉，内容就可以正常显示出来了。 if (name == 'class') { // console.dir(value); // 112 行 // value = value.join(\"\") node.classStr = value; } // has multi attibutes // make it array of attribute if (name == 'style') { // console.dir(value); // 119行 // value = value.join(\"\") node.styleStr = value; }  （ bug3 ）如果你需要引用图片，那么，你会发现引用不成功。这是因为，我们在网页后台编辑器里面上传的图片，是采用相对路径的，上传成绝对网络地址路径之后，换成域名，就没法很好的展示了。所以最好的方法，就是修改 html2json.js 这个文件，让 wxParse 自动添加域名前缀：地址  （ bug4 ）空格没法被正确替换，需要修改 wxDiscode.js 中的 strcharacterDiscode ： // 将原语句注释掉，替换为下面的语句 // str = str.replace(/&nbsp;/g, ' '); str = str.replace(/&nbsp;/g, '\\xa0');  （ bug5 ）如何干掉控制台 console 中 wxParse 的一大串输出： wxParse.js // 36行注释掉 console.log(JSON.stringify(transData, ' ', ' ')); // 41行注释掉 console.log(JSON.stringify(transData, ' ', ' '));  综上，jsliang 气得差口吐白沫了……换换换！有空要换成其他两种方式才行！！！ 3.14.3 rich-text  返回目录  jsliang 还未使用过 rich-text，这里先预留个坑。如果小伙伴们在开发 rich-text 过程中碰到过各种坑，可以跟 jsliang 提一下，我会写进这章节，顺带在章节尾写上你的大名，辛苦了~ 3.14.4 web-view  返回目录  jsliang 还未使用过 web-view，这里先预留个坑。如果小伙伴们在开发 web-view 过程中碰到过各种坑，可以跟 jsliang 提一下，我会写进这章节，顺带在章节尾写上你的大名，辛苦了~ 3.15 诡异的 open-type  返回目录 本节目前已有 1 个坑，有兴趣的小伙伴可以详看。  在小程序中，它有一些自定义的方法，例如 open-type ，是需要 来承接的。 所以，如果你写好了一个 view，里面有很好看的样式了，你本来打算用 bindtap 来搞事情的。但是，突然接到信息，需要外套一层 ，然后发现，样式需要重新跳过…… enm...加油不哭，重新写过样式吧~ 3.16 \\去样式及其内嵌\\  返回目录 本节目前已有 1 个坑，有兴趣的小伙伴可以详看。  就像上一章所说的，有时候，迫不得已，我们必须在 中内嵌个 或者 之类的，那么，一般怎么做呢？ 现在，假设我有一个 42*40 的图片，我来试试调下它的样式： *.wxml *.wxss .activity-user-action button { width: 42rpx; height: 80rpx; margin: 0; padding: 0; margin-top: -21rpx; background: #fff; } .activity-user-action button::after { border: none; } .activity-user-action image:last-child { width: 42rpx; height: 40rpx; }  如上，我们需要设置这个按钮的高度是图片高度的 2 倍，然后还需要设置 margin-top 的高度为图片高度的 1/2（注意 margin 与 margin-top 的顺序，如果你不知道顺序的重要性，推荐你使用 margin: -21rpx 0 0 0），同时 margin、padding、background、border 需要清空。 3.17 下拉刷新和上拉加载  返回目录 本节目前已有 2 个坑，有兴趣的小伙伴可以详看。  在浏览器中，有 F5 刷新，有鼠标滚轮滑动加载。 那么，换到微信小程序，又是怎样子的呢？ 是的，这就要说说用户下拉动作和上拉触底了：  下拉事件在小程序文档的解释：链接 2018-11-20 注意，该事件需要在 json 中设置： \"enablePullDownRefresh\": true /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () { },  上拉触底在小程序文档的解释：链接 /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () { },  这两个事件，都是在你新建 page 的时候，会自动添加的，小伙伴们注意下，免得前面写了，被后面的覆盖了哦~ 3.18 获取 input 的值  返回目录 本节目前已有 1 个坑，有兴趣的小伙伴可以详看。   获取电话号码  现在，假设我们在小程序中输入了一个 class 为 phone-number 的input 框，并且有一个 。那么，我们在微信小程序中，需要如何获取该 phone-number 的值呢？ 先在 中设置 name 为 phoneNumber 然后 data 中设置 phoneNumber: '' 接着 bindinput=\"phoneCodeInput' 再来设置 phoneCodeInput 方法来修改 this.data.phoneNumber 最后在 的绑定事件中获取 phoneNumber  步骤繁杂，下面贴出实现代码： *.wxml 获取验证码 *.js Page({ data: { // 输入的手机号码 phonenumber: '', }, // 获取手机号码 phoneNumberInput: function(e) { this.setData({ phonenumber: e.detail.value }) }, // 点击获取验证码 getPhoneNumber: function (e) { var phoneNumber = this.data.phonenumber console.log(phoneNumber); } })  在上面，我们仅仅是 获取 到了 input 的值。那么，我们要如何实现 动态修改 input 的值呢？  答案是：我们只需要将 value 的值设为 phoneNumber 就行了！  看到这里，如果有习惯 jQuery ，习惯操作 dom 节点的小伙伴可能会抱有很大疑惑：“它就不能像 jQuery 一样直接获取 dom 的内容么？” 答案是，有的：地址。但是，在这里， jsliang 并不推荐小伙伴这么做，想要学好一门新的技术，就不能因为旧的技术而限制了自己的观念。时代在进步，科技在发展，我们不学更多的知识，只能被淘汰在前端的潮流中。 3.19 onLaunch 加载问题与路由守卫  返回目录 本节目前已有 2 个坑，有兴趣的小伙伴可以详看。 3.19.1 小程序执行顺序  返回目录  这次的需求是：判断用户是否登录，如果登录了就跳转到首页，如果没登录就跳转到登录页。 我们都知道，在微信小程序中，有个 onLaunch 方法，微信小程序官方文档对其描述就是：每个页面进来需要先加载 onLaunch 方法，再去执行其他方法。然后，在 jsliang 尝试设置在 onLaunch 中调用 wx.login()，却发现，index.js 的 onLoad 方法是先于 onLaunch 执行的，这导致我们没法预先获取到需要的信息： 先执行 index.js 的 onload 再才执行 app.js 中的 onLaunch  迫于无奈，jsliang 对其进行了百度：地址 。通过百度这篇文章发现，有两个解决方案： 设置启动页，成功再返回首页 使用 Promise 来进行进程管理  但是，由于 jsliang 对于 Promise 的做法，觉得其太过复杂，故新增了一个 page/login。 3.19.2 路由守卫  返回目录  那么，如何在用户进入首页阅读文章、查看产品之前，先对用户进行微信授权、账号登录呢？ 设置 onLogin 的 Storage，在 index.js 中的 onload 进行判断，如果用户未进行登录，则使用 wx.redirectTo() 跳转到登录页面： index.js onLoad: function (options) { if (!wx.getStorageSync('isLogin')) { wx.redirectTo({ url: '../login/login', }) } } 如果用户进行了登录，在登录时设置 onLogin 为 true。 login.js loginSubmit: function(e) { wx.setStorageSync('isLogin', true); }  这样，我们就做到了路由守卫，即你不登录，不给跳转到首页。 3.20 request 封装与 api 抽离  返回目录 本节目前已有 1 个坑，有兴趣的小伙伴可以详看。  在 Ansen江 的推荐下，参照 Ansen江 的 api.js，对我这边的小程序接口 request 进行了 promise 封装，并做了 api.js 的分离。 api.js /* * @Author: jsliang * @Date: 2018-10-11 09:11:26 * @LastEditors: jsliang * @LastEditTime: 2018-10-11 09:11:29 * @Description: 接口文件 */ // 引入请求头文件 import header from './header.js'; // 加载中 const Loading = { show() { wx.showLoading({ title: '加载中' }); }, hide() { wx.hideLoading() } }; // 加载中白名单 const loadingWhite = [ 'index/index' ] // 将请求进行 Promise 封装 const fetch = ({url, data, header}) => { // 白名单地址会显示加载中状态 if(loadingWhite.includes(url)) { Loading.show(); } // 打印接口请求的信息 console.log(`【step1】API接口：${url}`); console.log(\"【step2】header请求头：\"); console.log(header); console.log(\"【step3】data传参：\"); console.log(data); // 返回 Promise return new Promise((resolve, reject) => { wx.request({ url: getApp().globalData.api + url, header: header, data: data, success: res => { Loading.hide(); // 成功时的处理 if (res.data.code == 0) { console.log(\"【step4】请求成功：\"); console.log(res.data); return resolve(res.data); } else { wx.showModal({ title: '请求失败', content: res.data.message, showCancel: false }); } }, fail: err => { Loading.hide(); // 失败时的处理 console.log(err); return reject(err); } }) }) } /** * code 换取 openId * @data { * jsCode - wx.login() 返回的 code * } */ export const wxLogin = data => { return fetch({ url: \"tbcUser/getWechatOpenId\", header: header.newHeader(), data: data }) }  在上面进行了分离 api.js 后，接着在其他地方调用 api.js： login.js import { wxLogin } from \"../../utils/api.js\" // 登录 wx.login({ success: res => { // 发送 code ，获取 openId console.log(\"\\n【API：获取 openId】\"); wxLogin({ jsCode: res.code }).then( res => { console.log(\"【step5】返回成功处理：\"); console.log(res); }, err => { console.log(\"【step5】返回失败处理：\"); console.log(err); } ) } })  输出结果：  这样，我们就成功做了 request 的封装，并通过调用 api.js 的形式，分离了代码，从而更方便地进行编程。 3.21 判断数据是否读取完  返回目录 本节目前已有 1 个坑，有兴趣的小伙伴可以详看。  在页面布局中，我们经常使用列表展示，然后在列表展示上，有时候该列表的最后一条数据下面是没有下划线或者虚线的。 那么，当数据读取到最后一条的时候，如何判断已经到了最后一条，不再展示下划线或者虚线呢？ 方法一 *.wxml {{item.recommendTitle}} {{item.recommendDescription}} {{item.userCount}}人在用 ￥{{item.productPrice}}  在这里，我们对要循环的对象使用 wx:for-index=\"index ，即：  然后，我们在下划线/点虚线位置进行 class 判断，如果 index+1 == topRecommended.length，那么我们就换一个样式：class=\"{{(index+1) == topRecommended.length ? 'class1' : 'class2'}}\"，即：  这样，我们就做到了判断是否处于最后一条数据，从而通过 class 来隐藏下划线或者虚线。 方法二  通过 CSS 的 last-child { ... }，可以直接修改最后的 view样式： *.wxss .content-item-gap:last-child { display: none; }  这样，就不需要复杂的 JS 逻辑，从而实现最后一个下划线的显示影藏。 如果你想了解下 last-child 为何物：链接 3.22 客服系统研究  返回目录 本节目前已有 1 个坑，有兴趣的小伙伴可以详看。  在微信小程序中，客服系统也是个相当诡异的玩意。 目前实现： *.wxml 在线咨询 能够进行正常的通讯 能够发送产品信息给客服  但是，这不能满足我的要求： 不能修改对话框的标题（查的资料标明需要进行小程序配置后后端返回？来源地址） 暂时无法验证是否能实现客服点击用户分享的产品卡片，跳转到小程序对应的产品页面上。  这些，都需要我们的小程序发布后进行验证。 3.23 文件在线预览  返回目录 本节目前已有 2 个坑，有兴趣的小伙伴可以详看。  话不多说，先丢出实现代码： *.wxml 点我下载 *.js Page({ data: { downloadUrl: '网上随便找一个下载地址' }, downloadFile: function(e) { // 获取传递过来的下载地址 var url = e.currentTarget.dataset.url; // 调用下载 API wx.downloadFile({ url: url, success: function (res) { console.log(\"下载文件成功\"); console.log(res); var tempFilePath = res.tempFilePath; // 在线预览文档 wx.openDocument({ filePath: tempFilePath, success: res => { console.log(\"打开成功\"); }, fail: res => { console.log(res); }, complete: res => { console.log(res); } }) }, fail: function () { console.log(\"下载失败\"); } }) } })  然后，在下载的时候，后端小伙伴偷懒，上传的是没有数据的 Word、PPT，这时候，小程序会报：openDocument:fail filetype not supported 的 error，所以小伙伴们要注意下。 3.24 尽量使用 ES6  返回目录 本节目前已有 1 个坑，有兴趣的小伙伴可以详看。  由于 jsliang 平时都是使用 ES5 ，一直口嚷嚷说要步入 ES6 大堂，但是一直就是没入门，所以乘着有功夫，尽量使用 ES6 ，用熟了才能进步。  绑定方法写法修改： 原写法： getUserPhone: function(e) { console.log(e); } 现写法： getUserPhone(e) { console.log(e); }  循环写法： 原写法 for(var i = 0; i 新写法 for (let i of array) { console.log(i); } 3.25 视频功能实现  返回目录 本节目前已有 1 个坑，有兴趣的小伙伴可以详看。  官方地址：地址  官方实现效果：  项目实现效果：  从图中可以看出，我们大概要实现3个步骤： 调整 CSS，使 Video 占满 100% 的宽，并且居顶。 调整 HTML+CSS，使图片覆盖住视频。 编写 JS，使图片点击时，隐藏图片，播放视频。 *.wxml *.wxss /* 设置视频宽高 */ video { width: 100%; height: 420rpx; } /* 隐藏遮罩层 */ .hide-video-mask { display: none; } /* 遮罩层 */ .video-mask { width: 100%; height: 420rpx; position: absolute; top: 0; left: 0; z-index: 8; } /* 遮罩层图片 */ .video-image { width: 100%; height: 420rpx; position: absolute; top: 0; left: 0; z-index: 9; } /* 遮罩层播放按钮 */ .video-button { width: 98rpx; height: 98rpx; position: absolute; top: 50%; left: 50%; margin-top: -49rpx; margin-left: -49rpx; z-index: 99; } *.js Page({ data: { // 视频字段 // videoSrc: 'http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&bizid=1023&hy=SH&fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400', videoSrc: '', videoImageSrc: '', showVideo: true, }, /** * 播放视频 */ playVideo: function () { var that = this; that.setData({ showVideo: false }); // videoContext 的定义在 onReady 上 this.videoContext.play(); }, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () { this.videoContext = wx.createVideoContext(\"video\") }, })  如上，实现了视频播放。 3.26 多层 for 循环  返回目录 本节目前已有 1 个坑，有兴趣的小伙伴可以详看。  作为一个 曾经的 Vuer，昨儿收到任务，要处理下面的数据： 代码片段 contactsData: [ { groupName: 'A', users: [ { userName: \"啊杰\", userPhone: '18933338765' } ] }, { groupName: 'L', users: [ { userName: \"李淑芬\", userPhone: '18925781396' } ] } ]  于是，jsliang 脑抽，直接：  不出意外失败了，回顾起来有点笑喷。^_^ 那么问题来了，在小程序中，如何进行多次数据遍历循环输出呢？ 代码片段 *.js contactsData: [ { groupName: 'A', users: [ { userName: \"啊杰\", userPhone: '18933338765' } ] }, { groupName: 'L', users: [ { userName: \"李淑芬\", userPhone: '18925781396' } ] } ] *.wxml {{contactsData.groupName}} {{userInfo.userName}} {{userInfo.userPhone}}  如上，在设计数据的多层嵌套时，我们要多层遍历输出数据，应该利用 wx-for-item 的使用，它可以帮助我们进行变量的重命名。在单层数据中，我们使用： {{item.name}}  然而，我们如果执行第二层及以上的 wx:for。那么，使用 item 就导致他们冲突了，所以应该通过 wx-for-item 重命名要循环的数据： {{student.studentGroup}} {{studentInfo.studentName}} 3.27 拼音导航  返回目录 本节目前已有 1 个坑，有兴趣的小伙伴可以详看。  在项目的开发中，jsliang 碰到了联系人列表的开发需求。话不多说，直接上手： *.wxml {{item}} *.wxss .pinyin-nav { font-size: 28rpx; line-height: 28rpx; position: fixed; right: 10rpx; top: 9%; height: 80%; text-align: center; } .pinyin-nav-byte { display: inline-block; width: 30rpx; border-radius: 20rpx; padding: 5rpx 5rpx; margin-top: 3rpx; color: #fff; background: rgb(129, 212, 238); } *.js Page({ /** * 页面的初始数据 */ data: { // 导航字母 letters: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'], }, // 拼音导航 pingyinNav(e) { console.log(e.currentTarget.dataset.byte); }, })  在上面的代码中，jsliang 做了三件事： 编写 Wxml 结构，由于只有一层 view 在循环的时候，在控制台看到的 Wxml 结构并不好看，所以循环的是第二层 view，这样就形成下面的效果： ... 编写 Wxss 定位，jsliang 对 Wxml 进行了 position: fixed 的绝对定位，这样就可以将它固定在右侧。 最后，在 js 中定义了遍历的数据（字母 A-Z）及点击字母的时候，将该字母传递过来并打印。  在昨晚上面的基础环境搭建后，我们需要实现下拉、上拉的功能，这两个功能在微信小程序中有定义，这里就不做过多讲解：onPullDownRefresh、onReachBottom。下面我们重点讲解下点击字母滚动到对应页面： 代码片段 onLoad: function (options) { console.log(\"\\n成员管理页：\"); // 设备信息 wx.getSystemInfo({ success: res => { console.log(\"\\n设备信息为：\"); console.log(res); let equipmentOneRpx = 750 / res.windowWidth; console.log(\"换算信息：1rpx = \" + equipmentOneRpx + \"px\"); this.setData({ equipmentOneRpx: equipmentOneRpx }) }, }) }, 参考资料  我们在 onLoad 中获取到用户设备的信息，然后计算出 1rpx 等于多少 px。在 iphone6 中，1rpx = 2px。我们只需要将 css 中写的样式高度 / 比例，就能动态计算我们的高度。 这里讲解不甚清楚，有空将开启一篇新文章进行讲解。 四 网友补充  返回目录  这章主要讲解小伙伴们发现的 bug 及其解决思路，有兴趣的小伙伴可以私我QQ：1741020489，我将把你提出的 bug 写进这篇文章并附上你的大名（看个人意愿），谢谢小伙伴们的支持~ 注：小伙伴们提出的 bug，如果包含详细的问题描述和解决方案，我会统计进该文章的 bug 清单。 4.1 文件夹读取报错  返回目录 本组件目前已有 ? 个坑，有经验的小伙伴可以进行补充。  问题提出者：掘金 史前图腾。 问题反馈：wx.getFileSystemManager().readdir 文件夹读取 api 报错，但仍会返回结果。 问题解决：这个 api 作用是读取某个目录下的文件名，正常会返回文件名数组，但是现在 IDE 在返回数据之前会报 'indexOf' 未定义的错误，并不影响api 使用。我看官方论坛上月就有人反应了，至今未修复。 4.2 textarea问题多多  返回目录 本组件目前已有 ? 个坑，有经验的小伙伴可以进行补充。  问题提出者：掘金 jilaokang。 问题反馈：textare问题非常多，补一个。 问题解决：已联系大佬，等待回复。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-21 10:15:43 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "},"other-library/WeChatApplet/WeChatAppletFunctionList.html":{"url":"other-library/WeChatApplet/WeChatAppletFunctionList.html","title":"微信小程序之奇技淫巧","keywords":"","body":"微信小程序之奇技淫巧 Create by jsliang on 2018-11-21 20:46:36Recently revised in 2018-11-25 00:24:14  Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 你们的 star 是我学习的动力！GitHub 地址  开篇点题： 这是一篇专研微信小程序各种功能实现的文章，例如布局、通讯录、组件之底部导航栏等…… 感觉不错的小伙伴，点赞点 Star走一波；感觉文章有误的小伙伴，评论区、QQ群 溜达一番。 虚心求教，不胜感激~  项目图： 一 目录  不折腾的前端，和咸鱼有什么区别 文章篇幅甚多，请利用好目录进行跳转！ 目录 一 目录 二 前言 三 功能列表  3.1 排兵布阵 - Flex布局   3.1.1 楼起平地 - 基础概念   3.1.2 搭砖建瓦 - 左右布局   3.1.3 层台累榭 - 混合布局  3.2 沙场点兵 - 通讯录   3.2.1 谋定苍生 - 整体布局   3.2.2 千里寻敌 - 搜索功能   3.2.3 遥控追踪 - 底部导航   3.2.4 拒敌长城 - 弹窗实现   3.2.5 卧薪尝胆 - 思路整理   3.2.6 广聚民心 - 新增功能   3.2.7 化繁为简 - 修改功能   3.2.8 革新去旧 - 删除功能   3.2.9 兵分一路 - 正常加载   3.2.10 兵分二路 - 拼音导航   3.2.11 一统天下 - 归纳总结 四 项目地址 二 前言 返回目录  写文章无形中也会磨炼自己的表达能力。 这周 (2018-11-19) 在开发微信小程序的定制 通讯录 时，突然发现 微信小程序 bug 集中营 这篇文章不能再继续写了，因为它变得 臃肿、丑陋 且 难维护，就连我这个写作人都感慨：如果没有 Ctrl + F ，以及我的 目录 写得还不错，我真心不想再翻这篇文章。 为此，jsliang 单独开了一篇文章：微信小程序功能清单。用来记录小程序各种功能的实现，例如布局、通讯录、底部导航栏…… 然后嘛，为了能吸引小伙伴点进来瞅瞅，起个标新立异的标题吧：微信小程序之奇技淫巧。 三 功能列表 返回目录  为了小伙伴能快速了解代码中的意思，小伙伴可以去该 项目地址 下载代码到本地运行查看。  敲了再说  敲  看 一  一 遍  遍 ？  ？ 天  谁 差  都 地  可 别  以 ！  ！  顺带附上一些资源网站： Iconfont - 阿里巴巴矢量图标库 图片压缩 - TinyPNG 3.1 排兵布阵 - Flex布局 返回目录  如果你发现你的 CSS 水平还处于 float 布局，你会发现在小程序中你举步维艰，因为单单只用浮动布局，在小程序中它不好用。 所以，Flex 布局，是你的不二选择：布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。而 Flex 布局。又称弹性布局，可以简便、完整、响应式地实现各种页面布局。 网上较好的教程有： Flex 布局语法教程 | 菜鸟教程 Flex 布局教程：实例篇 | 阮一峰  如果你想全面了解 Flex，推荐去看上面的文章。 如果你已经了解 Flex 布局，点击 返回目录 寻找更多精彩！ 如果你想快速复习浏览 Flex 布局，那么，Here we go~  Flex 最终实现效果： 3.1.1 楼起平地 - 基础概念 返回目录  万丈高楼平地起，熟悉 Flex 需要先了解下面这 7 个 CSS 属性： /* 设置 Flex 模式 */ display: flex; /* 决定元素是横排还是竖着排，要不要倒序 */ flex-direction: column; /* 决定元素换行格式，一行排不下的时候如何排 */ flex-wrap: wrap; /* flex-flow = flex-direction + flex-wrap */ flex-flow: column wrap; /* 同一排下对齐方式，空格如何隔开各个元素 */ justify-content: space-between; /* 同一排下元素如何对齐，顶部对齐、中部对齐还是其他 */ align-items: center; /* 多行对齐方式 */ align-content: space-between;  下面我们详细分析这些元素的情况： flex-direction：决定主轴的方向 row - （默认）水平方向，起点在左端 row-reverse - 水平方向，起点在右端 column - 垂直方向，起点在上沿 column-reverse - 垂直方向，起点在下沿 display: flex; flex-direction: row | row-reverse | column | column-reverse; flex-wrap：一条轴线（一行）排不下时如何解决 nowrap - （默认）不换行 wrap - 换行，第一行在上方 wrap-reverse - 换行，第一行在下方 display: flex; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow：flex-flow = flex-direction + flex-wrap。即 flex-flow 是这两个属性的合集 row nowrap - （默认）水平方向，起点在左端，不换行 display: flex; flex-flow: || ;  详解参考 1 和 2 justify-content：定义项目在主轴上的对齐方式 flex-start - 左边对齐 flex-end - 右边对齐 center - 居中对齐 space-between - 两端对齐，空格在中间 space-around - 空格环绕 display: flex; justify-content: flex-start | flex-end | center | space-between | space-around; align-items：定义项目在交叉轴上如何对齐 flex-start - 顶部对齐，即文字图片等顶部同一条线上 flex-end - 底部对其，即文字图片等底部在同一条线上 center - 中间对其，即文字图片不管多高，都拿它们的中间放在同一条线上 stretch - 将文字图片充满整个容器的高度，强制统一 baseline - 将每项的第一行文字做统一在一条线上对齐 display: flex; align-items: flex-start | flex-end | center | stretch | baseline; align-content：定义多根轴线的对齐方式。如果只有一根轴线（只有一行），该属性不起作用 flex-start - 这几行顶部对齐 flex-end - 这几行底部对齐 center - 这几行居中对齐 stretch - 这几行进行扩展或者缩放，从而填满容器高 space-between - 这几行中间使用空格进行填充 space-around - 这几行两边及中间进行填充 display: flex; align-content: flex-start | flex-end | center | space-between | space-around | stretch; 3.1.2 搭砖建瓦 - 左右布局 返回目录  实现效果如下：  如图，这是我们要实现的左右布局效果。那么，在微信小程序要怎么做呢？ *.wxml 左右布局 GitHub 地址 查看详情 *.wxss .left-and-right-layout { padding: 0 30rpx; } .left-and-right-layout-floor-one { font-size: 32rpx; line-height: 32rpx; font-weight: bold; } .left-and-right-layout-floor-two { /* Flex 左右布局关键点 */ display: flex; justify-content: space-between; padding: 30rpx 0; font-size: 30rpx; line-height: 30rpx; border-bottom: 1rpx solid #ccc; } .left-and-right-layout-floor-two-right { color: deepskyblue; } 3.1.3 层台累榭 - 混合布局 返回目录  实现效果如下：  如图，这是我们要实现的混合布局效果，那么在微信小程序中要如何编程呢？ *.wxml 混合布局 微信小程序之奇技淫巧 作者：jsliang 查看详情 这是一篇专研小程序各种功能实现的文章，例如布局、通讯录、底部导航栏……如果你感觉不错，可以点赞点 Star；如果感觉有错，那就评论区溜达一番，虚心求教，不胜感激~ 2018-11-23 2018阅读 #小程序功能清单# *.wxss /* 混合布局 */ /* 混合布局包裹层 */ .mixed-layout { margin-top: 30rpx; padding: 0 30rpx 30rpx; } /* 混合布局第一层 */ .mixed-layout-floor-one { font-size: 32rpx; line-height: 32rpx; font-weight: bold; } /* 混合布局第二层 */ .mixed-layout-floor-two { /* 关键 Flex 布局 */ display: flex; justify-content: space-between; align-items: center; margin-top: 40rpx; font-size: 32rpx; border-bottom: 1rpx dotted #ccc; } .mixed-layout-floor-two-left { /* 左侧竖行排序 */ display: flex; flex-direction: column; } .mixed-layout-floor-two-left-title { font-weight: bold; } .mixed-layout-floor-two-left-author { margin-top: 10rpx; color: rgb(146, 138, 138); font-size: 30rpx; } .mixed-layout-floor-two-right { color: deepskyblue; } /* 混合布局第三层 */ .mixed-layout-floor-three { margin-top: 20rpx; font-size: 30rpx; line-height: 36rpx; color: rgb(110, 108, 108); text-indent: 1em; } /* 混合布局第四层 */ .mixed-layout-floor-four { /* 关键 Flex 布局 */ display: flex; justify-content: space-between; margin-top: 20rpx; font-size: 30rpx; line-height: 30rpx; } .mixed-layout-floor-four-classification { color: #d0a763; } 3.2 沙场点兵 - 通讯录 返回目录  不知道小伙伴们在日常开发中，有没有碰到各种稀奇古怪的功能效果，我们觉得不可思议，但是在项目经理的眼中它却是能 “满足客户需求” 的。 所以，拿到 “奇怪的” 需求清单的时候不要恐慌，我们仔细分析，总能找到它的破绽，从而完成我们的任务。  通讯录功能的开发如下： 开发时间：4 天 实现效果： 3.2.1 谋定苍生 - 整体布局 返回目录  工欲善其事，必先利其器。  首先，我们先将该页面命名为：addressList，并编写它的 json 门面： addressList.json { \"backgroundTextStyle\": \"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"通讯录\", \"navigationBarTextStyle\": \"black\" }  接着，我们明确需要实现的功能点： 搜索功能 弹窗新增功能 弹窗修改功能 删除功能 拼音导航功能 底部导航栏  然后，我们明确下页面布局：  如上图，它主要分三大块：头部、内容区、底部。 最后，我们根据功能实现及页面布局编写 wxml 的布局： wxml 骨架  如上，我们将页面分为 7 种情况，其中： 搜索功能 - part1、part2、part4、part5 弹窗新增功能 - part1、part3、part4、part5、part6 弹窗修改功能 - part1、part3、part4、part5、part7 删除功能 - part1、part3、part4、part5 拼音导航功能 - part1、part3、part4、part5 底部导航栏 - part1、part3、part4、part5  请注意，出现的 part 部分表明在这种模式下，页面要显示的 part 都有哪些，其他的则暂时隐藏，而加粗的意味着这是这个功能特有的部分。为此，我们应该在 js 的 data 中定义好这些模式： js 代码片段 Page({ data: { /** * 功能模式 * normalModel - 正常模式 * addModel - 新增模式 * editModel - 修改模式 * deleteModel - 删除模式 * searchModel - 搜索模式 * pinyinNavModel - 拼音导航模式 */ normalModel: false, addModel: false, editModel: false, deleteModel: false, searchModel: true, pinyinNavModel: false, } })  这样，我们除了底部导航栏外，为其他功能定义了一个模式，正常情况下我们开启 normalModel，其他暂时关闭。 在下文中，我们将根据模式的开启与关闭，显示/隐藏某些内容，并进行数据的管理，请小伙伴们稍微理解下这种思路。 3.2.2 千里寻敌 - 搜索功能 返回目录 查看 wxml 代码：Go to wxml 查看 wxss 代码：Go to wxss 查看 js代码`：Go to js  本章节实现效果：  实现思路、编码及代码讲解： addressList.wxml 在 wxml 与 wxss 结构上。  首先，我们通过 fixed 定位，将 search-form 固定在顶部。 然后，我们将 search-form 其内部分为 搜索区 search 与 功能区 action。 接着，我们将 search 分为 假的搜索区 search-model-one 与 真的搜索区 search-model-two。为什么要分两种情况呢？因为这样我们就不用烦恼 input 的 placeholder 一会居中一会靠边要怎么区分，思路不容易乱。 最后，根据功能，我们逐步完善 wxml 与 wxss代码。 返回本节开头 搜索 0}}\" class=\"clear-input\" bindtap=\"clearInput\">× 取消 0}}\" class=\"search-model-two-button search-model-two-button-submit\" bindtap=\"searchSubmit\">搜索 添加 删除 完成 {{item.userName}} {{item.userPhone}} addressList.wxss 返回本节开头 /* 全局样式 */ view { box-sizing: border-box; } .icon { width: 32rpx; height: 32rpx; } /* 搜索区域 */ .search-form { display: flex; justify-content: space-around; width: 100%; height: 100rpx; font-size: 32rpx; padding: 0 30rpx; /* 绝对定位 - 固定搜索部分 */ position: fixed; top: 0; left: 0; background: #fff; } /* 搜索区域 - 结构 1 */ .search { width: 60%; } .search-model { height: 70rpx; line-height: 50rpx; padding: 10rpx 0; } .search-model-one { margin: 15rpx 0; background: #f5f5f5; text-align: center; border-radius: 50rpx; } .search-model-one-text { margin-left: 30rpx; color: #9b9b9b; font-size: 30rpx; } .search-model-two { position: relative; display: flex; margin-top: 6rpx; } .search-model-two-icon { position: absolute; left: 20rpx; top: 30rpx; z-index: 10; } .search-model-two-form { width: 69%; height: 70rpx; background: #f5f5f5; position: relative; } .search-model-two-input { padding: 0 65rpx 0 65rpx; height: 70rpx; font-size: 30rpx; } .clear-input { position: absolute; right: 10rpx; top: 15rpx; display: inline-block; width: 30rpx; height: 30rpx; line-height: 30rpx; text-align: center; padding: 5rpx; color: #fff; background: #ccc; border-radius: 20rpx; z-index: 10; } .search-model-two-button { display: inline-block; text-align: center; width: 90rpx; height: 60rpx; line-height: 60rpx; font-size: 24rpx; padding: 5rpx 15rpx; margin-left: 10rpx; color: #fff; } .search-model-two-button-cancel { background: rgb(8, 202, 186); } .search-model-two-button-submit { background: rgb(8, 200, 248); } /* 搜索区域 - 结构2 */ .action { width: 39%; } .action-button { display: inline-block; text-align: center; width: 90rpx; height: 60rpx; line-height: 60rpx; font-size: 24rpx; margin-top: 15rpx; padding: 5rpx 15rpx; border: 1rpx solid deepskyblue; border-radius: 40rpx; } .action-add, .action-delete, .action-delete-comfirm { margin-left: 10rpx; } .action-delete-comfirm { color: #d0a763; border: 1rpx solid #d0a763; } /* 搜索结果 */ .search-result { margin-top: 100rpx; } .search-result-item { box-sizing: border-box; height: 120rpx; display: flex; justify-content: space-between; align-items: center; padding: 27rpx 60rpx 27rpx 30rpx; border-bottom: 1rpx solid #f3f3f3; } .search-result-item-left { display: flex; flex-direction: column; } .search-result-item-left-name { font-size: 30rpx; color: #333333; } .search-result-item-left-phone { font-size: 26rpx; color: #999999; } .search-result-item-right image { width: 32rpx; height: 32rpx; } .search-result-item-right-edit { margin-right: 30rpx; } .search-result-item-right-delete { margin-right: 30rpx; } addressList.js 在 js上。  我们仔细观察本节开头的 GIF 图，发现它有这几个特点： 点击假的搜索区，进入真的搜索区 输入内容，按钮由【取消】变为【搜索】 点击【搜索】按钮，页面显示搜索内容 上拉加载更多数据 点击 × 按钮，输入内容消失 点击【取消】按钮，关闭搜索页面 返回本节开头 Page({ /** * 页面的初始数据 */ data: { /** * 功能模式 * normalModel - 正常模式 * addModel - 新增模式 * editModel - 修改模式 * deleteModel - 删除模式 * searchModel - 搜索模式 * pinyinNavModel - 拼音导航模式 */ normalModel: true, addModel: false, editModel: false, deleteModel: false, searchModel: false, pinyinNavModel: false, /** * 搜索功能 * inputFocus - 搜索框聚焦 * searchVal - 搜索内容 * searchData - 搜索结果 */ inputFocus: false, searchVal: '', searchData: [], }, /** * 搜索功能 * showSearch - 显示搜索框 * monitorInputVal - 监听搜索框的值 * searchSubmit - 提交搜索 * clearInput - 清除搜索 */ showSearch(e) { this.setData({ normalModel: !this.data.normalModel, searchModel: !this.data.searchModel, searchData: [], inputFocus: true }) }, monitorInputVal(e) { this.setData({ searchVal: e.detail.value }) }, searchSubmit(e) { console.log(\"\\n【API - 确认搜索】\"); console.log(\"搜素字段：\" + this.data.searchVal); // 原数据 let searchData = this.data.searchData; // 搜索数据 - 假设搜索数据是这个，实际应该是接口返回数据 let newSearchData = [ { userName: '阿狸', userPhone: '18811111111', pinyin: 'ali' }, { userName: '贝吉塔', userPhone: '18822222222', pinyin: 'beijita' }, { userName: '楚怡', userPhone: '18833333333', pinyin: 'chuyi' }, { userName: '邓婕', userPhone: '18844444444', pinyin: 'dengjie' }, { userName: '尔康', userPhone: '18855555555', pinyin: 'erkang' }, { userName: '福狸', userPhone: '18866666666', pinyin: 'fuli' }, { userName: '古狸', userPhone: '18877777777', pinyin: 'guli' }, { userName: '哈狸', userPhone: '18888888888', pinyin: 'hali' }, { userName: 'i狸', userPhone: '18899999999', pinyin: 'ili' }, { userName: '激狸', userPhone: '18800000000', pinyin: 'jli' }, ] // 拼接新旧数据 searchData.push(...newSearchData); console.log(\"\\搜索后数据：\"); console.log(searchData); this.setData({ searchData: searchData }) }, clearInput(e) { console.log(\"\\n清除搜索\"); this.setData({ searchVal: '' }) }, /** * 删除功能 */ showDelete(e) { this.setData({ deleteModel: !this.data.deleteModel }) }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { console.log(\"\\n通讯录\"); }, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () { if (this.data.normalModel) { // 正常模式上拉 console.log(\"\\n正常模式上拉\") } else if (this.data.searchModel) { // 搜索模式上拉 console.log(\"\\n搜索模式上拉：\"); // 新数据 let newSearchData = [ { userName: '克狸', userPhone: '18811121112', pinyin: 'keli' }, ] // 原数据 let searchData = this.data.searchData; // 拼接新旧数据 searchData.push(...newSearchData); console.log(\"\\上拉加载后数据：\"); console.log(searchData); this.setData({ searchData: searchData }) } else if (this.data.pinyinNavModel) { // 拼音模式上拉 console.log(\"\\n拼音模式上拉\"); } }, })  到此，我们就实现了搜索功能。尽管它还有点小 bug，就是不停上拉的时候，它会重复地加载一条数据。 在实际项目中，jsliang 会定义一个 searchNoData 来判断接口是否还在返回数据，如果它不再返回数据，那么通过判断 searchNoData == true 来禁止继续加载。 这样，我们就完美搞定了搜索功能的实现。 3.2.3 遥控追踪 - 底部导航 返回目录  本章节实现效果：  众所周知，微信小程序的子页面（除了设置 tabBar 的页面）是没有底部导航栏的。那么，我们要如何设计，才能编写一个 自定义的底部导航栏 呢？ 在日常开发中，我们通过 fixed 布局，在页面实现一个 自定义的底部导航栏 是很容易的。 但是，考虑到其他页面可能也需要使用这个底部导航栏，我们就需要想办法将其封装成组件了：  微信小程序 - 自定义组件  是的，微信小程序官方文档中是存在这个东西的。当然，仅有官方文档，是满足不了我的，至于过程中我百度了几篇文章来辅助写出下面的代码，你猜？  下面贴出实现代码及如何使用： 建立目录。  首先，在根目录中新建 component 目录，用来存放我们项目的组件。 然后，我们新建 navBar 目录，用来存放我们的组件 navBar。 最后，我们新建 Component 为 navBar。 进行组件代码编写。 navBar.wxml 返回本节开头 首页 探索 我的 navBar.wxss 返回本节开头 /* 底部导航条 */ .navBar { display: flex; justify-content: space-around; box-sizing: border-box; width: 100%; height: 97rpx; padding: 5rpx 0; border-top: 1rpx solid #cccccc; position: fixed; bottom: 0; background: #F7F7FA; } .navBar image { width: 55rpx; height: 55rpx; } .navBar-item { display: flex; flex-direction: column; align-items: center; font-size: 20rpx; color: #999999; } .nor-active-text { padding-top: 5rpx; } .active-text { padding-top: 5rpx; color: #d0a763; } navBar.js 返回本节开头 Component({ /** * 组件的属性列表 */ properties: { homeActive: { type: Boolean, value: false }, exploreActive: { type: Boolean, value: false }, userActive: { type: Boolean, value: false } }, /** * 组件的初始数据 */ data: { }, /** * 组件的方法列表 */ methods: { // 返回首页 goHome: function (e) { wx.switchTab({ url: '../index/index', }) }, // 返回探索页 goExplore: function (e) { wx.switchTab({ url: '../explore/explore', }) }, // 返回我的 goUser: function (e) { wx.switchTab({ url: '../user/user', }) } } }) navBar.json 返回本节开头 { \"component\": true, \"usingComponents\": {} } 在需要引用的界面引用该组件 addressList.wxml addressList.json { \"backgroundTextStyle\": \"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"通讯录\", \"navigationBarTextStyle\": \"black\", \"usingComponents\": { \"navBar\": \"../../component/navBar/navBar\" } } addressList.js Page({ data: { // 引用底部导航 homeActive: true, } })  下次我们还需使用该底部导航栏的时候，我们只需要重复在 addressList 的步骤就行了。 当然，我们需要根据需要活跃的位置，进行 homeActive、exploreActive、userActive 这三个活跃状态与否的设置。 这样，我们就实现了底部导航栏组件的开发及引用。 3.2.4 拒敌长城 - 弹窗实现 返回目录  本章节实现效果：  弹窗？微信小程序就有啊，为啥不用它的呢？ 类型 说明 地址 模态弹窗 wx.showModal(Object) - 模态弹窗可以给你选择【取消】或者【确定】 链接 \\ \\是可以提供用户填写 链接 消息弹窗 wx.showToast(Object) - 消息弹窗就是操作成功或者操作失败的那一刻，系统的提示弹窗，无需用户操作，可设定几秒自动关闭 链接 操作菜单 wx.showActionSheet(Object) - 操作菜单类似于弹出的下拉菜单，提供你选择其中某项或者【取消】 链接  然而，逐一尝试，你会发现，上面辣么多弹窗，没有一种符合你的需求的！所以，咱要画一个属于自己的弹窗：  首先，咱在 part6 中新增两个层：遮罩层 jsliang-mask 和弹窗内容 jsliang-alert。 然后，往弹窗内容中编写我们需要的标题、 input 输入框以及 text 按钮。 最后，我们逐一细化编写代码。 addressList.wxml 返回本节开头 添加成员 × 添加 addressList.wxss 返回本节开头 /* 弹窗-添加成员 */ .jsliang-mask { z-index: 998; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #404040; filter: alpha(opacity=90); -ms-filter: \"alpha(opacity=90)\"; opacity: 0.9; } .jsliang-alert { z-index: 999; position: fixed; top: 15%; left: 9%; width: 620rpx; height: 580rpx; box-shadow: 2rpx 2rpx 4rpx #A0A0A0, -2rpx -2rpx 4rpx #A0A0A0; background-color: #fff; border-radius: 15rpx; } /* 弹窗标题 */ .jsliang-alert-title { height: 120rpx; line-height: 120rpx; color: #333333; background: #f8f0e3; font-size: 40rpx; font-weight: bold; text-align: center; position: relative; border-radius: 15rpx; } .jsliang-alert-title-close { display: inline-block; color: #999999; position: absolute; font-size: 50rpx; right: 40rpx; } /* 弹窗内容 */ .jsliang-alert-content { padding: 0 70rpx; } .jsliang-alert-content input { height: 120rpx; line-height: 120rpx; font-size: 30rpx; border-bottom: 1rpx solid #e6e6e6; } .jsliang-alert-content-user-name-placeholder, .jsliang-alert-content-user-phone-placeholder { font-size: 30rpx; color: #b6b6b6; } .jsliang-alert-content-user-phone { color: rgb(238, 227, 227); } .jsliang-alert-submit { font-size: 30rpx; margin: 60rpx auto; text-align: center; width: 400rpx; height: 90rpx; line-height: 90rpx; color: #fff; background: deepskyblue; border-radius: 50rpx; }  这样，我们就可以通过控制 addModel 的 true 或者 false，来显示隐藏新增弹窗。 同理，我们可以依法炮制通过 editModel 控制修改弹窗。 3.2.5 卧薪尝胆 - 思路整理 返回目录  文章写到这里，我们需要整理下我们都完成了什么，还缺什么？  如上，我们实现了： 搜索功能 底部导航 弹窗显示  那么，我们还缺少： 新增成员功能 修改成员功能 删除成员功能 拼音导航功能  很好！我们实现了一半功能了！但是，小伙伴有没有发现，我们的主内容区是空白的。 所以，为了剩下的功能实现，我们应该编写下 内容区域，并进行页面的数据加载： addressList.wxml 返回本节开头 {{contactsDataItem.groupName}} {{usersItem.userName}} {{usersItem.userPhone}} addressList.wxss 返回本节开头 /* 联系人列表 */ .contacts-list { margin-top: 100rpx; margin-bottom: 120rpx; } .contacts-list-title { box-sizing: border-box; font-size: 24rpx; font-weight: bold; height: 44rpx; line-height: 44rpx; color: #b2b2b2; background: #f5f5f5; border-bottom: 1rpx solid #efefef; padding-left: 30rpx; } .contacts-list-user { box-sizing: border-box; height: 120rpx; display: flex; justify-content: space-between; align-items: center; padding: 27rpx 60rpx 27rpx 30rpx; border-bottom: 1rpx solid #f3f3f3; } .contacts-list-user-left { display: flex; flex-direction: column; } .contacts-list-user-left-name { font-size: 30rpx; color: #333333; } .contacts-list-user-left-phone { font-size: 26rpx; color: #999999; } .contacts-list-user-right image { width: 32rpx; height: 32rpx; } .contacts-list-user-right-edit { margin-right: 30rpx; } .contacts-list-user-right-delete { margin-right: 30rpx; } addressList.js 返回本节开头 Page({ data: { // 数据定义 contactsData: [ { groupName: 'A', users: [] }, { groupName: 'B', users: [] }, { groupName: 'C', users: [] }, { groupName: 'D', users: [] }, { groupName: 'E', users: [] }, { groupName: 'F', users: [] }, { groupName: 'G', users: [] }, { groupName: 'H', users: [] }, { groupName: 'I', users: [] }, { groupName: 'J', users: [] }, { groupName: 'K', users: [] }, { groupName: 'L', users: [] }, { groupName: 'M', users: [] }, { groupName: 'N', users: [] }, { groupName: 'O', users: [] }, { groupName: 'P', users: [] }, { groupName: 'Q', users: [] }, { groupName: 'R', users: [] }, { groupName: 'S', users: [] }, { groupName: 'T', users: [] }, { groupName: 'U', users: [] }, { groupName: 'V', users: [] }, { groupName: 'W', users: [] }, { groupName: 'X', users: [] }, { groupName: 'Y', users: [] }, { groupName: 'Z', users: [] } ], }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { console.log(\"\\n通讯录\"); let that = this; // 原数据 let oldData = that.data.contactsData; // 第一页数据 let newData = [ { userName: '阿狸', userPhone: '18811111111', pinyin: 'ali' }, { userName: '贝吉塔', userPhone: '18822222222', pinyin: 'beijita' }, { userName: '楚怡', userPhone: '18833333333', pinyin: 'chuyi' }, { userName: '邓婕', userPhone: '18844444444', pinyin: 'dengjie' }, { userName: '尔康', userPhone: '18855555555', pinyin: 'erkang' }, { userName: '福狸', userPhone: '18866666666', pinyin: 'fuli' }, { userName: '古狸', userPhone: '18877777777', pinyin: 'guli' }, { userName: '哈狸', userPhone: '18888888888', pinyin: 'hali' }, { userName: 'i狸', userPhone: '18899999999', pinyin: 'ili' }, { userName: '激狸', userPhone: '18800000000', pinyin: 'jli' }, ] // 循环新数据 for (let newDataItem in newData) { // 转换新数据拼音首字母为大写 let initials = newData[newDataItem].pinyin.substr(0, 1).toUpperCase(); // 循环旧数据 for (let oldDataItem in oldData) { // 获取旧数据字母分组 let groupName = oldData[oldDataItem].groupName; // 判断两个字母是否相同 if (initials == groupName) { // 使用 array[array.length] 将数据加入到该组中 oldData[oldDataItem].users[oldData[oldDataItem].users.length] = newData[newDataItem]; } } } console.log(\"\\页面初始加载数据：\"); console.log(oldData); that.setData({ contactsData: oldData }) } })  如上，我们在前几章节代码的前提下，将 part3 部分进行定义，并在 onLoad() 这个内置的页面加载函数中，虚拟了接口返回的第一页数据，最后将它循环判断，放在不同的字母中，从而实现了首页的加载。 所以，我们可以开始实现我们其他的功能咯~ 3.2.6 广聚民心 - 新增功能 返回目录  本章节实现效果：  如上图，我们实现了新增的功能。那么，它在代码中是如何实现的呢？  首先，我们要知道弹窗效果是如何出来的： addressList.wxml 代码片段 添加 删除 完成  然后，我们在 js 中设置弹窗事件： addressList.js 代码片段 showAdd(e) { this.setData({ addModel: !this.data.addModel }) },  是的，在这里，我们通过 addModel 的模式来控制弹窗，那么，弹窗要怎么编写呢？相信小伙伴在前一章了解过弹窗效果的实现，在这里我们为了连贯，再贴下实现新增弹窗的代码： addressList.wxml 代码片段 返回本节开头 添加成员 × 添加 addressList.wxss 代码片段 返回本节开头 /* 弹窗-添加成员 */ .jsliang-mask { z-index: 998; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #404040; filter: alpha(opacity=90); -ms-filter: \"alpha(opacity=90)\"; opacity: 0.9; } .jsliang-alert { z-index: 999; position: fixed; top: 15%; left: 9%; width: 620rpx; height: 580rpx; box-shadow: 2rpx 2rpx 4rpx #A0A0A0, -2rpx -2rpx 4rpx #A0A0A0; background-color: #fff; border-radius: 15rpx; } /* 弹窗标题 */ .jsliang-alert-title { height: 120rpx; line-height: 120rpx; color: #333333; background: #f8f0e3; font-size: 40rpx; font-weight: bold; text-align: center; position: relative; border-radius: 15rpx; } .jsliang-alert-title-close { display: inline-block; color: #999999; position: absolute; font-size: 50rpx; right: 40rpx; } /* 弹窗内容 */ .jsliang-alert-content { padding: 0 70rpx; } .jsliang-alert-content input { height: 120rpx; line-height: 120rpx; font-size: 30rpx; border-bottom: 1rpx solid #e6e6e6; } .jsliang-alert-content-user-name-placeholder, .jsliang-alert-content-user-phone-placeholder { font-size: 30rpx; color: #b6b6b6; } .jsliang-alert-content-user-phone { color: rgb(238, 227, 227); } .jsliang-alert-submit { font-size: 30rpx; margin: 60rpx auto; text-align: center; width: 400rpx; height: 90rpx; line-height: 90rpx; color: #fff; background: deepskyblue; border-radius: 50rpx; }  最后，我们完善 js 代码，获取 input 的值，动态新增到原数据中： addressList.js 返回本节开头 Page({ /** * 页面的初始数据 */ data: { /** * 新增功能 * addUserName - 新增的用户名 * addUserPhone - 新增的电话号码 */ addUserName: '', addUserPhone: '', }, /** * 添加功能 * showAdd - 显示/隐藏 新增弹窗 * getAddUserName - 双向绑定成员姓名 * getAddUserPhone - 双向绑定成员电话 * addConfirm - 确认添加 */ showAdd(e) { this.setData({ addModel: !this.data.addModel }) }, getAddUserName(e) { this.setData({ addUserName: e.detail.value }) }, getAddUserPhone(e) { this.setData({ addUserPhone: e.detail.value }) }, addConfirm(e) { console.log(\"\\n【API -添加成员】\"); let userName = this.data.addUserName; let userPhone = this.data.addUserPhone; if (userName == \"\") { // 不允许姓名为空 wx.showModal({ title: '添加失败', content: '姓名不能为空~', showCancel: false }) } else if (!(/^[\\u4e00-\\u9fa5a-zA-Z]{1,11}$/.test(userName))) { // 不允许非中文或者大小写英文 wx.showModal({ title: '添加失败', content: '请用中文或者大小写英文命名~', showCancel: false }) } else if (userPhone == \"\") { // 不允许电话号码为空 wx.showModal({ title: '添加失败', content: '电话号码不能为空~', showCancel: false }) } else if (!(/^1[345789]\\d{9}$/.test(userPhone))) { // 不允许电话号码不是 13/4/5/7/8/9 开头的 11 位数字 wx.showModal({ title: '添加失败', content: '请输入正确的 11 位电话号码~', showCancel: false }) } else { // 添加成功 // 新数据。假设后端接口返回的数据为 newData let newData = { userName: this.data.addUserName, userPhone: this.data.addUserPhone, pinyin: 'ali' } // 旧数据 let oldData = this.data.contactsData; // 获取新数据的首字母并转换为大写 let initials = newData.pinyin.substr(0, 1).toUpperCase(); // 循环旧数据 for (let oldDataItem in oldData) { // 获取旧数据字母 let groupName = oldData[oldDataItem].groupName; // 判断这两者字母是否相同 if (initials === groupName) { // 往该字母最后一位数据添加新数据 oldData[oldDataItem].users[oldData[oldDataItem].users.length] = newData; } } console.log(\"新增后数据：\"); console.log(oldData); this.setData({ contactsData: oldData, normalModel: true, addModel: false, addUserName: '', addUserPhone: '' }) } } })  到此，我们就实现了新增的功能！ 3.2.7 化繁为简 - 修改功能 返回目录  本章节实现效果：  在新增功能的开发后，我们的修改功能就显得比较容易了。 首先，我们整理下修改的思路： 用户点击按钮，传递数据给窗口：用户姓名、用户电话。 用户点击修改，循环遍历原数据，找到要修改的字母组下要修改的名字再进行修改，所以，单单是上面的两个字段还不够，应该有：用户所在组、用户原姓名、用户新姓名、用户电话。  所以，在 wxml 中我们应该这么写： addressList.wxml 代码片段 返回本节开头  然后，我们将新增的弹窗照搬过来并加入电话无法修改的效果： addressList.wxml 代码片段 返回本节开头 修改成员 × 修改 addressList.wxss 代码片段 返回本节开头 /* 弹窗-添加成员 */ .jsliang-mask { z-index: 998; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #404040; filter: alpha(opacity=90); -ms-filter: \"alpha(opacity=90)\"; opacity: 0.9; } .jsliang-alert { z-index: 999; position: fixed; top: 15%; left: 9%; width: 620rpx; height: 580rpx; box-shadow: 2rpx 2rpx 4rpx #A0A0A0, -2rpx -2rpx 4rpx #A0A0A0; background-color: #fff; border-radius: 15rpx; } /* 弹窗标题 */ .jsliang-alert-title { height: 120rpx; line-height: 120rpx; color: #333333; background: #f8f0e3; font-size: 40rpx; font-weight: bold; text-align: center; position: relative; border-radius: 15rpx; } .jsliang-alert-title-close { display: inline-block; color: #999999; position: absolute; font-size: 50rpx; right: 40rpx; } /* 弹窗内容 */ .jsliang-alert-content { padding: 0 70rpx; } .jsliang-alert-content input { height: 120rpx; line-height: 120rpx; font-size: 30rpx; border-bottom: 1rpx solid #e6e6e6; } .jsliang-alert-content-user-name-placeholder, .jsliang-alert-content-user-phone-placeholder { font-size: 30rpx; color: #b6b6b6; } .jsliang-alert-content-user-phone { color: rgb(238, 227, 227); } .jsliang-alert-submit { font-size: 30rpx; margin: 60rpx auto; text-align: center; width: 400rpx; height: 90rpx; line-height: 90rpx; color: #fff; background: deepskyblue; border-radius: 50rpx; } /* 弹窗-修改成员 */ .input-forbid { color: rgb(202, 196, 196); }  最后，我们在 js 中实现修改的功能： addressList.js 代码片段 返回本节开头 // pages/addressList/addressList.js Page({ /** * 页面的初始数据 */ data: { /** * 修改功能 * editOldUserName - 在哪组改动 * editOldUserName - 原名字 * editNewUserName - 新名字 * editUserPhone - 电话 */ editGroupName: '', editOldUserName: '', editNewUserName: '', editUserPhone: '', }, /** * 修改功能 * showEdit - 显示修改框 * getEditUserName - 双向绑定成员名 * getEditUserPhone - 双向绑定成员电话 * editConfirm - 确认修改 */ showEdit(e) { if (!this.data.editModel) { // 显示弹窗则传递数据 this.setData({ editModel: true, editGroupName: e.currentTarget.dataset.groupname, editOldUserName: e.currentTarget.dataset.username, editNewUserName: e.currentTarget.dataset.username, editUserPhone: e.currentTarget.dataset.userphone, }) } else { // 否则只控制弹窗隐藏 this.setData({ editModel: false }) } }, getEditUserName(e) { this.setData({ editNewUserName: e.detail.value }) }, editUserPhone(e) { this.setData({ editUserPhone: e.detail.value }) }, editConfirm(e) { console.log(\"\\n【API - 修改成员】\"); let userName = this.data.editNewUserName; let userPhone = this.data.editUserPhone; if (userName == \"\") { // 不允许姓名为空 wx.showModal({ title: '修改失败', content: '姓名不能为空~', showCancel: false }) } else if (!(/^[\\u4e00-\\u9fa5a-zA-Z]{1,11}$/.test(userName))) { // 不允许非中文或者大小写英文 wx.showModal({ title: '修改失败', content: '请用中文或者大小写英文命名~', showCancel: false }) } else { let contactsData = this.data.contactsData; // 循环遍历原数据 for (let groupInfo in contactsData) { // 找到原数据中的该字母组 if (this.data.editGroupName == contactsData[groupInfo].groupName) { // 遍历该组的用户名 for (let userInfo in contactsData[groupInfo].users) { // 找到原数据中相同的姓名 if (this.data.editOldUserName == contactsData[groupInfo].users[userInfo].userName) { // 修改它的姓名 contactsData[groupInfo].users[userInfo].userName = this.data.editNewUserName; console.log(\"新增后数据：\"); console.log(contactsData); this.setData({ contactsData: contactsData, editModel: false, normalModel: true }) wx.showToast({ title: '修改成功~', }) break; } } } } } } })  这样，我们就实现了弹窗修改功能！ 3.2.8 革新去旧 - 删除功能 返回目录  本章节实现效果：  如果有小伙伴是跟着前面章节一步一步走下来的，会发现我在写 搜索功能 的时候，写上了删除模式 deleteModel，可以唤出删除按钮： addressList.wxml 代码片段 返回本节开头 添加 删除 完成  它绑定了个 showDelete 的事件，来控制删除按钮的显示隐藏： addressList.js 代码片段 返回本节开头 showDelete(e) { this.setData({ deleteModel: !this.data.deleteModel }) }, addressList.wxml 代码片段 返回本节开头  然后，如何实现删除功能呢？我们需要传递什么数据给 js？ 字母组名 该项所在索引  我们只需要遍历原数据，找到对应的组，并根据传递过来的索引，删除该组中对应索引的值，我们就完成了删除的功能： addressList.js 代码片段 返回本节开头 Page({ /** * 删除功能 * showDelete - 显示/隐藏 删除图标 * showConfirm - 确认删除 */ showDelete(e) { this.setData({ deleteModel: !this.data.deleteModel }) }, deleteConfirm(e) { console.log(\"\\n【API - 删除用户\"); let userName = e.currentTarget.dataset.username; let groupName = e.currentTarget.dataset.groupname; let index = e.currentTarget.dataset.index; wx.showModal({ title: '删除确认', content: '是否删除成员【' + e.currentTarget.dataset.username + \"】?\", success: (e) => { if (e.confirm) { // 如果确认删除 console.log(\"删除成功!\"); // 原数据 let contactsData = this.data.contactsData; // 遍历原数据 for (let groupInfo in contactsData) { // 找到要删除成员所在的组 if (groupName == contactsData[groupInfo].groupName) { // 根据索引删除该条记录 contactsData[groupInfo].users.splice(index, 1); } } this.setData({ contactsData: contactsData }) wx.showToast({ title: '删除成功~', }) } else if (e.cancel) { // 如果取消 console.log(\"取消删除!\"); } } }) } }) 3.2.9 兵分一路 - 正常加载 返回目录  本章节实现效果：  写到这里，jsliang 终于可以松一口气了，咱离胜利不远了~ 现在，我们实现正常情况下的不断下拉加载：  正如我们在 搜索功能 实现章节中提及到的，我们分三种上拉模式：正常模式上拉、搜索模式上拉、拼音模式上拉： addressList.js 代码片段 page({ /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () { if (this.data.normalModel) { // 正常模式上拉 console.log(\"\\n正常模式上拉\"); } else if (this.data.searchModel) { // 搜索模式上拉 console.log(\"\\n搜索模式上拉\"); } else if (this.data.pinyinNavModel) { // 拼音模式上拉 console.log(\"\\n拼音模式上拉\"); } } })  那么，我们只需要参考 onLoad 中的正常加载方式，往正常模式中模拟数据，实现上拉效果，就 OK 了： addressList.js 代码片段 Page({ /** * 页面的初始数据 */ data: { /** * 上拉触底 * normalModelNoData - 正常模式没数据加载了 */ normalModelNoData: false, }, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () { if (this.data.normalModel) { // 正常模式上拉 console.log(\"\\n正常模式上拉\"); if (!this.data.normalModelNoData) { // 如果还有数据 // 新数据 let newData = [ { userName: '克狸', userPhone: '18811121112', pinyin: 'keli' }, { userName: '拉狸', userPhone: '18811131113', pinyin: 'lali' }, { userName: '磨狸', userPhone: '18811141114', pinyin: 'moli' }, { userName: '尼狸', userPhone: '18811151115', pinyin: 'nili' }, { userName: '噢狸', userPhone: '18811161116', pinyin: 'oli' }, { userName: '皮皮狸', userPhone: '18811171117', pinyin: 'pipili' }, { userName: '曲狸', userPhone: '18811181118', pinyin: 'quli' }, { userName: '任狸', userPhone: '18811191119', pinyin: 'renli' }, { userName: '司马狸', userPhone: '18811211121', pinyin: 'simali' }, { userName: '提狸', userPhone: '18811221122', pinyin: 'tili' } ] // 原数据 let oldData = this.data.contactsData; // 循环新数据 for (let newDataItem in newData) { // 转换新数据拼音首字母为大写 let initials = newData[newDataItem].pinyin.substr(0, 1).toUpperCase(); // 循环旧数据 for (let oldDataItem in oldData) { // 获取旧数据字母分组 let groupName = oldData[oldDataItem].groupName; // 判断两个字母是否相同 if (initials == groupName) { // 使用 array[array.length] 将数据加入到该组中 oldData[oldDataItem].users[oldData[oldDataItem].users.length] = newData[newDataItem]; } } } console.log(\"\\上拉加载后数据：\"); console.log(oldData); this.setData({ contactsData: oldData, normalModelNoData: true }) } else { // 如果没数据了 console.log(\"正常模式没数据\"); } } else if (this.data.searchModel) { // 搜索模式上拉 console.log(\"\\n搜索模式上拉：\"); } else if (this.data.pinyinNavModel) { // 拼音模式上拉 console.log(\"\\n拼音模式上拉\"); } } }) 3.2.10 兵分二路 - 拼音导航 返回目录  本章节实现效果：  现在，我们完成最后且最重要的一步，实现 拼音导航 功能。  首先，我们先实现拼音导航的布局： addressList.wxml 代码片段 返回本节开头 {{item}} addressList.wxss 代码片段 返回本节开头 /* 拼音导航 */ .pinyin-nav { font-size: 28rpx; line-height: 28rpx; position: fixed; right: 10rpx; top: 9%; height: 80%; text-align: center; } .pinyin-nav-byte { display: inline-block; width: 30rpx; border-radius: 20rpx; padding: 5rpx 5rpx; margin-top: 3rpx; color: #fff; background: rgb(129, 212, 238); } addressList.js 代码片段 返回本节开头 Page({ /** * 页面的初始数据 */ data: { /** * 拼音导航功能 * letters - 导航字母 */ letters: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'], }, /** * 拼音导航功能 * pininNav - 点击字母 */ pingyinNav(e) { console.log(e.currentTarget.dataset.byte); }, })  然后，布局有了，我们要如何实现滚动效果呢？ 参考资料 - 根据设备宽高动态设置元素宽高  考虑到设备的不同，它的高度也不同，所以我们是需要获取到样式的动态高度的。先看看我们在 wxss 中定义的高度吧： addressList.wxss 代码片段 返回本节开头 .contacts-list-title { height: 44rpx; } .contacts-list-user { height: 120rpx; }  因此，我们的一个字母的高度，为 44rpx；而一个用户数据的高度，为 120rpx，即我们要滚动的高度 = 44 字母个数 + 120 用户条数。  最后，我们先在正常模式下模拟实现一遍拼音导航： addressList.js 代码片段 返回本节开头 Page({ /** * 页面的初始数据 */ data: { /** * 拼音导航功能 * letters - 导航字母 * equipmentOneRpx - 设备中 1rpx 为多少 px */ letters: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'], equipmentOneRpx: '', }, /** * 拼音导航功能 * pininNav - 点击字母 */ pingyinNav(e) { console.log(\"\\n【API - 拼音导航】\"); let byte = e.currentTarget.dataset.byte; let dataLength = 0; let byteLength = 0; let data = this.data.contactsData; for (let item in data) { // 如果该字母比点击的字母小，则添加数据长度 if (data[item].groupName = 1 && data[item].groupName != byte) { byteLength = byteLength + 1; } // 如果该字母等于点击的字母，则中断循环 if (data[item].groupName == byte) { break; } } console.log(\"title 长度为：\" + byteLength); console.log(\"data 条数为：\" + dataLength); console.log(\"\\n现在数组为：\"); console.log(data); wx.pageScrollTo({ // 滚动高度 scrollTop: byteLength * (44 / this.data.equipmentOneRpx) + dataLength * (120 / this.data.equipmentOneRpx) }) }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { console.log(\"\\n通讯录\"); // 设备信息 wx.getSystemInfo({ success: res => { console.log(\"\\n设备信息为：\"); console.log(res); let equipmentOneRpx = 750 / res.windowWidth; console.log(\"换算信息：1rpx = \" + equipmentOneRpx + \"px\"); this.setData({ equipmentOneRpx: equipmentOneRpx }) }, }) } })  我们在 onLoad 中获取到用户设备的信息，然后计算出 1rpx 等于多少 px。在 iphone6 中，1rpx = 2px。我们只需要将 css 中写的样式高度 / 比例，就能动态计算我们的高度，从而实现滚动到目标位置的效果。  —————— 分割线 ——————  现在，我们开始 真拼音导航 功能的实现：  首先，我们应该考虑到，正常加载模式与拼音导航模式，会对 contactsData 的使用产生冲突：假如用户划拉了几页数据，然后进入拼音导航，那么，用户想下拉刷新页面的时候，可能就加载原本数据了，而不是加载该字母上面的数据……为此，我们在第一次加载拼音模式的时候，应该清空 contactsData（多了也不行，因为用户可能点击其他字母）。 然后，我们关闭正常模式，并开启拼音导航模式，设置拼音导航模式不是第一次加载了。 接着，我们遍历空数据和新数据，删除重复数据后，将数据添加到 contactsData 中。 最后，我们才用上我们前面的页面滚动效果，滚动到我们希望跳转到的位置。  以上，考虑到步骤繁杂，我们应该使用 Promise 来实现： ES6 入门之 Promise | 阮一峰 addressList.js 代码片段 返回本节开头 Page({ /** * 页面的初始数据 */ data: { /** * 拼音导航功能 * letters - 导航字母 * equipmentOneRpx - 设备中 1rpx 为多少 px * firstEntryPinyinModel - 第一次进入拼音导航模式 */ letters: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'], equipmentOneRpx: '', firstEntryPinyinModel: true, }, /** * 拼音导航功能 * pininNav - 点击字母 */ pinyinNav(e) { console.log(\"\\n【API - 拼音导航】\"); let byte = e.currentTarget.dataset.byte; // 开启 Promise const promise = new Promise((resolve, reject) => { console.log(\"\\n第一步：清空原数据\"); let contactsData = [ { groupName: 'A', users: [] }, { groupName: 'B', users: [] }, { groupName: 'C', users: [] }, { groupName: 'D', users: [] }, { groupName: 'E', users: [] }, { groupName: 'F', users: [] }, { groupName: 'G', users: [] }, { groupName: 'H', users: [] }, { groupName: 'I', users: [] }, { groupName: 'J', users: [] }, { groupName: 'K', users: [] }, { groupName: 'L', users: [] }, { groupName: 'M', users: [] }, { groupName: 'N', users: [] }, { groupName: 'O', users: [] }, { groupName: 'P', users: [] }, { groupName: 'Q', users: [] }, { groupName: 'R', users: [] }, { groupName: 'S', users: [] }, { groupName: 'T', users: [] }, { groupName: 'U', users: [] }, { groupName: 'V', users: [] }, { groupName: 'W', users: [] }, { groupName: 'X', users: [] }, { groupName: 'Y', users: [] }, { groupName: 'Z', users: [] } ]; if (this.data.firstEntryPinyinModel) { // 为防止无法下拉，第一次进入拼音导航模式，清空原数据 this.setData({ contactsData: contactsData }) } // 告诉下一步可以执行了 let success = true; resolve(success); }).then(() => { console.log(\"\\n第二步：开启拼音导航模式\"); this.setData({ normalModel: false, pinyinNavModel: true, firstEntryPinyinModel: false, }) }).then(() => { console.log(\"\\n第三步：判断并添加数据\"); let data = this.data.contactsData; console.log(\"\\n现在的数据有：\"); console.log(data); let newData = [ { userName: '克狸', userPhone: '18811121112', pinyin: 'keli' }, { userName: '拉狸', userPhone: '18811131113', pinyin: 'lali' }, { userName: '磨狸', userPhone: '18811141114', pinyin: 'moli' }, { userName: '尼狸', userPhone: '18811151115', pinyin: 'nili' }, { userName: '噢狸', userPhone: '18811161116', pinyin: 'oli' }, { userName: '皮皮狸', userPhone: '18811171117', pinyin: 'pipili' }, { userName: '曲狸', userPhone: '18811181118', pinyin: 'quli' }, { userName: '任狸', userPhone: '18811191119', pinyin: 'renli' }, { userName: '司马狸', userPhone: '18811211121', pinyin: 'simali' }, { userName: '提狸', userPhone: '18811221122', pinyin: 'tili' } ] console.log(\"\\n新数据有：\"); console.log(newData); console.log(\"\\n组合数据：\"); for (let groupInfo in data) { // 循环原数据 for (let item in newData) { // 循环新数据 if (data[groupInfo].groupName == newData[item].pinyin.substr(0, 1).toUpperCase()) { // 如果新数据字母 与 原数据字母相同 // 清君侧，删除重复数据 // 循环用户数据，判断 新数据的用户名 是否存在于用户数据，如果存在则删除之 for (let userInfo in data[groupInfo].users) { // 循环用户原数据 console.log(newData); if (newData.length > 1) { if (data[groupInfo].users[userInfo].userName == newData[item].userName) { // 判断 新数据的用户名 是否存在于原用户数据 newData.splice(item, 1); } } } if (newData.length > 1) { // 判断是否还有数据 if (data[groupInfo].groupName == newData[item].pinyin.substr(0, 1).toUpperCase()) { // 再判断一次新数据与旧数据字母是否相同 console.log(\"添加到组：【\" + data[groupInfo].groupName + \"】\"); data[groupInfo].users.push(newData[item]); console.log(data); } } } } } this.setData({ contactsData: data, }) }).then(() => { console.log(\"\\n第四步：滚动页面\"); let dataLength = 0; let byteLength = 0; let data = this.data.contactsData; console.log(data); for (let item in data) { // 如果该字母比点击的字母小，则添加数据长度 if (data[item].groupName = 1 && data[item].groupName != byte) { byteLength = byteLength + 1; } // 如果该字母等于点击的字母，则中断循环 if (data[item].groupName == byte) { break; } } console.log(\"title 长度为：\" + byteLength); console.log(\"data 条数为：\" + dataLength); console.log(\"\\n现在数组为：\"); console.log(data); wx.pageScrollTo({ // 滚动高度 scrollTop: byteLength * (44 / this.data.equipmentOneRpx) + dataLength * (120 / this.data.equipmentOneRpx) }) }) } })  如此，我们就实现了拼音导航的点击加载了！下面，我们紧接着将拼音导航功能的 下拉刷新 和 上拉加载 搞定吧~  关于下拉刷新，我们需要现在 json 中开启下拉刷新的功能： addressList.json 返回本节开头 { \"backgroundTextStyle\": \"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"通讯录\", \"navigationBarTextStyle\": \"black\", \"enablePullDownRefresh\": true, \"usingComponents\": { \"navBar\": \"../../component/navBar/navBar\" } }  然后，我们在 onPullDownRefresh 中实现代码效果即可： addressList.js 代码片段 返回本节开头 Page({ /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () { if (this.data.pinyinNavModel) { // 拼音下拉刷新 console.log(\"\\n【API - 拼音下拉刷新】\"); let data = this.data.contactsData; console.log(\"\\n现在的数据有：\"); console.log(data); let newData = [ { userName: '阿狸', userPhone: '18811111111', pinyin: 'ali' }, { userName: '贝吉塔', userPhone: '18822222222', pinyin: 'beijita' }, { userName: '楚怡', userPhone: '18833333333', pinyin: 'chuyi' }, { userName: '邓婕', userPhone: '18844444444', pinyin: 'dengjie' }, { userName: '尔康', userPhone: '18855555555', pinyin: 'erkang' }, { userName: '福狸', userPhone: '18866666666', pinyin: 'fuli' }, { userName: '古狸', userPhone: '18877777777', pinyin: 'guli' }, { userName: '哈狸', userPhone: '18888888888', pinyin: 'hali' }, { userName: 'i狸', userPhone: '18899999999', pinyin: 'ili' }, { userName: '激狸', userPhone: '18800000000', pinyin: 'jli' }, ] console.log(\"\\n新数据有：\"); console.log(newData); console.log(\"\\n组合数据：\"); for (let groupInfo in data) { // 循环原数据 for (let item in newData) { // 循环新数据 if (data[groupInfo].groupName == newData[item].pinyin.substr(0, 1).toUpperCase()) { // 如果新数据字母 与 原数据字母相同 // 清君侧，删除重复数据 // 循环用户数据，判断 新数据的用户名 是否存在于用户数据，如果存在则删除之 for (let userInfo in data[groupInfo].users) { // 循环用户原数据 if (newData.length > 1) { if (data[groupInfo].users[userInfo].userName == newData[item].userName) { // 判断 新数据的用户名 是否存在于原用户数据 newData.splice(item, 1); } } } if (newData.length > 1) { // 判断是否还有数据 if (data[groupInfo].groupName == newData[item].pinyin.substr(0, 1).toUpperCase()) { // 再判断一次新数据与旧数据字母是否相同 console.log(\"添加到组：【\" + data[groupInfo].groupName + \"】\"); data[groupInfo].users.unshift(newData[item]); console.log(data); } } } } } this.setData({ contactsData: data }) } } })  同时，拼音导航功能的上拉功能实现如下： addressList.js 代码片段 返回本节开头 Page({ onReachBottom: function () { if (this.data.normalModel) { // 正常模式上拉 console.log(\"\\n正常模式上拉\"); } else if (this.data.searchModel) { // 搜索模式上拉 console.log(\"\\n搜索模式上拉：\"); } else if (this.data.pinyinNavModel) { // 拼音模式上拉 console.log(\"\\n拼音模式上拉\"); let data = this.data.contactsData; console.log(\"\\n现在的数据有：\"); console.log(data); let newData = [ { userName: 'u狸', userPhone: '18811311131', pinyin: 'uli' }, { userName: 'v狸', userPhone: '18811321132', pinyin: 'vli' }, { userName: '无狸', userPhone: '18811331133', pinyin: 'wuli' }, { userName: '犀狸', userPhone: '18811341134', pinyin: 'xili' }, { userName: '毅狸', userPhone: '18811351135', pinyin: 'yili' }, { userName: '醉狸', userPhone: '18811361136', pinyin: 'zuili' } ] console.log(\"\\n新数据有：\"); console.log(newData); console.log(\"\\n组合数据：\"); for (let groupInfo in data) { // 循环原数据 for (let item in newData) { // 循环新数据 if (data[groupInfo].groupName == newData[item].pinyin.substr(0, 1).toUpperCase()) { // 如果新数据字母 与 原数据字母相同 // 清君侧，删除重复数据 // 循环用户数据，判断 新数据的用户名 是否存在于用户数据，如果存在则删除之 for (let userInfo in data[groupInfo].users) { // 循环用户原数据 console.log(newData); if (newData.length > 1) { if (data[groupInfo].users[userInfo].userName == newData[item].userName) { // 判断 新数据的用户名 是否存在于原用户数据 newData.splice(item, 1); } } } if (newData.length > 1) { // 判断是否还有数据 if (data[groupInfo].groupName == newData[item].pinyin.substr(0, 1).toUpperCase()) { // 再判断一次新数据与旧数据字母是否相同 console.log(\"添加到组：【\" + data[groupInfo].groupName + \"】\"); data[groupInfo].users.push(newData[item]); console.log(data); } } } } } this.setData({ contactsData: data }) } } })  如上，我们成功实现拼音导航全部功能！！！ 3.2.11 一统天下 - 归纳总结 返回目录  天下大势，分久必合，合久必分。 写到这里，我们的通讯录已然完结，在此附上 jsliang 的代码地址：项目地址 然而，这是结束吗？并不是，我们的通讯录，还有个功能未实现：  如何在新增、删除的时候，对新增的字母进行排序，并导航到具体位置？  在工作项目的开发中，jsliang 曾想到将新增的中文昵称转换为拼音，然后通过二分查找法，找到对应的位置并进行插入…… 但是，正印了那句话：我的能力，可以造火箭，我却只有敲钉子的时间！ 时间是一切程序猿的杀手，新增排序，咱们，有缘再会！ 四 项目地址 返回目录  不定期更新，详情可关注 jsliang 的 GitHub 地址 最后的最后，奉上上面实例中的地址：  项目地址  撰文不易，如果文章对小伙伴有帮助，希望小伙伴们给勤劳敲代码、辛苦撰文的 jsliang 进行微信打赏，谢谢~ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-21 10:19:15 var gitalk = new Gitalk({\"clientID\": \"ed83a3545da1ea821c9f\", \"clientSecret\": \"1e2517a9549f0bca9dc508fadbbc32aabb7d2c5f\", \"repo\": \"document-library\", \"owner\": \"LiangJunrong\", \"admin\": [\"LiangJunrong\"], \"id\": location.pathname, \"distractionFreeMode\": false}); gitalk.render(\"gitalk-container\"); "}}