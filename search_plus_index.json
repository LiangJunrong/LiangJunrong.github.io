{"./":{"url":"./","title":"起始","keywords":"","body":"Document Library - 文档库 Here is the jsliang's learning and working experience document on programming. If you have doubts about this, please send an email to 1741020489@qq.com. 这里存放了jsliang的学习、工作中关于编程的经验文档。如果你对此有疑惑，请发邮件到 1741020489@qq.com。 一 前言 本文档库始建于 2018-08-20。 如想知道 jsliang 最新学习进度，请前往 撰文思路 进行查看。 如想知道 jsliang 各种新奇玩意，请前往 网站清单 进行查看。 如想参与 jsliang 组织的小竞赛，请前往 个人竞赛 进行查看。 建文档库的初始目的：记录一下 jsliang 的在折腾学习某个黑科技的时候的操作笔记。 因为，如果你学习而不写文章、不做笔记，某天你突发奇想，需要用到某个之前你用过的黑科技……那样的话，还需要 百度 / google 一遍，太累了！太浪费人生了！ 所以，集一生洪荒之力，写一个编程文档库，存放，我编程生涯的点点滴滴。 不折腾的前端，跟咸鱼有什么区别！ 二 文件目录 文件名 存放内容 CSS-library CSS 文档仓库 HTML-library HTML 文档仓库 JavaScript-library JavaScript 文档仓库 other-library 其他文档仓库(整站制作/微信小程序) public-repertory 文档仓库使用到的图片、CSS文件等…… 三 个人网站 目录 介绍 jsliang.top jsliang 的网站列表 cv.jsliang.top 通过 ECharts + Vue 打造个人线上简历 playregex.jsliang.top 通过游戏来了解正则表达式 lucky.jsliang.top 悠闲刮刮乐，仅供娱乐 deadline.jsliang.top jsliang 的工作时间轴 webpack.jsliang.top Webpack 学习成果，Webpack 多页面配置 game.jsliang.top 一个小游戏，只兼容 PC，适配移动端失败 company.jsliang.top Node 打造企业网站，支持注册、登录及留言 work.jsliang.top jsliang 工作成果，给领导或者工作小伙伴查看 四 反馈 QQ 群 如果对该文档库的某篇文章存有疑惑，如果有些问题想看下 jsliang 折腾过没有，请加 QQ 群：798961601。jsliang 在群里将第一时间根据小伙伴的疑问进行解答~ 五 推荐学习方法 建议小伙伴们有机会可以给自己配个显示器，也就 5/600 元，用起来也舒服。 jsliang 的开发配置为手提（16G / 6核 / 12线程 / 7200RMB） + 显示器 （21.5寸 / 1080P / 650RMB)。对前端开发的来说，这个价还是用得起的，而且自己的配置，自己用得会比较舒服。 最后，祝小伙伴们在编程生涯中找到自己的节奏，工资步步高升。 办公场景 学习场景 六 云服务器推广 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎加 QQ：1741020489 骚扰欢迎点击 云服务器推广 查看了解更多！ 七 打赏 撰文不易，如果文章对小伙伴有帮助，希望小伙伴们给勤劳敲代码、辛苦撰文的 jsliang 进行微信/支付宝打赏，你们的每一次打赏都是最好的鼓励，谢谢~ 八 文档协议 document library of jsliang by 梁峻荣 is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.Based on a work at https://github.com/LiangJunrong/document-library.Permissions beyond the scope of this license may be available at https://creativecommons.org/licenses/by-nc-sa/2.5/cn/. jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-17 15:44:36 "},"SUMMARY.html":{"url":"SUMMARY.html","title":"目录","keywords":"","body":"文档库目录 起始 目录 ★ CSS 资料室 ☆ CSS 基础 √ CSS 重置 ☆ CSS 布局 √ Flex 布局 ★ HTML 资料室 ★ JavaScript 资料室 ☆ React √ ReactDemoOne-TodoList ★ 其他资料室 ☆ Git ★ 共用资料 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 15:33:10 "},"CSS-library/":{"url":"CSS-library/","title":"★ CSS 资料室","keywords":"","body":"CSS 资料室 Create by jsliang on 2018-10-28 10:49:09Recently revised in 2019-5-20 08:23:35 Here is an article about CSS. 这里存放了关于 CSS 的文章。 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 "},"CSS-library/CSSBase/":{"url":"CSS-library/CSSBase/","title":"☆ CSS 基础","keywords":"","body":"CSS 基础 Create by jsliang on 2019-5-20 08:34:15Recently revised in 2019-5-20 08:34:18 记录 CSS 基础相关的资料 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 "},"CSS-library/CSSBase/CSSReset.html":{"url":"CSS-library/CSSBase/CSSReset.html","title":"√ CSS 重置","keywords":"","body":"CSS Reset Create by jsliang on 2018-12-23 20:12:08Recently revised in 2019-04-25 17:46:46 各式各样浏览器总有一些让人感觉难以接受的样式， 不管是 jQuery 还是 Vue，使用前最好重置一下样式： reset.css /* * reset 的目的不是让默认样式在所有浏览器下一致，而是减少默认样式有可能带来的问题。 * The purpose of reset is not to allow default styles to be consistent across all browsers, but to reduce the potential problems of default styles. * create by jsliang */ /** 清除内外边距 - clearance of inner and outer margins **/ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* 结构元素 - structural elements */ dl, dt, dd, ul, ol, li, /* 列表元素 - list elements */ pre, /* 文本格式元素 - text formatting elements */ form, fieldset, legend, button, input, textarea, /* 表单元素 - from elements */ th, td /* 表格元素 - table elements */ { margin: 0; padding: 0; } /** 设置默认字体 - setting the default font **/ body, button, input, select, textarea { font: 18px/1.5 '黑体', Helvetica, sans-serif; } h1, h2, h3, h4, h5, h6, button, input, select, textarea { font-size: 100%; } /** 重置列表元素 - reset the list element **/ ul, ol { list-style: none; } /** 重置文本格式元素 - reset the text format element **/ a, a:hover { text-decoration: none; } /** 重置表单元素 - reset the form element **/ button { cursor: pointer; } input { font-size: 18px; outline: none; } /** 重置表格元素 - reset the table element **/ table { border-collapse: collapse; border-spacing: 0; } /* * 图片自适应 - image responsize * 1. 清空浏览器对图片的设置 * 2. 图片 的情况下，图片会撑高 div，这么设置可以清除该影响 */ img { border: 0; display: inline-block; width: 100%; max-width: 100%; height: auto; vertical-align: middle; } /* * 默认box-sizing是content-box，该属性导致padding会撑大div，使用border-box可以解决该问题 * set border-box for box-sizing when you use div, it solve the problem when you add padding and don't want to make the div width bigger */ div, input { box-sizing: border-box; } /** 清除浮动 - clear float **/ .jsliang-clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .jsliang-clear, .clear { *zoom: 1; } /** 设置input的placeholder - set input placeholder **/ input::-webkit-input-placeholder { color: #919191; font-size: .32rem } /* Webkit browsers */ input::-moz-placeholder { color: #919191; font-size: .32rem } /* Mozilla Firefox */ input::-ms-input-placeholder { color: #919191; font-size: .32rem } /* Internet Explorer */ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.om/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-25 17:46:47 "},"CSS-library/Layout/":{"url":"CSS-library/Layout/","title":"☆ CSS 布局","keywords":"","body":"CSS 布局 Create by jsliang on 2019-5-20 08:35:56Recently revised in 2019-5-20 08:35:59 记录 CSS 布局相关的资料 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 "},"CSS-library/Layout/Flex.html":{"url":"CSS-library/Layout/Flex.html","title":"√ Flex 布局","keywords":"","body":"Flex 布局 create by jsliang on 2019-3-27 13:36:02Recently revised in 2019-3-27 13:42:10 万丈高楼平地起，熟悉 Flex 需要先了解下面这 7 个 CSS 属性： /* 设置 Flex 模式 */ display: flex; /* 决定元素是横排还是竖着排，要不要倒序 */ flex-direction: column; /* 决定元素换行格式，一行排不下的时候如何排 */ flex-wrap: wrap; /* flex-flow = flex-direction + flex-wrap */ flex-flow: column wrap; /* 同一排下对齐方式，空格如何隔开各个元素 */ justify-content: space-between; /* 同一排下元素如何对齐，顶部对齐、中部对齐还是其他 */ align-items: center; /* 多行对齐方式 */ align-content: space-between; 下面我们详细分析这些元素的情况： flex-direction：决定主轴的方向 row - （默认）水平方向，起点在左端 row-reverse - 水平方向，起点在右端 column - 垂直方向，起点在上沿 column-reverse - 垂直方向，起点在下沿 display: flex; flex-direction: row | row-reverse | column | column-reverse; flex-wrap：一条轴线（一行）排不下时如何解决 nowrap - （默认）不换行 wrap - 换行，第一行在上方 wrap-reverse - 换行，第一行在下方 display: flex; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow：flex-flow = flex-direction + flex-wrap。即 flex-flow 是这两个属性的合集 row nowrap - （默认）水平方向，起点在左端，不换行 display: flex; flex-flow: || ;  详解参考 1 和 2 justify-content：定义项目在主轴上的对齐方式 flex-start - 左边对齐 flex-end - 右边对齐 center - 居中对齐 space-between - 两端对齐，空格在中间 space-around - 空格环绕 display: flex; justify-content: flex-start | flex-end | center | space-between | space-around; align-items：定义项目在交叉轴上如何对齐 flex-start - 顶部对齐，即文字图片等顶部同一条线上 flex-end - 底部对其，即文字图片等底部在同一条线上 center - 中间对其，即文字图片不管多高，都拿它们的中间放在同一条线上 stretch - 将文字图片充满整个容器的高度，强制统一 baseline - 将每项的第一行文字做统一在一条线上对齐 display: flex; align-items: flex-start | flex-end | center | stretch | baseline; align-content：定义多根轴线的对齐方式。如果只有一根轴线（只有一行），该属性不起作用 flex-start - 这几行顶部对齐 flex-end - 这几行底部对齐 center - 这几行居中对齐 stretch - 这几行进行扩展或者缩放，从而填满容器高 space-between - 这几行中间使用空格进行填充 space-around - 这几行两边及中间进行填充 display: flex; align-content: flex-start | flex-end | center | space-between | space-around | stretch; jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"HTML-library/":{"url":"HTML-library/","title":"★ HTML 资料室","keywords":"","body":"HTML 资料室 Create by jsliang on 2018-10-28 10:50:22Recently revised in 2019-5-20 08:24:19 Here is an article about HTMl 这里存放了关于HTML的文章 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 "},"JavaScript-library/":{"url":"JavaScript-library/","title":"★ JavaScript 资料室","keywords":"","body":"JavaScript 资料室 Create by jsliang on 2018-10-28 10:51:18Recently revised in 2019-5-20 08:24:52 Here is an article about JavaScript 这里存放了关于 JavaScript 的文章 目录 Angular ES6 ECharts JavaScript React Vue 设计模式 jQuery jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 "},"JavaScript-library/React/ReactDemoOne-TodoList.html":{"url":"JavaScript-library/React/ReactDemoOne-TodoList.html","title":"√ ReactDemoOne-TodoList","keywords":"","body":"React Demo One - TodoList Create by jsliang on 2019-3-18 08:37:10Recently revised in 2019-4-7 03:03:32 Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 React 系列文章代码地址 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文  3.1 新建 React 项目  3.2 项目目录解析  3.3 精简项目结构  3.4 初探组件  3.5 JSX  3.6 事件及双向数据绑定  3.7 优化-抽取 CSS  3.8 优化-抽取 JS 四 总结 五 参考文献 二 前言 返回目录 关于 React，jsliang 从 2018-9-5 就开始折腾了，中途因为工作调动，没能继续折腾下去。最近因为新公司工作需求，从头开始继续折腾 React，希望我的文章能对没学过 React 或者初入 React 的小伙伴有所帮助。 本文参考来自慕课网： 《React 16.4 开发简书项目从零基础入门到实战》 其中掺杂个人对编程的理解，如有错误，望多多指正。 前置知识： ES5/ES6 Webpack npm 文章结构： 基础内容 -> 环境搭建 -> 基础语法 -> 原理进阶 -> 动画 Redux -> Redux 进阶 实战项目 -> 环境搭建 -> Header -> 首页 -> 详情页 登录校验 -> 上线 涉及知识点： create-react-app 组件化思维 JSX 开发调试工具 虚拟 DOM 生命周期 React-transition-group Redux Antd UI、容器组件 无状态组件 redux-thunk redux-saga styled-components immutable.js redux-immutable axios 其中，本文为第一个 Demo 案例：通过编写一个简单的 TodoList 小 Demo，熟悉 React 的开发流程。 三 正文 返回目录 Now，开始搞事情。 3.1 新建 React 项目 返回目录 下载 Node.js 安装 React 脚手架： npm i create-react-app -g 开启新项目： create-react-app todolist cd todolist npm start 打开 localhost:3000 查看页面 3.2 项目目录解析 返回目录 - todolist + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - mainfest.json —— 提供 meta 信息给项目，并与 serviceWorker.js 相呼应，进行离线 APP 定义 - src ——————————————————— 项目主要目录 - App.css —— 主组件样式 - App.js —— 主组件入口 - App.test.js —— 自动化测试文件 - index.css —— 全局 css 文件 - index.js —— 所有代码的入口 - logo.svg —— 页面的动态图 - serviceWorker.js —— PWA。帮助开发手机 APP 应用，具有缓存作用 - .gitignore ———————————— 配置文件。git 上传的时候忽略哪些文件 - package-lock.json ————— 锁定安装包的版本号，保证其他人在 npm i 的时候使用一致的 node 包 - package.json —————————— node 包文件，介绍项目以及说明一些依赖包等 - README.md ————————————— 项目介绍文件 3.3 精简项目结构 返回目录 为了方便开发，下面对 creat-react-app 的初始目录进行精简： - todolist + node_modules —————————— 项目依赖的第三方的包 - public ———————————————— 共用文件 - favicon.ico —— 网页标签左上角小图标 - index.html —— 网站首页模板 - src ——————————————————— 重要的目录 - App.js —— 主组件入口 - index.js —— 所有代码的入口 - .gitignore ———————————— 配置文件。git 上传的时候忽略哪些文件 - package.json —————————— node 包文件，介绍项目以及说明一些依赖包等 - README.md ————————————— 项目介绍文件 favicon.ico、.gitignore、README.md 是我们无需理会的，但是其他文件，我们需要精简下它们的代码： index.html 代码详情 ```html Todolist 你需要允许在 APP 中运行 JavaScript ``` App.js 代码详情 ```js import React, { Component } from 'react'; class App extends Component { render() { return ( Hello React! ); } } export default App; ``` index.js 代码详情 ```js import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; ReactDOM.render(, document.getElementById('root')); ``` package.json 代码详情 ```json { \"name\": \"todolist\", \"version\": \"0.1.0\", \"private\": true, \"dependencies\": { \"react\": \"^16.8.4\", \"react-dom\": \"^16.8.4\", \"react-scripts\": \"2.1.8\" }, \"scripts\": { \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test\", \"eject\": \"react-scripts eject\" }, \"eslintConfig\": { \"extends\": \"react-app\" }, \"browserslist\": [ \">0.2%\", \"not dead\", \"not ie 3.4 初探组件 返回目录 类似于上图，在进行页面开发的时候，我们很容易地使用庖丁解牛的技巧，将页面进行划分，然后一部分一部分地将页面搭建出来。 给个比较官方的说法，就叫页面组件化：将页面切成几个部分，从而有利于页面的拼装以及代码的维护。 在 create-react-app 的默认配置中，App.js 就是一个组件，一起来看： App.js // 1. 引用 React 及其组件 import React, { Component } from 'react'; // 2. 定义一个叫 App 的组件继承于 Component class App extends Component { render() { return ( Hello React! ); } } // 3. 根据 React 实例，在 App 内部编写完毕后，导出这个 App 组件 export default App; 在上面，我们引用、定义并导出了这个 App 的组件，然后我们就要使用它： index.js // 1. 引入 React、ReactDOM import React from 'react'; import ReactDOM from 'react-dom'; // 2. 将 App.js 导入进来 import App from './App'; // 3. 通过 ReactDOM 将 App.js 以虚拟 DOM 的形式渲染/挂载到 root 根节点，该节点在 index.html 中 ReactDOM.render(, document.getElementById('root')); index.js 告诉我们，它会通过 ReactDom，将 App.js 这个组件挂载到 root 这个节点上，那么，这个 root 在哪里呢？我们查看下 index.html： index.html Todolist 你需要允许在 APP 中运行 JavaScript OK，很容易地我们就捋清楚思路了：我们在 index.html 中定义了个 root 根节点，然后我们通过 index.js，将 App.js 以组件形式渲染到了 index.html 中，从而实现了节点的挂载。 思维发散：我们知道 index.js 和 App.js 的最终结合是挂载到 id=\"root\" 节点上的，如果我们再开一个 index2.js 和 App2.js，挂载到 id=\"root2\" 节点上，行不行呢？亦或者我们开一个 id=\"root3\" 的节点，我们在其中操作 jQuery，是不是也可行？ 3.5 JSX 返回目录 在 create-react-app 的文件中，不管是 index.js 中的： ReactDOM.render(, document.getElementById('root')); 还是 App.js 中的： class App extends React.Component { render() { return ( Hello React! ); } } 等这些有关 DOM 的渲染，都需要用到 JSX，因此需要引入 React： import React from 'react'; JSX 的定义： 那么，什么是 JSX 呢？ React 的核心机制之一就是可以在内存中创建虚拟的 DOM 元素。React 利用虚拟 DOM 来减少对实际 DOM 的操作从而提升性能。 JSX 就是 JavaScript 和 XML 结合的一种格式。 React 发明了 JSX，利用 HTML 语法来创建虚拟 DOM。当遇到 ，JSX 就当 HTML 解析，遇到 { 就当 JavaScript 解析。 JSX 的使用： 在 JSX 语法中，如果我们需要使用自己创建的组件，我们直接使用它的定义名即可，例如： index.js // 1. 引入 React、ReactDOM import React from 'react'; import ReactDOM from 'react-dom'; // 2. 将 App.js 导入进来 import App from './App'; // 3. 通过 ReactDOM 将 App.js 以虚拟 DOM 的形式渲染/挂载到 root 根节点，该节点在 index.html 中 ReactDOM.render(, document.getElementById('root')); 其中第三点即是自定义组件渲染到根节点。 提示：在 React 中，如果需要使用自定义组件，那么该组件不能小写开头 app，而是使用 App 这样的大写开头形式。 3.6 事件及双向数据绑定 返回目录 这是我们精简后的目录结构： 我们修改下目录结构，开始编写 TodoList： 首先，我们修改 App.js 为 TodoList.js： App.js TodoList.js import React, { Component } from 'react'; class TodoList extends Component { render() { return ( Hello React! ); } } export default TodoList; 然后，我们修改 index.js 中挂载到 index.html 的组件为 TodoList： index.js import React from 'react'; import ReactDOM from 'react-dom'; import TodoList from './TodoList'; // 3. 通过 ReactDOM 将 App.js 以虚拟 DOM 的形式渲染/挂载到 root 根节点，该节点在 index.html 中 ReactDOM.render(, document.getElementById('root')); 修改完毕，小伙伴们可以重启下 3000 端口，查看下我们的 React 是否能正常启动。 在此步骤中，我们仅仅修改 App.js 为 TodoList.js，使 index.js 挂载到 root 的是 TodoList.js，除此之外没进行其他操作。 最后，如果没有问题，那么我们进一步编写 TodoList，获取到 input 输入框的值，并渲染到列表中： TodoList.js 代码详情 ```js // Fragment 是一种占位符形式，类似于 Vue 的 Template import React, { Component, Fragment } from 'react'; class TodoList extends Component { constructor(props) { super(props); this.state = { inputValue: '', list: [] } } render() { return ( {/* 单项数据绑定 */} 提交 吃饭 X 睡觉 X 打豆豆 X ) } handleInputChange(e) { console.log(e.target.value); this.setState({ inputValue: e.target.value }) } } export default TodoList; ``` 我们先查看演示： OK，这样我们在每输入一个字符的时候，我们就能立刻获取到对应的数据，这时候实现了单向数据流：输入框 -> JS 内存。 其中有 3 点需要讲解下： Fragment 是 React 提供的一种占位符，它像 、 等标签一样，但是它在实际渲染的时候是不会出现的。因为 React 的 JSX 首层必须要有标签，然后如果使用 等会占用一个层级，所以，类似于 Vue 的 Template，React 使用了 Fragment 这种空标签。 constructor 表示父类的构造方法，在 ES6 中，构造方法 constructor 相当于其构造函数，用来新建父类的 this 对象，而 super(props) 则是用来修正 this 指向的。简而言之，我们可以在这里定义数据，并在整个 js 文件中使用。 onChange 这种写法，是 React 指定的写法，例如 onClick 等，在原生 JS 中，使用的是 onclick，而在 React 中，为了区别，需要进行半驼峰编写事件名字。同时，绑定的 handleInputChange，可以直接在 render 下面进行编写。 参考文献：《react 中 constructor() 和 super() 到底是个啥？》 这样，我们就对 React 的数据及事件有了初步理解，下面我们加下按钮点击新增列表事件以及点击 X 删除列表事件。 TodoList.js 代码详情 ```js // Fragment 是一种占位符形式，类似于 Vue 的 Template import React, { Component, Fragment } from 'react'; class TodoList extends Component { // 构造函数 constructor(props) { super(props); // 定义数据 this.state = { inputValue: '', list: [] } } // 渲染页面 render() { let closeStyle = { fontSize: '1.2em', color: 'deepskyblue', marginLeft: '10px' } return ( {/* 单项数据绑定 */} {/* 在 React 中，绑定时间的，一般为半驼峰形式 */} 提交 { this.state.list.map( (item, index) => { return {index}. {item} X }) } ) } // 方法体 - 输入内容 handleInputChange(e) { this.setState({ inputValue: e.target.value }) } // 方法体 - 点击提交 handleBtnClick() { this.setState({ list: [...this.state.list, this.state.inputValue], inputValue: '' }) } // 方法体 - 删除项目 handleItemDelete(index) { const list = [...this.state.list]; list.splice(index, 1); this.setState({ list: list }) } } export default TodoList; ``` 在这一部分，我们需要了解 3 个知识点： 在 render 中 closeStyle 这个变量，我们用来定义 CSS 属性，然后我们通过 style={closeStyle}，直接写了个行内样式（下面我们会抽离出来） 关于 JSX 遍历输出的形式： { this.state.list.map( (item, index) => { return {index}. {item} X }) } 我们通过 {} 里面循环输出 DOM 节点。如果你学过 jQuery，那么可以将它当为拼接字符串；如果你学过 Vue，那么可以将它当成 v-for 变了种写法。 在这里我们不用理会为什么这么写，我们先接受这种写法先。 关于改变 constructor 中的数据，我们使用： this.setState({ list: list }) 这种形式。其实，这也是有记忆技巧的，要知道我们在定义数据的时候，使用了： // 定义数据 this.state = { inputValue: '', list: [] } 即： this.state，那么我们需要修改数据，那就是 this.setState 了。 至此，我们的简易 TodoList 就实现了，下面我们进一步优化，将 CSS 和 JS 进一步抽取。 3.7 优化-抽取 CSS 返回目录 在上面中，我们提到 closeStyle 是一种行内的写法，作为一枚 完美编程者，我们肯定不能容忍，下面我们开始抽离： TodoList.js import React, { Component, Fragment } from 'react'; import './style.css' // ... 省略中间代码 { this.state.list.map( (item, index) => { return {index}. {item} X }) } 在这里，我们需要知道：我们可以通过 import 的形式，直接将 CSS 文件直接导入，然后，我们命名 class 的时候，因为 React 怕 JS 的 class 与 HTML 的 class 冲突，所以我们需要使用 className。 最后我们再编写下 CSS 文件： .icon-close { font-size: 1.2em; color: deepskyblue; margin-left: 10px; } 如此，我们就实现了 CSS 的抽取。 3.8 优化-抽取 JS 返回目录 在第 4 章关于组件的介绍中，我们讲到：一些复杂的 JS 是可以抽取出来，并以组件的形式，嵌入到需要放置的位置的。 那么，我们在 JSX 越写越多的情况下，是不是可以将列表渲染那部分抽取出来，从而精简下 JSX 呢？ 答案是可以的，下面我们看下实现： TodoList.js 代码详情 ```js // Fragment 是一种占位符形式，类似于 Vue 的 Template import React, { Component, Fragment } from 'react'; // 引入组件 import TodoItem from './TodoItem'; // 引用样式 import './style.css'; class TodoList extends Component { // 构造函数 constructor(props) { super(props); // 定义数据 this.state = { inputValue: '', list: [] } this.handleInputChange = this.handleInputChange.bind(this); this.handleBtnClick = this.handleBtnClick.bind(this); this.handleItemDelete = this.handleItemDelete.bind(this); } // 渲染页面 render() { return ( 输入内容： {/* 单项数据绑定 */} {/* 在 React 中，绑定时间的，一般为半驼峰形式 */} 提交 {/* 精简 JSX，将部分抽取出来 */} { this.getTodoItem() } ) } // 获取单独项 getTodoItem() { return this.state.list.map( (item, index) => { return ( ) }) } // 方法体 - 输入内容 handleInputChange(e) { const value = e.target.value; this.setState( () => ({ inputValue: value })) } // 方法体 - 点击提交 handleBtnClick() { const list = this.state.list, inputValue = this.state.inputValue; this.setState( () => ({ list: [...list, inputValue], inputValue: '' })) } // 方法体 - 删除项目 handleItemDelete(index) { // immutable - state 不允许做任何改变 const list = [...this.state.list]; list.splice(index, 1); this.setState( () => ({ list: list })) } } export default TodoList; ``` 我们关注下 TodoList.js 的改变： 我们在 constructor 中，将方法进行了提前定义： this.handleInputChange = this.handleInputChange.bind(this); 这样，我们在下面就不用写 .bind(this) 形式了。 我们修改了下 this.setState() 的形式： 原写法： this.setState({ list: list }) 现写法： this.setState( () => ({ list: list })) 因为 React 16 版本进行了更新，使用这种写法比之前的好，至于好在哪，咱先不关心，以后就用这种写法了。 我们引用了组件： import TodoItem from './TodoItem'; 并且将组件放到方法体：this.getTodoItem() 中，而 this.getTodoItem() 的定义是： // 获取单独项 getTodoItem() { return this.state.list.map( (item, index) => { return ( ) }) } 在这里我们可以看到，我们通过自定义值的形式，将数据 key、item、index 传递给了子组件 TodoItem。同时，通过 handleItemDelete，将自己的方法传递给了子组件，这样子组件就可以调用父组件的方法了： TodoItem.js 代码详情 ```js import React, { Component } from 'react' class TodoItem extends Component { constructor(props) { super(props); // 这种写法可以节省性能 this.handleClick = this.handleClick.bind(this); } render() { const { item } = this.props; return ( {item} X ) } handleClick() { const { handleItemDelete, index } = this.props; handleItemDelete(index); } } export default TodoItem; ``` 这样，我们就完成了组件的抽取，并学会了 父组件传递值给子组件 子组件调用父组件的方法 由此，我们在接下来就可以编写更丰富健全的项目了。 本文代码地址：React 系列源码地址 四 总结 返回目录 在我们学习任意一门语言中，大多就是上手 “Hello World！” 编程~ 然后做小案例的时候，我们都喜欢来个 TodoList，因为它能讲清楚一些有关基础的知识点。 现在，我们回顾下，我们开发 React 的 TodoList 有啥收获： create-react-app 的安装及开发。 组件化的思想及在 create-react-app 中关于组件化的应用。 React 关于数据 data 以及方法 methods 的定义及使用，以及如何进行数据双向绑定。 将大的组件拆分成小组件，并实现父子组件通讯（父组件传递参数给子组件，子组件调用父组件的方法） 至此，jsliang 就精通 jQuery、Vue、React 编写 TodoList 了，哈哈！ 五 参考文献 返回目录 《React.Component 与 React.PureComponent（React之性能优化）》 《visual studio code + react 开发环境搭建》 《react 中 constructor() 和 super() 到底是个啥？》 jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-25 17:16:59 "},"other-library/":{"url":"other-library/","title":"★ 其他资料室","keywords":"","body":"其他资料室 Create by jsliang on 2018-10-28 11:07:33Recently revised in 2019-5-20 08:25:29 All the articles that can not be classified are stored here 这里存放了目前所有无法分类的文章 jsliang 的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 "},"other-library/Git/":{"url":"other-library/Git/","title":"☆ Git","keywords":"","body":"Git Create by jsliang on 2018-10-25 15:14:00Recently revised in 2019-04-02 21:31:22 一 目录 不折腾的前端，和咸鱼有什么区别 目录 一 目录 二 前言 三 正文 二 前言 返回目录 一直以来，jsliang 对 Git 的操作，仅限于：git add .、git commit -m \"更新信息\"、git push 这三个，偶尔还会创建操作个分支。 但是，仅仅是这些是不够的。所以，跟随 廖雪峰 等大神的 Git 教程进行一波自我更新： 《Git 教程 - 廖雪峰》 什么是 Git Git 是目前世界上最先进的分布式版本控制系统。 这么说也许你很懵逼，没关系，我们用毕业论文来讲讲： 如上图。写过毕业论文的小伙伴，应该记忆深刻：《毕业论文》《毕业论文完成版》《毕业论文最终版》《毕业论文最最终版》…… 令人抓狂无比，当我们需要在 最最最最终版 找到之前文件中早早被删除的信息时，我们更加抓狂了：卧槽，我写到哪去了！ 这时候，如果有个软件之类的东西帮我们记录就好了： 文件名 更新信息 时间 毕业论文 第一版，整体内容搭建 2019-3-28 08:41:04 毕业论文完成版 第二版，完成了大部分内容，并进行了排版 2019-3-29 08:41:46 毕业论文最终版 第三版，对第二版进行了删减 2019-3-30 08:42:21 毕业论文最最终版 第四版，对第三版进行了新增 2019-3-31 08:42:42 ... ... ... 毕业论文最最最最终版 第六版，对整了下格式 2019-4-2 08:43:17 OK，这时候我们会发觉，我们要找到被删减的内容，只需要去第二版中查找就行了，这就是为何会有版本管理工具的原因。 而 Git，就是目前较盛行的版本管理工具。 集中式与分布式 历史总是前进的，在 Git 之前，还是有其他的版本管理系统： VSS：最老的版本有锁，需要锁住才能编辑，提交时解锁，独占修改，小规模最好用，大规模最难用。 CSV：代表协作版本系统或者并发版本系统同，是一种版本控制系统，提交失败时解决冲突比较麻烦。 SVN：目标是想取代 CSV，相对于 CSV 采用了分支管理系统，配置成 HTTP 服务时比较简单，稳定。 Git：相对于 SVN 多一个本地库。 历史总是被湮没，每次找资料，都找不全 关于版本管理工具的历史推进，咱在此就不做详述，如果有小伙伴找到比较全的资源，可以发出来分享下。 关于 SVN 和 Git，其实涉及两种管理系统的比较，即：集中式与分布式。 什么是集中式？集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 什么是分布式？区别于集中式版本控制系统，分布式版本控制系统中没有 “中央服务器”，每个人的电脑都是一个完整的版本库。既然你的电脑是一个完整的版本库，假设你改了文件 A，你的同事也改了文件 A，你们需要协作，这时候只需要将各自修改推送给对方，双方就知道对方修改了什么了。这就好比诸葛亮和周瑜在攻打曹操的时候，各自在手心写了一个字，写完之后亮给对方看，相视一笑：嗯，这 b 跟老子想得一样。 而 SVN 和 Git，分别作为集中式与分布式的代表之一。 Git 安装 对于 Git 安装，2018 年 jsliang 入职公司的时候已经安装过，又因为 廖雪峰 大佬已经安排的明明白白了，故不多此一举，贴上安装步骤文章： 《安装 Git》 Git 新建版本库 什么是版本库？ 版本库又名仓库，英文名 repository，可以简单理解为一个目录，这个目录里面的所有文件都可以被 Git 管理起来，用于追踪每个文件的修改、删除。 创建目录：mkdir learngit 前进到这个目录：cd learngit 显示当前目录：pwd 初始化仓库：git init 显示 .git：ls -ah 这时候会出来一个隐藏文件，叫 .git，这个目录就是 Git 用来跟踪管理版本库的，请不要手动修改里面的文件。 添加文件，新建 README.md： README.md Git 学习 === 将文件添加到仓库：git add README.md（git add . 是提交当前目录所有文件） 将文件提交到仓库：git commit -m \"Add a README\" 此处 -m 输入的是本次提交的说明，方便你根据说明查找需要的历史版本 修改文件内容： README.md Git 学习 === > Create by **jsliang** on **2019-3-29 09:08:48** > Recently revised in **2019-3-29 09:08:53** 查看结果：git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: README.md no changes added to commit (use \"git add\" and/or \"git commit -a\") 此刻可以看出，我们查看到了 README.md 被修改了。 查看版本差异：git diff index b379f95..78fb1fe 100644 --- a/README.md +++ b/README.md @@ -1,2 +1,5 @@ Git 学习 -=== \\ No newline at end of file +=== + +> Create by **jsliang** on **2019-3-29 09:09:03** +> Recently revised in **2019-3-29 09:09:07** \\ No newline at end of file 这时候，我们添加了时间，做了新的更改，所以我们又可以进行新一轮的提交： git add . git commit -m \"添加时间\" 我们再添加下证书并提交： README.md Git 学习 === > Create by **jsliang** on **2019-3-29 09:09:03** > Recently revised in **2019-3-29 09:09:07** > jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 git add . git commit -m \"添加协议\" 当我们做的事儿越多，越不可能记住几个字的更改，所以我们需要查找历史记录，见证我们成长的点滴：git log commit 7b88d86f3e079e048c3e5444f91616b826f553a0 (HEAD -> master) Author: jsliang Date: Fri Mar 29 09:21:35 2019 +0800 添加协议 commit 05abb578724b7d8cef860aa4280b0e19241c02a8 Author: jsliang Date: Fri Mar 29 09:14:16 2019 +0800 添加时间 commit 655433cc64356a8f9dc12e9a94808a25e844c0eb Author: jsliang Date: Fri Mar 29 09:03:59 2019 +0800 回退到上一个版本：git reset --hard HEAD^ HEAD is now at 05abb57 添加时间 注意，git log 显示的记录中，commit 后面的就是 HEAD，Git 通过 HEAD 控制版本 如果误回退了呢？尝试回退版本号：git reset --hard 7b88d86 HEAD is now at 7b88d86 添加协议 OK，现在它又回来了。记住：如果你操作失误回退了，请不要关闭命令行窗口，还有机会补救！ 找不到版本号，想恢复新版本：git reflog 7b88d86 (HEAD -> master) HEAD@{0}: reset: moving to 7b88d86 05abb57 HEAD@{1}: reset: moving to HEAD^ 7b88d86 (HEAD -> master) HEAD@{2}: commit: 添加协议 05abb57 HEAD@{3}: commit: 添加时间 可以看到，这里把前面版本的版本号显示出来了。 Git 命令 git fetch 从一个或多个其他存储库中获取分支和/或标签(统称为“引用”)以及完成其历史所必需的对象。 远程跟踪分支已更新(Git术语叫做commit)，需要将这些更新取回本地，这时就要用到git fetch命令。 git 取消忽略文件大小写的更改 在当前项目，输入 git config core.ignorecase false 即可关闭 git 忽略文件大小写的配置。 git 删除文件夹 删除 target 文件夹：git rm -r --cached target 提交更改：git commit -m \"删除 target 目录\" 确认更改：git push git 覆盖上一次 commit 提交信息 git commit -amend -m \"New commit\" git 分支 创建分支：git branch cheny 切换到分支：git checkout cheny 添加修改代码到缓存：git add . 提交：git commit -m \"修改\" 提交到分支：git push origin cheny/git push --set-upstream origin cheny 同时配置 GitLab 和 GitHub 缘由：公司使用 GitLab，个人使用 GitHub，因此需要配置下 Git，方便上传到公司的 GitLab 项目和个人的 GitHub 项目上。 参考文献： 同一台电脑同时使用gitlab和github 配置同时使用 Gitlab 和 Github 的开发环境 Mac 配置步骤 CD 到用户根目录下的 .ssh 文件夹中：cd .ssh 生成 GitLab 秘钥：ssh-keygen -t rsa -C \"注册 gitlab 账户的邮箱\"，提示后输入 id_rsa_gitlab，这样就在 .ssh 目录下生成了 GitLab 的秘钥。 生成 GitHub 秘钥：ssh-keygen -t rsa -C \"注册 github 账户的邮箱\"，提示后输入 id_rsa_github，这样就在 .ssh 目录下生成了 GitHub 的秘钥。 这时候我们 .ssh 目录中有文件： id_rsa_github.pub id_rsa_gitlab.pub id_rsa_github id_rsa_gitlab 提供公钥给服务器 复制 ~/.ssh/id_rsa_gitlab.pub文件内容，进入gitlab / profile / SSH Keys，将公钥内容添加至 gitlab 。 复制 ~/.ssh/id_rsa_github.pub文件内容，进入github / setting / SSH and GPG keys / New SSH key 将公钥内容添加至 github 。 在 .ssh 中添加 config 文件（文本文件，不存在后缀），内容为： config Host github.com HostName github.com User githubuser@xyz.com IdentityFile ~/.ssh/id_rsa_github Host gitlab.com HostName gitlab.com User gitlabuser@xyz.com IdentityFile ~/.ssh/id_rsa_gitlab 这时候我们 .ssh 目录中有文件： id_rsa_github.pub id_rsa_gitlab.pub id_rsa_github id_rsa_gitlab config （可选）在 GitHub 或者 GitLab 仓库大目录中使用下面三条命令： git init git config --global user.name \"githubuser\" git config --global user.email \"githubuser@xyz.com\" 在项目文件夹中使用以下命令： git clone 项目地址 新增/修改文件 git add . git commit -m \"修改配置\" git push 在终端输入账号密码信息后，就会提示上传成功了，最终项目目录中有文件： config id_rsa_github.pub id_rsa_gitlab.pub id_rsa_github id_rsa_gitlab known_hosts 配置 .gitignore 在我们使用Git的过程中，有时候喜欢建一些文件给自己查看使用而不是给大众使用，或者说像是 node_modules 这些文件不希望上传到代码仓库的，这时候就需要设置响应的忽略规则，来忽略这些文件的提交。 全局生效 定义全局 .gitignore 文件，将其放在任意位置即可生效 git config --global core.excludesfile ~/.gitignore 忽略规则 忽略掉所有文件名是 test.html 的文件 test.html 忽略掉 node_modules 文件夹 node_modules 忽略掉所有生成的备份文件 *.*~ 忽略所有 .o 和 .a 文件 *.[oa] 详细用法看文档：详情 VS Code 隐藏 node_modules 值得一提的就是，我们不仅要忽略它的上传，在 Visio Studio Code 这个编辑器中，如果我们也需要忽略它的话，就需要进行相应的设置，VS Code 隐藏工作区中的 node_modules 文件夹： 主菜单 -> 文件 -> 首选项 -> 用户设置： \"file.exclude\": { \"node_modules/\": true } jsliang 广告推送：也许小伙伴想了解下云服务器或者小伙伴想买一台云服务器或者小伙伴需要续费云服务器欢迎点击 云服务器推广 查看！ jsliang的文档库 由 梁峻荣 采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/LiangJunrong/document-library上的作品创作。本许可协议授权之外的使用权限可以从 https://creativecommons.org/licenses/by-nc-sa/2.5/cn/ 处获得。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-22 09:50:05 "},"public-repertory/":{"url":"public-repertory/","title":"★ 共用资料","keywords":"","body":"共用资料 create by jsliang on 2018-10-28 12:10:36Recently revised in 2019-5-20 08:26:08 All the file sharing resources are stored here. 这里存放了所有文件共享的资源。 目录 文件名 存放内容 css 文档使用到的css文件 img 文档使用到的图片 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-20 10:02:51 "}}